{
  "version": 3,
  "sources": ["../../../../src/aat/state-machine.ts", "../../../../src/types.ts", "../../../../src/buffer/glyph-buffer.ts", "../../../../src/buffer/unicode-buffer.ts", "../../../../src/font/binary/reader.ts", "../../../../src/font/tables/avar.ts", "../../../../src/font/tables/fvar.ts", "../../../../src/font/tables/hvar.ts", "../../../../src/font/face.ts", "../../../../src/font/woff2.ts", "../../../../src/font/tables/base.ts", "../../../../src/font/tables/cbdt.ts", "../../../../src/font/tables/cff.ts", "../../../../src/font/tables/cff2.ts", "../../../../src/font/tables/cmap.ts", "../../../../src/font/tables/colr.ts", "../../../../src/font/tables/cpal.ts", "../../../../src/layout/structures/class-def.ts", "../../../../src/font/tables/gdef.ts", "../../../../src/font/tables/gvar.ts", "../../../../src/font/tables/loca.ts", "../../../../src/font/tables/glyf.ts", "../../../../src/font/tables/cff-charstring.ts", "../../../../src/layout/structures/coverage.ts", "../../../../src/layout/structures/device.ts", "../../../../src/layout/structures/layout-common.ts", "../../../../src/font/tables/gpos-contextual.ts", "../../../../src/font/tables/gpos-mark.ts", "../../../../src/font/tables/gpos.ts", "../../../../src/font/tables/gsub-contextual.ts", "../../../../src/font/tables/gsub.ts", "../../../../src/font/tables/head.ts", "../../../../src/font/tables/hhea.ts", "../../../../src/font/tables/hmtx.ts", "../../../../src/font/tables/jstf.ts", "../../../../src/font/tables/kern.ts", "../../../../src/font/tables/kerx.ts", "../../../../src/font/tables/math.ts", "../../../../src/font/tables/maxp.ts", "../../../../src/font/tables/morx.ts", "../../../../src/font/tables/mvar.ts", "../../../../src/font/tables/name.ts", "../../../../src/font/tables/os2.ts", "../../../../src/font/tables/post.ts", "../../../../src/font/tables/sbix.ts", "../../../../src/font/tables/sfnt.ts", "../../../../src/font/tables/feat.ts", "../../../../src/font/tables/stat.ts", "../../../../src/font/tables/svg.ts", "../../../../src/font/tables/trak.ts", "../../../../src/font/tables/vhea.ts", "../../../../src/font/tables/vmtx.ts", "../../../../src/font/tables/vorg.ts", "../../../../src/font/tables/vvar.ts", "../../../../src/font/tables/hinting.ts", "../../../../src/font/tables/gasp.ts", "../../../../src/font/font.ts", "../../../../src/layout/justify.ts", "../../../../src/layout/structures/feature-variations.ts", "../../../../src/render/path.ts", "../../../../src/unicode/normalize.ts", "../../../../src/shaper/fallback.ts", "../../../../src/shaper/features.ts", "../../../../src/shaper/shape-plan.ts", "../../../../src/shaper/complex/arabic.ts", "../../../../src/shaper/complex/hangul.ts", "../../../../src/shaper/complex/hebrew.ts", "../../../../src/shaper/complex/indic.ts", "../../../../src/shaper/complex/khmer.ts", "../../../../src/shaper/complex/myanmar.ts", "../../../../src/shaper/complex/thai-lao.ts", "../../../../src/shaper/complex/use.ts", "../../../../src/shaper/shaper.ts", "../../../../src/unicode/bidi/brackets.data.ts", "../../../../src/unicode/bidi/parse-character-map.ts", "../../../../src/unicode/bidi/brackets.ts", "../../../../src/unicode/bidi/char-types.data.ts", "../../../../src/unicode/bidi/char-types.ts", "../../../../src/unicode/bidi/embedding-levels.ts", "../../../../src/unicode/bidi/mirroring.data.ts", "../../../../src/unicode/bidi/mirroring.ts", "../../../../src/unicode/bidi/reordering.ts", "../../../../src/unicode/bidi.ts", "../../../../src/unicode/line-break.ts", "../../../../src/unicode/segmentation.ts", "../../../../src/unicode/script.ts", "../../../../src/raster/types.ts", "../../../../src/raster/fixed-point.ts", "../../../../src/raster/cell.ts", "../../../../src/raster/gray-raster.ts", "../../../../src/raster/outline-decompose.ts", "../../../../src/hinting/types.ts", "../../../../src/hinting/instructions/stack.ts", "../../../../src/hinting/instructions/arithmetic.ts", "../../../../src/hinting/instructions/control-flow.ts", "../../../../src/hinting/rounding.ts", "../../../../src/hinting/instructions/graphics-state.ts", "../../../../src/hinting/instructions/points.ts", "../../../../src/hinting/instructions/interpolate.ts", "../../../../src/hinting/instructions/delta.ts", "../../../../src/hinting/interpreter.ts", "../../../../src/hinting/programs.ts", "../../../../src/raster/rasterize.ts"],
  "sourcesContent": ["import type {\n\tClassTable,\n\tContextualEntry,\n\tInsertionEntry,\n\tLigatureEntry,\n\tMorxContextualSubtable,\n\tMorxInsertionSubtable,\n\tMorxLigatureSubtable,\n\tMorxRearrangementSubtable,\n} from \"../font/tables/morx.ts\";\nimport type { GlyphId, GlyphInfo } from \"../types.ts\";\n\n/**\n * State machine driver for AAT processing\n */\nexport interface StateMachineContext {\n\t/** Current position in buffer */\n\tpos: number;\n\t/** Mark position (for some operations) */\n\tmark: number;\n\t/** Glyph stack for ligatures */\n\tstack: number[];\n}\n\n/**\n * Special class values\n */\nconst CLASS_END_OF_TEXT = 0;\nconst CLASS_OUT_OF_BOUNDS = 1;\nconst _CLASS_DELETED_GLYPH = 2;\nconst _CLASS_END_OF_LINE = 3;\n\n/**\n * Get class for a glyph\n */\nexport function getGlyphClass(\n\tclassTable: ClassTable,\n\tglyphId: GlyphId,\n): number {\n\tif (glyphId < 0 || glyphId >= classTable.classArray.length) {\n\t\treturn CLASS_OUT_OF_BOUNDS;\n\t}\n\treturn classTable.classArray[glyphId] ?? CLASS_OUT_OF_BOUNDS;\n}\n\n/**\n * Process rearrangement subtable\n * Reorders glyphs based on state machine\n */\nexport function processRearrangement(\n\tsubtable: MorxRearrangementSubtable,\n\tinfos: GlyphInfo[],\n): void {\n\tconst { stateTable } = subtable;\n\tlet state = 0;\n\tlet markFirst = 0;\n\tlet markLast = 0;\n\n\tfor (let i = 0; i <= infos.length; i++) {\n\t\tconst isEnd = i >= infos.length;\n\t\tconst glyphClass = isEnd\n\t\t\t? CLASS_END_OF_TEXT\n\t\t\t: getGlyphClass(stateTable.classTable, infos[i]?.glyphId);\n\n\t\tconst stateRow = stateTable.stateArray[state];\n\t\tif (!stateRow) break;\n\n\t\tconst entry = stateRow[glyphClass];\n\t\tif (!entry) break;\n\n\t\tconst flags = entry.flags;\n\n\t\t// Set mark first\n\t\tif (flags & 0x8000) {\n\t\t\tmarkFirst = i;\n\t\t}\n\n\t\t// Set mark last\n\t\tif (flags & 0x2000) {\n\t\t\tmarkLast = i;\n\t\t}\n\n\t\t// Perform rearrangement\n\t\tconst verb = flags & 0x000f;\n\t\tif (verb !== 0 && markFirst <= markLast && markLast < infos.length) {\n\t\t\trearrangeGlyphs(infos, markFirst, markLast, verb);\n\t\t}\n\n\t\t// Don't advance if flag set\n\t\tif (!(flags & 0x4000)) {\n\t\t\t// Stay at current position\n\t\t}\n\n\t\tstate = entry.newState;\n\t}\n}\n\n/**\n * Rearrangement verbs\n */\nfunction rearrangeGlyphs(\n\tinfos: GlyphInfo[],\n\tfirst: number,\n\tlast: number,\n\tverb: number,\n): void {\n\tif (first >= last || first >= infos.length || last >= infos.length) return;\n\n\tconst a = infos[first];\n\tconst b = infos[first + 1];\n\tconst c = infos[last - 1];\n\tconst d = infos[last];\n\n\tif (!a || !d) return;\n\n\tswitch (verb) {\n\t\tcase 1: // Ax => xA\n\t\t\tif (b) {\n\t\t\t\tinfos[first] = b;\n\t\t\t\tinfos[first + 1] = a;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2: // xD => Dx\n\t\t\tif (c) {\n\t\t\t\tinfos[last] = c;\n\t\t\t\tinfos[last - 1] = d;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3: // AxD => DxA\n\t\t\tinfos[first] = d;\n\t\t\tinfos[last] = a;\n\t\t\tbreak;\n\t\tcase 4: // ABx => xAB\n\t\t\tif (b && c) {\n\t\t\t\tconst temp = infos.slice(first, first + 2);\n\t\t\t\tconst [tempFirst, tempSecond] = temp;\n\t\t\t\tconst thirdItem = infos[first + 2];\n\t\t\t\tif (tempFirst && tempSecond && thirdItem) {\n\t\t\t\t\tinfos[first] = thirdItem;\n\t\t\t\t\tinfos[first + 1] = tempFirst;\n\t\t\t\t\tinfos[first + 2] = tempSecond;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 5: // ABx => xBA\n\t\t\tif (b && c) {\n\t\t\t\tconst temp = infos.slice(first, first + 2);\n\t\t\t\tconst [tempFirst, tempSecond] = temp;\n\t\t\t\tconst thirdItem = infos[first + 2];\n\t\t\t\tif (tempFirst && tempSecond && thirdItem) {\n\t\t\t\t\tinfos[first] = thirdItem;\n\t\t\t\t\tinfos[first + 1] = tempSecond;\n\t\t\t\t\tinfos[first + 2] = tempFirst;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 6: // xCD => CDx\n\t\t\tif (c && b) {\n\t\t\t\tconst temp = infos.slice(last - 1, last + 1);\n\t\t\t\tconst [tempFirst, tempSecond] = temp;\n\t\t\t\tconst prevItem = infos[last - 2];\n\t\t\t\tif (tempFirst && tempSecond && prevItem) {\n\t\t\t\t\tinfos[last] = prevItem;\n\t\t\t\t\tinfos[last - 1] = tempSecond;\n\t\t\t\t\tinfos[last - 2] = tempFirst;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 7: // xCD => DCx\n\t\t\tif (c && b) {\n\t\t\t\tconst temp = infos.slice(last - 1, last + 1);\n\t\t\t\tconst [tempFirst, tempSecond] = temp;\n\t\t\t\tconst prevItem = infos[last - 2];\n\t\t\t\tif (tempFirst && tempSecond && prevItem) {\n\t\t\t\t\tinfos[last] = prevItem;\n\t\t\t\t\tinfos[last - 1] = tempFirst;\n\t\t\t\t\tinfos[last - 2] = tempSecond;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 8: // AxCD => CDxA\n\t\t\tif (c) {\n\t\t\t\tconst tempA = a;\n\t\t\t\tinfos[first] = c;\n\t\t\t\tinfos[last - 1] = d;\n\t\t\t\tinfos[last] = tempA;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 9: // AxCD => DCxA\n\t\t\tif (c) {\n\t\t\t\tconst tempA = a;\n\t\t\t\tinfos[first] = d;\n\t\t\t\tinfos[last - 1] = c;\n\t\t\t\tinfos[last] = tempA;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 10: // ABxD => DxAB\n\t\t\tif (b) {\n\t\t\t\tconst tempD = d;\n\t\t\t\tinfos[last] = b;\n\t\t\t\tinfos[first + 1] = a;\n\t\t\t\tinfos[first] = tempD;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 11: // ABxD => DxBA\n\t\t\tif (b) {\n\t\t\t\tconst tempD = d;\n\t\t\t\tinfos[last] = a;\n\t\t\t\tinfos[first + 1] = b;\n\t\t\t\tinfos[first] = tempD;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 12: // ABxCD => CDxAB\n\t\t\tif (b && c) {\n\t\t\t\tconst tempAB = [a, b];\n\t\t\t\tinfos[first] = c;\n\t\t\t\tinfos[first + 1] = d;\n\t\t\t\tinfos[last - 1] = tempAB[0];\n\t\t\t\tinfos[last] = tempAB[1];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 13: // ABxCD => CDxBA\n\t\t\tif (b && c) {\n\t\t\t\tconst tempAB = [a, b];\n\t\t\t\tinfos[first] = c;\n\t\t\t\tinfos[first + 1] = d;\n\t\t\t\tinfos[last - 1] = tempAB[1];\n\t\t\t\tinfos[last] = tempAB[0];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 14: // ABxCD => DCxAB\n\t\t\tif (b && c) {\n\t\t\t\tconst tempAB = [a, b];\n\t\t\t\tinfos[first] = d;\n\t\t\t\tinfos[first + 1] = c;\n\t\t\t\tinfos[last - 1] = tempAB[0];\n\t\t\t\tinfos[last] = tempAB[1];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 15: // ABxCD => DCxBA\n\t\t\tif (b && c) {\n\t\t\t\tconst tempAB = [a, b];\n\t\t\t\tinfos[first] = d;\n\t\t\t\tinfos[first + 1] = c;\n\t\t\t\tinfos[last - 1] = tempAB[1];\n\t\t\t\tinfos[last] = tempAB[0];\n\t\t\t}\n\t\t\tbreak;\n\t}\n}\n\n/**\n * Process contextual substitution subtable\n */\nexport function processContextual(\n\tsubtable: MorxContextualSubtable,\n\tinfos: GlyphInfo[],\n): void {\n\tconst { stateTable, substitutionTable } = subtable;\n\tlet state = 0;\n\tlet markIndex = -1;\n\n\tfor (let i = 0; i <= infos.length; i++) {\n\t\tconst isEnd = i >= infos.length;\n\t\tconst glyphClass = isEnd\n\t\t\t? CLASS_END_OF_TEXT\n\t\t\t: getGlyphClass(stateTable.classTable, infos[i]?.glyphId);\n\n\t\tconst stateRow = stateTable.stateArray[state];\n\t\tif (!stateRow) break;\n\n\t\tconst entry = stateRow[glyphClass] as ContextualEntry | undefined;\n\t\tif (!entry) break;\n\n\t\t// Set mark\n\t\tif (entry.flags & 0x8000) {\n\t\t\tmarkIndex = i;\n\t\t}\n\n\t\t// Apply substitution at mark\n\t\tif (\n\t\t\tentry.markIndex !== 0xffff &&\n\t\t\tmarkIndex >= 0 &&\n\t\t\tmarkIndex < infos.length\n\t\t) {\n\t\t\tconst substTable = substitutionTable[entry.markIndex];\n\t\t\tif (substTable) {\n\t\t\t\tconst markedInfo = infos[markIndex];\n\t\t\t\tif (markedInfo) {\n\t\t\t\t\tconst replacement = substTable.get(markedInfo.glyphId);\n\t\t\t\t\tif (replacement !== undefined) {\n\t\t\t\t\t\tmarkedInfo.glyphId = replacement;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Apply substitution at current\n\t\tif (!isEnd && entry.currentIndex !== 0xffff) {\n\t\t\tconst substTable = substitutionTable[entry.currentIndex];\n\t\t\tif (substTable) {\n\t\t\t\tconst currentInfo = infos[i];\n\t\t\t\tif (currentInfo) {\n\t\t\t\t\tconst replacement = substTable.get(currentInfo.glyphId);\n\t\t\t\t\tif (replacement !== undefined) {\n\t\t\t\t\t\tcurrentInfo.glyphId = replacement;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don't advance\n\t\tif (!(entry.flags & 0x4000)) {\n\t\t\t// Stay\n\t\t}\n\n\t\tstate = entry.newState;\n\t}\n}\n\n/**\n * Process ligature subtable\n */\nexport function processLigature(\n\tsubtable: MorxLigatureSubtable,\n\tinfos: GlyphInfo[],\n): GlyphInfo[] {\n\tconst { stateTable, ligatureActions, components, ligatures } = subtable;\n\tlet state = 0;\n\tconst stack: number[] = [];\n\tconst result: GlyphInfo[] = [];\n\tconst deleted = new Set<number>();\n\n\tfor (let i = 0; i <= infos.length; i++) {\n\t\tconst isEnd = i >= infos.length;\n\t\tconst glyphClass = isEnd\n\t\t\t? CLASS_END_OF_TEXT\n\t\t\t: getGlyphClass(stateTable.classTable, infos[i]?.glyphId);\n\n\t\tconst stateRow = stateTable.stateArray[state];\n\t\tif (!stateRow) break;\n\n\t\tconst entry = stateRow[glyphClass] as LigatureEntry | undefined;\n\t\tif (!entry) break;\n\n\t\t// Push to stack\n\t\tif (entry.flags & 0x8000) {\n\t\t\tstack.push(i);\n\t\t}\n\n\t\t// Perform ligature action\n\t\tif (entry.flags & 0x2000 && entry.ligActionIndex < ligatureActions.length) {\n\t\t\tlet actionIndex = entry.ligActionIndex;\n\t\t\tlet ligatureGlyph: GlyphId = 0;\n\t\t\tconst componentIndices: number[] = [];\n\n\t\t\t// Process action chain\n\t\t\twhile (actionIndex < ligatureActions.length) {\n\t\t\t\tconst action = ligatureActions[actionIndex];\n\t\t\t\tif (action === undefined) break;\n\n\t\t\t\tconst last = (action & 0x80000000) !== 0;\n\t\t\t\tconst store = (action & 0x40000000) !== 0;\n\t\t\t\tconst componentOffset = ((action & 0x3fffffff) << 2) >> 2; // Sign extend\n\n\t\t\t\tconst stackIdx = stack.pop();\n\t\t\t\tif (stackIdx !== undefined && stackIdx < infos.length) {\n\t\t\t\t\tcomponentIndices.push(stackIdx);\n\t\t\t\t\tconst info = infos[stackIdx];\n\t\t\t\t\tif (info) {\n\t\t\t\t\t\tconst glyphId = info.glyphId;\n\t\t\t\t\t\tconst componentIdx = glyphId + componentOffset;\n\n\t\t\t\t\t\tif (componentIdx >= 0 && componentIdx < components.length) {\n\t\t\t\t\t\t\tconst component = components[componentIdx];\n\t\t\t\t\t\t\tif (component !== undefined) {\n\t\t\t\t\t\t\t\tligatureGlyph = component + ligatureGlyph;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (store && ligatureGlyph < ligatures.length) {\n\t\t\t\t\t// Replace first component with ligature\n\t\t\t\t\tconst firstIdx = componentIndices[componentIndices.length - 1];\n\t\t\t\t\tif (firstIdx !== undefined && firstIdx < infos.length) {\n\t\t\t\t\t\tconst firstInfo = infos[firstIdx];\n\t\t\t\t\t\tconst ligature = ligatures[ligatureGlyph];\n\t\t\t\t\t\tif (firstInfo && ligature !== undefined) {\n\t\t\t\t\t\t\tfirstInfo.glyphId = ligature;\n\t\t\t\t\t\t\t// Mark other components for deletion\n\t\t\t\t\t\t\tfor (const [j, idx] of componentIndices.entries()) {\n\t\t\t\t\t\t\t\tif (j < componentIndices.length - 1) {\n\t\t\t\t\t\t\t\t\tdeleted.add(idx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tligatureGlyph = 0;\n\t\t\t\t}\n\n\t\t\t\tif (last) break;\n\t\t\t\tactionIndex++;\n\t\t\t}\n\t\t}\n\n\t\t// Don't advance\n\t\tif (!(entry.flags & 0x4000)) {\n\t\t\t// Stay\n\t\t}\n\n\t\tstate = entry.newState;\n\t}\n\n\t// Build result without deleted glyphs\n\tfor (const [i, info] of infos.entries()) {\n\t\tif (!deleted.has(i)) {\n\t\t\tresult.push(info);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Process insertion subtable\n */\nexport function processInsertion(\n\tsubtable: MorxInsertionSubtable,\n\tinfos: GlyphInfo[],\n): GlyphInfo[] {\n\tconst { stateTable, insertionGlyphs } = subtable;\n\tlet state = 0;\n\tlet markIndex = -1;\n\tconst result: GlyphInfo[] = [];\n\tconst insertions: Map<number, { before: GlyphId[]; after: GlyphId[] }> =\n\t\tnew Map();\n\n\tfor (let i = 0; i <= infos.length; i++) {\n\t\tconst isEnd = i >= infos.length;\n\t\tconst glyphClass = isEnd\n\t\t\t? CLASS_END_OF_TEXT\n\t\t\t: getGlyphClass(stateTable.classTable, infos[i]?.glyphId);\n\n\t\tconst stateRow = stateTable.stateArray[state];\n\t\tif (!stateRow) break;\n\n\t\tconst entry = stateRow[glyphClass] as InsertionEntry | undefined;\n\t\tif (!entry) break;\n\n\t\t// Set mark\n\t\tif (entry.flags & 0x8000) {\n\t\t\tmarkIndex = i;\n\t\t}\n\n\t\t// Insert at marked position\n\t\tif (entry.markedInsertIndex !== 0xffff && markIndex >= 0) {\n\t\t\tconst count = (entry.flags >> 5) & 0x1f;\n\t\t\tconst insertBefore = (entry.flags & 0x0800) !== 0;\n\t\t\tconst glyphs = insertionGlyphs.slice(\n\t\t\t\tentry.markedInsertIndex,\n\t\t\t\tentry.markedInsertIndex + count,\n\t\t\t);\n\n\t\t\tlet ins = insertions.get(markIndex);\n\t\t\tif (!ins) {\n\t\t\t\tins = { before: [], after: [] };\n\t\t\t\tinsertions.set(markIndex, ins);\n\t\t\t}\n\t\t\tif (insertBefore) {\n\t\t\t\tins.before.push(...glyphs);\n\t\t\t} else {\n\t\t\t\tins.after.push(...glyphs);\n\t\t\t}\n\t\t}\n\n\t\t// Insert at current position\n\t\tif (!isEnd && entry.currentInsertIndex !== 0xffff) {\n\t\t\tconst count = entry.flags & 0x1f;\n\t\t\tconst insertBefore = (entry.flags & 0x0020) !== 0;\n\t\t\tconst glyphs = insertionGlyphs.slice(\n\t\t\t\tentry.currentInsertIndex,\n\t\t\t\tentry.currentInsertIndex + count,\n\t\t\t);\n\n\t\t\tlet ins = insertions.get(i);\n\t\t\tif (!ins) {\n\t\t\t\tins = { before: [], after: [] };\n\t\t\t\tinsertions.set(i, ins);\n\t\t\t}\n\t\t\tif (insertBefore) {\n\t\t\t\tins.before.push(...glyphs);\n\t\t\t} else {\n\t\t\t\tins.after.push(...glyphs);\n\t\t\t}\n\t\t}\n\n\t\t// Don't advance\n\t\tif (!(entry.flags & 0x4000)) {\n\t\t\t// Stay\n\t\t}\n\n\t\tstate = entry.newState;\n\t}\n\n\t// Build result with insertions\n\tfor (const [i, info] of infos.entries()) {\n\t\tconst ins = insertions.get(i);\n\n\t\tif (ins) {\n\t\t\t// Insert before\n\t\t\tfor (const glyph of ins.before) {\n\t\t\t\tresult.push({\n\t\t\t\t\tglyphId: glyph,\n\t\t\t\t\tcluster: info.cluster,\n\t\t\t\t\tmask: info.mask,\n\t\t\t\t\tcodepoint: 0,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tresult.push(info);\n\n\t\tif (ins) {\n\t\t\t// Insert after\n\t\t\tfor (const glyph of ins.after) {\n\t\t\t\tresult.push({\n\t\t\t\t\tglyphId: glyph,\n\t\t\t\t\tcluster: info.cluster,\n\t\t\t\t\tmask: info.mask,\n\t\t\t\t\tcodepoint: 0,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n", "// OpenType primitive types\nexport type uint8 = number;\nexport type int8 = number;\nexport type uint16 = number;\nexport type int16 = number;\nexport type uint32 = number;\nexport type int32 = number;\nexport type Fixed = number; // 16.16 fixed-point\nexport type F2Dot14 = number; // 2.14 fixed-point\nexport type FWord = number; // int16 in font units\nexport type UFWord = number; // uint16 in font units\nexport type Offset16 = number;\nexport type Offset32 = number;\nexport type GlyphId = number;\n\n/** 4-character ASCII tag (packed as uint32 for efficiency) */\nexport type Tag = number;\n\n/** Text direction */\nexport enum Direction {\n\tInvalid = 0,\n\tLTR = 4,\n\tRTL = 5,\n\tTTB = 6,\n\tBTT = 7,\n}\n\n/** Cluster level for glyph-character mapping */\nexport enum ClusterLevel {\n\tMonotoneGraphemes = 0,\n\tMonotoneCharacters = 1,\n\tCharacters = 2,\n}\n\n/** Buffer flags */\nexport enum BufferFlags {\n\tDefault = 0x0,\n\tBeginningOfText = 0x1,\n\tEndOfText = 0x2,\n\tPreserveDefaultIgnorables = 0x4,\n\tRemoveDefaultIgnorables = 0x8,\n\tDoNotInsertDottedCircle = 0x10,\n}\n\n/** Glyph classification from GDEF */\nexport enum GlyphClass {\n\tBase = 1,\n\tLigature = 2,\n\tMark = 3,\n\tComponent = 4,\n}\n\n/** Feature specification for shaping */\nexport interface Feature {\n\ttag: Tag;\n\tvalue: number;\n\tstart: number;\n\tend: number;\n}\n\n/** Variation axis value */\nexport interface Variation {\n\ttag: Tag;\n\tvalue: number;\n}\n\n/** Glyph info during shaping */\nexport interface GlyphInfo {\n\tglyphId: GlyphId;\n\tcluster: number;\n\tmask: number;\n\t/** Unicode codepoint (before shaping) */\n\tcodepoint: number;\n}\n\n/** Glyph position after shaping */\nexport interface GlyphPosition {\n\txAdvance: number;\n\tyAdvance: number;\n\txOffset: number;\n\tyOffset: number;\n}\n\n/** Table record from font directory */\nexport interface TableRecord {\n\ttag: Tag;\n\tchecksum: uint32;\n\toffset: Offset32;\n\tlength: uint32;\n}\n\n/** Lookup flags for controlling glyph matching */\nexport interface LookupFlags {\n\trightToLeft: boolean;\n\tignoreBaseGlyphs: boolean;\n\tignoreLigatures: boolean;\n\tignoreMarks: boolean;\n\tuseMarkFilteringSet: boolean;\n\tmarkAttachmentType: number;\n\tmarkFilteringSet?: number;\n}\n\n// Tag utilities\nexport function tag(str: string): Tag {\n\tif (str.length !== 4) {\n\t\tthrow new Error(`Tag must be exactly 4 characters: \"${str}\"`);\n\t}\n\treturn (\n\t\t(str.charCodeAt(0) << 24) |\n\t\t(str.charCodeAt(1) << 16) |\n\t\t(str.charCodeAt(2) << 8) |\n\t\tstr.charCodeAt(3)\n\t);\n}\n\nexport function tagToString(t: Tag): string {\n\treturn String.fromCharCode(\n\t\t(t >> 24) & 0xff,\n\t\t(t >> 16) & 0xff,\n\t\t(t >> 8) & 0xff,\n\t\tt & 0xff,\n\t);\n}\n\n// Common tags\nexport const Tags = {\n\t// Required tables\n\thead: tag(\"head\"),\n\thhea: tag(\"hhea\"),\n\thmtx: tag(\"hmtx\"),\n\tmaxp: tag(\"maxp\"),\n\tcmap: tag(\"cmap\"),\n\tloca: tag(\"loca\"),\n\tglyf: tag(\"glyf\"),\n\tname: tag(\"name\"),\n\tOS2: tag(\"OS/2\"),\n\tpost: tag(\"post\"),\n\n\t// OpenType layout\n\tGDEF: tag(\"GDEF\"),\n\tGSUB: tag(\"GSUB\"),\n\tGPOS: tag(\"GPOS\"),\n\tBASE: tag(\"BASE\"),\n\tJSTF: tag(\"JSTF\"),\n\tMATH: tag(\"MATH\"),\n\n\t// CFF\n\tCFF: tag(\"CFF \"),\n\tCFF2: tag(\"CFF2\"),\n\n\t// Variable fonts\n\tfvar: tag(\"fvar\"),\n\tgvar: tag(\"gvar\"),\n\tavar: tag(\"avar\"),\n\tHVAR: tag(\"HVAR\"),\n\tVVAR: tag(\"VVAR\"),\n\tMVAR: tag(\"MVAR\"),\n\n\t// AAT\n\tmorx: tag(\"morx\"),\n\tkerx: tag(\"kerx\"),\n\tkern: tag(\"kern\"),\n\ttrak: tag(\"trak\"),\n\tfeat: tag(\"feat\"),\n\n\t// Color\n\tCOLR: tag(\"COLR\"),\n\tCPAL: tag(\"CPAL\"),\n\tSVG: tag(\"SVG \"),\n\tsbix: tag(\"sbix\"),\n\tCBDT: tag(\"CBDT\"),\n\tCBLC: tag(\"CBLC\"),\n\n\t// Style Attributes\n\tSTAT: tag(\"STAT\"),\n\n\t// Vertical\n\tvhea: tag(\"vhea\"),\n\tvmtx: tag(\"vmtx\"),\n\tVORG: tag(\"VORG\"),\n\n\t// Hinting\n\tfpgm: tag(\"fpgm\"),\n\tprep: tag(\"prep\"),\n\tcvt: tag(\"cvt \"),\n\tgasp: tag(\"gasp\"),\n} as const;\n\n// Feature tags\nexport const FeatureTags = {\n\t// GSUB\n\tccmp: tag(\"ccmp\"),\n\tlocl: tag(\"locl\"),\n\trlig: tag(\"rlig\"),\n\tliga: tag(\"liga\"),\n\tclig: tag(\"clig\"),\n\tcalt: tag(\"calt\"),\n\trclt: tag(\"rclt\"),\n\tdlig: tag(\"dlig\"),\n\tsmcp: tag(\"smcp\"),\n\tc2sc: tag(\"c2sc\"),\n\n\t// Arabic\n\tisol: tag(\"isol\"),\n\tinit: tag(\"init\"),\n\tmedi: tag(\"medi\"),\n\tfina: tag(\"fina\"),\n\n\t// GPOS\n\tkern: tag(\"kern\"),\n\tmark: tag(\"mark\"),\n\tmkmk: tag(\"mkmk\"),\n\tcurs: tag(\"curs\"),\n\tdist: tag(\"dist\"),\n} as const;\n", "import {\n\tDirection,\n\ttype GlyphId,\n\ttype GlyphInfo,\n\ttype GlyphPosition,\n} from \"../types.ts\";\n\n/**\n * Output buffer containing shaped glyphs.\n * Result of the shaping process.\n */\nexport class GlyphBuffer {\n\t/** Direction used during shaping */\n\tdirection: Direction = Direction.LTR;\n\n\t/** Script used during shaping */\n\tscript: string = \"Zyyy\";\n\n\t/** Language used during shaping */\n\tlanguage: string | null = null;\n\n\t/** Glyph information array */\n\tinfos: GlyphInfo[] = [];\n\n\t/** Glyph position array */\n\tpositions: GlyphPosition[] = [];\n\n\t/** Create buffer with pre-allocated capacity */\n\tstatic withCapacity(capacity: number): GlyphBuffer {\n\t\tconst buffer = new GlyphBuffer();\n\t\tbuffer.infos = new Array(capacity);\n\t\tbuffer.positions = new Array(capacity);\n\t\treturn buffer;\n\t}\n\n\t/** Number of glyphs */\n\tget length(): number {\n\t\treturn this.infos.length;\n\t}\n\n\t/** Initialize from glyph infos (positions zeroed) */\n\tinitFromInfos(infos: GlyphInfo[]): void {\n\t\tthis.infos = infos;\n\t\tthis.positions = infos.map(() => ({\n\t\t\txAdvance: 0,\n\t\t\tyAdvance: 0,\n\t\t\txOffset: 0,\n\t\t\tyOffset: 0,\n\t\t}));\n\t}\n\n\t/** Set advance width for a glyph */\n\tsetAdvance(index: number, xAdvance: number, yAdvance = 0): void {\n\t\tconst pos = this.positions[index];\n\t\tif (pos) {\n\t\t\tpos.xAdvance = xAdvance;\n\t\t\tpos.yAdvance = yAdvance;\n\t\t}\n\t}\n\n\t/** Add offset to a glyph position */\n\taddOffset(index: number, xOffset: number, yOffset: number): void {\n\t\tconst pos = this.positions[index];\n\t\tif (pos) {\n\t\t\tpos.xOffset += xOffset;\n\t\t\tpos.yOffset += yOffset;\n\t\t}\n\t}\n\n\t/** Replace glyph at index */\n\treplaceGlyph(index: number, glyphId: GlyphId): void {\n\t\tconst info = this.infos[index];\n\t\tif (info) {\n\t\t\tinfo.glyphId = glyphId;\n\t\t}\n\t}\n\n\t/** Insert glyph at index */\n\tinsertGlyph(index: number, info: GlyphInfo, position: GlyphPosition): void {\n\t\tthis.infos.splice(index, 0, info);\n\t\tthis.positions.splice(index, 0, position);\n\t}\n\n\t/** Remove glyphs in range [start, end) */\n\tremoveRange(start: number, end: number): void {\n\t\tconst count = end - start;\n\t\tthis.infos.splice(start, count);\n\t\tthis.positions.splice(start, count);\n\t}\n\n\t/** Merge clusters from start to end (inclusive) */\n\tmergeClusters(start: number, end: number): void {\n\t\tif (start >= end || start < 0 || end >= this.infos.length) return;\n\n\t\tconst cluster = this.infos[start]?.cluster;\n\t\tfor (let i = start + 1; i <= end; i++) {\n\t\t\tconst info = this.infos[i];\n\t\t\tif (info) {\n\t\t\t\tinfo.cluster = cluster;\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Reverse glyph order (for RTL) */\n\treverse(): void {\n\t\tthis.infos.reverse();\n\t\tthis.positions.reverse();\n\t}\n\n\t/** Reverse range [start, end) */\n\treverseRange(start: number, end: number): void {\n\t\tlet i = start;\n\t\tlet j = end - 1;\n\t\twhile (i < j) {\n\t\t\t// Swap infos\n\t\t\tconst tmpInfo = this.infos[i];\n\t\t\tconst tmpInfoJ = this.infos[j];\n\t\t\tif (!tmpInfo || !tmpInfoJ) break;\n\t\t\tthis.infos[i] = tmpInfoJ;\n\t\t\tthis.infos[j] = tmpInfo;\n\n\t\t\t// Swap positions\n\t\t\tconst tmpPos = this.positions[i];\n\t\t\tconst tmpPosJ = this.positions[j];\n\t\t\tif (!tmpPos || !tmpPosJ) break;\n\t\t\tthis.positions[i] = tmpPosJ;\n\t\t\tthis.positions[j] = tmpPos;\n\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t}\n\n\t/** Get total advance width */\n\tgetTotalAdvance(): { x: number; y: number } {\n\t\tlet x = 0;\n\t\tlet y = 0;\n\t\tfor (const pos of this.positions) {\n\t\t\tx += pos.xAdvance;\n\t\t\ty += pos.yAdvance;\n\t\t}\n\t\treturn { x, y };\n\t}\n\n\t/** Serialize to HarfBuzz-compatible format */\n\tserialize(): string {\n\t\tconst parts: string[] = [];\n\n\t\tfor (const [i, info] of this.infos.entries()) {\n\t\t\tconst pos = this.positions[i];\n\t\t\tif (!pos) continue;\n\n\t\t\tlet str = `${info.glyphId}`;\n\n\t\t\t// Add cluster if not sequential\n\t\t\tif (i === 0 || info.cluster !== this.infos[i - 1]?.cluster) {\n\t\t\t\tstr += `=${info.cluster}`;\n\t\t\t}\n\n\t\t\t// Add positioning\n\t\t\tif (pos.xOffset !== 0 || pos.yOffset !== 0) {\n\t\t\t\tstr += `@${pos.xOffset},${pos.yOffset}`;\n\t\t\t}\n\t\t\tif (pos.xAdvance !== 0) {\n\t\t\t\tstr += `+${pos.xAdvance}`;\n\t\t\t}\n\n\t\t\tparts.push(str);\n\t\t}\n\n\t\treturn `[${parts.join(\"|\")}]`;\n\t}\n\n\t/** Get glyph IDs as array */\n\tglyphIds(): GlyphId[] {\n\t\treturn this.infos.map((info) => info.glyphId);\n\t}\n\n\t/** Get clusters as array */\n\tclusters(): number[] {\n\t\treturn this.infos.map((info) => info.cluster);\n\t}\n\n\t/** Iterator for glyph info/position pairs */\n\t*[Symbol.iterator](): Iterator<{ info: GlyphInfo; position: GlyphPosition }> {\n\t\tfor (const [i, info] of this.infos.entries()) {\n\t\t\tconst position = this.positions[i];\n\t\t\tif (!position) continue;\n\t\t\tyield { info, position };\n\t\t}\n\t}\n}\n", "import {\n\tBufferFlags,\n\tClusterLevel,\n\tDirection,\n\ttype GlyphInfo,\n} from \"../types.ts\";\n\n/**\n * Input buffer for text to be shaped.\n * Holds Unicode codepoints with associated properties.\n */\nexport class UnicodeBuffer {\n\tprivate _direction: Direction = Direction.LTR;\n\tprivate _script: string = \"Zyyy\"; // Common/Unknown\n\tprivate _language: string | null = null;\n\tprivate _clusterLevel: ClusterLevel = ClusterLevel.MonotoneGraphemes;\n\tprivate _flags: BufferFlags = BufferFlags.Default;\n\n\t/** Codepoints to shape */\n\treadonly codepoints: number[] = [];\n\t/** Cluster indices (maps each codepoint to its cluster) */\n\treadonly clusters: number[] = [];\n\n\t/** Pre-context (text before the buffer for contextual shaping) */\n\tpreContext: number[] = [];\n\t/** Post-context (text after the buffer for contextual shaping) */\n\tpostContext: number[] = [];\n\n\t/** Add a string to the buffer */\n\taddStr(text: string, startCluster = 0): this {\n\t\tlet cluster = startCluster;\n\t\tfor (const char of text) {\n\t\t\tconst codepoint = char.codePointAt(0);\n\t\t\tif (codepoint === undefined) continue;\n\t\t\tthis.codepoints.push(codepoint);\n\t\t\tthis.clusters.push(cluster);\n\t\t\tcluster++;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** Add codepoints directly */\n\taddCodepoints(codepoints: number[], startCluster = 0): this {\n\t\tlet cluster = startCluster;\n\t\tfor (const cp of codepoints) {\n\t\t\tthis.codepoints.push(cp);\n\t\t\tthis.clusters.push(cluster);\n\t\t\tcluster++;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** Add a single codepoint */\n\taddCodepoint(codepoint: number, cluster?: number): this {\n\t\tthis.codepoints.push(codepoint);\n\t\tthis.clusters.push(cluster ?? this.codepoints.length - 1);\n\t\treturn this;\n\t}\n\n\t/** Set text direction */\n\tsetDirection(direction: Direction): this {\n\t\tthis._direction = direction;\n\t\treturn this;\n\t}\n\n\t/** Set script (ISO 15924 tag, e.g., 'Latn', 'Arab') */\n\tsetScript(script: string): this {\n\t\tthis._script = script;\n\t\treturn this;\n\t}\n\n\t/** Set language (BCP 47 tag, e.g., 'en', 'ar') */\n\tsetLanguage(language: string | null): this {\n\t\tthis._language = language;\n\t\treturn this;\n\t}\n\n\t/** Set cluster level */\n\tsetClusterLevel(level: ClusterLevel): this {\n\t\tthis._clusterLevel = level;\n\t\treturn this;\n\t}\n\n\t/** Set buffer flags */\n\tsetFlags(flags: BufferFlags): this {\n\t\tthis._flags = flags;\n\t\treturn this;\n\t}\n\n\t/** Set pre-context string */\n\tsetPreContext(text: string): this {\n\t\tthis.preContext = [];\n\t\tfor (const char of text) {\n\t\t\tconst codepoint = char.codePointAt(0);\n\t\t\tif (codepoint !== undefined) {\n\t\t\t\tthis.preContext.push(codepoint);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** Set post-context string */\n\tsetPostContext(text: string): this {\n\t\tthis.postContext = [];\n\t\tfor (const char of text) {\n\t\t\tconst codepoint = char.codePointAt(0);\n\t\t\tif (codepoint !== undefined) {\n\t\t\t\tthis.postContext.push(codepoint);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** Clear the buffer */\n\tclear(): this {\n\t\tthis.codepoints.length = 0;\n\t\tthis.clusters.length = 0;\n\t\tthis.preContext.length = 0;\n\t\tthis.postContext.length = 0;\n\t\treturn this;\n\t}\n\n\t/** Number of codepoints */\n\tget length(): number {\n\t\treturn this.codepoints.length;\n\t}\n\n\tget direction(): Direction {\n\t\treturn this._direction;\n\t}\n\n\tget script(): string {\n\t\treturn this._script;\n\t}\n\n\tget language(): string | null {\n\t\treturn this._language;\n\t}\n\n\tget clusterLevel(): ClusterLevel {\n\t\treturn this._clusterLevel;\n\t}\n\n\tget flags(): BufferFlags {\n\t\treturn this._flags;\n\t}\n\n\t/** Convert to initial glyph infos (codepoint = glyphId initially) */\n\ttoGlyphInfos(): GlyphInfo[] {\n\t\treturn this.codepoints.map((codepoint, i) => ({\n\t\t\tglyphId: 0, // Will be set during shaping\n\t\t\tcluster: this.clusters[i] ?? 0,\n\t\t\tmask: 0,\n\t\t\tcodepoint,\n\t\t}));\n\t}\n}\n", "import type {\n\tF2Dot14,\n\tFixed,\n\tint16,\n\tint32,\n\tOffset16,\n\tOffset32,\n\tTag,\n\tuint8,\n\tuint16,\n\tuint32,\n} from \"../../types.ts\";\n\n/**\n * Zero-copy binary reader for OpenType font data.\n * All multi-byte values are big-endian per OpenType spec.\n */\nexport class Reader {\n\tprivate readonly data: DataView;\n\tprivate readonly start: number;\n\tprivate readonly end: number;\n\tprivate pos: number;\n\n\tconstructor(buffer: ArrayBuffer | DataView, offset = 0, length?: number) {\n\t\tif (buffer instanceof ArrayBuffer) {\n\t\t\tthis.data = new DataView(buffer);\n\t\t\tthis.start = offset;\n\t\t\tthis.end = length !== undefined ? offset + length : buffer.byteLength;\n\t\t} else {\n\t\t\tthis.data = buffer;\n\t\t\tthis.start = buffer.byteOffset + offset;\n\t\t\tthis.end =\n\t\t\t\tlength !== undefined\n\t\t\t\t\t? this.start + length\n\t\t\t\t\t: buffer.byteOffset + buffer.byteLength;\n\t\t}\n\t\tthis.pos = this.start;\n\t}\n\n\t/** Current read position relative to start */\n\tget offset(): number {\n\t\treturn this.pos - this.start;\n\t}\n\n\t/** Bytes remaining to read */\n\tget remaining(): number {\n\t\treturn this.end - this.pos;\n\t}\n\n\t/** Total length of this reader's view */\n\tget length(): number {\n\t\treturn this.end - this.start;\n\t}\n\n\t/** Seek to absolute offset (relative to this reader's start) */\n\tseek(offset: number): void {\n\t\tthis.pos = this.start + offset;\n\t}\n\n\t/** Skip bytes */\n\tskip(bytes: number): void {\n\t\tthis.pos += bytes;\n\t}\n\n\t/** Create a sub-reader (zero-copy slice) */\n\tslice(offset: number, length: number): Reader {\n\t\treturn new Reader(this.data, this.start + offset, length);\n\t}\n\n\t/** Create a sub-reader from current position */\n\tsliceFrom(offset: number): Reader {\n\t\treturn new Reader(\n\t\t\tthis.data,\n\t\t\tthis.start + offset,\n\t\t\tthis.end - this.start - offset,\n\t\t);\n\t}\n\n\t/** Peek at a value without advancing position */\n\tpeek<T>(fn: () => T): T {\n\t\tconst savedPos = this.pos;\n\t\tconst result = fn();\n\t\tthis.pos = savedPos;\n\t\treturn result;\n\t}\n\n\t// Primitive readers (big-endian)\n\n\tuint8(): uint8 {\n\t\tconst value = this.data.getUint8(this.pos);\n\t\tthis.pos += 1;\n\t\treturn value;\n\t}\n\n\tint8(): number {\n\t\tconst value = this.data.getInt8(this.pos);\n\t\tthis.pos += 1;\n\t\treturn value;\n\t}\n\n\tuint16(): uint16 {\n\t\tconst value = this.data.getUint16(this.pos, false);\n\t\tthis.pos += 2;\n\t\treturn value;\n\t}\n\n\tint16(): int16 {\n\t\tconst value = this.data.getInt16(this.pos, false);\n\t\tthis.pos += 2;\n\t\treturn value;\n\t}\n\n\tuint32(): uint32 {\n\t\tconst value = this.data.getUint32(this.pos, false);\n\t\tthis.pos += 4;\n\t\treturn value;\n\t}\n\n\tint32(): int32 {\n\t\tconst value = this.data.getInt32(this.pos, false);\n\t\tthis.pos += 4;\n\t\treturn value;\n\t}\n\n\t// OpenType-specific types\n\n\t/** 16.16 fixed-point number */\n\tfixed(): Fixed {\n\t\treturn this.int32() / 65536;\n\t}\n\n\t/** 2.14 fixed-point number */\n\tf2dot14(): F2Dot14 {\n\t\treturn this.int16() / 16384;\n\t}\n\n\t/** Signed 16-bit integer in font design units */\n\tfword(): int16 {\n\t\treturn this.int16();\n\t}\n\n\t/** Unsigned 16-bit integer in font design units */\n\tufword(): uint16 {\n\t\treturn this.uint16();\n\t}\n\n\t/** 64-bit signed integer (seconds since 1904-01-01) */\n\tlongDateTime(): bigint {\n\t\tconst high = this.uint32();\n\t\tconst low = this.uint32();\n\t\treturn (BigInt(high) << 32n) | BigInt(low);\n\t}\n\n\t/** 4-byte ASCII tag as packed uint32 */\n\ttag(): Tag {\n\t\treturn this.uint32();\n\t}\n\n\t/** 4-byte ASCII tag as string */\n\ttagString(): string {\n\t\tconst t = this.uint32();\n\t\treturn String.fromCharCode(\n\t\t\t(t >> 24) & 0xff,\n\t\t\t(t >> 16) & 0xff,\n\t\t\t(t >> 8) & 0xff,\n\t\t\tt & 0xff,\n\t\t);\n\t}\n\n\t/** 16-bit offset */\n\toffset16(): Offset16 {\n\t\treturn this.uint16();\n\t}\n\n\t/** 32-bit offset */\n\toffset32(): Offset32 {\n\t\treturn this.uint32();\n\t}\n\n\t/** 24-bit unsigned integer */\n\tuint24(): number {\n\t\tconst b0 = this.data.getUint8(this.pos);\n\t\tconst b1 = this.data.getUint8(this.pos + 1);\n\t\tconst b2 = this.data.getUint8(this.pos + 2);\n\t\tthis.pos += 3;\n\t\treturn (b0 << 16) | (b1 << 8) | b2;\n\t}\n\n\t// Array readers\n\n\tuint8Array(count: number): Uint8Array {\n\t\tconst result = new Uint8Array(count);\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tresult[i] = this.uint8();\n\t\t}\n\t\treturn result;\n\t}\n\n\tuint16Array(count: number): Uint16Array {\n\t\tconst result = new Uint16Array(count);\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tresult[i] = this.uint16();\n\t\t}\n\t\treturn result;\n\t}\n\n\tint16Array(count: number): Int16Array {\n\t\tconst result = new Int16Array(count);\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tresult[i] = this.int16();\n\t\t}\n\t\treturn result;\n\t}\n\n\tuint32Array(count: number): Uint32Array {\n\t\tconst result = new Uint32Array(count);\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tresult[i] = this.uint32();\n\t\t}\n\t\treturn result;\n\t}\n\n\t/** Read array using custom reader function */\n\tarray<T>(count: number, readFn: (reader: Reader) => T): T[] {\n\t\tconst result: T[] = new Array(count);\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tresult[i] = readFn(this);\n\t\t}\n\t\treturn result;\n\t}\n\n\t// String readers\n\n\t/** Read ASCII string of given length */\n\tascii(length: number): string {\n\t\tlet result = \"\";\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tresult += String.fromCharCode(this.uint8());\n\t\t}\n\t\treturn result;\n\t}\n\n\t/** Read UTF-16BE string (used in 'name' table) */\n\tutf16be(length: number): string {\n\t\tconst chars: number[] = [];\n\t\tconst charCount = length / 2;\n\t\tfor (let i = 0; i < charCount; i++) {\n\t\t\tchars.push(this.uint16());\n\t\t}\n\t\treturn String.fromCharCode(...chars);\n\t}\n\n\t// Utility methods\n\n\t/** Check if there are enough bytes remaining */\n\thasRemaining(bytes: number): boolean {\n\t\treturn this.remaining >= bytes;\n\t}\n\n\t/** Throw if not enough bytes remaining */\n\tensureRemaining(bytes: number): void {\n\t\tif (this.remaining < bytes) {\n\t\t\tthrow new Error(\n\t\t\t\t`Unexpected end of data: need ${bytes} bytes, have ${this.remaining}`,\n\t\t\t);\n\t\t}\n\t}\n\n\t/** Get raw bytes as Uint8Array (zero-copy view) */\n\tbytes(length: number): Uint8Array {\n\t\tconst result = new Uint8Array(\n\t\t\tthis.data.buffer,\n\t\t\tthis.data.byteOffset + this.pos,\n\t\t\tlength,\n\t\t);\n\t\tthis.pos += length;\n\t\treturn result;\n\t}\n\n\t/** Read value at specific offset without moving position */\n\treadAt<T>(offset: number, fn: (reader: Reader) => T): T {\n\t\tconst savedPos = this.pos;\n\t\tthis.pos = this.start + offset;\n\t\tconst result = fn(this);\n\t\tthis.pos = savedPos;\n\t\treturn result;\n\t}\n}\n", "import type { uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Axis Variations table (avar)\n * Maps user-facing axis values to normalized coordinates\n */\nexport interface AvarTable {\n\tmajorVersion: uint16;\n\tminorVersion: uint16;\n\taxisSegmentMaps: AxisSegmentMap[];\n}\n\n/**\n * Segment map for an axis\n */\nexport interface AxisSegmentMap {\n\taxisValueMaps: AxisValueMap[];\n}\n\n/**\n * Single value mapping\n */\nexport interface AxisValueMap {\n\tfromCoordinate: number; // F2DOT14\n\ttoCoordinate: number; // F2DOT14\n}\n\n/**\n * Parse avar table\n */\nexport function parseAvar(reader: Reader, axisCount: number): AvarTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\treader.skip(2); // reserved\n\n\tconst axisSegmentMaps: AxisSegmentMap[] = [];\n\n\tfor (let i = 0; i < axisCount; i++) {\n\t\tconst positionMapCount = reader.uint16();\n\t\tconst axisValueMaps: AxisValueMap[] = [];\n\n\t\tfor (let j = 0; j < positionMapCount; j++) {\n\t\t\taxisValueMaps.push({\n\t\t\t\tfromCoordinate: reader.f2dot14(),\n\t\t\t\ttoCoordinate: reader.f2dot14(),\n\t\t\t});\n\t\t}\n\n\t\taxisSegmentMaps.push({ axisValueMaps });\n\t}\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\taxisSegmentMaps,\n\t};\n}\n\n/**\n * Apply avar mapping to a normalized coordinate\n */\nexport function applyAvarMapping(\n\tsegmentMap: AxisSegmentMap,\n\tcoord: number,\n): number {\n\tconst maps = segmentMap.axisValueMaps;\n\n\tif (maps.length === 0) return coord;\n\n\t// Find the segment containing coord\n\tfor (let i = 0; i < maps.length - 1; i++) {\n\t\tconst map1 = maps[i];\n\t\tconst map2 = maps[i + 1];\n\t\tif (!map1 || !map2) continue;\n\n\t\tif (coord >= map1.fromCoordinate && coord <= map2.fromCoordinate) {\n\t\t\t// Linear interpolation\n\t\t\tconst t =\n\t\t\t\t(coord - map1.fromCoordinate) /\n\t\t\t\t(map2.fromCoordinate - map1.fromCoordinate);\n\t\t\treturn map1.toCoordinate + t * (map2.toCoordinate - map1.toCoordinate);\n\t\t}\n\t}\n\n\t// Clamp to range\n\tconst firstMap = maps[0];\n\tconst lastMap = maps[maps.length - 1];\n\tif (firstMap && coord <= firstMap.fromCoordinate) {\n\t\treturn firstMap.toCoordinate;\n\t}\n\treturn lastMap?.toCoordinate ?? coord;\n}\n\n/**\n * Apply avar mappings to all axis coordinates\n */\nexport function applyAvar(avar: AvarTable, coords: number[]): number[] {\n\tconst result: number[] = [];\n\n\tfor (const [i, coord] of coords.entries()) {\n\t\tconst segmentMap = avar.axisSegmentMaps[i];\n\t\tif (segmentMap) {\n\t\t\tresult.push(applyAvarMapping(segmentMap, coord));\n\t\t} else {\n\t\t\tresult.push(coord);\n\t\t}\n\t}\n\n\treturn result;\n}\n", "import type { Fixed, Tag } from \"../../types.ts\";\nimport { tagToString } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Font Variations table (fvar)\n * Defines axes of variation in a variable font\n */\nexport interface FvarTable {\n\tmajorVersion: number;\n\tminorVersion: number;\n\taxes: VariationAxis[];\n\tinstances: NamedInstance[];\n}\n\n/**\n * Variation axis definition\n */\nexport interface VariationAxis {\n\t/** 4-byte axis tag (e.g., 'wght', 'wdth', 'ital') */\n\ttag: Tag;\n\t/** Minimum coordinate value */\n\tminValue: Fixed;\n\t/** Default coordinate value */\n\tdefaultValue: Fixed;\n\t/** Maximum coordinate value */\n\tmaxValue: Fixed;\n\t/** Axis qualifiers (flags) */\n\tflags: number;\n\t/** Name ID for this axis */\n\taxisNameId: number;\n}\n\n/**\n * Named instance (predefined variation)\n */\nexport interface NamedInstance {\n\t/** Name ID for this instance */\n\tsubfamilyNameId: number;\n\t/** Flags */\n\tflags: number;\n\t/** Coordinate values for each axis */\n\tcoordinates: Fixed[];\n\t/** PostScript name ID (optional) */\n\tpostScriptNameId?: number;\n}\n\n/**\n * Common axis tags\n */\nexport const AxisTags = {\n\t/** Weight (100-900, default 400) */\n\twght: 0x77676874,\n\t/** Width (50-200%, default 100) */\n\twdth: 0x77647468,\n\t/** Italic (0-1) */\n\tital: 0x6974616c,\n\t/** Slant (-90 to 90 degrees) */\n\tslnt: 0x736c6e74,\n\t/** Optical size (in points) */\n\topsz: 0x6f70737a,\n} as const;\n\n/**\n * Parse fvar table\n */\nexport function parseFvar(reader: Reader): FvarTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst axesArrayOffset = reader.offset16();\n\treader.skip(2); // reserved\n\tconst axisCount = reader.uint16();\n\tconst axisSize = reader.uint16();\n\tconst instanceCount = reader.uint16();\n\tconst instanceSize = reader.uint16();\n\n\t// Parse axes\n\tconst axes: VariationAxis[] = [];\n\treader.seek(axesArrayOffset);\n\n\tfor (let i = 0; i < axisCount; i++) {\n\t\tconst axisStart = reader.offset;\n\t\tconst tag = reader.uint32();\n\t\tconst minValue = reader.fixed();\n\t\tconst defaultValue = reader.fixed();\n\t\tconst maxValue = reader.fixed();\n\t\tconst flags = reader.uint16();\n\t\tconst axisNameId = reader.uint16();\n\n\t\taxes.push({\n\t\t\ttag,\n\t\t\tminValue,\n\t\t\tdefaultValue,\n\t\t\tmaxValue,\n\t\t\tflags,\n\t\t\taxisNameId,\n\t\t});\n\n\t\t// Move to next axis (in case axisSize is larger than expected)\n\t\treader.seek(axisStart + axisSize);\n\t}\n\n\t// Parse instances\n\tconst instances: NamedInstance[] = [];\n\tconst hasPostScriptNameId = instanceSize >= 4 + axisCount * 4 + 2;\n\n\tfor (let i = 0; i < instanceCount; i++) {\n\t\tconst instanceStart = reader.offset;\n\t\tconst subfamilyNameId = reader.uint16();\n\t\tconst flags = reader.uint16();\n\n\t\tconst coordinates: Fixed[] = [];\n\t\tfor (let j = 0; j < axisCount; j++) {\n\t\t\tcoordinates.push(reader.fixed());\n\t\t}\n\n\t\tconst instance: NamedInstance = {\n\t\t\tsubfamilyNameId,\n\t\t\tflags,\n\t\t\tcoordinates,\n\t\t};\n\n\t\tif (hasPostScriptNameId) {\n\t\t\tinstance.postScriptNameId = reader.uint16();\n\t\t}\n\n\t\tinstances.push(instance);\n\n\t\t// Move to next instance\n\t\treader.seek(instanceStart + instanceSize);\n\t}\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\taxes,\n\t\tinstances,\n\t};\n}\n\n/**\n * Normalize axis value to range [-1, 1]\n */\nexport function normalizeAxisValue(axis: VariationAxis, value: number): number {\n\tif (value < axis.defaultValue) {\n\t\tif (value < axis.minValue) value = axis.minValue;\n\t\tif (axis.defaultValue === axis.minValue) return 0;\n\t\treturn (value - axis.defaultValue) / (axis.defaultValue - axis.minValue);\n\t} else if (value > axis.defaultValue) {\n\t\tif (value > axis.maxValue) value = axis.maxValue;\n\t\tif (axis.defaultValue === axis.maxValue) return 0;\n\t\treturn (value - axis.defaultValue) / (axis.maxValue - axis.defaultValue);\n\t}\n\treturn 0;\n}\n\n/**\n * Get axis by tag\n */\nexport function getAxis(fvar: FvarTable, axisTag: Tag): VariationAxis | null {\n\treturn fvar.axes.find((a) => a.tag === axisTag) ?? null;\n}\n\n/**\n * Get axis index by tag\n */\nexport function getAxisIndex(fvar: FvarTable, axisTag: Tag): number {\n\treturn fvar.axes.findIndex((a) => a.tag === axisTag);\n}\n\n/**\n * Debug: Print axis info\n */\nexport function formatAxis(axis: VariationAxis): string {\n\treturn `${tagToString(axis.tag)}: ${axis.minValue.toFixed(1)}..${axis.defaultValue.toFixed(1)}..${axis.maxValue.toFixed(1)}`;\n}\n", "import type { GlyphId, uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Horizontal Metrics Variations table (HVAR)\n * Provides variations for horizontal advance widths and LSB\n */\nexport interface HvarTable {\n\tmajorVersion: number;\n\tminorVersion: number;\n\titemVariationStore: ItemVariationStore;\n\tadvanceWidthMapping: DeltaSetIndexMap | null;\n\tlsbMapping: DeltaSetIndexMap | null;\n\trsbMapping: DeltaSetIndexMap | null;\n}\n\n/**\n * Item Variation Store - stores delta values for variations\n */\nexport interface ItemVariationStore {\n\tformat: number;\n\tvariationRegions: VariationRegion[];\n\titemVariationData: ItemVariationData[];\n}\n\n/**\n * Variation region defines the space where deltas apply\n */\nexport interface VariationRegion {\n\tregionAxes: RegionAxisCoordinates[];\n}\n\n/**\n * Axis coordinates for a region\n */\nexport interface RegionAxisCoordinates {\n\tstartCoord: number; // F2DOT14\n\tpeakCoord: number;\n\tendCoord: number;\n}\n\n/**\n * Item variation data subtable\n */\nexport interface ItemVariationData {\n\titemCount: uint16;\n\tregionIndexes: uint16[];\n\tdeltaSets: number[][];\n}\n\n/**\n * Delta set index map for mapping glyphs to variation data\n */\nexport interface DeltaSetIndexMap {\n\tformat: number;\n\tmapCount: uint32;\n\tentryFormat: number;\n\tinnerIndexBitCount: number;\n\tmapData: { outer: number; inner: number }[];\n}\n\n/**\n * Parse HVAR table\n */\nexport function parseHvar(reader: Reader): HvarTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst itemVariationStoreOffset = reader.offset32();\n\tconst advanceWidthMappingOffset = reader.offset32();\n\tconst lsbMappingOffset = reader.offset32();\n\tconst rsbMappingOffset = reader.offset32();\n\n\t// Parse item variation store\n\tconst itemVariationStore = parseItemVariationStore(\n\t\treader.sliceFrom(itemVariationStoreOffset),\n\t);\n\n\t// Parse mappings\n\tconst advanceWidthMapping =\n\t\tadvanceWidthMappingOffset !== 0\n\t\t\t? parseDeltaSetIndexMap(reader.sliceFrom(advanceWidthMappingOffset))\n\t\t\t: null;\n\n\tconst lsbMapping =\n\t\tlsbMappingOffset !== 0\n\t\t\t? parseDeltaSetIndexMap(reader.sliceFrom(lsbMappingOffset))\n\t\t\t: null;\n\n\tconst rsbMapping =\n\t\trsbMappingOffset !== 0\n\t\t\t? parseDeltaSetIndexMap(reader.sliceFrom(rsbMappingOffset))\n\t\t\t: null;\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\titemVariationStore,\n\t\tadvanceWidthMapping,\n\t\tlsbMapping,\n\t\trsbMapping,\n\t};\n}\n\nfunction parseItemVariationStore(reader: Reader): ItemVariationStore {\n\tconst format = reader.uint16();\n\tconst variationRegionListOffset = reader.offset32();\n\tconst itemVariationDataCount = reader.uint16();\n\n\tconst itemVariationDataOffsets: uint32[] = [];\n\tfor (let i = 0; i < itemVariationDataCount; i++) {\n\t\titemVariationDataOffsets.push(reader.offset32());\n\t}\n\n\t// Parse variation regions\n\tconst regionReader = reader.sliceFrom(variationRegionListOffset);\n\tconst axisCount = regionReader.uint16();\n\tconst regionCount = regionReader.uint16();\n\n\tconst variationRegions: VariationRegion[] = [];\n\tfor (let i = 0; i < regionCount; i++) {\n\t\tconst regionAxes: RegionAxisCoordinates[] = [];\n\t\tfor (let j = 0; j < axisCount; j++) {\n\t\t\tregionAxes.push({\n\t\t\t\tstartCoord: regionReader.f2dot14(),\n\t\t\t\tpeakCoord: regionReader.f2dot14(),\n\t\t\t\tendCoord: regionReader.f2dot14(),\n\t\t\t});\n\t\t}\n\t\tvariationRegions.push({ regionAxes });\n\t}\n\n\t// Parse item variation data\n\tconst itemVariationData: ItemVariationData[] = [];\n\tfor (const offset of itemVariationDataOffsets) {\n\t\tconst dataReader = reader.sliceFrom(offset);\n\t\tconst itemCount = dataReader.uint16();\n\t\tconst wordDeltaCount = dataReader.uint16();\n\t\tconst regionIndexCount = dataReader.uint16();\n\n\t\tconst regionIndexes: uint16[] = [];\n\t\tfor (let i = 0; i < regionIndexCount; i++) {\n\t\t\tregionIndexes.push(dataReader.uint16());\n\t\t}\n\n\t\t// Parse delta sets\n\t\tconst longWords = (wordDeltaCount & 0x8000) !== 0;\n\t\tconst wordCount = wordDeltaCount & 0x7fff;\n\t\tconst shortCount = regionIndexCount - wordCount;\n\n\t\tconst deltaSets: number[][] = [];\n\t\tfor (let i = 0; i < itemCount; i++) {\n\t\t\tconst deltas: number[] = [];\n\t\t\t// Read word-sized deltas\n\t\t\tfor (let j = 0; j < wordCount; j++) {\n\t\t\t\tif (longWords) {\n\t\t\t\t\tdeltas.push(dataReader.int32());\n\t\t\t\t} else {\n\t\t\t\t\tdeltas.push(dataReader.int16());\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Read short-sized deltas\n\t\t\tfor (let j = 0; j < shortCount; j++) {\n\t\t\t\tif (longWords) {\n\t\t\t\t\tdeltas.push(dataReader.int16());\n\t\t\t\t} else {\n\t\t\t\t\tdeltas.push(dataReader.int8());\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeltaSets.push(deltas);\n\t\t}\n\n\t\titemVariationData.push({ itemCount, regionIndexes, deltaSets });\n\t}\n\n\treturn { format, variationRegions, itemVariationData };\n}\n\nfunction parseDeltaSetIndexMap(reader: Reader): DeltaSetIndexMap {\n\tconst format = reader.uint8();\n\tconst entryFormat = reader.uint8();\n\tconst mapCount = format === 0 ? reader.uint16() : reader.uint32();\n\n\tconst innerIndexBitCount = (entryFormat & 0x0f) + 1;\n\tconst mapEntrySize = ((entryFormat >> 4) & 0x03) + 1;\n\n\tconst mapData: { outer: number; inner: number }[] = [];\n\tfor (let i = 0; i < mapCount; i++) {\n\t\tlet entry = 0;\n\t\tfor (let j = 0; j < mapEntrySize; j++) {\n\t\t\tentry = (entry << 8) | reader.uint8();\n\t\t}\n\n\t\tconst inner = entry & ((1 << innerIndexBitCount) - 1);\n\t\tconst outer = entry >> innerIndexBitCount;\n\t\tmapData.push({ outer, inner });\n\t}\n\n\treturn { format, mapCount, entryFormat, innerIndexBitCount, mapData };\n}\n\n/**\n * Calculate scalar for a variation region given axis coordinates\n */\nexport function calculateRegionScalar(\n\tregion: VariationRegion,\n\tcoords: number[], // Normalized axis coordinates [-1, 1]\n): number {\n\tlet scalar = 1.0;\n\n\tfor (let i = 0; i < region.regionAxes.length && i < coords.length; i++) {\n\t\tconst axis = region.regionAxes[i];\n\t\tconst coord = coords[i];\n\t\tif (axis === undefined || coord === undefined) continue;\n\n\t\t// Outside the region\n\t\tif (coord < axis.startCoord || coord > axis.endCoord) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// At peak\n\t\tif (coord === axis.peakCoord) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Interpolate\n\t\tif (coord < axis.peakCoord) {\n\t\t\tif (axis.peakCoord === axis.startCoord) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tscalar *= (coord - axis.startCoord) / (axis.peakCoord - axis.startCoord);\n\t\t} else {\n\t\t\tif (axis.peakCoord === axis.endCoord) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tscalar *= (axis.endCoord - coord) / (axis.endCoord - axis.peakCoord);\n\t\t}\n\t}\n\n\treturn scalar;\n}\n\n/**\n * Get delta for a glyph from HVAR using a specific mapping\n */\nfunction getDeltaFromMapping(\n\thvar: HvarTable,\n\tglyphId: GlyphId,\n\tcoords: number[],\n\tmapping: DeltaSetIndexMap | null,\n): number {\n\t// Get outer/inner index\n\tlet outer: number;\n\tlet inner: number;\n\n\tif (mapping && glyphId < mapping.mapData.length) {\n\t\tconst entry = mapping.mapData[glyphId];\n\t\tif (!entry) {\n\t\t\touter = 0;\n\t\t\tinner = glyphId;\n\t\t} else {\n\t\t\touter = entry.outer;\n\t\t\tinner = entry.inner;\n\t\t}\n\t} else {\n\t\t// Direct mapping: outer = 0, inner = glyphId\n\t\touter = 0;\n\t\tinner = glyphId;\n\t}\n\n\t// Get variation data\n\tconst varData = hvar.itemVariationStore.itemVariationData[outer];\n\tif (!varData || inner >= varData.itemCount) {\n\t\treturn 0;\n\t}\n\n\tconst deltaSet = varData.deltaSets[inner];\n\tif (!deltaSet) {\n\t\treturn 0;\n\t}\n\n\t// Calculate total delta\n\tlet delta = 0;\n\tfor (const [i, regionIndex] of varData.regionIndexes.entries()) {\n\t\tconst region = hvar.itemVariationStore.variationRegions[regionIndex];\n\t\tif (!region) continue;\n\n\t\tconst scalar = calculateRegionScalar(region, coords);\n\t\tconst regionDelta = deltaSet[i] ?? 0;\n\t\tdelta += scalar * regionDelta;\n\t}\n\n\treturn Math.round(delta);\n}\n\n/**\n * Get advance width delta for a glyph at given variation coordinates\n */\nexport function getAdvanceWidthDelta(\n\thvar: HvarTable,\n\tglyphId: GlyphId,\n\tcoords: number[],\n): number {\n\treturn getDeltaFromMapping(hvar, glyphId, coords, hvar.advanceWidthMapping);\n}\n\n/**\n * Get left side bearing delta for a glyph at given variation coordinates\n */\nexport function getLsbDelta(\n\thvar: HvarTable,\n\tglyphId: GlyphId,\n\tcoords: number[],\n): number {\n\tif (!hvar.lsbMapping) {\n\t\treturn 0; // No LSB variations in this font\n\t}\n\treturn getDeltaFromMapping(hvar, glyphId, coords, hvar.lsbMapping);\n}\n\n/**\n * Get right side bearing delta for a glyph at given variation coordinates\n */\nexport function getRsbDelta(\n\thvar: HvarTable,\n\tglyphId: GlyphId,\n\tcoords: number[],\n): number {\n\tif (!hvar.rsbMapping) {\n\t\treturn 0; // No RSB variations in this font\n\t}\n\treturn getDeltaFromMapping(hvar, glyphId, coords, hvar.rsbMapping);\n}\n", "import type { GlyphId, Tag, Variation } from \"../types.ts\";\nimport { tag } from \"../types.ts\";\nimport type { Font } from \"./font.ts\";\nimport { applyAvar } from \"./tables/avar.ts\";\nimport { normalizeAxisValue, type VariationAxis } from \"./tables/fvar.ts\";\nimport { getAdvanceWidthDelta, getLsbDelta } from \"./tables/hvar.ts\";\n\n/**\n * A Face represents a specific instance of a variable font.\n * For non-variable fonts, it simply wraps the Font.\n */\nexport class Face {\n\treadonly font: Font;\n\n\t/** Normalized axis coordinates [-1, 1] */\n\tprivate _coords: number[];\n\n\t/** User-space axis values */\n\tprivate _variations: Map<Tag, number>;\n\n\tconstructor(font: Font, variations?: Record<string, number> | Variation[]) {\n\t\tthis.font = font;\n\t\tthis._coords = [];\n\t\tthis._variations = new Map();\n\n\t\t// Initialize to default axis values\n\t\tconst fvar = font.fvar;\n\t\tif (fvar) {\n\t\t\tthis._coords = new Array(fvar.axes.length).fill(0);\n\n\t\t\t// Apply user variations\n\t\t\tif (variations) {\n\t\t\t\tthis.setVariations(variations);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Set variation axis values\n\t * @param variations Object with axis tags as keys (e.g., { wght: 700, wdth: 100 })\n\t *                   or array of Variation objects\n\t */\n\tsetVariations(variations: Record<string, number> | Variation[]): void {\n\t\tconst fvar = this.font.fvar;\n\t\tif (!fvar) return;\n\n\t\t// Convert to map\n\t\tif (Array.isArray(variations)) {\n\t\t\tfor (const v of variations) {\n\t\t\t\tthis._variations.set(v.tag, v.value);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const [tagStr, value] of Object.entries(variations)) {\n\t\t\t\tconst t = tag(tagStr.padEnd(4, \" \"));\n\t\t\t\tthis._variations.set(t, value);\n\t\t\t}\n\t\t}\n\n\t\t// Normalize coordinates\n\t\tfor (const [i, axis] of fvar.axes.entries()) {\n\t\t\tconst userValue = this._variations.get(axis.tag) ?? axis.defaultValue;\n\t\t\tthis._coords[i] = normalizeAxisValue(axis, userValue);\n\t\t}\n\n\t\t// Apply avar mapping if present\n\t\tconst avar = this.font.avar;\n\t\tif (avar) {\n\t\t\tthis._coords = applyAvar(avar, this._coords);\n\t\t}\n\t}\n\n\t/**\n\t * Get normalized coordinates for variation processing\n\t */\n\tget normalizedCoords(): number[] {\n\t\treturn this._coords;\n\t}\n\n\t/**\n\t * Check if this is a variable font instance\n\t */\n\tget isVariable(): boolean {\n\t\treturn this.font.isVariable;\n\t}\n\n\t/**\n\t * Get variation axes\n\t */\n\tget axes(): VariationAxis[] {\n\t\treturn this.font.fvar?.axes ?? [];\n\t}\n\n\t/**\n\t * Get current value for an axis\n\t */\n\tgetAxisValue(axisTag: Tag | string): number | null {\n\t\tconst t =\n\t\t\ttypeof axisTag === \"string\" ? tag(axisTag.padEnd(4, \" \")) : axisTag;\n\t\tconst fvar = this.font.fvar;\n\t\tif (!fvar) return null;\n\n\t\tconst value = this._variations.get(t);\n\t\tif (value !== undefined) return value;\n\n\t\tconst axis = fvar.axes.find((a) => a.tag === t);\n\t\treturn axis?.defaultValue ?? null;\n\t}\n\n\t/**\n\t * Get advance width for a glyph, including variation deltas\n\t */\n\tadvanceWidth(glyphId: GlyphId): number {\n\t\tlet advance = this.font.advanceWidth(glyphId);\n\n\t\t// Apply HVAR delta if variable\n\t\tif (this._coords.length > 0 && this.font.hvar) {\n\t\t\tconst delta = getAdvanceWidthDelta(this.font.hvar, glyphId, this._coords);\n\t\t\tadvance += delta;\n\t\t}\n\n\t\treturn advance;\n\t}\n\n\t/**\n\t * Get left side bearing for a glyph, including variation deltas\n\t */\n\tleftSideBearing(glyphId: GlyphId): number {\n\t\tlet lsb = this.font.leftSideBearing(glyphId);\n\n\t\t// Apply HVAR LSB delta if variable\n\t\tif (this._coords.length > 0 && this.font.hvar) {\n\t\t\tconst delta = getLsbDelta(this.font.hvar, glyphId, this._coords);\n\t\t\tlsb += delta;\n\t\t}\n\n\t\treturn lsb;\n\t}\n\n\t// Delegate common properties to font\n\n\tget numGlyphs(): number {\n\t\treturn this.font.numGlyphs;\n\t}\n\n\tget unitsPerEm(): number {\n\t\treturn this.font.unitsPerEm;\n\t}\n\n\tget ascender(): number {\n\t\treturn this.font.ascender;\n\t}\n\n\tget descender(): number {\n\t\treturn this.font.descender;\n\t}\n\n\tget lineGap(): number {\n\t\treturn this.font.lineGap;\n\t}\n\n\tglyphId(codepoint: number): GlyphId {\n\t\treturn this.font.glyphId(codepoint);\n\t}\n\n\tglyphIdForChar(char: string): GlyphId {\n\t\treturn this.font.glyphIdForChar(char);\n\t}\n\n\thasTable(t: Tag): boolean {\n\t\treturn this.font.hasTable(t);\n\t}\n\n\t// Expose tables\n\tget gdef() {\n\t\treturn this.font.gdef;\n\t}\n\tget gsub() {\n\t\treturn this.font.gsub;\n\t}\n\tget gpos() {\n\t\treturn this.font.gpos;\n\t}\n\tget kern() {\n\t\treturn this.font.kern;\n\t}\n\tget morx() {\n\t\treturn this.font.morx;\n\t}\n\tget cmap() {\n\t\treturn this.font.cmap;\n\t}\n\tget hmtx() {\n\t\treturn this.font.hmtx;\n\t}\n\tget hhea() {\n\t\treturn this.font.hhea;\n\t}\n}\n\n/**\n * Create a face from a font with optional variations\n */\nexport function createFace(\n\tfont: Font,\n\tvariations?: Record<string, number> | Variation[],\n): Face {\n\treturn new Face(font, variations);\n}\n", "/**\n * WOFF2 to SFNT Converter\n *\n * Converts WOFF2 compressed fonts back to raw TTF/OTF format.\n * Reference: https://www.w3.org/TR/WOFF2/\n */\n\n// Known table tags indexed by flag value 0-62\nconst KNOWN_TAGS = [\n\t\"cmap\", \"head\", \"hhea\", \"hmtx\", \"maxp\", \"name\", \"OS/2\", \"post\",\n\t\"cvt \", \"fpgm\", \"glyf\", \"loca\", \"prep\", \"CFF \", \"VORG\", \"EBDT\",\n\t\"EBLC\", \"gasp\", \"hdmx\", \"kern\", \"LTSH\", \"PCLT\", \"VDMX\", \"vhea\",\n\t\"vmtx\", \"BASE\", \"GDEF\", \"GPOS\", \"GSUB\", \"EBSC\", \"JSTF\", \"MATH\",\n\t\"CBDT\", \"CBLC\", \"COLR\", \"CPAL\", \"SVG \", \"sbix\", \"acnt\", \"avar\",\n\t\"bdat\", \"bloc\", \"bsln\", \"cvar\", \"fdsc\", \"feat\", \"fmtx\", \"fvar\",\n\t\"gvar\", \"hsty\", \"just\", \"lcar\", \"mort\", \"morx\", \"opbd\", \"prop\",\n\t\"trak\", \"Zapf\", \"Silf\", \"Glat\", \"Gloc\", \"Feat\", \"Sill\",\n];\n\ninterface Woff2TableEntry {\n\ttag: string;\n\torigLength: number;\n\ttransformLength: number;\n\ttransformVersion: number;\n}\n\n/** Read UIntBase128 variable-length integer */\nfunction readUIntBase128(data: Uint8Array, offset: { value: number }): number {\n\tlet result = 0;\n\tfor (let i = 0; i < 5; i++) {\n\t\tconst byte = data[offset.value++];\n\t\tif (i === 0 && byte === 0x80) {\n\t\t\tthrow new Error(\"Invalid UIntBase128: leading zeros\");\n\t\t}\n\t\tif (result > 0x1fffff) {\n\t\t\tthrow new Error(\"UIntBase128 overflow\");\n\t\t}\n\t\tresult = (result << 7) | (byte & 0x7f);\n\t\tif ((byte & 0x80) === 0) {\n\t\t\treturn result;\n\t\t}\n\t}\n\tthrow new Error(\"UIntBase128 too long\");\n}\n\n/** Read 255UInt16 */\nfunction read255UInt16(data: Uint8Array, offset: { value: number }): number {\n\tconst code = data[offset.value++];\n\tif (code === 253) {\n\t\tconst hi = data[offset.value++];\n\t\tconst lo = data[offset.value++];\n\t\treturn (hi << 8) | lo;\n\t} else if (code === 255) {\n\t\treturn data[offset.value++] + 253 * 2;\n\t} else if (code === 254) {\n\t\treturn data[offset.value++] + 253;\n\t}\n\treturn code;\n}\n\n/** Parse WOFF2 table directory entries */\nfunction parseTableDirectory(data: Uint8Array, offset: { value: number }, numTables: number): Woff2TableEntry[] {\n\tconst tables: Woff2TableEntry[] = [];\n\n\tfor (let i = 0; i < numTables; i++) {\n\t\tconst flags = data[offset.value++];\n\t\tconst tagIndex = flags & 0x3f;\n\t\tconst transformVersion = (flags >> 6) & 0x03;\n\n\t\tlet tag: string;\n\t\tif (tagIndex === 63) {\n\t\t\ttag = String.fromCharCode(\n\t\t\t\tdata[offset.value++],\n\t\t\t\tdata[offset.value++],\n\t\t\t\tdata[offset.value++],\n\t\t\t\tdata[offset.value++]\n\t\t\t);\n\t\t} else {\n\t\t\ttag = KNOWN_TAGS[tagIndex];\n\t\t}\n\n\t\tconst origLength = readUIntBase128(data, offset);\n\n\t\tlet transformLength = origLength;\n\t\t// glyf/loca: transform version 0 = transformed, 3 = null transform\n\t\t// others: transform version 0 = null transform\n\t\tconst hasTransform = (tag === \"glyf\" || tag === \"loca\")\n\t\t\t? transformVersion === 0\n\t\t\t: transformVersion !== 0;\n\n\t\tif (hasTransform) {\n\t\t\ttransformLength = readUIntBase128(data, offset);\n\t\t}\n\n\t\ttables.push({ tag, origLength, transformLength, transformVersion });\n\t}\n\n\treturn tables;\n}\n\n/** Decompress Brotli data using native APIs when available */\nasync function decompressBrotli(data: Uint8Array): Promise<Uint8Array> {\n\t// 1. Bun/Node.js - use native zlib (fastest)\n\tif (typeof process !== \"undefined\" && process.versions?.node || typeof Bun !== \"undefined\") {\n\t\tconst zlib = await import(\"node:zlib\");\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tzlib.brotliDecompress(Buffer.from(data), (err, result) => {\n\t\t\t\tif (err) reject(err);\n\t\t\t\telse resolve(new Uint8Array(result));\n\t\t\t});\n\t\t});\n\t}\n\n\t// 2. Browser - try native DecompressionStream with \"brotli\" (Safari 18.4+, Deno)\n\tif (typeof DecompressionStream !== \"undefined\") {\n\t\ttry {\n\t\t\tconst ds = new DecompressionStream(\"brotli\" as CompressionFormat);\n\t\t\tconst blob = new Blob([data]);\n\t\t\tconst decompressedStream = blob.stream().pipeThrough(ds);\n\t\t\tconst result = await new Response(decompressedStream).arrayBuffer();\n\t\t\treturn new Uint8Array(result);\n\t\t} catch {\n\t\t\t// \"brotli\" not supported in this browser\n\t\t}\n\t}\n\n\t// 3. Fallback - pure TypeScript brotli decoder\n\tconst { decompress } = await import(\"./brotli/decode.ts\");\n\treturn decompress(data);\n}\n\n/** Write uint16 big-endian */\nfunction writeUint16BE(arr: Uint8Array, offset: number, value: number): void {\n\tarr[offset] = (value >> 8) & 0xff;\n\tarr[offset + 1] = value & 0xff;\n}\n\n/** Write uint32 big-endian */\nfunction writeUint32BE(arr: Uint8Array, offset: number, value: number): void {\n\tarr[offset] = (value >> 24) & 0xff;\n\tarr[offset + 1] = (value >> 16) & 0xff;\n\tarr[offset + 2] = (value >> 8) & 0xff;\n\tarr[offset + 3] = value & 0xff;\n}\n\n/** Read uint16 big-endian */\nfunction readUint16BE(arr: Uint8Array, offset: number): number {\n\treturn (arr[offset] << 8) | arr[offset + 1];\n}\n\n/** Read int16 big-endian */\nfunction readInt16BE(arr: Uint8Array, offset: number): number {\n\tconst val = readUint16BE(arr, offset);\n\treturn val >= 0x8000 ? val - 0x10000 : val;\n}\n\n/** Read uint32 big-endian */\nfunction readUint32BE(arr: Uint8Array, offset: number): number {\n\treturn ((arr[offset] << 24) | (arr[offset + 1] << 16) | (arr[offset + 2] << 8) | arr[offset + 3]) >>> 0;\n}\n\n/** Calculate OpenType checksum */\nfunction calcChecksum(data: Uint8Array, offset: number, length: number): number {\n\tlet sum = 0;\n\tconst nLongs = Math.ceil(length / 4);\n\tfor (let i = 0; i < nLongs; i++) {\n\t\tconst idx = offset + i * 4;\n\t\tsum = (sum + (\n\t\t\t((data[idx] || 0) << 24) |\n\t\t\t((data[idx + 1] || 0) << 16) |\n\t\t\t((data[idx + 2] || 0) << 8) |\n\t\t\t(data[idx + 3] || 0)\n\t\t)) >>> 0;\n\t}\n\treturn sum;\n}\n\n/** Round up to 4-byte boundary */\nfunction pad4(n: number): number {\n\treturn (n + 3) & ~3;\n}\n\n/**\n * Decode triplet-encoded coordinates from WOFF2 glyph stream.\n * Based on fonttools implementation.\n *\n * Flag byte structure:\n *   bit 7: on-curve (0) or off-curve (1) - NOTE: inverted from TrueType!\n *   bits 0-6: encoding index (0-127)\n *\n * Encoding index determines:\n *   0-9: dy only (1 byte)\n *   10-19: dx only (1 byte)\n *   20-83: dx and dy (1 byte total)\n *   84-119: dx and dy (2 bytes total)\n *   120-123: dx and dy (3 bytes total)\n *   124-127: dx and dy (4 bytes total)\n */\nfunction decodeTriplets(\n\tflagStream: Uint8Array,\n\tglyphStream: Uint8Array,\n\tnPoints: number,\n\tflagIdx: { value: number },\n\tglyphIdx: { value: number }\n): { x: number; y: number; onCurve: boolean }[] {\n\tconst points: { x: number; y: number; onCurve: boolean }[] = [];\n\tlet x = 0, y = 0;\n\n\tfunction withSign(flag: number, baseval: number): number {\n\t\treturn (flag & 1) ? baseval : -baseval;\n\t}\n\n\tfor (let i = 0; i < nPoints; i++) {\n\t\tconst flag = flagStream[flagIdx.value++];\n\t\tconst onCurve = (flag >> 7) === 0; // bit 7 clear = on curve\n\t\tconst flagValue = flag & 0x7f;\n\n\t\tlet dx = 0, dy = 0;\n\n\t\tif (flagValue < 10) {\n\t\t\t// dy only, 1 byte\n\t\t\tdx = 0;\n\t\t\tdy = withSign(flag, ((flagValue & 14) << 7) + glyphStream[glyphIdx.value++]);\n\t\t} else if (flagValue < 20) {\n\t\t\t// dx only, 1 byte\n\t\t\tdx = withSign(flag, (((flagValue - 10) & 14) << 7) + glyphStream[glyphIdx.value++]);\n\t\t\tdy = 0;\n\t\t} else if (flagValue < 84) {\n\t\t\t// Both in 1 byte\n\t\t\tconst b0 = flagValue - 20;\n\t\t\tconst b1 = glyphStream[glyphIdx.value++];\n\t\t\tdx = withSign(flag, 1 + (b0 & 0x30) + (b1 >> 4));\n\t\t\tdy = withSign(flag >> 1, 1 + ((b0 & 0x0c) << 2) + (b1 & 0x0f));\n\t\t} else if (flagValue < 120) {\n\t\t\t// Both in 2 bytes\n\t\t\tconst b0 = flagValue - 84;\n\t\t\tdx = withSign(flag, 1 + (Math.floor(b0 / 12) << 8) + glyphStream[glyphIdx.value++]);\n\t\t\tdy = withSign(flag >> 1, 1 + (((b0 % 12) >> 2) << 8) + glyphStream[glyphIdx.value++]);\n\t\t} else if (flagValue < 124) {\n\t\t\t// Both in 3 bytes\n\t\t\tconst b1 = glyphStream[glyphIdx.value++];\n\t\t\tconst b2 = glyphStream[glyphIdx.value++];\n\t\t\tconst b3 = glyphStream[glyphIdx.value++];\n\t\t\tdx = withSign(flag, (b1 << 4) + (b2 >> 4));\n\t\t\tdy = withSign(flag >> 1, ((b2 & 0x0f) << 8) + b3);\n\t\t} else {\n\t\t\t// Both in 4 bytes\n\t\t\tdx = withSign(flag, (glyphStream[glyphIdx.value++] << 8) + glyphStream[glyphIdx.value++]);\n\t\t\tdy = withSign(flag >> 1, (glyphStream[glyphIdx.value++] << 8) + glyphStream[glyphIdx.value++]);\n\t\t}\n\n\t\tx += dx;\n\t\ty += dy;\n\t\tpoints.push({ x, y, onCurve });\n\t}\n\n\treturn points;\n}\n\n/** Reconstruct glyf and loca tables from WOFF2 transformed format */\nfunction reconstructGlyfLoca(\n\tglyfTransform: Uint8Array,\n\tnumGlyphs: number,\n\tindexFormat: number\n): { glyf: Uint8Array; loca: Uint8Array } {\n\tlet offset = 0;\n\n\t// Read transformed glyf header (per WOFF2 spec Table 1)\n\tconst version = readUint16BE(glyfTransform, offset); offset += 2;\n\tif (version !== 0) {\n\t\tthrow new Error(`Unsupported glyf transform version: ${version}`);\n\t}\n\tconst optionFlags = readUint16BE(glyfTransform, offset); offset += 2;\n\tconst numGlyphsHeader = readUint16BE(glyfTransform, offset); offset += 2;\n\tconst indexFormatHeader = readUint16BE(glyfTransform, offset); offset += 2;\n\n\tconst nContourStreamSize = readUint32BE(glyfTransform, offset); offset += 4;\n\tconst nPointsStreamSize = readUint32BE(glyfTransform, offset); offset += 4;\n\tconst flagStreamSize = readUint32BE(glyfTransform, offset); offset += 4;\n\tconst glyphStreamSize = readUint32BE(glyfTransform, offset); offset += 4;\n\tconst compositeStreamSize = readUint32BE(glyfTransform, offset); offset += 4;\n\tconst bboxStreamSize = readUint32BE(glyfTransform, offset); offset += 4;\n\tconst instructionStreamSize = readUint32BE(glyfTransform, offset); offset += 4;\n\n\t// Extract streams\n\tconst nContourStream = glyfTransform.slice(offset, offset + nContourStreamSize);\n\toffset += nContourStreamSize;\n\tconst nPointsStream = glyfTransform.slice(offset, offset + nPointsStreamSize);\n\toffset += nPointsStreamSize;\n\tconst flagStream = glyfTransform.slice(offset, offset + flagStreamSize);\n\toffset += flagStreamSize;\n\tconst glyphStream = glyfTransform.slice(offset, offset + glyphStreamSize);\n\toffset += glyphStreamSize;\n\tconst compositeStream = glyfTransform.slice(offset, offset + compositeStreamSize);\n\toffset += compositeStreamSize;\n\tconst bboxStream = glyfTransform.slice(offset, offset + bboxStreamSize);\n\toffset += bboxStreamSize;\n\tconst instructionStream = glyfTransform.slice(offset, offset + instructionStreamSize);\n\n\t// Stream indices\n\tconst nContourIdx = { value: 0 };\n\tconst nPointsIdx = { value: 0 };\n\tconst flagIdx = { value: 0 };\n\tconst glyphIdx = { value: 0 };\n\tconst compositeIdx = { value: 0 };\n\tconst bboxIdx = { value: 0 };\n\tconst instructionIdx = { value: 0 };\n\n\t// First pass: calculate glyf size\n\tconst glyphOffsets: number[] = [0];\n\tconst glyphParts: Uint8Array[] = [];\n\tlet totalGlyfSize = 0;\n\n\tfor (let g = 0; g < numGlyphs; g++) {\n\t\tconst nContours = readInt16BE(nContourStream, nContourIdx.value);\n\t\tnContourIdx.value += 2;\n\n\t\tif (nContours === 0) {\n\t\t\t// Empty glyph\n\t\t\tglyphParts.push(new Uint8Array(0));\n\t\t\tglyphOffsets.push(totalGlyfSize);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (nContours > 0) {\n\t\t\t// Simple glyph\n\t\t\tconst glyphData = reconstructSimpleGlyph(\n\t\t\t\tnContours,\n\t\t\t\tnPointsStream, nPointsIdx,\n\t\t\t\tflagStream, flagIdx,\n\t\t\t\tglyphStream, glyphIdx,\n\t\t\t\tbboxStream, bboxIdx,\n\t\t\t\tinstructionStream, instructionIdx,\n\t\t\t\toptionFlags\n\t\t\t);\n\t\t\tglyphParts.push(glyphData);\n\t\t\ttotalGlyfSize += pad4(glyphData.length);\n\t\t\tglyphOffsets.push(totalGlyfSize);\n\t\t} else {\n\t\t\t// Composite glyph (nContours === -1)\n\t\t\tconst glyphData = reconstructCompositeGlyph(\n\t\t\t\tcompositeStream, compositeIdx,\n\t\t\t\tbboxStream, bboxIdx,\n\t\t\t\tinstructionStream, instructionIdx,\n\t\t\t\toptionFlags\n\t\t\t);\n\t\t\tglyphParts.push(glyphData);\n\t\t\ttotalGlyfSize += pad4(glyphData.length);\n\t\t\tglyphOffsets.push(totalGlyfSize);\n\t\t}\n\t}\n\n\t// Build glyf table\n\tconst glyf = new Uint8Array(totalGlyfSize);\n\tlet glyfOffset = 0;\n\tfor (const part of glyphParts) {\n\t\tglyf.set(part, glyfOffset);\n\t\tglyfOffset += pad4(part.length);\n\t}\n\n\t// Build loca table\n\tconst locaSize = indexFormat === 0 ? (numGlyphs + 1) * 2 : (numGlyphs + 1) * 4;\n\tconst loca = new Uint8Array(locaSize);\n\n\tfor (let i = 0; i <= numGlyphs; i++) {\n\t\tif (indexFormat === 0) {\n\t\t\twriteUint16BE(loca, i * 2, glyphOffsets[i] / 2);\n\t\t} else {\n\t\t\twriteUint32BE(loca, i * 4, glyphOffsets[i]);\n\t\t}\n\t}\n\n\treturn { glyf, loca };\n}\n\nfunction reconstructSimpleGlyph(\n\tnContours: number,\n\tnPointsStream: Uint8Array, nPointsIdx: { value: number },\n\tflagStream: Uint8Array, flagIdx: { value: number },\n\tglyphStream: Uint8Array, glyphIdx: { value: number },\n\tbboxStream: Uint8Array, bboxIdx: { value: number },\n\tinstructionStream: Uint8Array, instructionIdx: { value: number },\n\toptionFlags: number\n): Uint8Array {\n\t// Read endpoints\n\tconst endPtsOfContours: number[] = [];\n\tlet totalPoints = 0;\n\tfor (let c = 0; c < nContours; c++) {\n\t\tconst nPoints = read255UInt16(nPointsStream, nPointsIdx);\n\t\ttotalPoints += nPoints;\n\t\tendPtsOfContours.push(totalPoints - 1);\n\t}\n\n\t// Read point data using triplet encoding\n\tconst points = decodeTriplets(flagStream, glyphStream, totalPoints, flagIdx, glyphIdx);\n\n\t// Read/compute bbox\n\tlet xMin: number, yMin: number, xMax: number, yMax: number;\n\tconst bboxBitmap = (optionFlags & 1) === 0; // bit 0 clear = explicit bboxes stored\n\n\tif (bboxBitmap && bboxIdx.value + 8 <= bboxStream.length) {\n\t\txMin = readInt16BE(bboxStream, bboxIdx.value); bboxIdx.value += 2;\n\t\tyMin = readInt16BE(bboxStream, bboxIdx.value); bboxIdx.value += 2;\n\t\txMax = readInt16BE(bboxStream, bboxIdx.value); bboxIdx.value += 2;\n\t\tyMax = readInt16BE(bboxStream, bboxIdx.value); bboxIdx.value += 2;\n\t} else {\n\t\t// Compute bbox\n\t\txMin = yMin = 0x7fff;\n\t\txMax = yMax = -0x8000;\n\t\tfor (const pt of points) {\n\t\t\txMin = Math.min(xMin, pt.x);\n\t\t\tyMin = Math.min(yMin, pt.y);\n\t\t\txMax = Math.max(xMax, pt.x);\n\t\t\tyMax = Math.max(yMax, pt.y);\n\t\t}\n\t}\n\n\t// Read instructions - length is read from glyphStream using 255UInt16 encoding\n\tconst instructionLength = read255UInt16(glyphStream, glyphIdx);\n\tconst instructions = instructionStream.slice(instructionIdx.value, instructionIdx.value + instructionLength);\n\tinstructionIdx.value += instructionLength;\n\n\t// Encode glyph in TrueType format\n\t// Convert absolute coords to deltas and encode\n\tconst xDeltas: number[] = [];\n\tconst yDeltas: number[] = [];\n\tlet prevX = 0, prevY = 0;\n\tfor (const pt of points) {\n\t\txDeltas.push(pt.x - prevX);\n\t\tyDeltas.push(pt.y - prevY);\n\t\tprevX = pt.x;\n\t\tprevY = pt.y;\n\t}\n\n\t// Encode flags and coordinates\n\tconst encodedFlags: number[] = [];\n\tconst encodedX: number[] = [];\n\tconst encodedY: number[] = [];\n\n\tfor (let i = 0; i < totalPoints; i++) {\n\t\tlet flag = points[i].onCurve ? 1 : 0;\n\t\tconst dx = xDeltas[i];\n\t\tconst dy = yDeltas[i];\n\n\t\t// X encoding\n\t\tif (dx === 0) {\n\t\t\tflag |= 0x10; // x-same\n\t\t} else if (dx >= -255 && dx <= 255) {\n\t\t\tflag |= 0x02; // x-short\n\t\t\tif (dx > 0) flag |= 0x10; // positive\n\t\t\tencodedX.push(Math.abs(dx));\n\t\t} else {\n\t\t\tencodedX.push((dx >> 8) & 0xff, dx & 0xff);\n\t\t}\n\n\t\t// Y encoding\n\t\tif (dy === 0) {\n\t\t\tflag |= 0x20; // y-same\n\t\t} else if (dy >= -255 && dy <= 255) {\n\t\t\tflag |= 0x04; // y-short\n\t\t\tif (dy > 0) flag |= 0x20; // positive\n\t\t\tencodedY.push(Math.abs(dy));\n\t\t} else {\n\t\t\tencodedY.push((dy >> 8) & 0xff, dy & 0xff);\n\t\t}\n\n\t\tencodedFlags.push(flag);\n\t}\n\n\t// Build glyph buffer\n\tconst headerSize = 10 + nContours * 2 + 2 + instructionLength;\n\tconst totalSize = headerSize + encodedFlags.length + encodedX.length + encodedY.length;\n\tconst data = new Uint8Array(totalSize);\n\tlet off = 0;\n\n\t// Header\n\twriteUint16BE(data, off, nContours); off += 2;\n\twriteUint16BE(data, off, xMin & 0xffff); off += 2;\n\twriteUint16BE(data, off, yMin & 0xffff); off += 2;\n\twriteUint16BE(data, off, xMax & 0xffff); off += 2;\n\twriteUint16BE(data, off, yMax & 0xffff); off += 2;\n\n\t// End points\n\tfor (const endPt of endPtsOfContours) {\n\t\twriteUint16BE(data, off, endPt); off += 2;\n\t}\n\n\t// Instructions\n\twriteUint16BE(data, off, instructionLength); off += 2;\n\tdata.set(instructions, off); off += instructionLength;\n\n\t// Flags\n\tfor (const f of encodedFlags) {\n\t\tdata[off++] = f;\n\t}\n\n\t// X coordinates\n\tfor (const x of encodedX) {\n\t\tdata[off++] = x;\n\t}\n\n\t// Y coordinates\n\tfor (const y of encodedY) {\n\t\tdata[off++] = y;\n\t}\n\n\treturn data.slice(0, off);\n}\n\nfunction reconstructCompositeGlyph(\n\tcompositeStream: Uint8Array, compositeIdx: { value: number },\n\tbboxStream: Uint8Array, bboxIdx: { value: number },\n\tinstructionStream: Uint8Array, instructionIdx: { value: number },\n\toptionFlags: number\n): Uint8Array {\n\tconst parts: number[] = [];\n\n\t// Read bbox\n\tconst xMin = readInt16BE(bboxStream, bboxIdx.value); bboxIdx.value += 2;\n\tconst yMin = readInt16BE(bboxStream, bboxIdx.value); bboxIdx.value += 2;\n\tconst xMax = readInt16BE(bboxStream, bboxIdx.value); bboxIdx.value += 2;\n\tconst yMax = readInt16BE(bboxStream, bboxIdx.value); bboxIdx.value += 2;\n\n\t// Header\n\tparts.push(0xff, 0xff); // nContours = -1\n\tparts.push((xMin >> 8) & 0xff, xMin & 0xff);\n\tparts.push((yMin >> 8) & 0xff, yMin & 0xff);\n\tparts.push((xMax >> 8) & 0xff, xMax & 0xff);\n\tparts.push((yMax >> 8) & 0xff, yMax & 0xff);\n\n\t// Read components\n\tlet hasMoreComponents = true;\n\tlet hasInstructions = false;\n\n\twhile (hasMoreComponents) {\n\t\tconst flags = readUint16BE(compositeStream, compositeIdx.value);\n\t\tcompositeIdx.value += 2;\n\t\tconst glyphIndex = readUint16BE(compositeStream, compositeIdx.value);\n\t\tcompositeIdx.value += 2;\n\n\t\tparts.push((flags >> 8) & 0xff, flags & 0xff);\n\t\tparts.push((glyphIndex >> 8) & 0xff, glyphIndex & 0xff);\n\n\t\t// Arguments\n\t\tif (flags & 0x0001) { // ARG_1_AND_2_ARE_WORDS\n\t\t\tparts.push(compositeStream[compositeIdx.value++]);\n\t\t\tparts.push(compositeStream[compositeIdx.value++]);\n\t\t\tparts.push(compositeStream[compositeIdx.value++]);\n\t\t\tparts.push(compositeStream[compositeIdx.value++]);\n\t\t} else {\n\t\t\tparts.push(compositeStream[compositeIdx.value++]);\n\t\t\tparts.push(compositeStream[compositeIdx.value++]);\n\t\t}\n\n\t\t// Transform\n\t\tif (flags & 0x0008) { // WE_HAVE_A_SCALE\n\t\t\tparts.push(compositeStream[compositeIdx.value++]);\n\t\t\tparts.push(compositeStream[compositeIdx.value++]);\n\t\t} else if (flags & 0x0040) { // WE_HAVE_AN_X_AND_Y_SCALE\n\t\t\tfor (let i = 0; i < 4; i++) parts.push(compositeStream[compositeIdx.value++]);\n\t\t} else if (flags & 0x0080) { // WE_HAVE_A_TWO_BY_TWO\n\t\t\tfor (let i = 0; i < 8; i++) parts.push(compositeStream[compositeIdx.value++]);\n\t\t}\n\n\t\thasMoreComponents = (flags & 0x0020) !== 0;\n\t\tif (flags & 0x0100) hasInstructions = true;\n\t}\n\n\t// Instructions\n\tif (hasInstructions) {\n\t\tconst instrLen = read255UInt16(instructionStream, instructionIdx);\n\t\tparts.push((instrLen >> 8) & 0xff, instrLen & 0xff);\n\t\tfor (let i = 0; i < instrLen; i++) {\n\t\t\tparts.push(instructionStream[instructionIdx.value++]);\n\t\t}\n\t}\n\n\treturn new Uint8Array(parts);\n}\n\n/** Convert WOFF2 to SFNT */\nexport async function woff2ToSfnt(buffer: ArrayBuffer): Promise<ArrayBuffer> {\n\tconst data = new Uint8Array(buffer);\n\tconst view = new DataView(buffer);\n\n\t// Read header\n\tconst signature = view.getUint32(0, false);\n\tif (signature !== 0x774f4632) {\n\t\tthrow new Error(\"Not a valid WOFF2 file\");\n\t}\n\n\tconst flavor = view.getUint32(4, false);\n\tconst numTables = view.getUint16(12, false);\n\tconst totalCompressedSize = view.getUint32(20, false);\n\n\t// Parse table directory\n\tconst offset = { value: 48 };\n\tconst tables = parseTableDirectory(data, offset, numTables);\n\n\t// Decompress all table data\n\tconst compressedData = data.slice(offset.value, offset.value + totalCompressedSize);\n\tconst decompressedData = await decompressBrotli(compressedData);\n\n\t// Extract individual table data\n\tconst tableData: Map<string, Uint8Array> = new Map();\n\tlet decompOffset = 0;\n\n\tfor (const table of tables) {\n\t\tconst tdata = decompressedData.slice(decompOffset, decompOffset + table.transformLength);\n\t\ttableData.set(table.tag, tdata);\n\t\tdecompOffset += table.transformLength;\n\t}\n\n\t// Get metadata from maxp and head\n\tconst maxpData = tableData.get(\"maxp\");\n\tconst headData = tableData.get(\"head\");\n\tif (!maxpData || !headData) {\n\t\tthrow new Error(\"Missing required tables\");\n\t}\n\n\tconst numGlyphs = readUint16BE(maxpData, 4);\n\tconst indexToLocFormat = readInt16BE(headData, 50);\n\n\t// Handle glyf/loca transform\n\tconst glyfEntry = tables.find(t => t.tag === \"glyf\");\n\tconst locaEntry = tables.find(t => t.tag === \"loca\");\n\n\tif (glyfEntry && glyfEntry.transformVersion === 0) {\n\t\tconst glyfTransformed = tableData.get(\"glyf\")!;\n\t\tconst { glyf, loca } = reconstructGlyfLoca(glyfTransformed, numGlyphs, indexToLocFormat);\n\t\ttableData.set(\"glyf\", glyf);\n\t\ttableData.set(\"loca\", loca);\n\n\t\t// Update lengths\n\t\tglyfEntry.origLength = glyf.length;\n\t\tif (locaEntry) {\n\t\t\tlocaEntry.origLength = loca.length;\n\t\t}\n\t}\n\n\t// Calculate SFNT size\n\tconst headerSize = 12;\n\tconst directorySize = numTables * 16;\n\tlet tableOffset = headerSize + directorySize;\n\n\tconst tableOffsets: number[] = [];\n\tfor (const table of tables) {\n\t\ttableOffsets.push(tableOffset);\n\t\ttableOffset += pad4(table.origLength);\n\t}\n\n\t// Build output\n\tconst output = new Uint8Array(tableOffset);\n\n\t// SFNT header\n\tconst searchRange = Math.pow(2, Math.floor(Math.log2(numTables))) * 16;\n\tconst entrySelector = Math.floor(Math.log2(numTables));\n\tconst rangeShift = numTables * 16 - searchRange;\n\n\twriteUint32BE(output, 0, flavor);\n\twriteUint16BE(output, 4, numTables);\n\twriteUint16BE(output, 6, searchRange);\n\twriteUint16BE(output, 8, entrySelector);\n\twriteUint16BE(output, 10, rangeShift);\n\n\t// Table directory and data\n\tlet headOffset = -1;\n\tfor (let i = 0; i < tables.length; i++) {\n\t\tconst table = tables[i];\n\t\tconst tdata = tableData.get(table.tag)!;\n\t\tconst dirOffset = headerSize + i * 16;\n\n\t\tif (table.tag === \"head\") headOffset = tableOffsets[i];\n\n\t\t// Tag\n\t\tfor (let j = 0; j < 4; j++) {\n\t\t\toutput[dirOffset + j] = table.tag.charCodeAt(j);\n\t\t}\n\n\t\t// Checksum\n\t\tconst checksum = calcChecksum(tdata, 0, tdata.length);\n\t\twriteUint32BE(output, dirOffset + 4, checksum);\n\n\t\t// Offset\n\t\twriteUint32BE(output, dirOffset + 8, tableOffsets[i]);\n\n\t\t// Length\n\t\twriteUint32BE(output, dirOffset + 12, table.origLength);\n\n\t\t// Copy table data\n\t\toutput.set(tdata.slice(0, table.origLength), tableOffsets[i]);\n\t}\n\n\t// Fix head checksum adjustment\n\tif (headOffset >= 0) {\n\t\tconst totalChecksum = calcChecksum(output, 0, output.length);\n\t\tconst checksumAdjustment = (0xB1B0AFBA - totalChecksum) >>> 0;\n\t\twriteUint32BE(output, headOffset + 8, checksumAdjustment);\n\t}\n\n\treturn output.buffer;\n}\n", "import type { int16, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * BASE table - Baseline alignment data\n * Provides baseline offsets for scripts to align mixed-script text\n */\n\n/** Baseline tags */\nexport const BaselineTag = {\n\t/** Hanging baseline (Devanagari, Tibetan) */\n\thang: 0x68616e67,\n\t/** Ideographic character face bottom edge (CJK) */\n\ticfb: 0x69636662,\n\t/** Ideographic character face top edge (CJK) */\n\ticft: 0x69636674,\n\t/** Ideographic em-box bottom edge (CJK) */\n\tideo: 0x6964656f,\n\t/** Ideographic em-box top edge */\n\tidtp: 0x69647470,\n\t/** Mathematical baseline (math layout) */\n\tmath: 0x6d617468,\n\t/** Roman baseline (Latin, Greek, Cyrillic) */\n\tromn: 0x726f6d6e,\n} as const;\n\n/** A single baseline value */\nexport interface BaselineValue {\n\tbaselineTag: number;\n\tcoordinate: int16;\n}\n\n/** Min/max extent values */\nexport interface MinMaxRecord {\n\tminCoord: int16 | null;\n\tmaxCoord: int16 | null;\n}\n\n/** Feature-specific min/max values */\nexport interface FeatMinMaxRecord {\n\tfeatureTag: number;\n\tminCoord: int16 | null;\n\tmaxCoord: int16 | null;\n}\n\n/** Base values for a script */\nexport interface BaseValues {\n\tdefaultBaselineIndex: uint16;\n\tbaseCoords: int16[];\n}\n\n/** MinMax values for a language system */\nexport interface MinMax {\n\tminCoord: int16 | null;\n\tmaxCoord: int16 | null;\n\tfeatMinMaxRecords: FeatMinMaxRecord[];\n}\n\n/** Base script record */\nexport interface BaseScriptRecord {\n\tscriptTag: number;\n\tbaseValues: BaseValues | null;\n\tdefaultMinMax: MinMax | null;\n\tbaseLangSysRecords: Map<number, MinMax>;\n}\n\n/** Axis table (horizontal or vertical) */\nexport interface AxisTable {\n\tbaseTagList: number[];\n\tbaseScriptList: BaseScriptRecord[];\n}\n\n/** BASE table */\nexport interface BaseTable {\n\tmajorVersion: uint16;\n\tminorVersion: uint16;\n\thorizAxis: AxisTable | null;\n\tvertAxis: AxisTable | null;\n}\n\n/** Coordinate format */\ninterface BaseCoord {\n\tformat: uint16;\n\tcoordinate: int16;\n\treferenceGlyph?: uint16;\n\tbaseCoordPoint?: uint16;\n\tdeviceOffset?: uint16;\n}\n\nfunction parseBaseCoord(reader: Reader): BaseCoord {\n\tconst format = reader.uint16();\n\tconst coordinate = reader.int16();\n\n\tconst result: BaseCoord = { format, coordinate };\n\n\tif (format === 2) {\n\t\tresult.referenceGlyph = reader.uint16();\n\t\tresult.baseCoordPoint = reader.uint16();\n\t} else if (format === 3) {\n\t\tresult.deviceOffset = reader.uint16();\n\t}\n\n\treturn result;\n}\n\nfunction parseMinMax(reader: Reader, minMaxOffset: number): MinMax | null {\n\tif (minMaxOffset === 0) return null;\n\n\tconst minMaxReader = reader.sliceFrom(minMaxOffset);\n\tconst minCoordOffset = minMaxReader.uint16();\n\tconst maxCoordOffset = minMaxReader.uint16();\n\tconst featMinMaxCount = minMaxReader.uint16();\n\n\tlet minCoord: int16 | null = null;\n\tlet maxCoord: int16 | null = null;\n\n\tif (minCoordOffset !== 0) {\n\t\tconst coordReader = reader.sliceFrom(minMaxOffset + minCoordOffset);\n\t\tminCoord = parseBaseCoord(coordReader).coordinate;\n\t}\n\n\tif (maxCoordOffset !== 0) {\n\t\tconst coordReader = reader.sliceFrom(minMaxOffset + maxCoordOffset);\n\t\tmaxCoord = parseBaseCoord(coordReader).coordinate;\n\t}\n\n\tconst featMinMaxRecords: FeatMinMaxRecord[] = [];\n\tfor (let i = 0; i < featMinMaxCount; i++) {\n\t\tconst featureTag = minMaxReader.uint32();\n\t\tconst minOffset = minMaxReader.uint16();\n\t\tconst maxOffset = minMaxReader.uint16();\n\n\t\tlet featMin: int16 | null = null;\n\t\tlet featMax: int16 | null = null;\n\n\t\tif (minOffset !== 0) {\n\t\t\tconst coordReader = reader.sliceFrom(minMaxOffset + minOffset);\n\t\t\tfeatMin = parseBaseCoord(coordReader).coordinate;\n\t\t}\n\n\t\tif (maxOffset !== 0) {\n\t\t\tconst coordReader = reader.sliceFrom(minMaxOffset + maxOffset);\n\t\t\tfeatMax = parseBaseCoord(coordReader).coordinate;\n\t\t}\n\n\t\tfeatMinMaxRecords.push({\n\t\t\tfeatureTag,\n\t\t\tminCoord: featMin,\n\t\t\tmaxCoord: featMax,\n\t\t});\n\t}\n\n\treturn { minCoord, maxCoord, featMinMaxRecords };\n}\n\nfunction parseBaseValues(\n\treader: Reader,\n\tbaseValuesOffset: number,\n\t_baseTagList: number[],\n): BaseValues | null {\n\tif (baseValuesOffset === 0) return null;\n\n\tconst bvReader = reader.sliceFrom(baseValuesOffset);\n\tconst defaultBaselineIndex = bvReader.uint16();\n\tconst baseCoordCount = bvReader.uint16();\n\n\tconst coordOffsets: uint16[] = [];\n\tfor (let i = 0; i < baseCoordCount; i++) {\n\t\tcoordOffsets.push(bvReader.uint16());\n\t}\n\n\tconst baseCoords: int16[] = [];\n\tfor (const offset of coordOffsets) {\n\t\tif (offset !== 0) {\n\t\t\tconst coordReader = reader.sliceFrom(baseValuesOffset + offset);\n\t\t\tbaseCoords.push(parseBaseCoord(coordReader).coordinate);\n\t\t} else {\n\t\t\tbaseCoords.push(0);\n\t\t}\n\t}\n\n\treturn { defaultBaselineIndex, baseCoords };\n}\n\nfunction parseBaseScriptRecord(\n\treader: Reader,\n\tscriptOffset: number,\n\tbaseTagList: number[],\n): Omit<BaseScriptRecord, \"scriptTag\"> {\n\tconst scriptReader = reader.sliceFrom(scriptOffset);\n\tconst baseValuesOffset = scriptReader.uint16();\n\tconst defaultMinMaxOffset = scriptReader.uint16();\n\tconst baseLangSysCount = scriptReader.uint16();\n\n\tconst baseLangSysRecords = new Map<number, MinMax>();\n\tconst langSysData: Array<{ tag: number; offset: number }> = [];\n\n\tfor (let i = 0; i < baseLangSysCount; i++) {\n\t\tconst tag = scriptReader.uint32();\n\t\tconst offset = scriptReader.uint16();\n\t\tlangSysData.push({ tag, offset });\n\t}\n\n\tconst baseValues = parseBaseValues(\n\t\treader,\n\t\tscriptOffset + baseValuesOffset,\n\t\tbaseTagList,\n\t);\n\tconst defaultMinMax = parseMinMax(reader, scriptOffset + defaultMinMaxOffset);\n\n\tfor (const { tag, offset } of langSysData) {\n\t\tconst minMax = parseMinMax(reader, scriptOffset + offset);\n\t\tif (minMax) {\n\t\t\tbaseLangSysRecords.set(tag, minMax);\n\t\t}\n\t}\n\n\treturn { baseValues, defaultMinMax, baseLangSysRecords };\n}\n\nfunction parseAxisTable(reader: Reader, axisOffset: number): AxisTable | null {\n\tif (axisOffset === 0) return null;\n\n\tconst axisReader = reader.sliceFrom(axisOffset);\n\tconst baseTagListOffset = axisReader.uint16();\n\tconst baseScriptListOffset = axisReader.uint16();\n\n\t// Parse base tag list\n\tconst baseTagList: number[] = [];\n\tif (baseTagListOffset !== 0) {\n\t\tconst tagReader = reader.sliceFrom(axisOffset + baseTagListOffset);\n\t\tconst baseTagCount = tagReader.uint16();\n\t\tfor (let i = 0; i < baseTagCount; i++) {\n\t\t\tbaseTagList.push(tagReader.uint32());\n\t\t}\n\t}\n\n\t// Parse base script list\n\tconst baseScriptList: BaseScriptRecord[] = [];\n\tif (baseScriptListOffset !== 0) {\n\t\tconst scriptListReader = reader.sliceFrom(\n\t\t\taxisOffset + baseScriptListOffset,\n\t\t);\n\t\tconst baseScriptCount = scriptListReader.uint16();\n\n\t\tconst scriptData: Array<{ tag: number; offset: number }> = [];\n\t\tfor (let i = 0; i < baseScriptCount; i++) {\n\t\t\tconst tag = scriptListReader.uint32();\n\t\t\tconst offset = scriptListReader.uint16();\n\t\t\tscriptData.push({ tag, offset });\n\t\t}\n\n\t\tfor (const { tag, offset } of scriptData) {\n\t\t\tconst record = parseBaseScriptRecord(\n\t\t\t\treader,\n\t\t\t\taxisOffset + baseScriptListOffset + offset,\n\t\t\t\tbaseTagList,\n\t\t\t);\n\t\t\tbaseScriptList.push({ scriptTag: tag, ...record });\n\t\t}\n\t}\n\n\treturn { baseTagList, baseScriptList };\n}\n\nexport function parseBase(reader: Reader): BaseTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst horizAxisOffset = reader.uint16();\n\tconst vertAxisOffset = reader.uint16();\n\n\tconst horizAxis = parseAxisTable(reader, horizAxisOffset);\n\tconst vertAxis = parseAxisTable(reader, vertAxisOffset);\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\thorizAxis,\n\t\tvertAxis,\n\t};\n}\n\n/** Get baseline value for a script */\nexport function getBaselineForScript(\n\tbase: BaseTable,\n\tscriptTag: number,\n\tbaselineTag: number,\n\thorizontal: boolean = true,\n): int16 | null {\n\tconst axis = horizontal ? base.horizAxis : base.vertAxis;\n\tif (!axis) return null;\n\n\t// Find script record\n\tconst scriptRecord = axis.baseScriptList.find(\n\t\t(r) => r.scriptTag === scriptTag,\n\t);\n\tif (!scriptRecord?.baseValues) return null;\n\n\t// Find baseline tag index\n\tconst tagIndex = axis.baseTagList.indexOf(baselineTag);\n\tif (tagIndex === -1) return null;\n\n\treturn scriptRecord.baseValues.baseCoords[tagIndex] ?? null;\n}\n\n/** Get default baseline for a script */\nexport function getDefaultBaseline(\n\tbase: BaseTable,\n\tscriptTag: number,\n\thorizontal: boolean = true,\n): { tag: number; coordinate: int16 } | null {\n\tconst axis = horizontal ? base.horizAxis : base.vertAxis;\n\tif (!axis) return null;\n\n\tconst scriptRecord = axis.baseScriptList.find(\n\t\t(r) => r.scriptTag === scriptTag,\n\t);\n\tif (!scriptRecord?.baseValues) return null;\n\n\tconst index = scriptRecord.baseValues.defaultBaselineIndex;\n\tconst tag = axis.baseTagList[index];\n\tconst coordinate = scriptRecord.baseValues.baseCoords[index];\n\n\tif (tag === undefined || coordinate === undefined) return null;\n\n\treturn { tag, coordinate };\n}\n\n/** Get min/max extent for a script/language */\nexport function getMinMaxExtent(\n\tbase: BaseTable,\n\tscriptTag: number,\n\tlanguageTag?: number,\n\thorizontal: boolean = true,\n): MinMaxRecord | null {\n\tconst axis = horizontal ? base.horizAxis : base.vertAxis;\n\tif (!axis) return null;\n\n\tconst scriptRecord = axis.baseScriptList.find(\n\t\t(r) => r.scriptTag === scriptTag,\n\t);\n\tif (!scriptRecord) return null;\n\n\t// Try language-specific first\n\tif (languageTag !== undefined) {\n\t\tconst langMinMax = scriptRecord.baseLangSysRecords.get(languageTag);\n\t\tif (langMinMax) {\n\t\t\treturn { minCoord: langMinMax.minCoord, maxCoord: langMinMax.maxCoord };\n\t\t}\n\t}\n\n\t// Fall back to default\n\tif (scriptRecord.defaultMinMax) {\n\t\treturn {\n\t\t\tminCoord: scriptRecord.defaultMinMax.minCoord,\n\t\t\tmaxCoord: scriptRecord.defaultMinMax.maxCoord,\n\t\t};\n\t}\n\n\treturn null;\n}\n", "import type { GlyphId, int8, uint8, uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Color Bitmap Data Table (CBDT)\n * Google's color bitmap table for emoji fonts\n * Used together with CBLC (Color Bitmap Location Table)\n */\nexport interface CbdtTable {\n\tmajorVersion: uint16;\n\tminorVersion: uint16;\n\t/** Raw data for bitmap lookup */\n\tdata: Uint8Array;\n}\n\n/**\n * Color Bitmap Location Table (CBLC)\n * Index for looking up bitmaps in CBDT\n */\nexport interface CblcTable {\n\tmajorVersion: uint16;\n\tminorVersion: uint16;\n\tbitmapSizes: BitmapSize[];\n}\n\n/**\n * Bitmap size record\n */\nexport interface BitmapSize {\n\tindexSubTableArrayOffset: uint32;\n\tindexTablesSize: uint32;\n\tnumberOfIndexSubTables: uint32;\n\tcolorRef: uint32;\n\thori: SbitLineMetrics;\n\tvert: SbitLineMetrics;\n\tstartGlyphIndex: GlyphId;\n\tendGlyphIndex: GlyphId;\n\tppemX: uint8;\n\tppemY: uint8;\n\tbitDepth: uint8;\n\tflags: int8;\n\tindexSubTables: IndexSubTable[];\n}\n\n/**\n * Line metrics for bitmap glyphs\n */\nexport interface SbitLineMetrics {\n\tascender: int8;\n\tdescender: int8;\n\twidthMax: uint8;\n\tcaretSlopeNumerator: int8;\n\tcaretSlopeDenominator: int8;\n\tcaretOffset: int8;\n\tminOriginSB: int8;\n\tminAdvanceSB: int8;\n\tmaxBeforeBL: int8;\n\tminAfterBL: int8;\n\tpad1: int8;\n\tpad2: int8;\n}\n\n/**\n * Index sub-table for glyph lookup\n */\nexport interface IndexSubTable {\n\tfirstGlyphIndex: GlyphId;\n\tlastGlyphIndex: GlyphId;\n\tindexFormat: uint16;\n\timageFormat: uint16;\n\timageDataOffset: uint32;\n\t/** Glyph offsets (format-dependent) */\n\tglyphOffsets: Map<GlyphId, { offset: uint32; length: uint32 }>;\n}\n\n/**\n * Bitmap glyph metrics\n */\nexport interface GlyphBitmapMetrics {\n\theight: uint8;\n\twidth: uint8;\n\tbearingX: int8;\n\tbearingY: int8;\n\tadvance: uint8;\n}\n\n/**\n * Bitmap glyph data\n */\nexport interface BitmapGlyph {\n\tmetrics: GlyphBitmapMetrics;\n\timageFormat: uint16;\n\tdata: Uint8Array;\n}\n\n/**\n * Image formats in CBDT\n */\nexport const CbdtImageFormat = {\n\tSmallMetrics: 1, // Small metrics, byte-aligned\n\tSmallMetricsPng: 17, // Small metrics + PNG\n\tBigMetrics: 2, // Big metrics, byte-aligned\n\tBigMetricsPng: 18, // Big metrics + PNG\n\tCompressedPng: 19, // Metrics in CBLC + PNG\n} as const;\n\n/**\n * Parse CBLC table\n */\nexport function parseCblc(reader: Reader): CblcTable {\n\tconst tableStart = reader.offset;\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst numSizes = reader.uint32();\n\n\tconst bitmapSizes: BitmapSize[] = [];\n\n\t// Read BitmapSize records\n\tfor (let i = 0; i < numSizes; i++) {\n\t\tconst indexSubTableArrayOffset = reader.uint32();\n\t\tconst indexTablesSize = reader.uint32();\n\t\tconst numberOfIndexSubTables = reader.uint32();\n\t\tconst colorRef = reader.uint32();\n\n\t\tconst hori = parseSbitLineMetrics(reader);\n\t\tconst vert = parseSbitLineMetrics(reader);\n\n\t\tconst startGlyphIndex = reader.uint16();\n\t\tconst endGlyphIndex = reader.uint16();\n\t\tconst ppemX = reader.uint8();\n\t\tconst ppemY = reader.uint8();\n\t\tconst bitDepth = reader.uint8();\n\t\tconst flags = reader.int8();\n\n\t\tbitmapSizes.push({\n\t\t\tindexSubTableArrayOffset,\n\t\t\tindexTablesSize,\n\t\t\tnumberOfIndexSubTables,\n\t\t\tcolorRef,\n\t\t\thori,\n\t\t\tvert,\n\t\t\tstartGlyphIndex,\n\t\t\tendGlyphIndex,\n\t\t\tppemX,\n\t\t\tppemY,\n\t\t\tbitDepth,\n\t\t\tflags,\n\t\t\tindexSubTables: [],\n\t\t});\n\t}\n\n\t// Parse index sub-tables for each bitmap size\n\tfor (const size of bitmapSizes) {\n\t\tconst subTableReader = reader.sliceFrom(\n\t\t\ttableStart + size.indexSubTableArrayOffset,\n\t\t);\n\n\t\t// Read IndexSubTableArray\n\t\tconst subTableHeaders: {\n\t\t\tfirstGlyphIndex: uint16;\n\t\t\tlastGlyphIndex: uint16;\n\t\t\tadditionalOffsetToIndexSubtable: uint32;\n\t\t}[] = [];\n\n\t\tfor (let i = 0; i < size.numberOfIndexSubTables; i++) {\n\t\t\tsubTableHeaders.push({\n\t\t\t\tfirstGlyphIndex: subTableReader.uint16(),\n\t\t\t\tlastGlyphIndex: subTableReader.uint16(),\n\t\t\t\tadditionalOffsetToIndexSubtable: subTableReader.uint32(),\n\t\t\t});\n\t\t}\n\n\t\t// Parse each index sub-table\n\t\tfor (const header of subTableHeaders) {\n\t\t\tconst indexSubTable = parseIndexSubTable(\n\t\t\t\treader,\n\t\t\t\ttableStart +\n\t\t\t\t\tsize.indexSubTableArrayOffset +\n\t\t\t\t\theader.additionalOffsetToIndexSubtable,\n\t\t\t\theader.firstGlyphIndex,\n\t\t\t\theader.lastGlyphIndex,\n\t\t\t);\n\t\t\tsize.indexSubTables.push(indexSubTable);\n\t\t}\n\t}\n\n\treturn { majorVersion, minorVersion, bitmapSizes };\n}\n\nfunction parseSbitLineMetrics(reader: Reader): SbitLineMetrics {\n\treturn {\n\t\tascender: reader.int8(),\n\t\tdescender: reader.int8(),\n\t\twidthMax: reader.uint8(),\n\t\tcaretSlopeNumerator: reader.int8(),\n\t\tcaretSlopeDenominator: reader.int8(),\n\t\tcaretOffset: reader.int8(),\n\t\tminOriginSB: reader.int8(),\n\t\tminAdvanceSB: reader.int8(),\n\t\tmaxBeforeBL: reader.int8(),\n\t\tminAfterBL: reader.int8(),\n\t\tpad1: reader.int8(),\n\t\tpad2: reader.int8(),\n\t};\n}\n\nfunction parseIndexSubTable(\n\treader: Reader,\n\toffset: number,\n\tfirstGlyph: GlyphId,\n\tlastGlyph: GlyphId,\n): IndexSubTable {\n\tconst subReader = reader.sliceFrom(offset);\n\tconst indexFormat = subReader.uint16();\n\tconst imageFormat = subReader.uint16();\n\tconst imageDataOffset = subReader.uint32();\n\n\tconst glyphOffsets = new Map<GlyphId, { offset: uint32; length: uint32 }>();\n\tconst numGlyphs = lastGlyph - firstGlyph + 1;\n\n\tswitch (indexFormat) {\n\t\tcase 1: {\n\t\t\t// Variable metrics, 4-byte offsets\n\t\t\tconst offsets: uint32[] = [];\n\t\t\tfor (let i = 0; i <= numGlyphs; i++) {\n\t\t\t\toffsets.push(subReader.uint32());\n\t\t\t}\n\t\t\tfor (let i = 0; i < numGlyphs; i++) {\n\t\t\t\tconst glyphOffset = offsets[i]!;\n\t\t\t\tconst nextOffset = offsets[i + 1]!;\n\t\t\t\tif (nextOffset > glyphOffset) {\n\t\t\t\t\tglyphOffsets.set(firstGlyph + i, {\n\t\t\t\t\t\toffset: imageDataOffset + glyphOffset,\n\t\t\t\t\t\tlength: nextOffset - glyphOffset,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 2: {\n\t\t\t// Constant image size\n\t\t\tconst imageSize = subReader.uint32();\n\t\t\t// Big metrics follow\n\t\t\tconst _bigMetrics = {\n\t\t\t\theight: subReader.uint8(),\n\t\t\t\twidth: subReader.uint8(),\n\t\t\t\thoriBearingX: subReader.int8(),\n\t\t\t\thoriBearingY: subReader.int8(),\n\t\t\t\thoriAdvance: subReader.uint8(),\n\t\t\t\tvertBearingX: subReader.int8(),\n\t\t\t\tvertBearingY: subReader.int8(),\n\t\t\t\tvertAdvance: subReader.uint8(),\n\t\t\t};\n\t\t\tfor (let i = 0; i < numGlyphs; i++) {\n\t\t\t\tglyphOffsets.set(firstGlyph + i, {\n\t\t\t\t\toffset: imageDataOffset + i * imageSize,\n\t\t\t\t\tlength: imageSize,\n\t\t\t\t});\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 3: {\n\t\t\t// Variable metrics, 2-byte offsets\n\t\t\tconst offsets: uint16[] = [];\n\t\t\tfor (let i = 0; i <= numGlyphs; i++) {\n\t\t\t\toffsets.push(subReader.uint16());\n\t\t\t}\n\t\t\tfor (let i = 0; i < numGlyphs; i++) {\n\t\t\t\tconst glyphOffset = offsets[i]!;\n\t\t\t\tconst nextOffset = offsets[i + 1]!;\n\t\t\t\tif (nextOffset > glyphOffset) {\n\t\t\t\t\tglyphOffsets.set(firstGlyph + i, {\n\t\t\t\t\t\toffset: imageDataOffset + glyphOffset,\n\t\t\t\t\t\tlength: nextOffset - glyphOffset,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 4: {\n\t\t\t// Sparse glyph array\n\t\t\tconst numGlyphsActual = subReader.uint32();\n\t\t\tconst glyphArray: { glyphId: uint16; offset: uint16 }[] = [];\n\t\t\tfor (let i = 0; i <= numGlyphsActual; i++) {\n\t\t\t\tglyphArray.push({\n\t\t\t\t\tglyphId: subReader.uint16(),\n\t\t\t\t\toffset: subReader.uint16(),\n\t\t\t\t});\n\t\t\t}\n\t\t\tfor (let i = 0; i < numGlyphsActual; i++) {\n\t\t\t\tconst entry = glyphArray[i]!;\n\t\t\t\tconst nextEntry = glyphArray[i + 1]!;\n\t\t\t\tglyphOffsets.set(entry.glyphId, {\n\t\t\t\t\toffset: imageDataOffset + entry.offset,\n\t\t\t\t\tlength: nextEntry.offset - entry.offset,\n\t\t\t\t});\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 5: {\n\t\t\t// Constant metrics, sparse glyph array\n\t\t\tconst imageSize = subReader.uint32();\n\t\t\t// Big metrics\n\t\t\tsubReader.skip(8);\n\t\t\tconst numGlyphsActual = subReader.uint32();\n\t\t\tfor (let i = 0; i < numGlyphsActual; i++) {\n\t\t\t\tconst glyphId = subReader.uint16();\n\t\t\t\tglyphOffsets.set(glyphId, {\n\t\t\t\t\toffset: imageDataOffset + i * imageSize,\n\t\t\t\t\tlength: imageSize,\n\t\t\t\t});\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn {\n\t\tfirstGlyphIndex: firstGlyph,\n\t\tlastGlyphIndex: lastGlyph,\n\t\tindexFormat,\n\t\timageFormat,\n\t\timageDataOffset,\n\t\tglyphOffsets,\n\t};\n}\n\n/**\n * Parse CBDT table\n */\nexport function parseCbdt(reader: Reader): CbdtTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\n\t// Store raw data for later lookup\n\tconst data = reader.bytes(reader.remaining);\n\n\treturn { majorVersion, minorVersion, data };\n}\n\n/**\n * Get bitmap glyph from CBDT using CBLC index\n */\nexport function getBitmapGlyph(\n\tcblc: CblcTable,\n\tcbdt: CbdtTable,\n\tglyphId: GlyphId,\n\tppem: number,\n): BitmapGlyph | null {\n\t// Find matching bitmap size\n\tlet bestSize: BitmapSize | null = null;\n\tlet bestDiff = Infinity;\n\n\tfor (const size of cblc.bitmapSizes) {\n\t\tif (glyphId < size.startGlyphIndex || glyphId > size.endGlyphIndex) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst diff = Math.abs(size.ppemX - ppem);\n\t\tif (diff < bestDiff) {\n\t\t\tbestDiff = diff;\n\t\t\tbestSize = size;\n\t\t}\n\t}\n\n\tif (!bestSize) return null;\n\n\t// Find glyph in index sub-tables\n\tfor (const subTable of bestSize.indexSubTables) {\n\t\tconst glyphInfo = subTable.glyphOffsets.get(glyphId);\n\t\tif (!glyphInfo) continue;\n\n\t\t// Read glyph data from CBDT\n\t\tconst glyphData = cbdt.data.slice(\n\t\t\tglyphInfo.offset - 4, // Adjust for CBDT header\n\t\t\tglyphInfo.offset - 4 + glyphInfo.length,\n\t\t);\n\n\t\treturn parseGlyphData(glyphData, subTable.imageFormat);\n\t}\n\n\treturn null;\n}\n\nfunction parseGlyphData(\n\tdata: Uint8Array,\n\timageFormat: uint16,\n): BitmapGlyph | null {\n\tif (data.length === 0) return null;\n\n\tlet offset = 0;\n\tlet metrics: GlyphBitmapMetrics;\n\n\tswitch (imageFormat) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 17:\n\t\tcase 18: {\n\t\t\t// Small or big metrics embedded\n\t\t\tif (imageFormat === 1 || imageFormat === 17) {\n\t\t\t\t// Small metrics (5 bytes)\n\t\t\t\tmetrics = {\n\t\t\t\t\theight: data[offset++]!,\n\t\t\t\t\twidth: data[offset++]!,\n\t\t\t\t\tbearingX: (data[offset++]! << 24) >> 24, // Sign extend\n\t\t\t\t\tbearingY: (data[offset++]! << 24) >> 24,\n\t\t\t\t\tadvance: data[offset++]!,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t// Big metrics (8 bytes)\n\t\t\t\tmetrics = {\n\t\t\t\t\theight: data[offset++]!,\n\t\t\t\t\twidth: data[offset++]!,\n\t\t\t\t\tbearingX: (data[offset++]! << 24) >> 24,\n\t\t\t\t\tbearingY: (data[offset++]! << 24) >> 24,\n\t\t\t\t\tadvance: data[offset++]!,\n\t\t\t\t};\n\t\t\t\toffset += 3; // Skip vertical metrics\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 19: {\n\t\t\t// Metrics in CBLC, just PNG data\n\t\t\tmetrics = { height: 0, width: 0, bearingX: 0, bearingY: 0, advance: 0 };\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\treturn null;\n\t}\n\n\treturn {\n\t\tmetrics,\n\t\timageFormat,\n\t\tdata: data.slice(offset),\n\t};\n}\n\n/**\n * Check if glyph has color bitmap\n */\nexport function hasColorBitmap(\n\tcblc: CblcTable,\n\tglyphId: GlyphId,\n\tppem?: number,\n): boolean {\n\tfor (const size of cblc.bitmapSizes) {\n\t\tif (ppem !== undefined && size.ppemX !== ppem) continue;\n\t\tif (glyphId < size.startGlyphIndex || glyphId > size.endGlyphIndex) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (const subTable of size.indexSubTables) {\n\t\t\tif (subTable.glyphOffsets.has(glyphId)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * Get available ppem sizes for color bitmaps\n */\nexport function getColorBitmapSizes(cblc: CblcTable): number[] {\n\tconst sizes = new Set<number>();\n\tfor (const size of cblc.bitmapSizes) {\n\t\tsizes.add(size.ppemX);\n\t}\n\treturn Array.from(sizes).sort((a, b) => a - b);\n}\n", "import { Reader } from \"../binary/reader.ts\";\n\n/**\n * CFF (Compact Font Format) table parser\n * Used by OpenType fonts with PostScript outlines\n */\n\nexport interface CffTable {\n\tversion: { major: number; minor: number };\n\tnames: string[];\n\ttopDicts: TopDict[];\n\tstrings: string[];\n\tglobalSubrs: Uint8Array[];\n\tcharStrings: Uint8Array[][];\n\tlocalSubrs: Uint8Array[][];\n\tfdArrays: FDDict[][];\n\tfdSelects: FDSelect[];\n}\n\nexport interface TopDict {\n\tversion?: string;\n\tnotice?: string;\n\tcopyright?: string;\n\tfullName?: string;\n\tfamilyName?: string;\n\tweight?: string;\n\tisFixedPitch?: boolean;\n\titalicAngle?: number;\n\tunderlinePosition?: number;\n\tunderlineThickness?: number;\n\tpaintType?: number;\n\tcharstringType?: number;\n\tfontMatrix?: number[];\n\tuniqueID?: number;\n\tfontBBox?: number[];\n\tstrokeWidth?: number;\n\tcharset?: number;\n\tencoding?: number;\n\tcharStrings?: number;\n\tprivate?: [number, number]; // [size, offset]\n\tsyntheticBase?: number;\n\tpostScript?: string;\n\tbaseFontName?: string;\n\tbaseFontBlend?: number[];\n\t// CIDFont-specific\n\tros?: { registry: string; ordering: string; supplement: number };\n\tcidFontVersion?: number;\n\tcidFontRevision?: number;\n\tcidFontType?: number;\n\tcidCount?: number;\n\tuidBase?: number;\n\tfdArray?: number;\n\tfdSelect?: number;\n\tfontName?: string;\n}\n\nexport interface PrivateDict {\n\tblueValues?: number[];\n\totherBlues?: number[];\n\tfamilyBlues?: number[];\n\tfamilyOtherBlues?: number[];\n\tblueScale?: number;\n\tblueShift?: number;\n\tblueFuzz?: number;\n\tstdHW?: number;\n\tstdVW?: number;\n\tstemSnapH?: number[];\n\tstemSnapV?: number[];\n\tforceBold?: boolean;\n\tlanguageGroup?: number;\n\texpansionFactor?: number;\n\tinitialRandomSeed?: number;\n\tsubrs?: number;\n\tdefaultWidthX?: number;\n\tnominalWidthX?: number;\n}\n\nexport interface FDDict extends PrivateDict {\n\tfontName?: string;\n\t/** Local subroutines for this FD (parsed from private dict subrs offset) */\n\tlocalSubrs?: Uint8Array[];\n}\n\nexport interface FDSelect {\n\tformat: number;\n\tselect: (glyphId: number) => number;\n}\n\n// Standard strings defined in CFF spec\nconst STANDARD_STRINGS = [\n\t\".notdef\",\n\t\"space\",\n\t\"exclam\",\n\t\"quotedbl\",\n\t\"numbersign\",\n\t\"dollar\",\n\t\"percent\",\n\t\"ampersand\",\n\t\"quoteright\",\n\t\"parenleft\",\n\t\"parenright\",\n\t\"asterisk\",\n\t\"plus\",\n\t\"comma\",\n\t\"hyphen\",\n\t\"period\",\n\t\"slash\",\n\t\"zero\",\n\t\"one\",\n\t\"two\",\n\t\"three\",\n\t\"four\",\n\t\"five\",\n\t\"six\",\n\t\"seven\",\n\t\"eight\",\n\t\"nine\",\n\t\"colon\",\n\t\"semicolon\",\n\t\"less\",\n\t\"equal\",\n\t\"greater\",\n\t\"question\",\n\t\"at\",\n\t\"A\",\n\t\"B\",\n\t\"C\",\n\t\"D\",\n\t\"E\",\n\t\"F\",\n\t\"G\",\n\t\"H\",\n\t\"I\",\n\t\"J\",\n\t\"K\",\n\t\"L\",\n\t\"M\",\n\t\"N\",\n\t\"O\",\n\t\"P\",\n\t\"Q\",\n\t\"R\",\n\t\"S\",\n\t\"T\",\n\t\"U\",\n\t\"V\",\n\t\"W\",\n\t\"X\",\n\t\"Y\",\n\t\"Z\",\n\t\"bracketleft\",\n\t\"backslash\",\n\t\"bracketright\",\n\t\"asciicircum\",\n\t\"underscore\",\n\t\"quoteleft\",\n\t\"a\",\n\t\"b\",\n\t\"c\",\n\t\"d\",\n\t\"e\",\n\t\"f\",\n\t\"g\",\n\t\"h\",\n\t\"i\",\n\t\"j\",\n\t\"k\",\n\t\"l\",\n\t\"m\",\n\t\"n\",\n\t\"o\",\n\t\"p\",\n\t\"q\",\n\t\"r\",\n\t\"s\",\n\t\"t\",\n\t\"u\",\n\t\"v\",\n\t\"w\",\n\t\"x\",\n\t\"y\",\n\t\"z\",\n\t\"braceleft\",\n\t\"bar\",\n\t\"braceright\",\n\t\"asciitilde\",\n\t\"exclamdown\",\n\t\"cent\",\n\t\"sterling\",\n\t\"fraction\",\n\t\"yen\",\n\t\"florin\",\n\t\"section\",\n\t\"currency\",\n\t\"quotesingle\",\n\t\"quotedblleft\",\n\t\"guillemotleft\",\n\t\"guilsinglleft\",\n\t\"guilsinglright\",\n\t\"fi\",\n\t\"fl\",\n\t\"endash\",\n\t\"dagger\",\n\t\"daggerdbl\",\n\t\"periodcentered\",\n\t\"paragraph\",\n\t\"bullet\",\n\t\"quotesinglbase\",\n\t\"quotedblbase\",\n\t\"quotedblright\",\n\t\"guillemotright\",\n\t\"ellipsis\",\n\t\"perthousand\",\n\t\"questiondown\",\n\t\"grave\",\n\t\"acute\",\n\t\"circumflex\",\n\t\"tilde\",\n\t\"macron\",\n\t\"breve\",\n\t\"dotaccent\",\n\t\"dieresis\",\n\t\"ring\",\n\t\"cedilla\",\n\t\"hungarumlaut\",\n\t\"ogonek\",\n\t\"caron\",\n\t\"emdash\",\n\t\"AE\",\n\t\"ordfeminine\",\n\t\"Lslash\",\n\t\"Oslash\",\n\t\"OE\",\n\t\"ordmasculine\",\n\t\"ae\",\n\t\"dotlessi\",\n\t\"lslash\",\n\t\"oslash\",\n\t\"oe\",\n\t\"germandbls\",\n\t\"onesuperior\",\n\t\"logicalnot\",\n\t\"mu\",\n\t\"trademark\",\n\t\"Eth\",\n\t\"onehalf\",\n\t\"plusminus\",\n\t\"Thorn\",\n\t\"onequarter\",\n\t\"divide\",\n\t\"brokenbar\",\n\t\"degree\",\n\t\"thorn\",\n\t\"threequarters\",\n\t\"twosuperior\",\n\t\"registered\",\n\t\"minus\",\n\t\"eth\",\n\t\"multiply\",\n\t\"threesuperior\",\n\t\"copyright\",\n\t\"Aacute\",\n\t\"Acircumflex\",\n\t\"Adieresis\",\n\t\"Agrave\",\n\t\"Aring\",\n\t\"Atilde\",\n\t\"Ccedilla\",\n\t\"Eacute\",\n\t\"Ecircumflex\",\n\t\"Edieresis\",\n\t\"Egrave\",\n\t\"Iacute\",\n\t\"Icircumflex\",\n\t\"Idieresis\",\n\t\"Igrave\",\n\t\"Ntilde\",\n\t\"Oacute\",\n\t\"Ocircumflex\",\n\t\"Odieresis\",\n\t\"Ograve\",\n\t\"Otilde\",\n\t\"Scaron\",\n\t\"Uacute\",\n\t\"Ucircumflex\",\n\t\"Udieresis\",\n\t\"Ugrave\",\n\t\"Yacute\",\n\t\"Ydieresis\",\n\t\"Zcaron\",\n\t\"aacute\",\n\t\"acircumflex\",\n\t\"adieresis\",\n\t\"agrave\",\n\t\"aring\",\n\t\"atilde\",\n\t\"ccedilla\",\n\t\"eacute\",\n\t\"ecircumflex\",\n\t\"edieresis\",\n\t\"egrave\",\n\t\"iacute\",\n\t\"icircumflex\",\n\t\"idieresis\",\n\t\"igrave\",\n\t\"ntilde\",\n\t\"oacute\",\n\t\"ocircumflex\",\n\t\"odieresis\",\n\t\"ograve\",\n\t\"otilde\",\n\t\"scaron\",\n\t\"uacute\",\n\t\"ucircumflex\",\n\t\"udieresis\",\n\t\"ugrave\",\n\t\"yacute\",\n\t\"ydieresis\",\n\t\"zcaron\",\n\t\"exclamsmall\",\n\t\"Hungarumlautsmall\",\n\t\"dollaroldstyle\",\n\t\"dollarsuperior\",\n\t\"ampersandsmall\",\n\t\"Acutesmall\",\n\t\"parenleftsuperior\",\n\t\"parenrightsuperior\",\n\t\"twodotenleader\",\n\t\"onedotenleader\",\n\t\"zerooldstyle\",\n\t\"oneoldstyle\",\n\t\"twooldstyle\",\n\t\"threeoldstyle\",\n\t\"fouroldstyle\",\n\t\"fiveoldstyle\",\n\t\"sixoldstyle\",\n\t\"sevenoldstyle\",\n\t\"eightoldstyle\",\n\t\"nineoldstyle\",\n\t\"commasuperior\",\n\t\"threequartersemdash\",\n\t\"periodsuperior\",\n\t\"questionsmall\",\n\t\"asuperior\",\n\t\"bsuperior\",\n\t\"centsuperior\",\n\t\"dsuperior\",\n\t\"esuperior\",\n\t\"isuperior\",\n\t\"lsuperior\",\n\t\"msuperior\",\n\t\"nsuperior\",\n\t\"osuperior\",\n\t\"rsuperior\",\n\t\"ssuperior\",\n\t\"tsuperior\",\n\t\"ff\",\n\t\"ffi\",\n\t\"ffl\",\n\t\"parenleftinferior\",\n\t\"parenrightinferior\",\n\t\"Circumflexsmall\",\n\t\"hyphensuperior\",\n\t\"Gravesmall\",\n\t\"Asmall\",\n\t\"Bsmall\",\n\t\"Csmall\",\n\t\"Dsmall\",\n\t\"Esmall\",\n\t\"Fsmall\",\n\t\"Gsmall\",\n\t\"Hsmall\",\n\t\"Ismall\",\n\t\"Jsmall\",\n\t\"Ksmall\",\n\t\"Lsmall\",\n\t\"Msmall\",\n\t\"Nsmall\",\n\t\"Osmall\",\n\t\"Psmall\",\n\t\"Qsmall\",\n\t\"Rsmall\",\n\t\"Ssmall\",\n\t\"Tsmall\",\n\t\"Usmall\",\n\t\"Vsmall\",\n\t\"Wsmall\",\n\t\"Xsmall\",\n\t\"Ysmall\",\n\t\"Zsmall\",\n\t\"colonmonetary\",\n\t\"onefitted\",\n\t\"rupiah\",\n\t\"Tildesmall\",\n\t\"exclamdownsmall\",\n\t\"centoldstyle\",\n\t\"Lslashsmall\",\n\t\"Scaronsmall\",\n\t\"Zcaronsmall\",\n\t\"Dieresissmall\",\n\t\"Brevesmall\",\n\t\"Caronsmall\",\n\t\"Dotaccentsmall\",\n\t\"Macronsmall\",\n\t\"figuredash\",\n\t\"hypheninferior\",\n\t\"Ogoneksmall\",\n\t\"Ringsmall\",\n\t\"Cedillasmall\",\n\t\"questiondownsmall\",\n\t\"oneeighth\",\n\t\"threeeighths\",\n\t\"fiveeighths\",\n\t\"seveneighths\",\n\t\"onethird\",\n\t\"twothirds\",\n\t\"zerosuperior\",\n\t\"foursuperior\",\n\t\"fivesuperior\",\n\t\"sixsuperior\",\n\t\"sevensuperior\",\n\t\"eightsuperior\",\n\t\"ninesuperior\",\n\t\"zeroinferior\",\n\t\"oneinferior\",\n\t\"twoinferior\",\n\t\"threeinferior\",\n\t\"fourinferior\",\n\t\"fiveinferior\",\n\t\"sixinferior\",\n\t\"seveninferior\",\n\t\"eightinferior\",\n\t\"nineinferior\",\n\t\"centinferior\",\n\t\"dollarinferior\",\n\t\"periodinferior\",\n\t\"commainferior\",\n\t\"Agravesmall\",\n\t\"Aacutesmall\",\n\t\"Acircumflexsmall\",\n\t\"Atildesmall\",\n\t\"Adieresissmall\",\n\t\"Aringsmall\",\n\t\"AEsmall\",\n\t\"Ccedillasmall\",\n\t\"Egravesmall\",\n\t\"Eacutesmall\",\n\t\"Ecircumflexsmall\",\n\t\"Edieresissmall\",\n\t\"Igravesmall\",\n\t\"Iacutesmall\",\n\t\"Icircumflexsmall\",\n\t\"Idieresissmall\",\n\t\"Ethsmall\",\n\t\"Ntildesmall\",\n\t\"Ogravesmall\",\n\t\"Oacutesmall\",\n\t\"Ocircumflexsmall\",\n\t\"Otildesmall\",\n\t\"Odieresissmall\",\n\t\"OEsmall\",\n\t\"Oslashsmall\",\n\t\"Ugravesmall\",\n\t\"Uacutesmall\",\n\t\"Ucircumflexsmall\",\n\t\"Udieresissmall\",\n\t\"Yacutesmall\",\n\t\"Thornsmall\",\n\t\"Ydieresissmall\",\n\t\"001.000\",\n\t\"001.001\",\n\t\"001.002\",\n\t\"001.003\",\n\t\"Black\",\n\t\"Bold\",\n\t\"Book\",\n\t\"Light\",\n\t\"Medium\",\n\t\"Regular\",\n\t\"Roman\",\n\t\"Semibold\",\n];\n\n// Top DICT operators\nenum TopDictOp {\n\tversion = 0,\n\tNotice = 1,\n\tFullName = 2,\n\tFamilyName = 3,\n\tWeight = 4,\n\tFontBBox = 5,\n\tUniqueID = 13,\n\tXUID = 14,\n\tcharset = 15,\n\tEncoding = 16,\n\tCharStrings = 17,\n\tPrivate = 18,\n\tCopyright = 0x0c00,\n\tisFixedPitch = 0x0c01,\n\tItalicAngle = 0x0c02,\n\tUnderlinePosition = 0x0c03,\n\tUnderlineThickness = 0x0c04,\n\tPaintType = 0x0c05,\n\tCharstringType = 0x0c06,\n\tFontMatrix = 0x0c07,\n\tStrokeWidth = 0x0c08,\n\tSyntheticBase = 0x0c14,\n\tPostScript = 0x0c15,\n\tBaseFontName = 0x0c16,\n\tBaseFontBlend = 0x0c17,\n\t// CID-specific\n\tROS = 0x0c1e,\n\tCIDFontVersion = 0x0c1f,\n\tCIDFontRevision = 0x0c20,\n\tCIDFontType = 0x0c21,\n\tCIDCount = 0x0c22,\n\tUIDBase = 0x0c23,\n\tFDArray = 0x0c24,\n\tFDSelect = 0x0c25,\n\tFontName = 0x0c26,\n}\n\n// Private DICT operators\nenum PrivateDictOp {\n\tBlueValues = 6,\n\tOtherBlues = 7,\n\tFamilyBlues = 8,\n\tFamilyOtherBlues = 9,\n\tStdHW = 10,\n\tStdVW = 11,\n\tSubrs = 19,\n\tdefaultWidthX = 20,\n\tnominalWidthX = 21,\n\tBlueScale = 0x0c09,\n\tBlueShift = 0x0c0a,\n\tBlueFuzz = 0x0c0b,\n\tStemSnapH = 0x0c0c,\n\tStemSnapV = 0x0c0d,\n\tForceBold = 0x0c0e,\n\tLanguageGroup = 0x0c11,\n\tExpansionFactor = 0x0c12,\n\tinitialRandomSeed = 0x0c13,\n}\n\n/**\n * Parse CFF table\n */\nexport function parseCff(reader: Reader): CffTable {\n\tconst startOffset = reader.offset;\n\n\t// Header\n\tconst major = reader.uint8();\n\tconst minor = reader.uint8();\n\tconst hdrSize = reader.uint8();\n\tconst _offSize = reader.uint8();\n\n\treader.seek(startOffset + hdrSize);\n\n\t// Name INDEX\n\tconst names = parseIndex(reader).map((data) =>\n\t\tnew TextDecoder().decode(data),\n\t);\n\n\t// Top DICT INDEX\n\tconst topDictData = parseIndex(reader);\n\tconst topDicts: TopDict[] = [];\n\n\t// String INDEX\n\tconst stringData = parseIndex(reader);\n\tconst strings = stringData.map((data) => new TextDecoder().decode(data));\n\n\t// Global Subr INDEX\n\tconst globalSubrs = parseIndex(reader);\n\n\t// Parse Top DICTs\n\tfor (const data of topDictData) {\n\t\ttopDicts.push(\n\t\t\tparseTopDict(\n\t\t\t\tnew Reader(\n\t\t\t\t\tdata.buffer as ArrayBuffer,\n\t\t\t\t\tdata.byteOffset,\n\t\t\t\t\tdata.byteLength,\n\t\t\t\t),\n\t\t\t\tstrings,\n\t\t\t),\n\t\t);\n\t}\n\n\t// Parse CharStrings and local subrs for each font\n\tconst charStrings: Uint8Array[][] = [];\n\tconst localSubrs: Uint8Array[][] = [];\n\tconst fdArrays: FDDict[][] = [];\n\tconst fdSelects: FDSelect[] = [];\n\n\tfor (const topDict of topDicts) {\n\t\t// CharStrings\n\t\tif (topDict.charStrings !== undefined) {\n\t\t\treader.seek(startOffset + topDict.charStrings);\n\t\t\tcharStrings.push(parseIndex(reader));\n\t\t} else {\n\t\t\tcharStrings.push([]);\n\t\t}\n\n\t\t// Private DICT and local subrs\n\t\tif (topDict.private) {\n\t\t\tconst [privateSize, privateOffset] = topDict.private;\n\t\t\tconst privateDict = parsePrivateDict(\n\t\t\t\treader.slice(privateOffset, privateSize),\n\t\t\t\tstrings,\n\t\t\t);\n\n\t\t\tif (privateDict.subrs !== undefined) {\n\t\t\t\treader.seek(startOffset + privateOffset + privateDict.subrs);\n\t\t\t\tlocalSubrs.push(parseIndex(reader));\n\t\t\t} else {\n\t\t\t\tlocalSubrs.push([]);\n\t\t\t}\n\t\t} else {\n\t\t\tlocalSubrs.push([]);\n\t\t}\n\n\t\t// FDArray (for CID fonts)\n\t\tif (topDict.fdArray !== undefined) {\n\t\t\treader.seek(startOffset + topDict.fdArray);\n\t\t\tconst fdData = parseIndex(reader);\n\t\t\tconst fds: FDDict[] = [];\n\t\t\tfor (const data of fdData) {\n\t\t\t\tconst fdDict = parseTopDict(\n\t\t\t\t\tnew Reader(\n\t\t\t\t\t\tdata.buffer as ArrayBuffer,\n\t\t\t\t\t\tdata.byteOffset,\n\t\t\t\t\t\tdata.byteLength,\n\t\t\t\t\t),\n\t\t\t\t\tstrings,\n\t\t\t\t) as FDDict;\n\n\t\t\t\t// Parse FD-specific private dict and local subrs\n\t\t\t\tif (fdDict.private) {\n\t\t\t\t\tconst [fdPrivateSize, fdPrivateOffset] = fdDict.private;\n\t\t\t\t\tconst fdPrivateDict = parsePrivateDict(\n\t\t\t\t\t\treader.slice(startOffset + fdPrivateOffset, fdPrivateSize),\n\t\t\t\t\t\tstrings,\n\t\t\t\t\t);\n\t\t\t\t\t// Copy private dict properties to fdDict\n\t\t\t\t\tObject.assign(fdDict, fdPrivateDict);\n\n\t\t\t\t\t// Parse FD-specific local subrs\n\t\t\t\t\tif (fdPrivateDict.subrs !== undefined) {\n\t\t\t\t\t\treader.seek(startOffset + fdPrivateOffset + fdPrivateDict.subrs);\n\t\t\t\t\t\tfdDict.localSubrs = parseIndex(reader);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfds.push(fdDict);\n\t\t\t}\n\t\t\tfdArrays.push(fds);\n\t\t} else {\n\t\t\tfdArrays.push([]);\n\t\t}\n\n\t\t// FDSelect (for CID fonts)\n\t\tif (topDict.fdSelect !== undefined) {\n\t\t\treader.seek(startOffset + topDict.fdSelect);\n\t\t\tconst lastCharStrings = charStrings[charStrings.length - 1];\n\t\t\tfdSelects.push(parseFDSelect(reader, lastCharStrings?.length ?? 0));\n\t\t} else {\n\t\t\tfdSelects.push({ format: 0, select: () => 0 });\n\t\t}\n\t}\n\n\treturn {\n\t\tversion: { major, minor },\n\t\tnames,\n\t\ttopDicts,\n\t\tstrings,\n\t\tglobalSubrs,\n\t\tcharStrings,\n\t\tlocalSubrs,\n\t\tfdArrays,\n\t\tfdSelects,\n\t};\n}\n\n/**\n * Parse an INDEX structure\n */\nfunction parseIndex(reader: Reader): Uint8Array[] {\n\tconst count = reader.uint16();\n\tif (count === 0) return [];\n\n\tconst offSize = reader.uint8();\n\tconst offsets: number[] = [];\n\n\tfor (let i = 0; i <= count; i++) {\n\t\toffsets.push(readOffset(reader, offSize));\n\t}\n\n\tconst result: Uint8Array[] = [];\n\tfor (let i = 0; i < count; i++) {\n\t\tconst start = offsets[i];\n\t\tconst end = offsets[i + 1];\n\t\tif (start === undefined || end === undefined) continue;\n\t\tconst length = end - start;\n\t\tresult.push(reader.bytes(length));\n\t}\n\n\treturn result;\n}\n\n/**\n * Read offset of given size\n */\nfunction readOffset(reader: Reader, offSize: number): number {\n\tswitch (offSize) {\n\t\tcase 1:\n\t\t\treturn reader.uint8();\n\t\tcase 2:\n\t\t\treturn reader.uint16();\n\t\tcase 3:\n\t\t\treturn reader.uint24();\n\t\tcase 4:\n\t\t\treturn reader.uint32();\n\t\tdefault:\n\t\t\tthrow new Error(`Invalid offset size: ${offSize}`);\n\t}\n}\n\n/**\n * Parse a DICT structure\n */\nfunction parseDict(reader: Reader): Map<number, number[]> {\n\tconst result = new Map<number, number[]>();\n\tconst operands: number[] = [];\n\n\twhile (reader.remaining > 0) {\n\t\tconst b0 = reader.uint8();\n\n\t\tif (b0 <= 21) {\n\t\t\t// Operator\n\t\t\tlet op = b0;\n\t\t\tif (b0 === 12) {\n\t\t\t\top = 0x0c00 | reader.uint8();\n\t\t\t}\n\t\t\tresult.set(op, [...operands]);\n\t\t\toperands.length = 0;\n\t\t} else if (b0 === 28) {\n\t\t\t// 16-bit signed integer\n\t\t\toperands.push(reader.int16());\n\t\t} else if (b0 === 29) {\n\t\t\t// 32-bit signed integer\n\t\t\toperands.push(reader.int32());\n\t\t} else if (b0 === 30) {\n\t\t\t// Real number\n\t\t\toperands.push(parseReal(reader));\n\t\t} else if (b0 >= 32 && b0 <= 246) {\n\t\t\toperands.push(b0 - 139);\n\t\t} else if (b0 >= 247 && b0 <= 250) {\n\t\t\tconst b1 = reader.uint8();\n\t\t\toperands.push((b0 - 247) * 256 + b1 + 108);\n\t\t} else if (b0 >= 251 && b0 <= 254) {\n\t\t\tconst b1 = reader.uint8();\n\t\t\toperands.push(-(b0 - 251) * 256 - b1 - 108);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Parse real number from DICT\n */\nfunction parseReal(reader: Reader): number {\n\tlet str = \"\";\n\tconst nibbleChars = \"0123456789.EE -\";\n\tlet done = false;\n\n\twhile (!done) {\n\t\tconst byte = reader.uint8();\n\t\tfor (let i = 0; i < 2; i++) {\n\t\t\tconst nibble = i === 0 ? byte >> 4 : byte & 0x0f;\n\t\t\tif (nibble === 0x0f) {\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nibble === 0x0c) {\n\t\t\t\tstr += \"E-\";\n\t\t\t} else {\n\t\t\t\tstr += nibbleChars[nibble];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn parseFloat(str);\n}\n\n/**\n * Parse Top DICT\n */\nfunction parseTopDict(reader: Reader, strings: string[]): TopDict {\n\tconst dict = parseDict(reader);\n\tconst result: TopDict = {};\n\n\tconst getString = (sid: number): string => {\n\t\tif (sid < STANDARD_STRINGS.length) {\n\t\t\tconst str = STANDARD_STRINGS[sid];\n\t\t\treturn str ?? \"\";\n\t\t}\n\t\treturn strings[sid - STANDARD_STRINGS.length] ?? \"\";\n\t};\n\n\tfor (const [op, operands] of dict) {\n\t\tconst op0 = operands[0];\n\t\tconst op1 = operands[1];\n\t\tconst op2 = operands[2];\n\n\t\tswitch (op) {\n\t\t\tcase TopDictOp.version:\n\t\t\t\tif (op0 !== undefined) result.version = getString(op0);\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.Notice:\n\t\t\t\tif (op0 !== undefined) result.notice = getString(op0);\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.Copyright:\n\t\t\t\tif (op0 !== undefined) result.copyright = getString(op0);\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.FullName:\n\t\t\t\tif (op0 !== undefined) result.fullName = getString(op0);\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.FamilyName:\n\t\t\t\tif (op0 !== undefined) result.familyName = getString(op0);\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.Weight:\n\t\t\t\tif (op0 !== undefined) result.weight = getString(op0);\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.isFixedPitch:\n\t\t\t\tresult.isFixedPitch = op0 !== 0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.ItalicAngle:\n\t\t\t\tresult.italicAngle = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.UnderlinePosition:\n\t\t\t\tresult.underlinePosition = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.UnderlineThickness:\n\t\t\t\tresult.underlineThickness = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.PaintType:\n\t\t\t\tresult.paintType = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.CharstringType:\n\t\t\t\tresult.charstringType = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.FontMatrix:\n\t\t\t\tresult.fontMatrix = operands;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.UniqueID:\n\t\t\t\tresult.uniqueID = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.FontBBox:\n\t\t\t\tresult.fontBBox = operands;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.StrokeWidth:\n\t\t\t\tresult.strokeWidth = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.charset:\n\t\t\t\tresult.charset = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.Encoding:\n\t\t\t\tresult.encoding = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.CharStrings:\n\t\t\t\tresult.charStrings = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.Private:\n\t\t\t\tif (op0 !== undefined && op1 !== undefined) {\n\t\t\t\t\tresult.private = [op0, op1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.SyntheticBase:\n\t\t\t\tresult.syntheticBase = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.PostScript:\n\t\t\t\tif (op0 !== undefined) result.postScript = getString(op0);\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.BaseFontName:\n\t\t\t\tif (op0 !== undefined) result.baseFontName = getString(op0);\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.BaseFontBlend:\n\t\t\t\tresult.baseFontBlend = operands;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.ROS:\n\t\t\t\tif (op0 !== undefined && op1 !== undefined && op2 !== undefined) {\n\t\t\t\t\tresult.ros = {\n\t\t\t\t\t\tregistry: getString(op0),\n\t\t\t\t\t\tordering: getString(op1),\n\t\t\t\t\t\tsupplement: op2,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.CIDFontVersion:\n\t\t\t\tresult.cidFontVersion = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.CIDFontRevision:\n\t\t\t\tresult.cidFontRevision = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.CIDFontType:\n\t\t\t\tresult.cidFontType = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.CIDCount:\n\t\t\t\tresult.cidCount = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.UIDBase:\n\t\t\t\tresult.uidBase = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.FDArray:\n\t\t\t\tresult.fdArray = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.FDSelect:\n\t\t\t\tresult.fdSelect = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.FontName:\n\t\t\t\tif (op0 !== undefined) result.fontName = getString(op0);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Parse Private DICT\n */\nfunction parsePrivateDict(reader: Reader, _strings: string[]): PrivateDict {\n\tconst dict = parseDict(reader);\n\tconst result: PrivateDict = {};\n\n\tfor (const [op, operands] of dict) {\n\t\tconst op0 = operands[0];\n\n\t\tswitch (op) {\n\t\t\tcase PrivateDictOp.BlueValues:\n\t\t\t\tresult.blueValues = deltaToAbsolute(operands);\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.OtherBlues:\n\t\t\t\tresult.otherBlues = deltaToAbsolute(operands);\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.FamilyBlues:\n\t\t\t\tresult.familyBlues = deltaToAbsolute(operands);\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.FamilyOtherBlues:\n\t\t\t\tresult.familyOtherBlues = deltaToAbsolute(operands);\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.BlueScale:\n\t\t\t\tresult.blueScale = op0;\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.BlueShift:\n\t\t\t\tresult.blueShift = op0;\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.BlueFuzz:\n\t\t\t\tresult.blueFuzz = op0;\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.StdHW:\n\t\t\t\tresult.stdHW = op0;\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.StdVW:\n\t\t\t\tresult.stdVW = op0;\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.StemSnapH:\n\t\t\t\tresult.stemSnapH = deltaToAbsolute(operands);\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.StemSnapV:\n\t\t\t\tresult.stemSnapV = deltaToAbsolute(operands);\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.ForceBold:\n\t\t\t\tresult.forceBold = op0 !== 0;\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.LanguageGroup:\n\t\t\t\tresult.languageGroup = op0;\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.ExpansionFactor:\n\t\t\t\tresult.expansionFactor = op0;\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.initialRandomSeed:\n\t\t\t\tresult.initialRandomSeed = op0;\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.Subrs:\n\t\t\t\tresult.subrs = op0;\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.defaultWidthX:\n\t\t\t\tresult.defaultWidthX = op0;\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.nominalWidthX:\n\t\t\t\tresult.nominalWidthX = op0;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Convert delta-encoded values to absolute\n */\nfunction deltaToAbsolute(deltas: number[]): number[] {\n\tconst result: number[] = [];\n\tlet value = 0;\n\tfor (const delta of deltas) {\n\t\tvalue += delta;\n\t\tresult.push(value);\n\t}\n\treturn result;\n}\n\n/**\n * Parse FDSelect structure\n */\nfunction parseFDSelect(reader: Reader, numGlyphs: number): FDSelect {\n\tconst format = reader.uint8();\n\n\tif (format === 0) {\n\t\tconst fds = reader.uint8Array(numGlyphs);\n\t\treturn {\n\t\t\tformat,\n\t\t\tselect: (glyphId: number) => fds[glyphId] ?? 0,\n\t\t};\n\t} else if (format === 3) {\n\t\tconst nRanges = reader.uint16();\n\t\tconst ranges: Array<{ first: number; fd: number }> = [];\n\n\t\tfor (let i = 0; i < nRanges; i++) {\n\t\t\tranges.push({\n\t\t\t\tfirst: reader.uint16(),\n\t\t\t\tfd: reader.uint8(),\n\t\t\t});\n\t\t}\n\t\tconst _sentinel = reader.uint16();\n\n\t\treturn {\n\t\t\tformat,\n\t\t\tselect: (glyphId: number) => {\n\t\t\t\t// Binary search through ranges\n\t\t\t\tlet lo = 0;\n\t\t\t\tlet hi = ranges.length - 1;\n\t\t\t\twhile (lo < hi) {\n\t\t\t\t\tconst mid = Math.ceil((lo + hi) / 2);\n\t\t\t\t\tconst range = ranges[mid];\n\t\t\t\t\tif (range && range.first <= glyphId) {\n\t\t\t\t\t\tlo = mid;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thi = mid - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst foundRange = ranges[lo];\n\t\t\t\treturn foundRange?.fd ?? 0;\n\t\t\t},\n\t\t};\n\t}\n\n\treturn { format, select: () => 0 };\n}\n\n/**\n * Get string by SID\n */\nexport function getCffString(cff: CffTable, sid: number): string {\n\tif (sid < STANDARD_STRINGS.length) {\n\t\tconst str = STANDARD_STRINGS[sid];\n\t\treturn str ?? \"\";\n\t}\n\treturn cff.strings[sid - STANDARD_STRINGS.length] ?? \"\";\n}\n", "import { Reader } from \"../binary/reader.ts\";\n\n/**\n * CFF2 (Compact Font Format 2) table parser\n * Used by variable fonts with PostScript outlines\n */\n\nexport interface Cff2Table {\n\tversion: { major: number; minor: number };\n\ttopDict: Cff2TopDict;\n\tglobalSubrs: Uint8Array[];\n\tcharStrings: Uint8Array[];\n\tfdArray: Cff2FDDict[];\n\tfdSelect: Cff2FDSelect | null;\n\tvstore: ItemVariationStore | null;\n}\n\nexport interface Cff2TopDict {\n\tcharStrings?: number;\n\tfdArray?: number;\n\tfdSelect?: number;\n\tvstore?: number;\n\tfontMatrix?: number[];\n}\n\nexport interface Cff2PrivateDict {\n\tblueValues?: number[];\n\totherBlues?: number[];\n\tfamilyBlues?: number[];\n\tfamilyOtherBlues?: number[];\n\tblueScale?: number;\n\tblueShift?: number;\n\tblueFuzz?: number;\n\tstdHW?: number;\n\tstdVW?: number;\n\tstemSnapH?: number[];\n\tstemSnapV?: number[];\n\tlanguageGroup?: number;\n\texpansionFactor?: number;\n\tsubrs?: number;\n\tvsindex?: number;\n\tblend?: number[];\n}\n\nexport interface Cff2FDDict {\n\tfontName?: string;\n\tprivate?: Cff2PrivateDict;\n\tprivateOffset?: number;\n\tprivateSize?: number;\n\tlocalSubrs?: Uint8Array[];\n}\n\nexport interface Cff2FDSelect {\n\tformat: number;\n\tselect: (glyphId: number) => number;\n}\n\nexport interface ItemVariationStore {\n\tformat: number;\n\tvariationRegionList: VariationRegionList;\n\titemVariationData: ItemVariationData[];\n}\n\nexport interface VariationRegionList {\n\taxisCount: number;\n\tregionCount: number;\n\tregions: VariationRegion[];\n}\n\nexport interface VariationRegion {\n\taxes: RegionAxisCoordinates[];\n}\n\nexport interface RegionAxisCoordinates {\n\tstartCoord: number;\n\tpeakCoord: number;\n\tendCoord: number;\n}\n\nexport interface ItemVariationData {\n\titemCount: number;\n\tregionIndexCount: number;\n\tregionIndexes: number[];\n\tdeltaSets: number[][];\n}\n\n// CFF2 Top DICT operators\nenum Cff2TopDictOp {\n\tFontMatrix = 0x0c07,\n\tCharStrings = 17,\n\tFDArray = 0x0c24,\n\tFDSelect = 0x0c25,\n\tvstore = 24,\n}\n\n// CFF2 Private DICT operators\nenum Cff2PrivateDictOp {\n\tBlueValues = 6,\n\tOtherBlues = 7,\n\tFamilyBlues = 8,\n\tFamilyOtherBlues = 9,\n\tStdHW = 10,\n\tStdVW = 11,\n\tSubrs = 19,\n\tvsindex = 22,\n\tblend = 23,\n\tBlueScale = 0x0c09,\n\tBlueShift = 0x0c0a,\n\tBlueFuzz = 0x0c0b,\n\tStemSnapH = 0x0c0c,\n\tStemSnapV = 0x0c0d,\n\tLanguageGroup = 0x0c11,\n\tExpansionFactor = 0x0c12,\n}\n\n/**\n * Parse CFF2 table\n */\nexport function parseCff2(reader: Reader): Cff2Table {\n\tconst startOffset = reader.offset;\n\n\t// Header\n\tconst major = reader.uint8();\n\tconst minor = reader.uint8();\n\tconst headerSize = reader.uint8();\n\tconst topDictLength = reader.uint16();\n\n\t// Skip to after header\n\treader.seek(startOffset + headerSize);\n\n\t// Top DICT (not an INDEX in CFF2, just raw data)\n\tconst topDictReader = reader.slice(\n\t\treader.offset - startOffset,\n\t\ttopDictLength,\n\t);\n\treader.skip(topDictLength);\n\tconst topDict = parseCff2TopDict(topDictReader);\n\n\t// Global Subr INDEX\n\tconst globalSubrs = parseIndex(reader);\n\n\t// CharStrings INDEX\n\tlet charStrings: Uint8Array[] = [];\n\tif (topDict.charStrings !== undefined) {\n\t\treader.seek(startOffset + topDict.charStrings);\n\t\tcharStrings = parseIndex(reader);\n\t}\n\n\t// FDArray INDEX\n\tconst fdArray: Cff2FDDict[] = [];\n\tif (topDict.fdArray !== undefined) {\n\t\treader.seek(startOffset + topDict.fdArray);\n\t\tconst fdDictData = parseIndex(reader);\n\n\t\tfor (const data of fdDictData) {\n\t\t\tconst fd = parseCff2FDDict(\n\t\t\t\tnew Reader(\n\t\t\t\t\tdata.buffer as ArrayBuffer,\n\t\t\t\t\tdata.byteOffset,\n\t\t\t\t\tdata.byteLength,\n\t\t\t\t),\n\t\t\t);\n\n\t\t\t// Parse local subrs if Private DICT has them\n\t\t\tif (fd.privateOffset !== undefined && fd.privateSize !== undefined) {\n\t\t\t\treader.seek(startOffset + fd.privateOffset);\n\t\t\t\tconst privateReader = reader.slice(0, fd.privateSize);\n\t\t\t\tfd.private = parseCff2PrivateDict(privateReader);\n\n\t\t\t\tif (fd.private.subrs !== undefined) {\n\t\t\t\t\treader.seek(startOffset + fd.privateOffset + fd.private.subrs);\n\t\t\t\t\tfd.localSubrs = parseIndex(reader);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfdArray.push(fd);\n\t\t}\n\t}\n\n\t// FDSelect\n\tlet fdSelect: Cff2FDSelect | null = null;\n\tif (topDict.fdSelect !== undefined) {\n\t\treader.seek(startOffset + topDict.fdSelect);\n\t\tfdSelect = parseFDSelect(reader, charStrings.length);\n\t}\n\n\t// Variation Store\n\tlet vstore: ItemVariationStore | null = null;\n\tif (topDict.vstore !== undefined) {\n\t\treader.seek(startOffset + topDict.vstore);\n\t\tvstore = parseItemVariationStore(reader);\n\t}\n\n\treturn {\n\t\tversion: { major, minor },\n\t\ttopDict,\n\t\tglobalSubrs,\n\t\tcharStrings,\n\t\tfdArray,\n\t\tfdSelect,\n\t\tvstore,\n\t};\n}\n\n/**\n * Parse CFF2 INDEX structure (uses 32-bit count)\n */\nfunction parseIndex(reader: Reader): Uint8Array[] {\n\tconst count = reader.uint32();\n\tif (count === 0) return [];\n\n\tconst offSize = reader.uint8();\n\tconst offsets: number[] = [];\n\n\tfor (let i = 0; i <= count; i++) {\n\t\toffsets.push(readOffset(reader, offSize));\n\t}\n\n\tconst result: Uint8Array[] = [];\n\tfor (let i = 0; i < count; i++) {\n\t\tconst start = offsets[i];\n\t\tconst end = offsets[i + 1];\n\t\tif (start === undefined || end === undefined) continue;\n\t\tconst length = end - start;\n\t\tresult.push(reader.bytes(length));\n\t}\n\n\treturn result;\n}\n\n/**\n * Read offset of given size\n */\nfunction readOffset(reader: Reader, offSize: number): number {\n\tswitch (offSize) {\n\t\tcase 1:\n\t\t\treturn reader.uint8();\n\t\tcase 2:\n\t\t\treturn reader.uint16();\n\t\tcase 3:\n\t\t\treturn reader.uint24();\n\t\tcase 4:\n\t\t\treturn reader.uint32();\n\t\tdefault:\n\t\t\tthrow new Error(`Invalid offset size: ${offSize}`);\n\t}\n}\n\n/**\n * Parse a CFF2 DICT structure\n */\nfunction parseDict(reader: Reader): Map<number, number[]> {\n\tconst result = new Map<number, number[]>();\n\tconst operands: number[] = [];\n\n\twhile (reader.remaining > 0) {\n\t\tconst b0 = reader.uint8();\n\n\t\tif (b0 <= 21) {\n\t\t\t// Operator\n\t\t\tlet op = b0;\n\t\t\tif (b0 === 12) {\n\t\t\t\top = 0x0c00 | reader.uint8();\n\t\t\t}\n\t\t\tresult.set(op, [...operands]);\n\t\t\toperands.length = 0;\n\t\t} else if (b0 === 22) {\n\t\t\t// vsindex operator\n\t\t\tresult.set(22, [...operands]);\n\t\t\toperands.length = 0;\n\t\t} else if (b0 === 23) {\n\t\t\t// blend operator\n\t\t\tresult.set(23, [...operands]);\n\t\t\toperands.length = 0;\n\t\t} else if (b0 === 24) {\n\t\t\t// vstore operator\n\t\t\tresult.set(24, [...operands]);\n\t\t\toperands.length = 0;\n\t\t} else if (b0 === 28) {\n\t\t\t// 16-bit signed integer\n\t\t\toperands.push(reader.int16());\n\t\t} else if (b0 === 29) {\n\t\t\t// 32-bit signed integer\n\t\t\toperands.push(reader.int32());\n\t\t} else if (b0 === 30) {\n\t\t\t// Real number\n\t\t\toperands.push(parseReal(reader));\n\t\t} else if (b0 >= 32 && b0 <= 246) {\n\t\t\toperands.push(b0 - 139);\n\t\t} else if (b0 >= 247 && b0 <= 250) {\n\t\t\tconst b1 = reader.uint8();\n\t\t\toperands.push((b0 - 247) * 256 + b1 + 108);\n\t\t} else if (b0 >= 251 && b0 <= 254) {\n\t\t\tconst b1 = reader.uint8();\n\t\t\toperands.push(-(b0 - 251) * 256 - b1 - 108);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Parse real number\n */\nfunction parseReal(reader: Reader): number {\n\tlet str = \"\";\n\tconst nibbleChars = \"0123456789.EE -\";\n\tlet done = false;\n\n\twhile (!done) {\n\t\tconst byte = reader.uint8();\n\t\tfor (let i = 0; i < 2; i++) {\n\t\t\tconst nibble = i === 0 ? byte >> 4 : byte & 0x0f;\n\t\t\tif (nibble === 0x0f) {\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nibble === 0x0c) {\n\t\t\t\tstr += \"E-\";\n\t\t\t} else {\n\t\t\t\tconst char = nibbleChars[nibble];\n\t\t\t\tif (char !== undefined) str += char;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn parseFloat(str);\n}\n\n/**\n * Parse CFF2 Top DICT\n */\nfunction parseCff2TopDict(reader: Reader): Cff2TopDict {\n\tconst dict = parseDict(reader);\n\tconst result: Cff2TopDict = {};\n\n\tfor (const [op, operands] of dict) {\n\t\tswitch (op) {\n\t\t\tcase Cff2TopDictOp.FontMatrix:\n\t\t\t\tresult.fontMatrix = operands;\n\t\t\t\tbreak;\n\t\t\tcase Cff2TopDictOp.CharStrings:\n\t\t\t\tresult.charStrings = operands[0];\n\t\t\t\tbreak;\n\t\t\tcase Cff2TopDictOp.FDArray:\n\t\t\t\tresult.fdArray = operands[0];\n\t\t\t\tbreak;\n\t\t\tcase Cff2TopDictOp.FDSelect:\n\t\t\t\tresult.fdSelect = operands[0];\n\t\t\t\tbreak;\n\t\t\tcase Cff2TopDictOp.vstore:\n\t\t\t\tresult.vstore = operands[0];\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Parse CFF2 FD DICT\n */\nfunction parseCff2FDDict(reader: Reader): Cff2FDDict {\n\tconst dict = parseDict(reader);\n\tconst result: Cff2FDDict = {};\n\n\t// Private DICT pointer (operator 18)\n\tconst privateOp = dict.get(18);\n\tif (privateOp && privateOp.length >= 2) {\n\t\tresult.privateSize = privateOp[0];\n\t\tresult.privateOffset = privateOp[1];\n\t}\n\n\treturn result;\n}\n\n/**\n * Parse CFF2 Private DICT\n */\nfunction parseCff2PrivateDict(reader: Reader): Cff2PrivateDict {\n\tconst dict = parseDict(reader);\n\tconst result: Cff2PrivateDict = {};\n\n\tfor (const [op, operands] of dict) {\n\t\tconst op0 = operands[0];\n\n\t\tswitch (op) {\n\t\t\tcase Cff2PrivateDictOp.BlueValues:\n\t\t\t\tresult.blueValues = deltaToAbsolute(operands);\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.OtherBlues:\n\t\t\t\tresult.otherBlues = deltaToAbsolute(operands);\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.FamilyBlues:\n\t\t\t\tresult.familyBlues = deltaToAbsolute(operands);\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.FamilyOtherBlues:\n\t\t\t\tresult.familyOtherBlues = deltaToAbsolute(operands);\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.BlueScale:\n\t\t\t\tresult.blueScale = op0;\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.BlueShift:\n\t\t\t\tresult.blueShift = op0;\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.BlueFuzz:\n\t\t\t\tresult.blueFuzz = op0;\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.StdHW:\n\t\t\t\tresult.stdHW = op0;\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.StdVW:\n\t\t\t\tresult.stdVW = op0;\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.StemSnapH:\n\t\t\t\tresult.stemSnapH = deltaToAbsolute(operands);\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.StemSnapV:\n\t\t\t\tresult.stemSnapV = deltaToAbsolute(operands);\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.LanguageGroup:\n\t\t\t\tresult.languageGroup = op0;\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.ExpansionFactor:\n\t\t\t\tresult.expansionFactor = op0;\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.Subrs:\n\t\t\t\tresult.subrs = op0;\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.vsindex:\n\t\t\t\tresult.vsindex = op0;\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.blend:\n\t\t\t\tresult.blend = operands;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Convert delta-encoded values to absolute\n */\nfunction deltaToAbsolute(deltas: number[]): number[] {\n\tconst result: number[] = [];\n\tlet value = 0;\n\tfor (const delta of deltas) {\n\t\tvalue += delta;\n\t\tresult.push(value);\n\t}\n\treturn result;\n}\n\n/**\n * Parse FDSelect structure\n */\nfunction parseFDSelect(reader: Reader, numGlyphs: number): Cff2FDSelect {\n\tconst format = reader.uint8();\n\n\tif (format === 0) {\n\t\tconst fds = reader.uint8Array(numGlyphs);\n\t\treturn {\n\t\t\tformat,\n\t\t\tselect: (glyphId: number) => fds[glyphId] ?? 0,\n\t\t};\n\t} else if (format === 3) {\n\t\tconst nRanges = reader.uint16();\n\t\tconst ranges: Array<{ first: number; fd: number }> = [];\n\n\t\tfor (let i = 0; i < nRanges; i++) {\n\t\t\tranges.push({\n\t\t\t\tfirst: reader.uint16(),\n\t\t\t\tfd: reader.uint8(),\n\t\t\t});\n\t\t}\n\t\treader.uint16(); // sentinel\n\n\t\treturn {\n\t\t\tformat,\n\t\t\tselect: (glyphId: number) => {\n\t\t\t\tlet lo = 0;\n\t\t\t\tlet hi = ranges.length - 1;\n\t\t\t\twhile (lo < hi) {\n\t\t\t\t\tconst mid = Math.ceil((lo + hi) / 2);\n\t\t\t\t\tconst range = ranges[mid];\n\t\t\t\t\tif (range && range.first <= glyphId) {\n\t\t\t\t\t\tlo = mid;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thi = mid - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst foundRange = ranges[lo];\n\t\t\t\treturn foundRange?.fd ?? 0;\n\t\t\t},\n\t\t};\n\t} else if (format === 4) {\n\t\t// CFF2 format 4: 32-bit range records\n\t\tconst nRanges = reader.uint32();\n\t\tconst ranges: Array<{ first: number; fd: number }> = [];\n\n\t\tfor (let i = 0; i < nRanges; i++) {\n\t\t\tranges.push({\n\t\t\t\tfirst: reader.uint32(),\n\t\t\t\tfd: reader.uint16(),\n\t\t\t});\n\t\t}\n\t\treader.uint32(); // sentinel\n\n\t\treturn {\n\t\t\tformat,\n\t\t\tselect: (glyphId: number) => {\n\t\t\t\tlet lo = 0;\n\t\t\t\tlet hi = ranges.length - 1;\n\t\t\t\twhile (lo < hi) {\n\t\t\t\t\tconst mid = Math.ceil((lo + hi) / 2);\n\t\t\t\t\tconst range = ranges[mid];\n\t\t\t\t\tif (range && range.first <= glyphId) {\n\t\t\t\t\t\tlo = mid;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thi = mid - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst foundRange = ranges[lo];\n\t\t\t\treturn foundRange?.fd ?? 0;\n\t\t\t},\n\t\t};\n\t}\n\n\treturn { format, select: () => 0 };\n}\n\n/**\n * Parse ItemVariationStore\n */\nfunction parseItemVariationStore(reader: Reader): ItemVariationStore {\n\tconst startOffset = reader.offset;\n\n\tconst _length = reader.uint16();\n\tconst format = reader.uint16();\n\tconst variationRegionListOffset = reader.uint32();\n\tconst itemVariationDataCount = reader.uint16();\n\tconst itemVariationDataOffsets: number[] = [];\n\n\tfor (let i = 0; i < itemVariationDataCount; i++) {\n\t\titemVariationDataOffsets.push(reader.uint32());\n\t}\n\n\t// Parse VariationRegionList\n\treader.seek(startOffset + variationRegionListOffset);\n\tconst variationRegionList = parseVariationRegionList(reader);\n\n\t// Parse ItemVariationData\n\tconst itemVariationData: ItemVariationData[] = [];\n\tfor (const offset of itemVariationDataOffsets) {\n\t\treader.seek(startOffset + offset);\n\t\titemVariationData.push(parseItemVariationData(reader));\n\t}\n\n\treturn {\n\t\tformat,\n\t\tvariationRegionList,\n\t\titemVariationData,\n\t};\n}\n\n/**\n * Parse VariationRegionList\n */\nfunction parseVariationRegionList(reader: Reader): VariationRegionList {\n\tconst axisCount = reader.uint16();\n\tconst regionCount = reader.uint16();\n\tconst regions: VariationRegion[] = [];\n\n\tfor (let i = 0; i < regionCount; i++) {\n\t\tconst axes: RegionAxisCoordinates[] = [];\n\t\tfor (let j = 0; j < axisCount; j++) {\n\t\t\taxes.push({\n\t\t\t\tstartCoord: reader.f2dot14(),\n\t\t\t\tpeakCoord: reader.f2dot14(),\n\t\t\t\tendCoord: reader.f2dot14(),\n\t\t\t});\n\t\t}\n\t\tregions.push({ axes });\n\t}\n\n\treturn { axisCount, regionCount, regions };\n}\n\n/**\n * Parse ItemVariationData\n */\nfunction parseItemVariationData(reader: Reader): ItemVariationData {\n\tconst itemCount = reader.uint16();\n\tconst wordDeltaCount = reader.uint16();\n\tconst regionIndexCount = wordDeltaCount & 0x7fff;\n\tconst longWords = (wordDeltaCount & 0x8000) !== 0;\n\n\tconst regionIndexes: number[] = [];\n\tfor (let i = 0; i < regionIndexCount; i++) {\n\t\tregionIndexes.push(reader.uint16());\n\t}\n\n\tconst deltaSets: number[][] = [];\n\tfor (let i = 0; i < itemCount; i++) {\n\t\tconst deltas: number[] = [];\n\t\tfor (let j = 0; j < regionIndexCount; j++) {\n\t\t\tif (longWords) {\n\t\t\t\tdeltas.push(reader.int32());\n\t\t\t} else {\n\t\t\t\tdeltas.push(reader.int16());\n\t\t\t}\n\t\t}\n\t\tdeltaSets.push(deltas);\n\t}\n\n\treturn {\n\t\titemCount,\n\t\tregionIndexCount,\n\t\tregionIndexes,\n\t\tdeltaSets,\n\t};\n}\n\n/**\n * Calculate variation delta for given coordinates\n */\nexport function calculateVariationDelta(\n\tvstore: ItemVariationStore,\n\touterIndex: number,\n\tinnerIndex: number,\n\tnormalizedCoords: number[],\n): number {\n\tconst itemData = vstore.itemVariationData[outerIndex];\n\tif (!itemData) return 0;\n\n\tconst deltaSet = itemData.deltaSets[innerIndex];\n\tif (!deltaSet) return 0;\n\n\tlet delta = 0;\n\tfor (let i = 0; i < itemData.regionIndexCount; i++) {\n\t\tconst regionIndex = itemData.regionIndexes[i];\n\t\tif (regionIndex === undefined) continue;\n\t\tconst region = vstore.variationRegionList.regions[regionIndex];\n\t\tif (!region) continue;\n\n\t\t// Calculate scalar for this region\n\t\tlet scalar = 1.0;\n\t\tfor (const [axis, coords] of region.axes.entries()) {\n\t\t\tconst coord = normalizedCoords[axis] ?? 0;\n\n\t\t\tif (coords.peakCoord === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (coord < coords.startCoord || coord > coords.endCoord) {\n\t\t\t\tscalar = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (coord === coords.peakCoord) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (coord < coords.peakCoord) {\n\t\t\t\tscalar *=\n\t\t\t\t\t(coord - coords.startCoord) / (coords.peakCoord - coords.startCoord);\n\t\t\t} else {\n\t\t\t\tscalar *=\n\t\t\t\t\t(coords.endCoord - coord) / (coords.endCoord - coords.peakCoord);\n\t\t\t}\n\t\t}\n\n\t\tdelta += scalar * (deltaSet[i] ?? 0);\n\t}\n\n\treturn Math.round(delta);\n}\n", "import type { GlyphId, uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/** Platform IDs */\nexport enum PlatformId {\n\tUnicode = 0,\n\tMacintosh = 1,\n\tISO = 2, // deprecated\n\tWindows = 3,\n\tCustom = 4,\n}\n\n/** Encoding record in cmap header */\nexport interface EncodingRecord {\n\tplatformId: uint16;\n\tencodingId: uint16;\n\toffset: uint32;\n}\n\n/** Base interface for cmap subtables */\ninterface CmapSubtableBase {\n\tformat: number;\n\tlookup(codepoint: number): GlyphId | undefined;\n}\n\n/** Format 0: Byte encoding table (legacy, 256 entries) */\ninterface CmapFormat0 extends CmapSubtableBase {\n\tformat: 0;\n\tglyphIdArray: Uint8Array;\n}\n\n/** Format 4: Segment mapping to delta values (BMP characters) */\ninterface CmapFormat4 extends CmapSubtableBase {\n\tformat: 4;\n\tsegCount: number;\n\tendCodes: Uint16Array;\n\tstartCodes: Uint16Array;\n\tidDeltas: Int16Array;\n\tidRangeOffsets: Uint16Array;\n\tglyphIdArray: Uint16Array;\n}\n\n/** Format 12: Segmented coverage (full Unicode) */\ninterface CmapFormat12 extends CmapSubtableBase {\n\tformat: 12;\n\tgroups: Array<{\n\t\tstartCharCode: uint32;\n\t\tendCharCode: uint32;\n\t\tstartGlyphId: uint32;\n\t}>;\n}\n\n/** Variation selector record */\ninterface VariationSelectorRecord {\n\tvarSelector: number;\n\tdefaultUVS: Array<{\n\t\tstartUnicodeValue: number;\n\t\tadditionalCount: number;\n\t}> | null;\n\tnonDefaultUVS: Array<{ unicodeValue: number; glyphId: GlyphId }> | null;\n}\n\n/** Format 14: Unicode Variation Sequences */\ninterface CmapFormat14 extends CmapSubtableBase {\n\tformat: 14;\n\tvarSelectorRecords: VariationSelectorRecord[];\n\tlookupVariation(\n\t\tcodepoint: number,\n\t\tvariationSelector: number,\n\t): GlyphId | undefined | \"default\";\n}\n\nexport type CmapSubtable =\n\t| CmapFormat0\n\t| CmapFormat4\n\t| CmapFormat12\n\t| CmapFormat14;\n\n/** Character to glyph index mapping table */\nexport interface CmapTable {\n\tversion: uint16;\n\tnumTables: uint16;\n\tencodingRecords: EncodingRecord[];\n\tsubtables: Map<string, CmapSubtable>;\n\t/** Best subtable for Unicode lookup */\n\tbestSubtable: CmapSubtable | null;\n}\n\nexport function parseCmap(reader: Reader, tableLength: number): CmapTable {\n\tconst _tableStart = reader.offset;\n\tconst version = reader.uint16();\n\tconst numTables = reader.uint16();\n\n\tconst encodingRecords: EncodingRecord[] = [];\n\tfor (let i = 0; i < numTables; i++) {\n\t\tencodingRecords.push({\n\t\t\tplatformId: reader.uint16(),\n\t\t\tencodingId: reader.uint16(),\n\t\t\toffset: reader.uint32(),\n\t\t});\n\t}\n\n\t// Parse subtables\n\tconst subtables = new Map<string, CmapSubtable>();\n\tconst parsedOffsets = new Set<number>();\n\n\tfor (const record of encodingRecords) {\n\t\t// Skip duplicates (multiple records can point to same subtable)\n\t\tif (parsedOffsets.has(record.offset)) {\n\t\t\tconst key = `${record.platformId}-${record.encodingId}`;\n\t\t\t// Find existing subtable\n\t\t\tfor (const [existingKey, subtable] of subtables) {\n\t\t\t\tconst parts = existingKey.split(\"@\");\n\t\t\t\tconst existingOffset = parts[0];\n\t\t\t\tif (\n\t\t\t\t\texistingOffset &&\n\t\t\t\t\tNumber.parseInt(existingOffset, 10) === record.offset\n\t\t\t\t) {\n\t\t\t\t\tsubtables.set(key, subtable);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tparsedOffsets.add(record.offset);\n\n\t\tconst subtableReader = reader.slice(\n\t\t\trecord.offset,\n\t\t\ttableLength - record.offset,\n\t\t);\n\t\tconst subtable = parseCmapSubtable(subtableReader);\n\n\t\tif (subtable) {\n\t\t\tconst key = `${record.platformId}-${record.encodingId}`;\n\t\t\tsubtables.set(key, subtable);\n\t\t}\n\t}\n\n\t// Find best subtable for Unicode lookup\n\t// Prefer: Windows Unicode full (3-10), Unicode full (0-4), Windows BMP (3-1), Unicode BMP (0-3)\n\tconst preferredKeys = [\"3-10\", \"0-4\", \"3-1\", \"0-3\", \"0-6\", \"1-0\"];\n\tlet bestSubtable: CmapSubtable | null = null;\n\n\tfor (const key of preferredKeys) {\n\t\tconst subtable = subtables.get(key);\n\t\tif (subtable && subtable.format !== 14) {\n\t\t\tbestSubtable = subtable;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Fallback to first non-format-14 subtable\n\tif (!bestSubtable) {\n\t\tfor (const subtable of subtables.values()) {\n\t\t\tif (subtable.format !== 14) {\n\t\t\t\tbestSubtable = subtable;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tversion,\n\t\tnumTables,\n\t\tencodingRecords,\n\t\tsubtables,\n\t\tbestSubtable,\n\t};\n}\n\nfunction parseCmapSubtable(reader: Reader): CmapSubtable | null {\n\tconst format = reader.uint16();\n\n\tswitch (format) {\n\t\tcase 0:\n\t\t\treturn parseCmapFormat0(reader);\n\t\tcase 4:\n\t\t\treturn parseCmapFormat4(reader);\n\t\tcase 12:\n\t\t\treturn parseCmapFormat12(reader);\n\t\tcase 14:\n\t\t\treturn parseCmapFormat14(reader);\n\t\tdefault:\n\t\t\t// Unsupported format - skip\n\t\t\treturn null;\n\t}\n}\n\nfunction parseCmapFormat0(reader: Reader): CmapFormat0 {\n\tconst _length = reader.uint16();\n\tconst _language = reader.uint16();\n\tconst glyphIdArray = reader.uint8Array(256);\n\n\treturn {\n\t\tformat: 0,\n\t\tglyphIdArray,\n\t\tlookup(codepoint: number): GlyphId | undefined {\n\t\t\tif (codepoint >= 0 && codepoint < 256) {\n\t\t\t\treturn glyphIdArray[codepoint];\n\t\t\t}\n\t\t\treturn undefined;\n\t\t},\n\t};\n}\n\nfunction parseCmapFormat4(reader: Reader): CmapFormat4 {\n\tconst _length = reader.uint16();\n\tconst _language = reader.uint16();\n\tconst segCountX2 = reader.uint16();\n\tconst segCount = segCountX2 / 2;\n\n\treader.skip(6); // searchRange, entrySelector, rangeShift\n\n\tconst endCodes = reader.uint16Array(segCount);\n\treader.skip(2); // reservedPad\n\tconst startCodes = reader.uint16Array(segCount);\n\tconst idDeltas = reader.int16Array(segCount);\n\n\t// Save position before idRangeOffsets for glyph ID calculation\n\tconst _idRangeOffsetPos = reader.offset;\n\tconst idRangeOffsets = reader.uint16Array(segCount);\n\n\t// Read remaining glyph IDs\n\tconst remainingBytes = reader.remaining;\n\tconst glyphIdCount = remainingBytes / 2;\n\tconst glyphIdArray = reader.uint16Array(glyphIdCount);\n\n\treturn {\n\t\tformat: 4,\n\t\tsegCount,\n\t\tendCodes,\n\t\tstartCodes,\n\t\tidDeltas,\n\t\tidRangeOffsets,\n\t\tglyphIdArray,\n\t\tlookup(codepoint: number): GlyphId | undefined {\n\t\t\tif (codepoint > 0xffff) return undefined;\n\n\t\t\t// Binary search for segment\n\t\t\tlet low = 0;\n\t\t\tlet high = segCount - 1;\n\n\t\t\twhile (low <= high) {\n\t\t\t\tconst mid = (low + high) >>> 1;\n\t\t\t\tconst endCode = endCodes[mid];\n\t\t\t\tif (endCode === undefined) break;\n\n\t\t\t\tif (codepoint > endCode) {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\tconst startCode = startCodes[mid];\n\t\t\t\t\tif (startCode === undefined) break;\n\t\t\t\t\tif (codepoint < startCode) {\n\t\t\t\t\t\thigh = mid - 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Found segment\n\t\t\t\t\t\tconst idRangeOffset = idRangeOffsets[mid];\n\t\t\t\t\t\tconst idDelta = idDeltas[mid];\n\t\t\t\t\t\tif (idRangeOffset === undefined || idDelta === undefined) break;\n\n\t\t\t\t\t\tif (idRangeOffset === 0) {\n\t\t\t\t\t\t\treturn (codepoint + idDelta) & 0xffff;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Calculate index into glyphIdArray\n\t\t\t\t\t\t// idRangeOffset is relative to its own position in the array\n\t\t\t\t\t\tconst glyphIdIndex =\n\t\t\t\t\t\t\tidRangeOffset / 2 - (segCount - mid) + (codepoint - startCode);\n\n\t\t\t\t\t\tconst glyphId = glyphIdArray[glyphIdIndex];\n\t\t\t\t\t\tif (glyphId === undefined || glyphId === 0) {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (glyphId + idDelta) & 0xffff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t},\n\t};\n}\n\nfunction parseCmapFormat12(reader: Reader): CmapFormat12 {\n\treader.skip(2); // reserved\n\tconst _length = reader.uint32();\n\tconst _language = reader.uint32();\n\tconst numGroups = reader.uint32();\n\n\tconst groups: CmapFormat12[\"groups\"] = new Array(numGroups);\n\tfor (let i = 0; i < numGroups; i++) {\n\t\tgroups[i] = {\n\t\t\tstartCharCode: reader.uint32(),\n\t\t\tendCharCode: reader.uint32(),\n\t\t\tstartGlyphId: reader.uint32(),\n\t\t};\n\t}\n\n\treturn {\n\t\tformat: 12,\n\t\tgroups,\n\t\tlookup(codepoint: number): GlyphId | undefined {\n\t\t\t// Binary search for group\n\t\t\tlet low = 0;\n\t\t\tlet high = groups.length - 1;\n\n\t\t\twhile (low <= high) {\n\t\t\t\tconst mid = (low + high) >>> 1;\n\t\t\t\tconst group = groups[mid];\n\t\t\t\tif (!group) break;\n\n\t\t\t\tif (codepoint > group.endCharCode) {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t} else if (codepoint < group.startCharCode) {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t} else {\n\t\t\t\t\t// Found group\n\t\t\t\t\treturn group.startGlyphId + (codepoint - group.startCharCode);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t},\n\t};\n}\n\nfunction parseCmapFormat14(reader: Reader): CmapFormat14 {\n\tconst subtableStart = reader.offset - 2; // Account for format already read\n\tconst _length = reader.uint32();\n\tconst numVarSelectorRecords = reader.uint32();\n\n\t// First pass: read all variation selector records\n\tconst rawRecords: Array<{\n\t\tvarSelector: number;\n\t\tdefaultUVSOffset: number;\n\t\tnonDefaultUVSOffset: number;\n\t}> = [];\n\n\tfor (let i = 0; i < numVarSelectorRecords; i++) {\n\t\trawRecords.push({\n\t\t\tvarSelector: reader.uint24(),\n\t\t\tdefaultUVSOffset: reader.uint32(),\n\t\t\tnonDefaultUVSOffset: reader.uint32(),\n\t\t});\n\t}\n\n\t// Second pass: parse the UVS tables\n\tconst varSelectorRecords: VariationSelectorRecord[] = [];\n\n\tfor (const raw of rawRecords) {\n\t\tlet defaultUVS: VariationSelectorRecord[\"defaultUVS\"] = null;\n\t\tlet nonDefaultUVS: VariationSelectorRecord[\"nonDefaultUVS\"] = null;\n\n\t\t// Parse default UVS table (ranges where default glyph is used)\n\t\tif (raw.defaultUVSOffset !== 0) {\n\t\t\tconst uvsReader = reader.sliceFrom(subtableStart + raw.defaultUVSOffset);\n\t\t\tconst numUnicodeValueRanges = uvsReader.uint32();\n\t\t\tdefaultUVS = [];\n\n\t\t\tfor (let j = 0; j < numUnicodeValueRanges; j++) {\n\t\t\t\tdefaultUVS.push({\n\t\t\t\t\tstartUnicodeValue: uvsReader.uint24(),\n\t\t\t\t\tadditionalCount: uvsReader.uint8(),\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Parse non-default UVS table (specific glyph mappings)\n\t\tif (raw.nonDefaultUVSOffset !== 0) {\n\t\t\tconst uvsReader = reader.sliceFrom(\n\t\t\t\tsubtableStart + raw.nonDefaultUVSOffset,\n\t\t\t);\n\t\t\tconst numUVSMappings = uvsReader.uint32();\n\t\t\tnonDefaultUVS = [];\n\n\t\t\tfor (let j = 0; j < numUVSMappings; j++) {\n\t\t\t\tnonDefaultUVS.push({\n\t\t\t\t\tunicodeValue: uvsReader.uint24(),\n\t\t\t\t\tglyphId: uvsReader.uint16(),\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tvarSelectorRecords.push({\n\t\t\tvarSelector: raw.varSelector,\n\t\t\tdefaultUVS,\n\t\t\tnonDefaultUVS,\n\t\t});\n\t}\n\n\treturn {\n\t\tformat: 14,\n\t\tvarSelectorRecords,\n\t\tlookup(_codepoint: number): GlyphId | undefined {\n\t\t\t// Format 14 is only for variation selectors\n\t\t\treturn undefined;\n\t\t},\n\t\tlookupVariation(\n\t\t\tcodepoint: number,\n\t\t\tvariationSelector: number,\n\t\t): GlyphId | undefined | \"default\" {\n\t\t\t// Binary search for the variation selector\n\t\t\tlet low = 0;\n\t\t\tlet high = varSelectorRecords.length - 1;\n\t\t\tlet record: VariationSelectorRecord | null = null;\n\n\t\t\twhile (low <= high) {\n\t\t\t\tconst mid = (low + high) >>> 1;\n\t\t\t\tconst rec = varSelectorRecords[mid];\n\t\t\t\tif (!rec) break;\n\n\t\t\t\tif (variationSelector > rec.varSelector) {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t} else if (variationSelector < rec.varSelector) {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t} else {\n\t\t\t\t\trecord = rec;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!record) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\t// Check non-default UVS first (specific glyph mappings)\n\t\t\tif (record.nonDefaultUVS) {\n\t\t\t\tlet lo = 0;\n\t\t\t\tlet hi = record.nonDefaultUVS.length - 1;\n\n\t\t\t\twhile (lo <= hi) {\n\t\t\t\t\tconst mid = (lo + hi) >>> 1;\n\t\t\t\t\tconst mapping = record.nonDefaultUVS[mid];\n\t\t\t\t\tif (!mapping) break;\n\n\t\t\t\t\tif (codepoint > mapping.unicodeValue) {\n\t\t\t\t\t\tlo = mid + 1;\n\t\t\t\t\t} else if (codepoint < mapping.unicodeValue) {\n\t\t\t\t\t\thi = mid - 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn mapping.glyphId;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check default UVS (use default glyph for base codepoint)\n\t\t\tif (record.defaultUVS) {\n\t\t\t\tfor (const range of record.defaultUVS) {\n\t\t\t\t\tconst end = range.startUnicodeValue + range.additionalCount;\n\t\t\t\t\tif (codepoint >= range.startUnicodeValue && codepoint <= end) {\n\t\t\t\t\t\treturn \"default\"; // Signal to use the default glyph\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t},\n\t};\n}\n\n/** Get glyph ID for a codepoint using the best subtable */\nexport function getGlyphId(cmap: CmapTable, codepoint: number): GlyphId {\n\treturn cmap.bestSubtable?.lookup(codepoint) ?? 0;\n}\n\n/** Get glyph ID for a variation sequence (base + variation selector) */\nexport function getVariationGlyphId(\n\tcmap: CmapTable,\n\tcodepoint: number,\n\tvariationSelector: number,\n): GlyphId | undefined {\n\t// Find Format 14 subtable\n\tconst format14 = Array.from(cmap.subtables.values()).find(\n\t\t(s): s is CmapFormat14 => s.format === 14,\n\t);\n\n\tif (!format14) {\n\t\treturn undefined;\n\t}\n\n\tconst result = format14.lookupVariation(codepoint, variationSelector);\n\n\tif (result === \"default\") {\n\t\t// Use the default glyph for this codepoint\n\t\treturn getGlyphId(cmap, codepoint);\n\t}\n\n\treturn result;\n}\n\n/** Check if a codepoint is a variation selector */\nexport function isVariationSelector(codepoint: number): boolean {\n\t// Variation Selectors block (VS1-VS16)\n\tif (codepoint >= 0xfe00 && codepoint <= 0xfe0f) {\n\t\treturn true;\n\t}\n\t// Variation Selectors Supplement (VS17-VS256)\n\tif (codepoint >= 0xe0100 && codepoint <= 0xe01ef) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "import type { GlyphId } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * COLR (Color) table parser\n * Defines color glyph layers\n */\n\nexport interface ColrTable {\n\tversion: number;\n\t// v0 data\n\tbaseGlyphRecords: BaseGlyphRecord[];\n\tlayerRecords: LayerRecord[];\n\t// v1 data\n\tbaseGlyphPaintRecords?: BaseGlyphPaintRecord[];\n\tlayerList?: Paint[];\n\tclipList?: ClipRecord[];\n\tvarIdxMap?: number[];\n\titemVariationStore?: ItemVariationStore;\n}\n\n// v0 structures\nexport interface BaseGlyphRecord {\n\tglyphId: GlyphId;\n\tfirstLayerIndex: number;\n\tnumLayers: number;\n}\n\nexport interface LayerRecord {\n\tglyphId: GlyphId;\n\tpaletteIndex: number;\n}\n\n// v1 structures\nexport interface BaseGlyphPaintRecord {\n\tglyphId: GlyphId;\n\tpaint: Paint;\n}\n\n// Paint types for COLR v1\nexport enum PaintFormat {\n\tColrLayers = 1,\n\tSolid = 2,\n\tVarSolid = 3,\n\tLinearGradient = 4,\n\tVarLinearGradient = 5,\n\tRadialGradient = 6,\n\tVarRadialGradient = 7,\n\tSweepGradient = 8,\n\tVarSweepGradient = 9,\n\tGlyph = 10,\n\tColrGlyph = 11,\n\tTransform = 12,\n\tVarTransform = 13,\n\tTranslate = 14,\n\tVarTranslate = 15,\n\tScale = 16,\n\tVarScale = 17,\n\tScaleAroundCenter = 18,\n\tVarScaleAroundCenter = 19,\n\tScaleUniform = 20,\n\tVarScaleUniform = 21,\n\tScaleUniformAroundCenter = 22,\n\tVarScaleUniformAroundCenter = 23,\n\tRotate = 24,\n\tVarRotate = 25,\n\tRotateAroundCenter = 26,\n\tVarRotateAroundCenter = 27,\n\tSkew = 28,\n\tVarSkew = 29,\n\tSkewAroundCenter = 30,\n\tVarSkewAroundCenter = 31,\n\tComposite = 32,\n}\n\nexport type Paint =\n\t| PaintColrLayers\n\t| PaintSolid\n\t| PaintLinearGradient\n\t| PaintRadialGradient\n\t| PaintSweepGradient\n\t| PaintGlyph\n\t| PaintColrGlyph\n\t| PaintTransform\n\t| PaintTranslate\n\t| PaintScale\n\t| PaintRotate\n\t| PaintSkew\n\t| PaintComposite;\n\nexport interface PaintColrLayers {\n\tformat: PaintFormat.ColrLayers;\n\tnumLayers: number;\n\tfirstLayerIndex: number;\n}\n\nexport interface PaintSolid {\n\tformat: PaintFormat.Solid | PaintFormat.VarSolid;\n\tpaletteIndex: number;\n\talpha: number;\n\tvarIndexBase?: number;\n}\n\nexport interface PaintLinearGradient {\n\tformat: PaintFormat.LinearGradient | PaintFormat.VarLinearGradient;\n\tcolorLine: ColorLine;\n\tx0: number;\n\ty0: number;\n\tx1: number;\n\ty1: number;\n\tx2: number;\n\ty2: number;\n}\n\nexport interface PaintRadialGradient {\n\tformat: PaintFormat.RadialGradient | PaintFormat.VarRadialGradient;\n\tcolorLine: ColorLine;\n\tx0: number;\n\ty0: number;\n\tradius0: number;\n\tx1: number;\n\ty1: number;\n\tradius1: number;\n}\n\nexport interface PaintSweepGradient {\n\tformat: PaintFormat.SweepGradient | PaintFormat.VarSweepGradient;\n\tcolorLine: ColorLine;\n\tcenterX: number;\n\tcenterY: number;\n\tstartAngle: number;\n\tendAngle: number;\n}\n\nexport interface PaintGlyph {\n\tformat: PaintFormat.Glyph;\n\tpaint: Paint;\n\tglyphId: GlyphId;\n}\n\nexport interface PaintColrGlyph {\n\tformat: PaintFormat.ColrGlyph;\n\tglyphId: GlyphId;\n}\n\nexport interface PaintTransform {\n\tformat: PaintFormat.Transform | PaintFormat.VarTransform;\n\tpaint: Paint;\n\ttransform: Affine2x3;\n}\n\nexport interface PaintTranslate {\n\tformat: PaintFormat.Translate | PaintFormat.VarTranslate;\n\tpaint: Paint;\n\tdx: number;\n\tdy: number;\n}\n\nexport interface PaintScale {\n\tformat:\n\t\t| PaintFormat.Scale\n\t\t| PaintFormat.VarScale\n\t\t| PaintFormat.ScaleAroundCenter\n\t\t| PaintFormat.VarScaleAroundCenter\n\t\t| PaintFormat.ScaleUniform\n\t\t| PaintFormat.VarScaleUniform\n\t\t| PaintFormat.ScaleUniformAroundCenter\n\t\t| PaintFormat.VarScaleUniformAroundCenter;\n\tpaint: Paint;\n\tscaleX: number;\n\tscaleY: number;\n\tcenterX?: number;\n\tcenterY?: number;\n}\n\nexport interface PaintRotate {\n\tformat:\n\t\t| PaintFormat.Rotate\n\t\t| PaintFormat.VarRotate\n\t\t| PaintFormat.RotateAroundCenter\n\t\t| PaintFormat.VarRotateAroundCenter;\n\tpaint: Paint;\n\tangle: number;\n\tcenterX?: number;\n\tcenterY?: number;\n}\n\nexport interface PaintSkew {\n\tformat:\n\t\t| PaintFormat.Skew\n\t\t| PaintFormat.VarSkew\n\t\t| PaintFormat.SkewAroundCenter\n\t\t| PaintFormat.VarSkewAroundCenter;\n\tpaint: Paint;\n\txSkewAngle: number;\n\tySkewAngle: number;\n\tcenterX?: number;\n\tcenterY?: number;\n}\n\nexport interface PaintComposite {\n\tformat: PaintFormat.Composite;\n\tsourcePaint: Paint;\n\tcompositeMode: CompositeMode;\n\tbackdropPaint: Paint;\n}\n\nexport interface ColorLine {\n\textend: Extend;\n\tcolorStops: ColorStop[];\n}\n\nexport interface ColorStop {\n\tstopOffset: number;\n\tpaletteIndex: number;\n\talpha: number;\n}\n\nexport enum Extend {\n\tPad = 0,\n\tRepeat = 1,\n\tReflect = 2,\n}\n\nexport enum CompositeMode {\n\tClear = 0,\n\tSrc = 1,\n\tDest = 2,\n\tSrcOver = 3,\n\tDestOver = 4,\n\tSrcIn = 5,\n\tDestIn = 6,\n\tSrcOut = 7,\n\tDestOut = 8,\n\tSrcAtop = 9,\n\tDestAtop = 10,\n\tXor = 11,\n\tPlus = 12,\n\tScreen = 13,\n\tOverlay = 14,\n\tDarken = 15,\n\tLighten = 16,\n\tColorDodge = 17,\n\tColorBurn = 18,\n\tHardLight = 19,\n\tSoftLight = 20,\n\tDifference = 21,\n\tExclusion = 22,\n\tMultiply = 23,\n\tHue = 24,\n\tSaturation = 25,\n\tColor = 26,\n\tLuminosity = 27,\n}\n\nexport interface Affine2x3 {\n\txx: number;\n\tyx: number;\n\txy: number;\n\tyy: number;\n\tdx: number;\n\tdy: number;\n}\n\nexport interface ClipRecord {\n\tstartGlyphId: GlyphId;\n\tendGlyphId: GlyphId;\n\tclipBox: ClipBox;\n}\n\nexport interface ClipBox {\n\tformat: number;\n\txMin: number;\n\tyMin: number;\n\txMax: number;\n\tyMax: number;\n\tvarIndexBase?: number;\n}\n\nexport interface ItemVariationStore {\n\tformat: number;\n\tvariationRegionListOffset: number;\n\titemVariationDataCount: number;\n\titemVariationDataOffsets: number[];\n\tvariationRegions: VariationRegion[];\n\titemVariationData: ItemVariationData[];\n}\n\nexport interface VariationRegion {\n\tregionAxes: RegionAxisCoordinates[];\n}\n\nexport interface RegionAxisCoordinates {\n\tstartCoord: number;\n\tpeakCoord: number;\n\tendCoord: number;\n}\n\nexport interface ItemVariationData {\n\titemCount: number;\n\twordDeltaCount: number;\n\tregionIndexCount: number;\n\tregionIndexes: number[];\n\tdeltaSets: number[][];\n}\n\nexport interface VarColorLine extends ColorLine {\n\tvarIndexBase?: number;\n}\n\nexport interface VarColorStop extends ColorStop {\n\tvarIndexBase?: number;\n}\n\n/**\n * Parse COLR table\n */\nexport function parseColr(reader: Reader): ColrTable {\n\tconst startOffset = reader.offset;\n\n\tconst version = reader.uint16();\n\tconst numBaseGlyphRecords = reader.uint16();\n\tconst baseGlyphRecordsOffset = reader.uint32();\n\tconst layerRecordsOffset = reader.uint32();\n\tconst numLayerRecords = reader.uint16();\n\n\t// Parse v0 base glyph records\n\tconst baseGlyphRecords: BaseGlyphRecord[] = [];\n\tif (baseGlyphRecordsOffset !== 0 && numBaseGlyphRecords > 0) {\n\t\treader.seek(startOffset + baseGlyphRecordsOffset);\n\t\tfor (let i = 0; i < numBaseGlyphRecords; i++) {\n\t\t\tbaseGlyphRecords.push({\n\t\t\t\tglyphId: reader.uint16(),\n\t\t\t\tfirstLayerIndex: reader.uint16(),\n\t\t\t\tnumLayers: reader.uint16(),\n\t\t\t});\n\t\t}\n\t}\n\n\t// Parse v0 layer records\n\tconst layerRecords: LayerRecord[] = [];\n\tif (layerRecordsOffset !== 0 && numLayerRecords > 0) {\n\t\treader.seek(startOffset + layerRecordsOffset);\n\t\tfor (let i = 0; i < numLayerRecords; i++) {\n\t\t\tlayerRecords.push({\n\t\t\t\tglyphId: reader.uint16(),\n\t\t\t\tpaletteIndex: reader.uint16(),\n\t\t\t});\n\t\t}\n\t}\n\n\tconst result: ColrTable = {\n\t\tversion,\n\t\tbaseGlyphRecords,\n\t\tlayerRecords,\n\t};\n\n\t// Parse v1 extensions\n\tif (version >= 1) {\n\t\treader.seek(startOffset + 14); // After v0 header\n\n\t\tconst baseGlyphListOffset = reader.uint32();\n\t\tconst layerListOffset = reader.uint32();\n\t\tconst clipListOffset = reader.uint32();\n\t\tconst varIdxMapOffset = reader.uint32();\n\t\tconst itemVariationStoreOffset = reader.uint32();\n\n\t\t// Parse base glyph paint records\n\t\tif (baseGlyphListOffset !== 0) {\n\t\t\treader.seek(startOffset + baseGlyphListOffset);\n\t\t\tconst numRecords = reader.uint32();\n\t\t\tresult.baseGlyphPaintRecords = [];\n\n\t\t\tfor (let i = 0; i < numRecords; i++) {\n\t\t\t\tconst glyphId = reader.uint16();\n\t\t\t\tconst paintOffset = reader.uint32();\n\n\t\t\t\t// Parse paint at offset\n\t\t\t\tconst savedPos = reader.offset;\n\t\t\t\treader.seek(\n\t\t\t\t\tstartOffset + baseGlyphListOffset + 4 + i * 6 + 2 + paintOffset - 4,\n\t\t\t\t);\n\t\t\t\tconst paint = parsePaint(reader, startOffset);\n\t\t\t\treader.seek(savedPos);\n\n\t\t\t\tresult.baseGlyphPaintRecords.push({ glyphId, paint });\n\t\t\t}\n\t\t}\n\n\t\t// Parse layer list\n\t\tif (layerListOffset !== 0) {\n\t\t\treader.seek(startOffset + layerListOffset);\n\t\t\tconst numLayers = reader.uint32();\n\t\t\tconst paintOffsets: number[] = [];\n\n\t\t\tfor (let i = 0; i < numLayers; i++) {\n\t\t\t\tpaintOffsets.push(reader.uint32());\n\t\t\t}\n\n\t\t\tresult.layerList = [];\n\t\t\tfor (const offset of paintOffsets) {\n\t\t\t\treader.seek(startOffset + layerListOffset + offset);\n\t\t\t\tresult.layerList.push(parsePaint(reader, startOffset));\n\t\t\t}\n\t\t}\n\n\t\t// Parse clip list\n\t\tif (clipListOffset !== 0) {\n\t\t\treader.seek(startOffset + clipListOffset);\n\t\t\tresult.clipList = parseClipList(reader, startOffset);\n\t\t}\n\n\t\t// Parse DeltaSetIndexMap (for variable fonts)\n\t\tif (varIdxMapOffset !== 0) {\n\t\t\treader.seek(startOffset + varIdxMapOffset);\n\t\t\tresult.varIdxMap = parseDeltaSetIndexMap(reader);\n\t\t}\n\n\t\t// Parse ItemVariationStore (for variable fonts)\n\t\tif (itemVariationStoreOffset !== 0) {\n\t\t\treader.seek(startOffset + itemVariationStoreOffset);\n\t\t\tresult.itemVariationStore = parseItemVariationStore(reader);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Parse a Paint structure\n */\nfunction parsePaint(reader: Reader, tableOffset: number): Paint {\n\tconst format = reader.uint8();\n\n\tswitch (format) {\n\t\tcase PaintFormat.ColrLayers:\n\t\t\treturn {\n\t\t\t\tformat,\n\t\t\t\tnumLayers: reader.uint8(),\n\t\t\t\tfirstLayerIndex: reader.uint32(),\n\t\t\t};\n\n\t\tcase PaintFormat.Solid:\n\t\t\treturn {\n\t\t\t\tformat,\n\t\t\t\tpaletteIndex: reader.uint16(),\n\t\t\t\talpha: reader.f2dot14(),\n\t\t\t};\n\n\t\tcase PaintFormat.VarSolid:\n\t\t\treturn {\n\t\t\t\tformat,\n\t\t\t\tpaletteIndex: reader.uint16(),\n\t\t\t\talpha: reader.f2dot14(),\n\t\t\t\tvarIndexBase: reader.uint32(),\n\t\t\t};\n\n\t\tcase PaintFormat.LinearGradient:\n\t\tcase PaintFormat.VarLinearGradient: {\n\t\t\tconst colorLineOffset = reader.uint24();\n\t\t\tconst x0 = reader.fword();\n\t\t\tconst y0 = reader.fword();\n\t\t\tconst x1 = reader.fword();\n\t\t\tconst y1 = reader.fword();\n\t\t\tconst x2 = reader.fword();\n\t\t\tconst y2 = reader.fword();\n\n\t\t\tconst savedPos = reader.offset;\n\t\t\treader.seek(reader.offset - 18 + colorLineOffset);\n\t\t\tconst colorLine = parseColorLine(reader);\n\t\t\treader.seek(savedPos);\n\n\t\t\treturn { format, colorLine, x0, y0, x1, y1, x2, y2 };\n\t\t}\n\n\t\tcase PaintFormat.RadialGradient:\n\t\tcase PaintFormat.VarRadialGradient: {\n\t\t\tconst colorLineOffset = reader.uint24();\n\t\t\tconst x0 = reader.fword();\n\t\t\tconst y0 = reader.fword();\n\t\t\tconst radius0 = reader.ufword();\n\t\t\tconst x1 = reader.fword();\n\t\t\tconst y1 = reader.fword();\n\t\t\tconst radius1 = reader.ufword();\n\n\t\t\tconst savedPos = reader.offset;\n\t\t\treader.seek(reader.offset - 18 + colorLineOffset);\n\t\t\tconst colorLine = parseColorLine(reader);\n\t\t\treader.seek(savedPos);\n\n\t\t\treturn { format, colorLine, x0, y0, radius0, x1, y1, radius1 };\n\t\t}\n\n\t\tcase PaintFormat.SweepGradient:\n\t\tcase PaintFormat.VarSweepGradient: {\n\t\t\tconst colorLineOffset = reader.uint24();\n\t\t\tconst centerX = reader.fword();\n\t\t\tconst centerY = reader.fword();\n\t\t\tconst startAngle = reader.f2dot14();\n\t\t\tconst endAngle = reader.f2dot14();\n\n\t\t\tconst savedPos = reader.offset;\n\t\t\treader.seek(reader.offset - 12 + colorLineOffset);\n\t\t\tconst colorLine = parseColorLine(reader);\n\t\t\treader.seek(savedPos);\n\n\t\t\treturn { format, colorLine, centerX, centerY, startAngle, endAngle };\n\t\t}\n\n\t\tcase PaintFormat.Glyph: {\n\t\t\tconst paintOffset = reader.uint24();\n\t\t\tconst glyphId = reader.uint16();\n\n\t\t\tconst savedPos = reader.offset;\n\t\t\treader.seek(reader.offset - 5 + paintOffset);\n\t\t\tconst paint = parsePaint(reader, tableOffset);\n\t\t\treader.seek(savedPos);\n\n\t\t\treturn { format, paint, glyphId };\n\t\t}\n\n\t\tcase PaintFormat.ColrGlyph:\n\t\t\treturn {\n\t\t\t\tformat,\n\t\t\t\tglyphId: reader.uint16(),\n\t\t\t};\n\n\t\tcase PaintFormat.Transform:\n\t\tcase PaintFormat.VarTransform: {\n\t\t\tconst paintOffset = reader.uint24();\n\t\t\tconst transformOffset = reader.uint24();\n\n\t\t\tconst paintPos = reader.offset - 6 + paintOffset;\n\t\t\tconst transformPos = reader.offset - 3 + transformOffset;\n\n\t\t\treader.seek(transformPos);\n\t\t\tconst transform: Affine2x3 = {\n\t\t\t\txx: reader.fixed(),\n\t\t\t\tyx: reader.fixed(),\n\t\t\t\txy: reader.fixed(),\n\t\t\t\tyy: reader.fixed(),\n\t\t\t\tdx: reader.fixed(),\n\t\t\t\tdy: reader.fixed(),\n\t\t\t};\n\n\t\t\treader.seek(paintPos);\n\t\t\tconst paint = parsePaint(reader, tableOffset);\n\n\t\t\treturn { format, paint, transform };\n\t\t}\n\n\t\tcase PaintFormat.Translate:\n\t\tcase PaintFormat.VarTranslate: {\n\t\t\tconst paintOffset = reader.uint24();\n\t\t\tconst dx = reader.fword();\n\t\t\tconst dy = reader.fword();\n\n\t\t\tconst savedPos = reader.offset;\n\t\t\treader.seek(reader.offset - 7 + paintOffset);\n\t\t\tconst paint = parsePaint(reader, tableOffset);\n\t\t\treader.seek(savedPos);\n\n\t\t\treturn { format, paint, dx, dy };\n\t\t}\n\n\t\tcase PaintFormat.Scale:\n\t\tcase PaintFormat.VarScale: {\n\t\t\tconst paintOffset = reader.uint24();\n\t\t\tconst scaleX = reader.f2dot14();\n\t\t\tconst scaleY = reader.f2dot14();\n\n\t\t\tconst savedPos = reader.offset;\n\t\t\treader.seek(reader.offset - 7 + paintOffset);\n\t\t\tconst paint = parsePaint(reader, tableOffset);\n\t\t\treader.seek(savedPos);\n\n\t\t\treturn { format, paint, scaleX, scaleY };\n\t\t}\n\n\t\tcase PaintFormat.ScaleAroundCenter:\n\t\tcase PaintFormat.VarScaleAroundCenter: {\n\t\t\tconst paintOffset = reader.uint24();\n\t\t\tconst scaleX = reader.f2dot14();\n\t\t\tconst scaleY = reader.f2dot14();\n\t\t\tconst centerX = reader.fword();\n\t\t\tconst centerY = reader.fword();\n\n\t\t\tconst savedPos = reader.offset;\n\t\t\treader.seek(reader.offset - 11 + paintOffset);\n\t\t\tconst paint = parsePaint(reader, tableOffset);\n\t\t\treader.seek(savedPos);\n\n\t\t\treturn { format, paint, scaleX, scaleY, centerX, centerY };\n\t\t}\n\n\t\tcase PaintFormat.ScaleUniform:\n\t\tcase PaintFormat.VarScaleUniform: {\n\t\t\tconst paintOffset = reader.uint24();\n\t\t\tconst scale = reader.f2dot14();\n\n\t\t\tconst savedPos = reader.offset;\n\t\t\treader.seek(reader.offset - 5 + paintOffset);\n\t\t\tconst paint = parsePaint(reader, tableOffset);\n\t\t\treader.seek(savedPos);\n\n\t\t\treturn { format, paint, scaleX: scale, scaleY: scale };\n\t\t}\n\n\t\tcase PaintFormat.ScaleUniformAroundCenter:\n\t\tcase PaintFormat.VarScaleUniformAroundCenter: {\n\t\t\tconst paintOffset = reader.uint24();\n\t\t\tconst scale = reader.f2dot14();\n\t\t\tconst centerX = reader.fword();\n\t\t\tconst centerY = reader.fword();\n\n\t\t\tconst savedPos = reader.offset;\n\t\t\treader.seek(reader.offset - 9 + paintOffset);\n\t\t\tconst paint = parsePaint(reader, tableOffset);\n\t\t\treader.seek(savedPos);\n\n\t\t\treturn { format, paint, scaleX: scale, scaleY: scale, centerX, centerY };\n\t\t}\n\n\t\tcase PaintFormat.Rotate:\n\t\tcase PaintFormat.VarRotate: {\n\t\t\tconst paintOffset = reader.uint24();\n\t\t\tconst angle = reader.f2dot14();\n\n\t\t\tconst savedPos = reader.offset;\n\t\t\treader.seek(reader.offset - 5 + paintOffset);\n\t\t\tconst paint = parsePaint(reader, tableOffset);\n\t\t\treader.seek(savedPos);\n\n\t\t\treturn { format, paint, angle };\n\t\t}\n\n\t\tcase PaintFormat.RotateAroundCenter:\n\t\tcase PaintFormat.VarRotateAroundCenter: {\n\t\t\tconst paintOffset = reader.uint24();\n\t\t\tconst angle = reader.f2dot14();\n\t\t\tconst centerX = reader.fword();\n\t\t\tconst centerY = reader.fword();\n\n\t\t\tconst savedPos = reader.offset;\n\t\t\treader.seek(reader.offset - 9 + paintOffset);\n\t\t\tconst paint = parsePaint(reader, tableOffset);\n\t\t\treader.seek(savedPos);\n\n\t\t\treturn { format, paint, angle, centerX, centerY };\n\t\t}\n\n\t\tcase PaintFormat.Skew:\n\t\tcase PaintFormat.VarSkew: {\n\t\t\tconst paintOffset = reader.uint24();\n\t\t\tconst xSkewAngle = reader.f2dot14();\n\t\t\tconst ySkewAngle = reader.f2dot14();\n\n\t\t\tconst savedPos = reader.offset;\n\t\t\treader.seek(reader.offset - 7 + paintOffset);\n\t\t\tconst paint = parsePaint(reader, tableOffset);\n\t\t\treader.seek(savedPos);\n\n\t\t\treturn { format, paint, xSkewAngle, ySkewAngle };\n\t\t}\n\n\t\tcase PaintFormat.SkewAroundCenter:\n\t\tcase PaintFormat.VarSkewAroundCenter: {\n\t\t\tconst paintOffset = reader.uint24();\n\t\t\tconst xSkewAngle = reader.f2dot14();\n\t\t\tconst ySkewAngle = reader.f2dot14();\n\t\t\tconst centerX = reader.fword();\n\t\t\tconst centerY = reader.fword();\n\n\t\t\tconst savedPos = reader.offset;\n\t\t\treader.seek(reader.offset - 11 + paintOffset);\n\t\t\tconst paint = parsePaint(reader, tableOffset);\n\t\t\treader.seek(savedPos);\n\n\t\t\treturn { format, paint, xSkewAngle, ySkewAngle, centerX, centerY };\n\t\t}\n\n\t\tcase PaintFormat.Composite: {\n\t\t\tconst sourcePaintOffset = reader.uint24();\n\t\t\tconst compositeMode = reader.uint8() as CompositeMode;\n\t\t\tconst backdropPaintOffset = reader.uint24();\n\n\t\t\tconst sourcePos = reader.offset - 7 + sourcePaintOffset;\n\t\t\tconst backdropPos = reader.offset - 3 + backdropPaintOffset;\n\n\t\t\treader.seek(sourcePos);\n\t\t\tconst sourcePaint = parsePaint(reader, tableOffset);\n\n\t\t\treader.seek(backdropPos);\n\t\t\tconst backdropPaint = parsePaint(reader, tableOffset);\n\n\t\t\treturn { format, sourcePaint, compositeMode, backdropPaint };\n\t\t}\n\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown paint format: ${format}`);\n\t}\n}\n\n/**\n * Parse ColorLine structure\n */\nfunction parseColorLine(reader: Reader): ColorLine {\n\tconst extend = reader.uint8() as Extend;\n\tconst numStops = reader.uint16();\n\tconst colorStops: ColorStop[] = [];\n\n\tfor (let i = 0; i < numStops; i++) {\n\t\tcolorStops.push({\n\t\t\tstopOffset: reader.f2dot14(),\n\t\t\tpaletteIndex: reader.uint16(),\n\t\t\talpha: reader.f2dot14(),\n\t\t});\n\t}\n\n\treturn { extend, colorStops };\n}\n\n/**\n * Parse ClipList structure\n */\nfunction parseClipList(reader: Reader, _tableOffset: number): ClipRecord[] {\n\tconst _format = reader.uint8();\n\tconst numClips = reader.uint32();\n\tconst records: ClipRecord[] = [];\n\n\tfor (let i = 0; i < numClips; i++) {\n\t\tconst startGlyphId = reader.uint16();\n\t\tconst endGlyphId = reader.uint16();\n\t\tconst clipBoxOffset = reader.uint24();\n\n\t\tconst savedPos = reader.offset;\n\t\treader.seek(reader.offset - 7 + clipBoxOffset);\n\n\t\tconst boxFormat = reader.uint8();\n\t\tconst clipBox: ClipBox = {\n\t\t\tformat: boxFormat,\n\t\t\txMin: reader.fword(),\n\t\t\tyMin: reader.fword(),\n\t\t\txMax: reader.fword(),\n\t\t\tyMax: reader.fword(),\n\t\t};\n\n\t\tif (boxFormat === 2) {\n\t\t\tclipBox.varIndexBase = reader.uint32();\n\t\t}\n\n\t\treader.seek(savedPos);\n\n\t\trecords.push({ startGlyphId, endGlyphId, clipBox });\n\t}\n\n\treturn records;\n}\n\n/**\n * Get color layers for a glyph (v0)\n */\nexport function getColorLayers(\n\tcolr: ColrTable,\n\tglyphId: GlyphId,\n): LayerRecord[] | null {\n\t// Binary search for base glyph record\n\tconst records = colr.baseGlyphRecords;\n\tlet lo = 0;\n\tlet hi = records.length - 1;\n\n\twhile (lo <= hi) {\n\t\tconst mid = (lo + hi) >>> 1;\n\t\tconst record = records[mid];\n\t\tif (!record) break;\n\n\t\tif (record.glyphId === glyphId) {\n\t\t\tconst layers: LayerRecord[] = [];\n\t\t\tfor (let i = 0; i < record.numLayers; i++) {\n\t\t\t\tconst layer = colr.layerRecords[record.firstLayerIndex + i];\n\t\t\t\tif (layer) layers.push(layer);\n\t\t\t}\n\t\t\treturn layers;\n\t\t} else if (record.glyphId < glyphId) {\n\t\t\tlo = mid + 1;\n\t\t} else {\n\t\t\thi = mid - 1;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * Get paint for a glyph (v1)\n */\nexport function getColorPaint(colr: ColrTable, glyphId: GlyphId): Paint | null {\n\tif (!colr.baseGlyphPaintRecords) return null;\n\n\t// Binary search\n\tconst records = colr.baseGlyphPaintRecords;\n\tlet lo = 0;\n\tlet hi = records.length - 1;\n\n\twhile (lo <= hi) {\n\t\tconst mid = (lo + hi) >>> 1;\n\t\tconst record = records[mid];\n\t\tif (!record) break;\n\n\t\tif (record.glyphId === glyphId) {\n\t\t\treturn record.paint;\n\t\t} else if (record.glyphId < glyphId) {\n\t\t\tlo = mid + 1;\n\t\t} else {\n\t\t\thi = mid - 1;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * Check if glyph has color data\n */\nexport function hasColorGlyph(colr: ColrTable, glyphId: GlyphId): boolean {\n\treturn (\n\t\tgetColorLayers(colr, glyphId) !== null ||\n\t\tgetColorPaint(colr, glyphId) !== null\n\t);\n}\n\n/**\n * Parse DeltaSetIndexMap (used by variable fonts)\n */\nfunction parseDeltaSetIndexMap(reader: Reader): number[] {\n\tconst format = reader.uint8();\n\tconst entryFormat = reader.uint8();\n\tconst mapCount = format === 0 ? reader.uint16() : reader.uint32();\n\n\tconst innerBits = (entryFormat & 0x0f) + 1;\n\tconst outerBits = ((entryFormat >> 4) & 0x0f) + 1;\n\tconst entrySize = Math.ceil((innerBits + outerBits) / 8);\n\n\tconst result: number[] = [];\n\tfor (let i = 0; i < mapCount; i++) {\n\t\tlet entry = 0;\n\t\tfor (let b = 0; b < entrySize; b++) {\n\t\t\tentry = (entry << 8) | reader.uint8();\n\t\t}\n\t\t// Pack outer and inner indices into a single number\n\t\t// Format: (outer << 16) | inner\n\t\tconst innerMask = (1 << innerBits) - 1;\n\t\tconst inner = entry & innerMask;\n\t\tconst outer = entry >> innerBits;\n\t\tresult.push((outer << 16) | inner);\n\t}\n\n\treturn result;\n}\n\n/**\n * Parse ItemVariationStore (used by variable fonts)\n */\nfunction parseItemVariationStore(reader: Reader): ItemVariationStore {\n\tconst storeOffset = reader.offset;\n\tconst format = reader.uint16();\n\tconst variationRegionListOffset = reader.uint32();\n\tconst itemVariationDataCount = reader.uint16();\n\n\tconst itemVariationDataOffsets: number[] = [];\n\tfor (let i = 0; i < itemVariationDataCount; i++) {\n\t\titemVariationDataOffsets.push(reader.uint32());\n\t}\n\n\t// Parse variation region list\n\treader.seek(storeOffset + variationRegionListOffset);\n\tconst axisCount = reader.uint16();\n\tconst regionCount = reader.uint16();\n\n\tconst variationRegions: VariationRegion[] = [];\n\tfor (let i = 0; i < regionCount; i++) {\n\t\tconst regionAxes: RegionAxisCoordinates[] = [];\n\t\tfor (let j = 0; j < axisCount; j++) {\n\t\t\tregionAxes.push({\n\t\t\t\tstartCoord: reader.f2dot14(),\n\t\t\t\tpeakCoord: reader.f2dot14(),\n\t\t\t\tendCoord: reader.f2dot14(),\n\t\t\t});\n\t\t}\n\t\tvariationRegions.push({ regionAxes });\n\t}\n\n\t// Parse item variation data subtables\n\tconst itemVariationData: ItemVariationData[] = [];\n\tfor (const offset of itemVariationDataOffsets) {\n\t\treader.seek(storeOffset + offset);\n\t\tconst itemCount = reader.uint16();\n\t\tconst wordDeltaCount = reader.uint16();\n\t\tconst regionIndexCount = reader.uint16();\n\n\t\tconst regionIndexes: number[] = [];\n\t\tfor (let i = 0; i < regionIndexCount; i++) {\n\t\t\tregionIndexes.push(reader.uint16());\n\t\t}\n\n\t\t// Parse delta sets\n\t\tconst longWords = (wordDeltaCount & 0x8000) !== 0;\n\t\tconst wordCount = wordDeltaCount & 0x7fff;\n\n\t\tconst deltaSets: number[][] = [];\n\t\tfor (let i = 0; i < itemCount; i++) {\n\t\t\tconst deltas: number[] = [];\n\t\t\tfor (let j = 0; j < regionIndexCount; j++) {\n\t\t\t\tif (j < wordCount) {\n\t\t\t\t\tdeltas.push(longWords ? reader.int32() : reader.int16());\n\t\t\t\t} else {\n\t\t\t\t\tdeltas.push(longWords ? reader.int16() : reader.int8());\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeltaSets.push(deltas);\n\t\t}\n\n\t\titemVariationData.push({\n\t\t\titemCount,\n\t\t\twordDeltaCount,\n\t\t\tregionIndexCount,\n\t\t\tregionIndexes,\n\t\t\tdeltaSets,\n\t\t});\n\t}\n\n\treturn {\n\t\tformat,\n\t\tvariationRegionListOffset,\n\t\titemVariationDataCount,\n\t\titemVariationDataOffsets,\n\t\tvariationRegions,\n\t\titemVariationData,\n\t};\n}\n\n/**\n * Get clip box for a glyph\n */\nexport function getClipBox(\n\tcolr: ColrTable,\n\tglyphId: GlyphId,\n): ClipBox | null {\n\tif (!colr.clipList) return null;\n\n\tfor (const record of colr.clipList) {\n\t\tif (glyphId >= record.startGlyphId && glyphId <= record.endGlyphId) {\n\t\t\treturn record.clipBox;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * Calculate variation delta for a paint value\n */\nexport function getColorVariationDelta(\n\tcolr: ColrTable,\n\tvarIndex: number,\n\tcoords: number[],\n): number {\n\tif (!colr.itemVariationStore || !colr.varIdxMap) return 0;\n\n\t// Get outer/inner indices from varIdxMap\n\tconst mappedIndex = colr.varIdxMap[varIndex];\n\tif (mappedIndex === undefined) return 0;\n\n\tconst outer = mappedIndex >> 16;\n\tconst inner = mappedIndex & 0xffff;\n\n\tconst store = colr.itemVariationStore;\n\tconst data = store.itemVariationData[outer];\n\tif (!data) return 0;\n\n\tconst deltas = data.deltaSets[inner];\n\tif (!deltas) return 0;\n\n\t// Calculate scalar for each region and sum deltas\n\tlet result = 0;\n\tfor (let i = 0; i < data.regionIndexCount; i++) {\n\t\tconst regionIndex = data.regionIndexes[i]!;\n\t\tconst region = store.variationRegions[regionIndex];\n\t\tif (!region) continue;\n\n\t\t// Calculate scalar for this region\n\t\tlet scalar = 1.0;\n\t\tfor (let j = 0; j < region.regionAxes.length && j < coords.length; j++) {\n\t\t\tconst axis = region.regionAxes[j]!;\n\t\t\tconst coord = coords[j]!;\n\t\t\tscalar *= calculateAxisScalar(coord, axis.startCoord, axis.peakCoord, axis.endCoord);\n\t\t\tif (scalar === 0) break;\n\t\t}\n\n\t\tresult += deltas[i]! * scalar;\n\t}\n\n\treturn result;\n}\n\n/**\n * Calculate scalar contribution for a single axis\n */\nfunction calculateAxisScalar(\n\tcoord: number,\n\tstart: number,\n\tpeak: number,\n\tend: number,\n): number {\n\t// If peak is 0, no contribution\n\tif (peak === 0) return 1.0;\n\n\t// If coord exactly at peak, full contribution\n\tif (coord === peak) return 1.0;\n\n\t// If coord outside range, no contribution\n\tif (coord < start || coord > end) return 0.0;\n\n\t// Interpolate\n\tif (coord < peak) {\n\t\tif (start === peak) return 1.0;\n\t\treturn (coord - start) / (peak - start);\n\t} else {\n\t\tif (peak === end) return 1.0;\n\t\treturn (end - coord) / (end - peak);\n\t}\n}\n\n/**\n * Check if COLR table is version 1\n */\nexport function isColrV1(colr: ColrTable): boolean {\n\treturn colr.version >= 1 && colr.baseGlyphPaintRecords !== undefined;\n}\n\n/**\n * Get the paint layer at a specific index from the layer list\n */\nexport function getLayerPaint(colr: ColrTable, index: number): Paint | null {\n\treturn colr.layerList?.[index] ?? null;\n}\n", "import type { Reader } from \"../binary/reader.ts\";\n\n/**\n * CPAL (Color Palette) table parser\n * Provides color palettes for color fonts\n */\n\nexport interface CpalTable {\n\tversion: number;\n\tnumPalettes: number;\n\tnumPaletteEntries: number;\n\tpalettes: ColorPalette[];\n\tpaletteTypes?: number[];\n\tpaletteLabels?: number[];\n\tpaletteEntryLabels?: number[];\n}\n\nexport interface ColorPalette {\n\tcolors: Color[];\n}\n\nexport interface Color {\n\tblue: number; // 0-255\n\tgreen: number; // 0-255\n\tred: number; // 0-255\n\talpha: number; // 0-255\n}\n\n/**\n * Palette type flags\n */\nexport enum PaletteType {\n\tUsableWithLightBackground = 0x0001,\n\tUsableWithDarkBackground = 0x0002,\n}\n\n/**\n * Parse CPAL table\n */\nexport function parseCpal(reader: Reader): CpalTable {\n\tconst startOffset = reader.offset;\n\n\tconst version = reader.uint16();\n\tconst numPaletteEntries = reader.uint16();\n\tconst numPalettes = reader.uint16();\n\tconst numColorRecords = reader.uint16();\n\tconst colorRecordsArrayOffset = reader.uint32();\n\n\t// Read color record indices for each palette\n\tconst colorRecordIndices: number[] = [];\n\tfor (let i = 0; i < numPalettes; i++) {\n\t\tcolorRecordIndices.push(reader.uint16());\n\t}\n\n\t// Read all color records\n\treader.seek(startOffset + colorRecordsArrayOffset);\n\tconst colorRecords: Color[] = [];\n\tfor (let i = 0; i < numColorRecords; i++) {\n\t\tcolorRecords.push({\n\t\t\tblue: reader.uint8(),\n\t\t\tgreen: reader.uint8(),\n\t\t\tred: reader.uint8(),\n\t\t\talpha: reader.uint8(),\n\t\t});\n\t}\n\n\t// Build palettes\n\tconst palettes: ColorPalette[] = [];\n\tfor (let i = 0; i < numPalettes; i++) {\n\t\tconst startIndex = colorRecordIndices[i];\n\t\tif (startIndex === undefined) continue;\n\t\tconst colors: Color[] = [];\n\t\tfor (let j = 0; j < numPaletteEntries; j++) {\n\t\t\tconst color = colorRecords[startIndex + j];\n\t\t\tif (color) colors.push(color);\n\t\t}\n\t\tpalettes.push({ colors });\n\t}\n\n\t// Version 1 extensions\n\tlet paletteTypes: number[] | undefined;\n\tlet paletteLabels: number[] | undefined;\n\tlet paletteEntryLabels: number[] | undefined;\n\n\tif (version >= 1) {\n\t\t// After color record indices\n\t\treader.seek(startOffset + 12 + numPalettes * 2);\n\n\t\tconst paletteTypesArrayOffset = reader.uint32();\n\t\tconst paletteLabelsArrayOffset = reader.uint32();\n\t\tconst paletteEntryLabelsArrayOffset = reader.uint32();\n\n\t\tif (paletteTypesArrayOffset !== 0) {\n\t\t\treader.seek(startOffset + paletteTypesArrayOffset);\n\t\t\tpaletteTypes = [];\n\t\t\tfor (let i = 0; i < numPalettes; i++) {\n\t\t\t\tpaletteTypes.push(reader.uint32());\n\t\t\t}\n\t\t}\n\n\t\tif (paletteLabelsArrayOffset !== 0) {\n\t\t\treader.seek(startOffset + paletteLabelsArrayOffset);\n\t\t\tpaletteLabels = [];\n\t\t\tfor (let i = 0; i < numPalettes; i++) {\n\t\t\t\tpaletteLabels.push(reader.uint16());\n\t\t\t}\n\t\t}\n\n\t\tif (paletteEntryLabelsArrayOffset !== 0) {\n\t\t\treader.seek(startOffset + paletteEntryLabelsArrayOffset);\n\t\t\tpaletteEntryLabels = [];\n\t\t\tfor (let i = 0; i < numPaletteEntries; i++) {\n\t\t\t\tpaletteEntryLabels.push(reader.uint16());\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tversion,\n\t\tnumPalettes,\n\t\tnumPaletteEntries,\n\t\tpalettes,\n\t\tpaletteTypes,\n\t\tpaletteLabels,\n\t\tpaletteEntryLabels,\n\t};\n}\n\n/**\n * Get color from palette\n */\nexport function getColor(\n\tcpal: CpalTable,\n\tpaletteIndex: number,\n\tcolorIndex: number,\n): Color | null {\n\tconst palette = cpal.palettes[paletteIndex];\n\tif (!palette) return null;\n\treturn palette.colors[colorIndex] ?? null;\n}\n\n/**\n * Convert color to CSS rgba string\n */\nexport function colorToRgba(color: Color): string {\n\treturn `rgba(${color.red}, ${color.green}, ${color.blue}, ${(color.alpha / 255).toFixed(3)})`;\n}\n\n/**\n * Convert color to CSS hex string\n */\nexport function colorToHex(color: Color): string {\n\tconst r = color.red.toString(16).padStart(2, \"0\");\n\tconst g = color.green.toString(16).padStart(2, \"0\");\n\tconst b = color.blue.toString(16).padStart(2, \"0\");\n\tif (color.alpha === 255) {\n\t\treturn `#${r}${g}${b}`;\n\t}\n\tconst a = color.alpha.toString(16).padStart(2, \"0\");\n\treturn `#${r}${g}${b}${a}`;\n}\n", "import type { Reader } from \"../../font/binary/reader.ts\";\nimport type { GlyphId, uint16 } from \"../../types.ts\";\n\n/** Class Definition table - maps glyph IDs to class values */\nexport interface ClassDef {\n\t/** Get class for a glyph ID (returns 0 if not defined) */\n\tget(glyphId: GlyphId): number;\n\n\t/** Get all glyphs in a specific class */\n\tglyphsInClass(classValue: number): GlyphId[];\n}\n\n/** Format 1: Array of class values for a range of glyph IDs */\nclass ClassDefFormat1 implements ClassDef {\n\tprivate readonly startGlyphId: GlyphId;\n\tprivate readonly classValueArray: Uint16Array;\n\n\tconstructor(startGlyphId: GlyphId, classValueArray: Uint16Array) {\n\t\tthis.startGlyphId = startGlyphId;\n\t\tthis.classValueArray = classValueArray;\n\t}\n\n\tget(glyphId: GlyphId): number {\n\t\tconst index = glyphId - this.startGlyphId;\n\t\tif (index >= 0 && index < this.classValueArray.length) {\n\t\t\tconst value = this.classValueArray[index];\n\t\t\treturn value ?? 0;\n\t\t}\n\t\treturn 0; // Default class\n\t}\n\n\tglyphsInClass(classValue: number): GlyphId[] {\n\t\tconst result: GlyphId[] = [];\n\t\tfor (let i = 0; i < this.classValueArray.length; i++) {\n\t\t\tif (this.classValueArray[i] === classValue) {\n\t\t\t\tresult.push(this.startGlyphId + i);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\n/** Class range record for Format 2 */\ninterface ClassRangeRecord {\n\tstartGlyphId: GlyphId;\n\tendGlyphId: GlyphId;\n\tclassValue: uint16;\n}\n\n/** Format 2: Ranges of glyph IDs with class values */\nclass ClassDefFormat2 implements ClassDef {\n\tprivate readonly ranges: ClassRangeRecord[];\n\n\tconstructor(ranges: ClassRangeRecord[]) {\n\t\tthis.ranges = ranges;\n\t}\n\n\tget(glyphId: GlyphId): number {\n\t\t// Binary search through ranges\n\t\tlet low = 0;\n\t\tlet high = this.ranges.length - 1;\n\n\t\twhile (low <= high) {\n\t\t\tconst mid = (low + high) >>> 1;\n\t\t\tconst range = this.ranges[mid];\n\t\t\tif (!range) continue;\n\n\t\t\tif (glyphId > range.endGlyphId) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else if (glyphId < range.startGlyphId) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else {\n\t\t\t\treturn range.classValue;\n\t\t\t}\n\t\t}\n\n\t\treturn 0; // Default class\n\t}\n\n\tglyphsInClass(classValue: number): GlyphId[] {\n\t\tconst result: GlyphId[] = [];\n\t\tfor (const range of this.ranges) {\n\t\t\tif (range.classValue === classValue) {\n\t\t\t\tfor (let g = range.startGlyphId; g <= range.endGlyphId; g++) {\n\t\t\t\t\tresult.push(g);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\n/** Empty class definition (all glyphs are class 0) */\nclass ClassDefEmpty implements ClassDef {\n\tget(_glyphId: GlyphId): number {\n\t\treturn 0;\n\t}\n\n\tglyphsInClass(_classValue: number): GlyphId[] {\n\t\treturn [];\n\t}\n}\n\n/** Singleton empty ClassDef */\nexport const EMPTY_CLASS_DEF: ClassDef = new ClassDefEmpty();\n\n/** Parse a Class Definition table */\nexport function parseClassDef(reader: Reader): ClassDef {\n\tconst format = reader.uint16();\n\n\tif (format === 1) {\n\t\tconst startGlyphId = reader.uint16();\n\t\tconst glyphCount = reader.uint16();\n\t\tconst classValueArray = reader.uint16Array(glyphCount);\n\t\treturn new ClassDefFormat1(startGlyphId, classValueArray);\n\t}\n\n\tif (format === 2) {\n\t\tconst classRangeCount = reader.uint16();\n\t\tconst ranges: ClassRangeRecord[] = new Array(classRangeCount);\n\n\t\tfor (let i = 0; i < classRangeCount; i++) {\n\t\t\tranges[i] = {\n\t\t\t\tstartGlyphId: reader.uint16(),\n\t\t\t\tendGlyphId: reader.uint16(),\n\t\t\t\tclassValue: reader.uint16(),\n\t\t\t};\n\t\t}\n\n\t\treturn new ClassDefFormat2(ranges);\n\t}\n\n\tthrow new Error(`Unknown ClassDef format: ${format}`);\n}\n\n/** Parse ClassDef from offset, or return empty if offset is 0 */\nexport function parseClassDefAt(reader: Reader, offset: number): ClassDef {\n\tif (offset === 0) {\n\t\treturn EMPTY_CLASS_DEF;\n\t}\n\treturn parseClassDef(reader.sliceFrom(offset));\n}\n", "import {\n\ttype ClassDef,\n\tparseClassDefAt,\n} from \"../../layout/structures/class-def.ts\";\nimport type { GlyphId, uint16 } from \"../../types.ts\";\nimport { GlyphClass } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/** Attach point for a glyph */\nexport interface AttachPoint {\n\tpointIndices: uint16[];\n}\n\n/** Ligature caret for a ligature glyph */\nexport interface LigatureCaret {\n\tcaretValues: number[];\n}\n\n/** Mark glyph sets */\nexport interface MarkGlyphSets {\n\t/** Check if glyph is in mark set */\n\thas(setIndex: number, glyphId: GlyphId): boolean;\n}\n\n/** Glyph Definition table */\nexport interface GdefTable {\n\tversion: { major: number; minor: number };\n\n\t/** Glyph class definitions (Base=1, Ligature=2, Mark=3, Component=4) */\n\tglyphClassDef: ClassDef;\n\n\t/** Attachment point list (optional) */\n\tattachList: Map<GlyphId, AttachPoint> | null;\n\n\t/** Ligature caret list (optional) */\n\tligCaretList: Map<GlyphId, LigatureCaret> | null;\n\n\t/** Mark attachment class definitions */\n\tmarkAttachClassDef: ClassDef;\n\n\t/** Mark glyph sets (version 1.2+) */\n\tmarkGlyphSets: MarkGlyphSets | null;\n}\n\nexport function parseGdef(reader: Reader): GdefTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\n\tconst glyphClassDefOffset = reader.offset16();\n\tconst attachListOffset = reader.offset16();\n\tconst ligCaretListOffset = reader.offset16();\n\tconst markAttachClassDefOffset = reader.offset16();\n\n\tlet markGlyphSetsDefOffset = 0;\n\tif (majorVersion === 1 && minorVersion >= 2) {\n\t\tmarkGlyphSetsDefOffset = reader.offset16();\n\t}\n\n\t// Parse glyph class definitions\n\tconst glyphClassDef = parseClassDefAt(reader, glyphClassDefOffset);\n\n\t// Parse attachment list (optional)\n\tlet attachList: Map<GlyphId, AttachPoint> | null = null;\n\tif (attachListOffset !== 0) {\n\t\tattachList = parseAttachList(reader.sliceFrom(attachListOffset));\n\t}\n\n\t// Parse ligature caret list (optional)\n\tlet ligCaretList: Map<GlyphId, LigatureCaret> | null = null;\n\tif (ligCaretListOffset !== 0) {\n\t\tligCaretList = parseLigCaretList(reader.sliceFrom(ligCaretListOffset));\n\t}\n\n\t// Parse mark attachment class definitions\n\tconst markAttachClassDef = parseClassDefAt(reader, markAttachClassDefOffset);\n\n\t// Parse mark glyph sets (version 1.2+)\n\tlet markGlyphSets: MarkGlyphSets | null = null;\n\tif (markGlyphSetsDefOffset !== 0) {\n\t\tmarkGlyphSets = parseMarkGlyphSets(\n\t\t\treader.sliceFrom(markGlyphSetsDefOffset),\n\t\t);\n\t}\n\n\treturn {\n\t\tversion: { major: majorVersion, minor: minorVersion },\n\t\tglyphClassDef,\n\t\tattachList,\n\t\tligCaretList,\n\t\tmarkAttachClassDef,\n\t\tmarkGlyphSets,\n\t};\n}\n\nexport function parseAttachList(reader: Reader): Map<GlyphId, AttachPoint> {\n\tconst coverageOffset = reader.offset16();\n\tconst glyphCount = reader.uint16();\n\n\t// Read attach point offsets\n\tconst attachPointOffsets = reader.uint16Array(glyphCount);\n\n\t// Parse coverage to get glyph IDs\n\tconst coverageReader = reader.sliceFrom(coverageOffset);\n\tconst format = coverageReader.uint16();\n\n\tconst glyphIds: GlyphId[] = [];\n\tif (format === 1) {\n\t\tconst count = coverageReader.uint16();\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tglyphIds.push(coverageReader.uint16());\n\t\t}\n\t} else if (format === 2) {\n\t\tconst rangeCount = coverageReader.uint16();\n\t\tfor (let i = 0; i < rangeCount; i++) {\n\t\t\tconst start = coverageReader.uint16();\n\t\t\tconst end = coverageReader.uint16();\n\t\t\tcoverageReader.skip(2); // startCoverageIndex\n\t\t\tfor (let g = start; g <= end; g++) {\n\t\t\t\tglyphIds.push(g);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Parse attach points\n\tconst result = new Map<GlyphId, AttachPoint>();\n\tfor (const [i, offset] of attachPointOffsets.entries()) {\n\t\tconst glyphId = glyphIds[i];\n\t\tif (glyphId === undefined) continue;\n\n\t\tconst pointReader = reader.sliceFrom(offset);\n\t\tconst pointCount = pointReader.uint16();\n\t\tconst pointIndices = Array.from(pointReader.uint16Array(pointCount));\n\n\t\tresult.set(glyphId, { pointIndices });\n\t}\n\n\treturn result;\n}\n\nexport function parseLigCaretList(reader: Reader): Map<GlyphId, LigatureCaret> {\n\tconst coverageOffset = reader.offset16();\n\tconst ligGlyphCount = reader.uint16();\n\n\t// Read ligature glyph offsets\n\tconst ligGlyphOffsets = reader.uint16Array(ligGlyphCount);\n\n\t// Parse coverage to get glyph IDs\n\tconst coverageReader = reader.sliceFrom(coverageOffset);\n\tconst format = coverageReader.uint16();\n\n\tconst glyphIds: GlyphId[] = [];\n\tif (format === 1) {\n\t\tconst count = coverageReader.uint16();\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tglyphIds.push(coverageReader.uint16());\n\t\t}\n\t} else if (format === 2) {\n\t\tconst rangeCount = coverageReader.uint16();\n\t\tfor (let i = 0; i < rangeCount; i++) {\n\t\t\tconst start = coverageReader.uint16();\n\t\t\tconst end = coverageReader.uint16();\n\t\t\tcoverageReader.skip(2);\n\t\t\tfor (let g = start; g <= end; g++) {\n\t\t\t\tglyphIds.push(g);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Parse ligature glyphs\n\tconst result = new Map<GlyphId, LigatureCaret>();\n\tfor (const [i, offset] of ligGlyphOffsets.entries()) {\n\t\tconst glyphId = glyphIds[i];\n\t\tif (glyphId === undefined) continue;\n\n\t\tconst ligReader = reader.sliceFrom(offset);\n\t\tconst caretCount = ligReader.uint16();\n\t\tconst caretValueOffsets = ligReader.uint16Array(caretCount);\n\n\t\tconst caretValues: number[] = [];\n\t\tfor (const caretOffset of caretValueOffsets) {\n\t\t\tconst caretReader = reader.sliceFrom(offset + caretOffset);\n\t\t\tconst caretFormat = caretReader.uint16();\n\n\t\t\tif (caretFormat === 1) {\n\t\t\t\t// Design units\n\t\t\t\tcaretValues.push(caretReader.int16());\n\t\t\t} else if (caretFormat === 2) {\n\t\t\t\t// Contour point\n\t\t\t\tcaretValues.push(caretReader.uint16()); // point index\n\t\t\t} else if (caretFormat === 3) {\n\t\t\t\t// Design units + device table\n\t\t\t\tcaretValues.push(caretReader.int16());\n\t\t\t}\n\t\t}\n\n\t\tresult.set(glyphId, { caretValues });\n\t}\n\n\treturn result;\n}\n\nexport function parseMarkGlyphSets(reader: Reader): MarkGlyphSets {\n\tconst _format = reader.uint16();\n\tconst markSetCount = reader.uint16();\n\n\t// Read coverage offsets\n\tconst coverageOffsets = reader.uint32Array(markSetCount);\n\n\t// Parse each mark set coverage\n\tconst markSets: Set<GlyphId>[] = [];\n\tfor (const offset of coverageOffsets) {\n\t\tconst coverageReader = reader.sliceFrom(offset);\n\t\tconst coverageFormat = coverageReader.uint16();\n\n\t\tconst glyphSet = new Set<GlyphId>();\n\t\tif (coverageFormat === 1) {\n\t\t\tconst count = coverageReader.uint16();\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tglyphSet.add(coverageReader.uint16());\n\t\t\t}\n\t\t} else if (coverageFormat === 2) {\n\t\t\tconst rangeCount = coverageReader.uint16();\n\t\t\tfor (let i = 0; i < rangeCount; i++) {\n\t\t\t\tconst start = coverageReader.uint16();\n\t\t\t\tconst end = coverageReader.uint16();\n\t\t\t\tcoverageReader.skip(2);\n\t\t\t\tfor (let g = start; g <= end; g++) {\n\t\t\t\t\tglyphSet.add(g);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmarkSets.push(glyphSet);\n\t}\n\n\treturn {\n\t\thas(setIndex: number, glyphId: GlyphId): boolean {\n\t\t\tconst set = markSets[setIndex];\n\t\t\treturn set ? set.has(glyphId) : false;\n\t\t},\n\t};\n}\n\n/** Get glyph class from GDEF */\nexport function getGlyphClass(\n\tgdef: GdefTable | null,\n\tglyphId: GlyphId,\n): GlyphClass | 0 {\n\tif (!gdef) return 0;\n\tconst cls = gdef.glyphClassDef.get(glyphId);\n\treturn cls as GlyphClass | 0;\n}\n\n/** Check if glyph is a base glyph */\nexport function isBaseGlyph(gdef: GdefTable | null, glyphId: GlyphId): boolean {\n\treturn getGlyphClass(gdef, glyphId) === GlyphClass.Base;\n}\n\n/** Check if glyph is a ligature */\nexport function isLigature(gdef: GdefTable | null, glyphId: GlyphId): boolean {\n\treturn getGlyphClass(gdef, glyphId) === GlyphClass.Ligature;\n}\n\n/** Check if glyph is a mark */\nexport function isMark(gdef: GdefTable | null, glyphId: GlyphId): boolean {\n\treturn getGlyphClass(gdef, glyphId) === GlyphClass.Mark;\n}\n\n/** Check if glyph is a component */\nexport function isComponent(gdef: GdefTable | null, glyphId: GlyphId): boolean {\n\treturn getGlyphClass(gdef, glyphId) === GlyphClass.Component;\n}\n", "import type { GlyphId, int16, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Glyph Variations table (gvar)\n * Contains variation data for TrueType glyph outlines\n */\nexport interface GvarTable {\n\tmajorVersion: uint16;\n\tminorVersion: uint16;\n\taxisCount: uint16;\n\tsharedTupleCount: uint16;\n\tsharedTuples: number[][]; // [tupleIndex][axisIndex]\n\tglyphVariationData: GlyphVariationData[];\n}\n\n/**\n * Variation data for a single glyph\n */\nexport interface GlyphVariationData {\n\ttupleVariationHeaders: TupleVariationHeader[];\n}\n\n/**\n * Tuple variation header\n */\nexport interface TupleVariationHeader {\n\tvariationDataSize: uint16;\n\ttupleIndex: uint16;\n\tpeakTuple: number[] | null; // null if embedded in shared tuples\n\tintermediateStartTuple: number[] | null;\n\tintermediateEndTuple: number[] | null;\n\tserializedData: Uint8Array;\n\tpointNumbers: number[] | null; // null means all points\n\tdeltas: PointDelta[];\n}\n\n/**\n * Delta values for a point\n */\nexport interface PointDelta {\n\tx: int16;\n\ty: int16;\n}\n\n// Tuple flags\nconst EMBEDDED_PEAK_TUPLE = 0x8000;\nconst INTERMEDIATE_REGION = 0x4000;\nconst PRIVATE_POINT_NUMBERS = 0x2000;\nconst TUPLE_INDEX_MASK = 0x0fff;\n\n/**\n * Parse gvar table\n */\nexport function parseGvar(reader: Reader, _numGlyphs: number): GvarTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst axisCount = reader.uint16();\n\tconst sharedTupleCount = reader.uint16();\n\tconst sharedTuplesOffset = reader.offset32();\n\tconst glyphCount = reader.uint16();\n\tconst flags = reader.uint16();\n\tconst glyphVariationDataArrayOffset = reader.offset32();\n\n\tconst offsetSize = flags & 1 ? 4 : 2;\n\n\t// Read glyph offsets\n\tconst offsets: number[] = [];\n\tfor (let i = 0; i <= glyphCount; i++) {\n\t\tconst offset = offsetSize === 4 ? reader.uint32() : reader.uint16() * 2;\n\t\toffsets.push(offset);\n\t}\n\n\t// Parse shared tuples\n\tconst sharedTuples: number[][] = [];\n\tif (sharedTupleCount > 0) {\n\t\tconst tupleReader = reader.sliceFrom(sharedTuplesOffset);\n\t\tfor (let i = 0; i < sharedTupleCount; i++) {\n\t\t\tconst tuple: number[] = [];\n\t\t\tfor (let a = 0; a < axisCount; a++) {\n\t\t\t\ttuple.push(tupleReader.f2dot14());\n\t\t\t}\n\t\t\tsharedTuples.push(tuple);\n\t\t}\n\t}\n\n\t// Parse glyph variation data\n\tconst glyphVariationData: GlyphVariationData[] = [];\n\tfor (let g = 0; g < glyphCount; g++) {\n\t\tconst startOffset = offsets[g];\n\t\tconst endOffset = offsets[g + 1];\n\t\tif (startOffset === undefined || endOffset === undefined) {\n\t\t\tglyphVariationData.push({ tupleVariationHeaders: [] });\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst dataStart = glyphVariationDataArrayOffset + startOffset;\n\t\tconst dataEnd = glyphVariationDataArrayOffset + endOffset;\n\n\t\tif (dataStart === dataEnd) {\n\t\t\t// No variation data for this glyph\n\t\t\tglyphVariationData.push({ tupleVariationHeaders: [] });\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst dataReader = reader.sliceFrom(dataStart);\n\t\tconst variationData = parseGlyphVariationData(\n\t\t\tdataReader,\n\t\t\tdataEnd - dataStart,\n\t\t\taxisCount,\n\t\t\tsharedTuples,\n\t\t);\n\t\tglyphVariationData.push(variationData);\n\t}\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\taxisCount,\n\t\tsharedTupleCount,\n\t\tsharedTuples,\n\t\tglyphVariationData,\n\t};\n}\n\nfunction parseGlyphVariationData(\n\treader: Reader,\n\tdataLength: number,\n\taxisCount: number,\n\tsharedTuples: number[][],\n): GlyphVariationData {\n\tif (dataLength === 0) {\n\t\treturn { tupleVariationHeaders: [] };\n\t}\n\n\tconst startOffset = reader.offset;\n\tconst tupleVariationCount = reader.uint16();\n\tconst dataOffset = reader.offset16();\n\n\tconst tupleCount = tupleVariationCount & 0x0fff;\n\tconst hasSharedPointNumbers = (tupleVariationCount & 0x8000) !== 0;\n\n\t// Read tuple variation headers first\n\tconst headerData: Array<{\n\t\tvariationDataSize: uint16;\n\t\ttupleIndex: uint16;\n\t\tpeakTuple: number[] | null;\n\t\tintermediateStartTuple: number[] | null;\n\t\tintermediateEndTuple: number[] | null;\n\t}> = [];\n\n\tfor (let i = 0; i < tupleCount; i++) {\n\t\tconst variationDataSize = reader.uint16();\n\t\tconst tupleIndex = reader.uint16();\n\n\t\tlet peakTuple: number[] | null = null;\n\t\tlet intermediateStartTuple: number[] | null = null;\n\t\tlet intermediateEndTuple: number[] | null = null;\n\n\t\tif (tupleIndex & EMBEDDED_PEAK_TUPLE) {\n\t\t\tpeakTuple = [];\n\t\t\tfor (let a = 0; a < axisCount; a++) {\n\t\t\t\tpeakTuple.push(reader.f2dot14());\n\t\t\t}\n\t\t} else {\n\t\t\tconst sharedIndex = tupleIndex & TUPLE_INDEX_MASK;\n\t\t\tpeakTuple = sharedTuples[sharedIndex] || null;\n\t\t}\n\n\t\tif (tupleIndex & INTERMEDIATE_REGION) {\n\t\t\tintermediateStartTuple = [];\n\t\t\tintermediateEndTuple = [];\n\t\t\tfor (let a = 0; a < axisCount; a++) {\n\t\t\t\tintermediateStartTuple.push(reader.f2dot14());\n\t\t\t}\n\t\t\tfor (let a = 0; a < axisCount; a++) {\n\t\t\t\tintermediateEndTuple.push(reader.f2dot14());\n\t\t\t}\n\t\t}\n\n\t\theaderData.push({\n\t\t\tvariationDataSize,\n\t\t\ttupleIndex,\n\t\t\tpeakTuple,\n\t\t\tintermediateStartTuple,\n\t\t\tintermediateEndTuple,\n\t\t});\n\t}\n\n\t// Now parse serialized data starting at dataOffset\n\tconst dataReader = reader.sliceFrom(startOffset + dataOffset);\n\n\t// Parse shared point numbers if present\n\tlet sharedPoints: number[] | null = null;\n\tif (hasSharedPointNumbers) {\n\t\tsharedPoints = parsePackedPoints(dataReader);\n\t}\n\n\t// Parse each tuple's deltas\n\tconst headers: TupleVariationHeader[] = [];\n\tfor (const hd of headerData) {\n\t\tconst hasPrivatePoints = (hd.tupleIndex & PRIVATE_POINT_NUMBERS) !== 0;\n\n\t\tlet pointNumbers: number[] | null;\n\t\tif (hasPrivatePoints) {\n\t\t\tpointNumbers = parsePackedPoints(dataReader);\n\t\t} else {\n\t\t\tpointNumbers = sharedPoints;\n\t\t}\n\n\t\t// Calculate number of points to read deltas for\n\t\tconst numPoints = pointNumbers ? pointNumbers.length : 0;\n\n\t\t// Parse x deltas then y deltas\n\t\tconst xDeltas =\n\t\t\tnumPoints > 0 ? parsePackedDeltas(dataReader, numPoints) : [];\n\t\tconst yDeltas =\n\t\t\tnumPoints > 0 ? parsePackedDeltas(dataReader, numPoints) : [];\n\n\t\tconst deltas: PointDelta[] = [];\n\t\tfor (const [p, xDelta] of xDeltas.entries()) {\n\t\t\tconst yDelta = yDeltas[p];\n\t\t\tdeltas.push({\n\t\t\t\tx: xDelta ?? 0,\n\t\t\t\ty: yDelta ?? 0,\n\t\t\t});\n\t\t}\n\n\t\theaders.push({\n\t\t\tvariationDataSize: hd.variationDataSize,\n\t\t\ttupleIndex: hd.tupleIndex,\n\t\t\tpeakTuple: hd.peakTuple,\n\t\t\tintermediateStartTuple: hd.intermediateStartTuple,\n\t\t\tintermediateEndTuple: hd.intermediateEndTuple,\n\t\t\tserializedData: new Uint8Array(0),\n\t\t\tpointNumbers,\n\t\t\tdeltas,\n\t\t});\n\t}\n\n\treturn { tupleVariationHeaders: headers };\n}\n\n/**\n * Parse packed point numbers\n */\nfunction parsePackedPoints(reader: Reader): number[] {\n\tconst count = reader.uint8();\n\tconst totalPoints =\n\t\tcount === 0\n\t\t\t? 0\n\t\t\t: count & 0x80\n\t\t\t\t? ((count & 0x7f) << 8) | reader.uint8()\n\t\t\t\t: count;\n\n\tif (totalPoints === 0) {\n\t\treturn []; // All points\n\t}\n\n\tconst points: number[] = [];\n\tlet pointIdx = 0;\n\n\twhile (points.length < totalPoints) {\n\t\tconst runHeader = reader.uint8();\n\t\tconst runCount = (runHeader & 0x7f) + 1;\n\t\tconst pointsAreWords = (runHeader & 0x80) !== 0;\n\n\t\tfor (let i = 0; i < runCount && points.length < totalPoints; i++) {\n\t\t\tconst delta = pointsAreWords ? reader.uint16() : reader.uint8();\n\t\t\tpointIdx += delta;\n\t\t\tpoints.push(pointIdx);\n\t\t}\n\t}\n\n\treturn points;\n}\n\n/**\n * Parse packed deltas\n */\nexport function parsePackedDeltas(reader: Reader, count: number): number[] {\n\tconst deltas: number[] = [];\n\n\twhile (deltas.length < count) {\n\t\tconst runHeader = reader.uint8();\n\t\tconst runCount = (runHeader & 0x3f) + 1;\n\t\tconst deltasAreZero = (runHeader & 0x80) !== 0;\n\t\tconst deltasAreWords = (runHeader & 0x40) !== 0;\n\n\t\tfor (let i = 0; i < runCount && deltas.length < count; i++) {\n\t\t\tif (deltasAreZero) {\n\t\t\t\tdeltas.push(0);\n\t\t\t} else if (deltasAreWords) {\n\t\t\t\tdeltas.push(reader.int16());\n\t\t\t} else {\n\t\t\t\tdeltas.push(reader.int8());\n\t\t\t}\n\t\t}\n\t}\n\n\treturn deltas;\n}\n\n/**\n * Calculate the scalar for a tuple given axis coordinates\n */\nexport function calculateTupleScalar(\n\tpeakTuple: number[],\n\taxisCoords: number[],\n\tintermediateStart: number[] | null,\n\tintermediateEnd: number[] | null,\n): number {\n\tlet scalar = 1.0;\n\n\tfor (const [i, peak] of peakTuple.entries()) {\n\t\tconst coord = axisCoords[i] ?? 0;\n\n\t\tif (peak === 0 || coord === 0) {\n\t\t\tif (peak !== 0) scalar = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (intermediateStart && intermediateEnd) {\n\t\t\tconst start = intermediateStart[i];\n\t\t\tconst end = intermediateEnd[i];\n\t\t\tif (start === undefined || end === undefined) continue;\n\n\t\t\tif (coord < start || coord > end) {\n\t\t\t\tscalar = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (coord < peak) {\n\t\t\t\tscalar *= (coord - start) / (peak - start);\n\t\t\t} else if (coord > peak) {\n\t\t\t\tscalar *= (end - coord) / (end - peak);\n\t\t\t}\n\t\t} else {\n\t\t\t// Simple case\n\t\t\tif ((peak > 0 && coord < 0) || (peak < 0 && coord > 0)) {\n\t\t\t\tscalar = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (Math.abs(coord) < Math.abs(peak)) {\n\t\t\t\tscalar *= coord / peak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn scalar;\n}\n\n/**\n * Get delta for a glyph point at given variation coordinates\n */\nexport function getGlyphDelta(\n\tgvar: GvarTable,\n\tglyphId: GlyphId,\n\tpointIndex: number,\n\taxisCoords: number[],\n): PointDelta {\n\tconst glyphData = gvar.glyphVariationData[glyphId];\n\tif (!glyphData) return { x: 0, y: 0 };\n\n\tlet totalX = 0;\n\tlet totalY = 0;\n\n\tfor (const header of glyphData.tupleVariationHeaders) {\n\t\tif (!header.peakTuple) continue;\n\n\t\tconst scalar = calculateTupleScalar(\n\t\t\theader.peakTuple,\n\t\t\taxisCoords,\n\t\t\theader.intermediateStartTuple,\n\t\t\theader.intermediateEndTuple,\n\t\t);\n\n\t\tif (scalar === 0) continue;\n\n\t\t// Check if point is in the variation\n\t\tif (header.pointNumbers !== null) {\n\t\t\tconst pointIdx = header.pointNumbers.indexOf(pointIndex);\n\t\t\tif (pointIdx < 0) continue;\n\n\t\t\tconst delta = header.deltas[pointIdx];\n\t\t\tif (delta) {\n\t\t\t\ttotalX += delta.x * scalar;\n\t\t\t\ttotalY += delta.y * scalar;\n\t\t\t}\n\t\t} else {\n\t\t\t// All points\n\t\t\tconst delta = header.deltas[pointIndex];\n\t\t\tif (delta) {\n\t\t\t\ttotalX += delta.x * scalar;\n\t\t\t\ttotalY += delta.y * scalar;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { x: Math.round(totalX), y: Math.round(totalY) };\n}\n", "import type { GlyphId, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * loca table - Glyph location index\n * Maps glyph IDs to byte offsets in the glyf table\n */\n\nexport interface LocaTable {\n\t/** Glyph offsets (numGlyphs + 1 entries) */\n\toffsets: uint32[];\n\t/** Whether the font uses short (16-bit) or long (32-bit) offsets */\n\tisShort: boolean;\n}\n\n/**\n * Parse loca table\n * @param reader - Reader positioned at start of loca table\n * @param numGlyphs - Number of glyphs from maxp table\n * @param indexToLocFormat - 0 for short offsets, 1 for long (from head table)\n */\nexport function parseLoca(\n\treader: Reader,\n\tnumGlyphs: number,\n\tindexToLocFormat: number,\n): LocaTable {\n\tconst isShort = indexToLocFormat === 0;\n\tconst offsets: uint32[] = [];\n\n\t// loca has numGlyphs + 1 entries (last entry marks end of last glyph)\n\tconst count = numGlyphs + 1;\n\n\tif (isShort) {\n\t\t// Short format: offsets are uint16, multiply by 2 to get actual byte offset\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\toffsets.push(reader.uint16() * 2);\n\t\t}\n\t} else {\n\t\t// Long format: offsets are uint32\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\toffsets.push(reader.uint32());\n\t\t}\n\t}\n\n\treturn { offsets, isShort };\n}\n\n/**\n * Get byte offset and length for a glyph in the glyf table\n * Returns null if glyph has no outline (empty glyph)\n */\nexport function getGlyphLocation(\n\tloca: LocaTable,\n\tglyphId: GlyphId,\n): { offset: uint32; length: uint32 } | null {\n\tif (glyphId < 0 || glyphId >= loca.offsets.length - 1) {\n\t\treturn null;\n\t}\n\n\tconst offset = loca.offsets[glyphId];\n\tconst nextOffset = loca.offsets[glyphId + 1];\n\tif (offset === undefined || nextOffset === undefined) {\n\t\treturn null;\n\t}\n\n\tconst length = nextOffset - offset;\n\n\t// Zero-length means empty glyph (space, etc.)\n\tif (length === 0) {\n\t\treturn null;\n\t}\n\n\treturn { offset, length };\n}\n\n/**\n * Check if a glyph has outline data\n */\nexport function hasGlyphOutline(loca: LocaTable, glyphId: GlyphId): boolean {\n\treturn getGlyphLocation(loca, glyphId) !== null;\n}\n", "import type { GlyphId, int16, uint8, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\nimport type { GvarTable, PointDelta } from \"./gvar.ts\";\nimport { calculateTupleScalar } from \"./gvar.ts\";\nimport type { LocaTable } from \"./loca.ts\";\nimport { getGlyphLocation } from \"./loca.ts\";\n\n/**\n * glyf table - Glyph outline data\n * Contains TrueType glyph contours as quadratic Bzier curves\n */\n\n/** Point flags */\nexport const PointFlag = {\n\tOnCurve: 0x01,\n\tXShortVector: 0x02,\n\tYShortVector: 0x04,\n\tRepeat: 0x08,\n\tXIsSameOrPositive: 0x10,\n\tYIsSameOrPositive: 0x20,\n\tOverlapSimple: 0x40,\n} as const;\n\n/** Composite glyph flags */\nexport const CompositeFlag = {\n\tArg1And2AreWords: 0x0001,\n\tArgsAreXYValues: 0x0002,\n\tRoundXYToGrid: 0x0004,\n\tWeHaveAScale: 0x0008,\n\tMoreComponents: 0x0020,\n\tWeHaveAnXAndYScale: 0x0040,\n\tWeHaveATwoByTwo: 0x0080,\n\tWeHaveInstructions: 0x0100,\n\tUseMyMetrics: 0x0200,\n\tOverlapCompound: 0x0400,\n\tScaledComponentOffset: 0x0800,\n\tUnscaledComponentOffset: 0x1000,\n} as const;\n\n/** A point in a glyph contour */\nexport interface GlyphPoint {\n\tx: number;\n\ty: number;\n\tonCurve: boolean;\n\t/** True if this is a cubic bezier control point (CFF fonts) */\n\tcubic?: boolean;\n}\n\n/** A contour is a closed path of points */\nexport type Contour = GlyphPoint[];\n\n/** Simple glyph with contours */\nexport interface SimpleGlyph {\n\ttype: \"simple\";\n\tnumberOfContours: int16;\n\txMin: int16;\n\tyMin: int16;\n\txMax: int16;\n\tyMax: int16;\n\tcontours: Contour[];\n\tinstructions: Uint8Array<ArrayBufferLike>;\n}\n\n/** Component of a composite glyph */\nexport interface GlyphComponent {\n\tglyphId: GlyphId;\n\tflags: uint16;\n\t/** X offset or point number */\n\targ1: number;\n\t/** Y offset or point number */\n\targ2: number;\n\t/** Transformation matrix [a, b, c, d] */\n\ttransform: [number, number, number, number];\n}\n\n/** Composite glyph made of other glyphs */\nexport interface CompositeGlyph {\n\ttype: \"composite\";\n\tnumberOfContours: int16;\n\txMin: int16;\n\tyMin: int16;\n\txMax: int16;\n\tyMax: int16;\n\tcomponents: GlyphComponent[];\n\tinstructions: Uint8Array<ArrayBufferLike>;\n}\n\n/** Empty glyph (space, etc.) */\nexport interface EmptyGlyph {\n\ttype: \"empty\";\n}\n\nexport type Glyph = SimpleGlyph | CompositeGlyph | EmptyGlyph;\n\n/** glyf table stores the raw reader for on-demand glyph parsing */\nexport interface GlyfTable {\n\treader: Reader;\n}\n\nexport function parseGlyf(reader: Reader): GlyfTable {\n\t// We don't parse all glyphs upfront - store reader for lazy access\n\treturn { reader };\n}\n\n/**\n * Parse a single glyph from the glyf table\n */\nexport function parseGlyph(\n\tglyf: GlyfTable,\n\tloca: LocaTable,\n\tglyphId: GlyphId,\n): Glyph {\n\tconst location = getGlyphLocation(loca, glyphId);\n\tif (!location) {\n\t\treturn { type: \"empty\" };\n\t}\n\n\tconst reader = glyf.reader.slice(location.offset, location.length);\n\treturn parseGlyphData(reader);\n}\n\nfunction parseGlyphData(reader: Reader): Glyph {\n\tconst numberOfContours = reader.int16();\n\tconst xMin = reader.int16();\n\tconst yMin = reader.int16();\n\tconst xMax = reader.int16();\n\tconst yMax = reader.int16();\n\n\tif (numberOfContours >= 0) {\n\t\treturn parseSimpleGlyph(reader, numberOfContours, xMin, yMin, xMax, yMax);\n\t} else {\n\t\treturn parseCompositeGlyph(\n\t\t\treader,\n\t\t\tnumberOfContours,\n\t\t\txMin,\n\t\t\tyMin,\n\t\t\txMax,\n\t\t\tyMax,\n\t\t);\n\t}\n}\n\nfunction parseSimpleGlyph(\n\treader: Reader,\n\tnumberOfContours: int16,\n\txMin: int16,\n\tyMin: int16,\n\txMax: int16,\n\tyMax: int16,\n): SimpleGlyph {\n\tif (numberOfContours === 0) {\n\t\treturn {\n\t\t\ttype: \"simple\",\n\t\t\tnumberOfContours,\n\t\t\txMin,\n\t\t\tyMin,\n\t\t\txMax,\n\t\t\tyMax,\n\t\t\tcontours: [],\n\t\t\tinstructions: new Uint8Array(0),\n\t\t};\n\t}\n\n\t// Read end points of each contour\n\tconst endPtsOfContours: uint16[] = [];\n\tfor (let i = 0; i < numberOfContours; i++) {\n\t\tendPtsOfContours.push(reader.uint16());\n\t}\n\n\t// Total number of points\n\tconst lastEndPt = endPtsOfContours[numberOfContours - 1];\n\tif (lastEndPt === undefined) {\n\t\treturn {\n\t\t\ttype: \"simple\",\n\t\t\tnumberOfContours,\n\t\t\txMin,\n\t\t\tyMin,\n\t\t\txMax,\n\t\t\tyMax,\n\t\t\tcontours: [],\n\t\t\tinstructions: new Uint8Array(0),\n\t\t};\n\t}\n\tconst numPoints = lastEndPt + 1;\n\n\t// Read instructions\n\tconst instructionLength = reader.uint16();\n\tconst instructions = reader.bytes(instructionLength);\n\n\t// Read flags\n\tconst flags: uint8[] = [];\n\twhile (flags.length < numPoints) {\n\t\tconst flag = reader.uint8();\n\t\tflags.push(flag);\n\n\t\t// Handle repeat flag\n\t\tif (flag & PointFlag.Repeat) {\n\t\t\tconst repeatCount = reader.uint8();\n\t\t\tfor (let i = 0; i < repeatCount; i++) {\n\t\t\t\tflags.push(flag);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Read X coordinates\n\tconst xCoordinates: number[] = [];\n\tlet x = 0;\n\tfor (const [_i, flag] of flags.entries()) {\n\t\tif (flag & PointFlag.XShortVector) {\n\t\t\tconst dx = reader.uint8();\n\t\t\tx += flag & PointFlag.XIsSameOrPositive ? dx : -dx;\n\t\t} else if (!(flag & PointFlag.XIsSameOrPositive)) {\n\t\t\tx += reader.int16();\n\t\t}\n\t\t// else x stays the same (XIsSameOrPositive with no short vector)\n\t\txCoordinates.push(x);\n\t}\n\n\t// Read Y coordinates\n\tconst yCoordinates: number[] = [];\n\tlet y = 0;\n\tfor (const [_i, flag] of flags.entries()) {\n\t\tif (flag & PointFlag.YShortVector) {\n\t\t\tconst dy = reader.uint8();\n\t\t\ty += flag & PointFlag.YIsSameOrPositive ? dy : -dy;\n\t\t} else if (!(flag & PointFlag.YIsSameOrPositive)) {\n\t\t\ty += reader.int16();\n\t\t}\n\t\t// else y stays the same\n\t\tyCoordinates.push(y);\n\t}\n\n\t// Build contours\n\tconst contours: Contour[] = [];\n\tlet pointIndex = 0;\n\tfor (const endPt of endPtsOfContours) {\n\t\tconst contour: Contour = [];\n\n\t\twhile (pointIndex <= endPt) {\n\t\t\tconst xCoord = xCoordinates[pointIndex];\n\t\t\tconst yCoord = yCoordinates[pointIndex];\n\t\t\tconst flag = flags[pointIndex];\n\t\t\tif (xCoord === undefined || yCoord === undefined || flag === undefined) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcontour.push({\n\t\t\t\tx: xCoord,\n\t\t\t\ty: yCoord,\n\t\t\t\tonCurve: (flag & PointFlag.OnCurve) !== 0,\n\t\t\t});\n\t\t\tpointIndex++;\n\t\t}\n\n\t\tcontours.push(contour);\n\t}\n\n\treturn {\n\t\ttype: \"simple\",\n\t\tnumberOfContours,\n\t\txMin,\n\t\tyMin,\n\t\txMax,\n\t\tyMax,\n\t\tcontours,\n\t\tinstructions,\n\t};\n}\n\nfunction parseCompositeGlyph(\n\treader: Reader,\n\tnumberOfContours: int16,\n\txMin: int16,\n\tyMin: int16,\n\txMax: int16,\n\tyMax: int16,\n): CompositeGlyph {\n\tconst components: GlyphComponent[] = [];\n\tlet flags: uint16;\n\n\tdo {\n\t\tflags = reader.uint16();\n\t\tconst glyphIndex = reader.uint16();\n\n\t\tlet arg1: number;\n\t\tlet arg2: number;\n\n\t\tif (flags & CompositeFlag.Arg1And2AreWords) {\n\t\t\tif (flags & CompositeFlag.ArgsAreXYValues) {\n\t\t\t\targ1 = reader.int16();\n\t\t\t\targ2 = reader.int16();\n\t\t\t} else {\n\t\t\t\targ1 = reader.uint16();\n\t\t\t\targ2 = reader.uint16();\n\t\t\t}\n\t\t} else {\n\t\t\tif (flags & CompositeFlag.ArgsAreXYValues) {\n\t\t\t\targ1 = reader.int8();\n\t\t\t\targ2 = reader.int8();\n\t\t\t} else {\n\t\t\t\targ1 = reader.uint8();\n\t\t\t\targ2 = reader.uint8();\n\t\t\t}\n\t\t}\n\n\t\t// Transformation matrix defaults to identity\n\t\tlet a = 1,\n\t\t\tb = 0,\n\t\t\tc = 0,\n\t\t\td = 1;\n\n\t\tif (flags & CompositeFlag.WeHaveAScale) {\n\t\t\ta = d = reader.f2dot14();\n\t\t} else if (flags & CompositeFlag.WeHaveAnXAndYScale) {\n\t\t\ta = reader.f2dot14();\n\t\t\td = reader.f2dot14();\n\t\t} else if (flags & CompositeFlag.WeHaveATwoByTwo) {\n\t\t\ta = reader.f2dot14();\n\t\t\tb = reader.f2dot14();\n\t\t\tc = reader.f2dot14();\n\t\t\td = reader.f2dot14();\n\t\t}\n\n\t\tcomponents.push({\n\t\t\tglyphId: glyphIndex,\n\t\t\tflags,\n\t\t\targ1,\n\t\t\targ2,\n\t\t\ttransform: [a, b, c, d],\n\t\t});\n\t} while (flags & CompositeFlag.MoreComponents);\n\n\t// Read instructions if present\n\tlet instructions: Uint8Array<ArrayBufferLike> = new Uint8Array(0);\n\tif (flags & CompositeFlag.WeHaveInstructions) {\n\t\tconst instructionLength = reader.uint16();\n\t\tinstructions = reader.bytes(instructionLength);\n\t}\n\n\treturn {\n\t\ttype: \"composite\",\n\t\tnumberOfContours,\n\t\txMin,\n\t\tyMin,\n\t\txMax,\n\t\tyMax,\n\t\tcomponents,\n\t\tinstructions,\n\t};\n}\n\n/**\n * Flatten a composite glyph into simple contours\n * Recursively resolves all component glyphs and applies transformations\n */\nexport function flattenCompositeGlyph(\n\tglyf: GlyfTable,\n\tloca: LocaTable,\n\tglyph: CompositeGlyph,\n\tdepth: number = 0,\n): Contour[] {\n\t// Prevent infinite recursion\n\tif (depth > 32) {\n\t\treturn [];\n\t}\n\n\tconst result: Contour[] = [];\n\n\tfor (const component of glyph.components) {\n\t\tconst componentGlyph = parseGlyph(glyf, loca, component.glyphId);\n\n\t\tlet componentContours: Contour[];\n\t\tif (componentGlyph.type === \"simple\") {\n\t\t\tcomponentContours = componentGlyph.contours;\n\t\t} else if (componentGlyph.type === \"composite\") {\n\t\t\tcomponentContours = flattenCompositeGlyph(\n\t\t\t\tglyf,\n\t\t\t\tloca,\n\t\t\t\tcomponentGlyph,\n\t\t\t\tdepth + 1,\n\t\t\t);\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Apply transformation and offset\n\t\tconst [a, b, c, d] = component.transform;\n\t\tconst dx =\n\t\t\tcomponent.flags & CompositeFlag.ArgsAreXYValues ? component.arg1 : 0;\n\t\tconst dy =\n\t\t\tcomponent.flags & CompositeFlag.ArgsAreXYValues ? component.arg2 : 0;\n\n\t\tfor (const contour of componentContours) {\n\t\t\tconst transformedContour: Contour = contour.map((point) => ({\n\t\t\t\tx: Math.round(a * point.x + c * point.y + dx),\n\t\t\t\ty: Math.round(b * point.x + d * point.y + dy),\n\t\t\t\tonCurve: point.onCurve,\n\t\t\t}));\n\t\t\tresult.push(transformedContour);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Get all contours for a glyph, flattening composites\n */\nexport function getGlyphContours(\n\tglyf: GlyfTable,\n\tloca: LocaTable,\n\tglyphId: GlyphId,\n): Contour[] {\n\tconst glyph = parseGlyph(glyf, loca, glyphId);\n\n\tif (glyph.type === \"empty\") {\n\t\treturn [];\n\t} else if (glyph.type === \"simple\") {\n\t\treturn glyph.contours;\n\t} else {\n\t\treturn flattenCompositeGlyph(glyf, loca, glyph);\n\t}\n}\n\n/**\n * Get bounding box for a glyph\n */\nexport function getGlyphBounds(\n\tglyf: GlyfTable,\n\tloca: LocaTable,\n\tglyphId: GlyphId,\n): { xMin: number; yMin: number; xMax: number; yMax: number } | null {\n\tconst glyph = parseGlyph(glyf, loca, glyphId);\n\n\tif (glyph.type === \"empty\") {\n\t\treturn null;\n\t}\n\n\treturn {\n\t\txMin: glyph.xMin,\n\t\tyMin: glyph.yMin,\n\t\txMax: glyph.xMax,\n\t\tyMax: glyph.yMax,\n\t};\n}\n\n/**\n * Get all deltas for a glyph at given variation coordinates\n */\nexport function getGlyphDeltas(\n\tgvar: GvarTable,\n\tglyphId: GlyphId,\n\tnumPoints: number,\n\taxisCoords: number[],\n): PointDelta[] {\n\tconst glyphData = gvar.glyphVariationData[glyphId];\n\tif (!glyphData) {\n\t\treturn Array(numPoints).fill({ x: 0, y: 0 });\n\t}\n\n\t// Initialize deltas array\n\tconst deltas: PointDelta[] = Array(numPoints)\n\t\t.fill(null)\n\t\t.map(() => ({ x: 0, y: 0 }));\n\n\tfor (const header of glyphData.tupleVariationHeaders) {\n\t\tif (!header.peakTuple) continue;\n\n\t\tconst scalar = calculateTupleScalar(\n\t\t\theader.peakTuple,\n\t\t\taxisCoords,\n\t\t\theader.intermediateStartTuple,\n\t\t\theader.intermediateEndTuple,\n\t\t);\n\n\t\tif (scalar === 0) continue;\n\n\t\tif (header.pointNumbers !== null) {\n\t\t\t// Sparse point deltas\n\t\t\tfor (const [i, pointIndex] of header.pointNumbers.entries()) {\n\t\t\t\tconst delta = deltas[pointIndex];\n\t\t\t\tconst headerDelta = header.deltas[i];\n\t\t\t\tif (pointIndex < numPoints && delta && headerDelta) {\n\t\t\t\t\tdelta.x += headerDelta.x * scalar;\n\t\t\t\t\tdelta.y += headerDelta.y * scalar;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// All points\n\t\t\tfor (let i = 0; i < Math.min(header.deltas.length, numPoints); i++) {\n\t\t\t\tconst delta = deltas[i];\n\t\t\t\tconst headerDelta = header.deltas[i];\n\t\t\t\tif (delta && headerDelta) {\n\t\t\t\t\tdelta.x += headerDelta.x * scalar;\n\t\t\t\t\tdelta.y += headerDelta.y * scalar;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Round final values\n\tfor (const d of deltas) {\n\t\td.x = Math.round(d.x);\n\t\td.y = Math.round(d.y);\n\t}\n\n\treturn deltas;\n}\n\n/**\n * Apply variation deltas to contours\n */\nexport function applyVariationDeltas(\n\tcontours: Contour[],\n\tdeltas: PointDelta[],\n): Contour[] {\n\tconst result: Contour[] = [];\n\tlet pointIndex = 0;\n\n\tfor (const contour of contours) {\n\t\tconst newContour: Contour = [];\n\t\tfor (const point of contour) {\n\t\t\tconst delta = deltas[pointIndex] ?? { x: 0, y: 0 };\n\t\t\tnewContour.push({\n\t\t\t\tx: point.x + delta.x,\n\t\t\t\ty: point.y + delta.y,\n\t\t\t\tonCurve: point.onCurve,\n\t\t\t});\n\t\t\tpointIndex++;\n\t\t}\n\t\tresult.push(newContour);\n\t}\n\n\treturn result;\n}\n\n/**\n * Get contours for a glyph with variation applied\n */\nexport function getGlyphContoursWithVariation(\n\tglyf: GlyfTable,\n\tloca: LocaTable,\n\tgvar: GvarTable | null,\n\tglyphId: GlyphId,\n\taxisCoords?: number[],\n): Contour[] {\n\tconst glyph = parseGlyph(glyf, loca, glyphId);\n\n\tif (glyph.type === \"empty\") {\n\t\treturn [];\n\t}\n\n\tlet contours: Contour[];\n\tif (glyph.type === \"simple\") {\n\t\tcontours = glyph.contours;\n\t} else {\n\t\tcontours = flattenCompositeGlyphWithVariation(\n\t\t\tglyf,\n\t\t\tloca,\n\t\t\tgvar,\n\t\t\tglyph,\n\t\t\taxisCoords,\n\t\t);\n\t}\n\n\t// Apply variation if we have gvar and axis coordinates\n\tif (gvar && axisCoords && axisCoords.length > 0) {\n\t\t// Count total points\n\t\tlet numPoints = 0;\n\t\tfor (const c of contours) {\n\t\t\tnumPoints += c.length;\n\t\t}\n\t\t// Add phantom points (4)\n\t\tnumPoints += 4;\n\n\t\tconst deltas = getGlyphDeltas(gvar, glyphId, numPoints, axisCoords);\n\t\tcontours = applyVariationDeltas(contours, deltas);\n\t}\n\n\treturn contours;\n}\n\n/**\n * Flatten composite glyph with variation support\n */\nfunction flattenCompositeGlyphWithVariation(\n\tglyf: GlyfTable,\n\tloca: LocaTable,\n\tgvar: GvarTable | null,\n\tglyph: CompositeGlyph,\n\taxisCoords?: number[],\n\tdepth: number = 0,\n): Contour[] {\n\tif (depth > 32) {\n\t\treturn [];\n\t}\n\n\tconst result: Contour[] = [];\n\n\tfor (const component of glyph.components) {\n\t\tconst componentGlyph = parseGlyph(glyf, loca, component.glyphId);\n\n\t\tlet componentContours: Contour[];\n\t\tif (componentGlyph.type === \"simple\") {\n\t\t\tcomponentContours = componentGlyph.contours;\n\n\t\t\t// Apply variation to component\n\t\t\tif (gvar && axisCoords && axisCoords.length > 0) {\n\t\t\t\tlet numPoints = 0;\n\t\t\t\tfor (const c of componentContours) {\n\t\t\t\t\tnumPoints += c.length;\n\t\t\t\t}\n\t\t\t\tnumPoints += 4; // phantom points\n\n\t\t\t\tconst deltas = getGlyphDeltas(\n\t\t\t\t\tgvar,\n\t\t\t\t\tcomponent.glyphId,\n\t\t\t\t\tnumPoints,\n\t\t\t\t\taxisCoords,\n\t\t\t\t);\n\t\t\t\tcomponentContours = applyVariationDeltas(componentContours, deltas);\n\t\t\t}\n\t\t} else if (componentGlyph.type === \"composite\") {\n\t\t\tcomponentContours = flattenCompositeGlyphWithVariation(\n\t\t\t\tglyf,\n\t\t\t\tloca,\n\t\t\t\tgvar,\n\t\t\t\tcomponentGlyph,\n\t\t\t\taxisCoords,\n\t\t\t\tdepth + 1,\n\t\t\t);\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Apply transformation and offset\n\t\tconst [a, b, c, d] = component.transform;\n\t\tconst dx =\n\t\t\tcomponent.flags & CompositeFlag.ArgsAreXYValues ? component.arg1 : 0;\n\t\tconst dy =\n\t\t\tcomponent.flags & CompositeFlag.ArgsAreXYValues ? component.arg2 : 0;\n\n\t\tfor (const contour of componentContours) {\n\t\t\tconst transformedContour: Contour = contour.map((point) => ({\n\t\t\t\tx: Math.round(a * point.x + c * point.y + dx),\n\t\t\t\ty: Math.round(b * point.x + d * point.y + dy),\n\t\t\t\tonCurve: point.onCurve,\n\t\t\t}));\n\t\t\tresult.push(transformedContour);\n\t\t}\n\t}\n\n\treturn result;\n}\n", "import type { GlyphId } from \"../../types.ts\";\nimport type { CffTable, PrivateDict } from \"./cff.ts\";\nimport type { Cff2Table, ItemVariationStore } from \"./cff2.ts\";\nimport type { Contour, GlyphPoint } from \"./glyf.ts\";\n\n/**\n * CFF CharString interpreter\n * Executes Type 2 CharString programs to produce glyph outlines\n */\n\n// CharString operators\nenum Op {\n\t// Path construction\n\thstem = 1,\n\tvstem = 3,\n\tvmoveto = 4,\n\trlineto = 5,\n\thlineto = 6,\n\tvlineto = 7,\n\trrcurveto = 8,\n\tcallsubr = 10,\n\treturn_ = 11,\n\tendchar = 14,\n\thstemhm = 18,\n\thintmask = 19,\n\tcntrmask = 20,\n\trmoveto = 21,\n\thmoveto = 22,\n\tvstemhm = 23,\n\trcurveline = 24,\n\trlinecurve = 25,\n\tvvcurveto = 26,\n\thhcurveto = 27,\n\tcallgsubr = 29,\n\tvhcurveto = 30,\n\thvcurveto = 31,\n\n\t// Two-byte operators (12 xx)\n\tdotsection = 0x0c00,\n\tand_ = 0x0c03,\n\tor_ = 0x0c04,\n\tnot_ = 0x0c05,\n\tabs_ = 0x0c09,\n\tadd_ = 0x0c0a,\n\tsub_ = 0x0c0b,\n\tdiv_ = 0x0c0c,\n\tneg_ = 0x0c0e,\n\teq_ = 0x0c0f,\n\tdrop_ = 0x0c12,\n\tput_ = 0x0c14,\n\tget_ = 0x0c15,\n\tifelse_ = 0x0c16,\n\trandom_ = 0x0c17,\n\tmul_ = 0x0c18,\n\tsqrt_ = 0x0c1a,\n\tdup_ = 0x0c1b,\n\texch_ = 0x0c1c,\n\tindex_ = 0x0c1d,\n\troll_ = 0x0c1e,\n\thflex = 0x0c22,\n\tflex = 0x0c23,\n\thflex1 = 0x0c24,\n\tflex1 = 0x0c25,\n\n\t// CFF2 operators\n\tvsindex = 15,\n\tblend = 16,\n}\n\ninterface CharStringState {\n\tx: number;\n\ty: number;\n\tstack: number[];\n\tnStems: number;\n\thaveWidth: boolean;\n\twidth: number;\n\tcontours: Contour[];\n\tcurrentContour: GlyphPoint[];\n\ttransientArray: number[];\n\t// For subroutine calls\n\tcallStack: { data: Uint8Array; pos: number }[];\n\t// For CFF2 blending\n\tvsindex: number;\n\taxisCoords: number[] | null;\n\tvstore: ItemVariationStore | null;\n}\n\n/**\n * Execute a CFF charstring and return contours\n */\nexport function executeCffCharString(\n\tcff: CffTable,\n\tglyphId: GlyphId,\n\tfontIndex: number = 0,\n): Contour[] | null {\n\tconst charStrings = cff.charStrings[fontIndex];\n\tif (!charStrings || glyphId >= charStrings.length) return null;\n\n\tconst charString = charStrings[glyphId];\n\tif (!charString) return null;\n\n\tconst globalSubrs = cff.globalSubrs;\n\n\t// For CID fonts, use fdSelect to get the right FD and its local subrs\n\tconst topDict = cff.topDicts[fontIndex];\n\tconst isCID = topDict?.ros !== undefined;\n\tlet localSubrs: Uint8Array[] = [];\n\n\tif (isCID && cff.fdSelects[fontIndex] && cff.fdArrays[fontIndex]) {\n\t\tconst fdIndex = cff.fdSelects[fontIndex]?.select(glyphId) ?? 0;\n\t\tconst fdArray = cff.fdArrays[fontIndex];\n\t\tconst fd = fdArray?.[fdIndex];\n\t\t// Use FD-specific local subrs if available\n\t\tlocalSubrs = fd?.localSubrs || cff.localSubrs[fontIndex] || [];\n\t} else {\n\t\tlocalSubrs = cff.localSubrs[fontIndex] || [];\n\t}\n\n\tconst state: CharStringState = {\n\t\tx: 0,\n\t\ty: 0,\n\t\tstack: [],\n\t\tnStems: 0,\n\t\thaveWidth: false,\n\t\twidth: 0,\n\t\tcontours: [],\n\t\tcurrentContour: [],\n\t\ttransientArray: new Array(32).fill(0),\n\t\tcallStack: [],\n\t\tvsindex: 0,\n\t\taxisCoords: null,\n\t\tvstore: null,\n\t};\n\n\texecuteCharString(state, charString, globalSubrs, localSubrs);\n\n\t// Close any open contour\n\tif (state.currentContour.length > 0) {\n\t\tstate.contours.push(state.currentContour);\n\t}\n\n\treturn state.contours;\n}\n\n/**\n * Execute a CFF2 charstring with variation support\n */\nexport function executeCff2CharString(\n\tcff2: Cff2Table,\n\tglyphId: GlyphId,\n\taxisCoords: number[] | null = null,\n): Contour[] | null {\n\tif (glyphId >= cff2.charStrings.length) return null;\n\n\tconst charString = cff2.charStrings[glyphId];\n\tif (!charString) return null;\n\n\tconst globalSubrs = cff2.globalSubrs;\n\n\t// Get FD index and local subrs\n\tconst fdIndex = cff2.fdSelect?.select(glyphId) ?? 0;\n\tconst fd = cff2.fdArray[fdIndex];\n\tconst localSubrs = fd?.localSubrs || [];\n\n\tconst state: CharStringState = {\n\t\tx: 0,\n\t\ty: 0,\n\t\tstack: [],\n\t\tnStems: 0,\n\t\thaveWidth: true, // CFF2 doesn't have width in charstring\n\t\twidth: 0,\n\t\tcontours: [],\n\t\tcurrentContour: [],\n\t\ttransientArray: new Array(32).fill(0),\n\t\tcallStack: [],\n\t\tvsindex: fd?.private?.vsindex ?? 0,\n\t\taxisCoords,\n\t\tvstore: cff2.vstore,\n\t};\n\n\texecuteCharString(state, charString, globalSubrs, localSubrs);\n\n\t// Close any open contour\n\tif (state.currentContour.length > 0) {\n\t\tstate.contours.push(state.currentContour);\n\t}\n\n\treturn state.contours;\n}\n\nfunction executeCharString(\n\tstate: CharStringState,\n\tdata: Uint8Array,\n\tglobalSubrs: Uint8Array[],\n\tlocalSubrs: Uint8Array[],\n): void {\n\tlet pos = 0;\n\n\twhile (pos < data.length) {\n\t\tconst b0 = data[pos++];\n\t\tif (b0 === undefined) return;\n\n\t\tif (b0 === 28) {\n\t\t\t// 16-bit signed integer\n\t\t\tconst b1 = data[pos++];\n\t\t\tif (b1 === undefined) return;\n\t\t\tconst b2 = data[pos++];\n\t\t\tif (b2 === undefined) return;\n\t\t\tstate.stack.push((((b1 << 8) | b2) << 16) >> 16);\n\t\t} else if (b0 === 255) {\n\t\t\t// 32-bit fixed point (16.16)\n\t\t\tconst b1 = data[pos++];\n\t\t\tif (b1 === undefined) return;\n\t\t\tconst b2 = data[pos++];\n\t\t\tif (b2 === undefined) return;\n\t\t\tconst b3 = data[pos++];\n\t\t\tif (b3 === undefined) return;\n\t\t\tconst b4 = data[pos++];\n\t\t\tif (b4 === undefined) return;\n\t\t\tconst val = ((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) >> 0;\n\t\t\tstate.stack.push(val / 65536);\n\t\t} else if (b0 >= 32 && b0 <= 246) {\n\t\t\tstate.stack.push(b0 - 139);\n\t\t} else if (b0 >= 247 && b0 <= 250) {\n\t\t\tconst b1 = data[pos++];\n\t\t\tif (b1 === undefined) return;\n\t\t\tstate.stack.push((b0 - 247) * 256 + b1 + 108);\n\t\t} else if (b0 >= 251 && b0 <= 254) {\n\t\t\tconst b1 = data[pos++];\n\t\t\tif (b1 === undefined) return;\n\t\t\tstate.stack.push(-(b0 - 251) * 256 - b1 - 108);\n\t\t} else if (b0 === 12) {\n\t\t\t// Two-byte operator\n\t\t\tconst b1 = data[pos++];\n\t\t\tif (b1 === undefined) return;\n\t\t\tconst op = 0x0c00 | b1;\n\t\t\texecuteOperator(state, op, globalSubrs, localSubrs);\n\t\t} else if (b0 === Op.hintmask || b0 === Op.cntrmask) {\n\t\t\t// hintmask/cntrmask: process stems from stack, then skip mask bytes\n\t\t\tconst stack = state.stack;\n\t\t\tconst hasWidth = stack.length % 2 !== 0;\n\t\t\tif (hasWidth && !state.haveWidth) {\n\t\t\t\tconst width = stack.shift();\n\t\t\t\tif (width !== undefined) {\n\t\t\t\t\tstate.width = width;\n\t\t\t\t\tstate.haveWidth = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstate.nStems += stack.length / 2;\n\t\t\tstack.length = 0;\n\t\t\t// Skip mask bytes (ceil(nStems / 8) bytes)\n\t\t\tconst maskBytes = Math.ceil(state.nStems / 8);\n\t\t\tpos += maskBytes;\n\t\t} else {\n\t\t\t// Single-byte operator\n\t\t\texecuteOperator(state, b0, globalSubrs, localSubrs);\n\t\t}\n\n\t\t// Handle return from subroutine\n\t\tif (state.callStack.length > 0) {\n\t\t\tconst frame = state.callStack[state.callStack.length - 1];\n\t\t\tif (frame && frame.pos >= frame.data.length) {\n\t\t\t\tstate.callStack.pop();\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction executeOperator(\n\tstate: CharStringState,\n\top: number,\n\tglobalSubrs: Uint8Array[],\n\tlocalSubrs: Uint8Array[],\n): void {\n\tconst stack = state.stack;\n\n\tswitch (op) {\n\t\tcase Op.hstem:\n\t\tcase Op.vstem:\n\t\tcase Op.hstemhm:\n\t\tcase Op.vstemhm: {\n\t\t\t// Stem hints\n\t\t\tconst hasWidth = stack.length % 2 !== 0;\n\t\t\tif (hasWidth && !state.haveWidth) {\n\t\t\t\tconst width = stack.shift();\n\t\t\t\tif (width === undefined) break;\n\t\t\t\tstate.width = width;\n\t\t\t\tstate.haveWidth = true;\n\t\t\t}\n\t\t\tstate.nStems += stack.length / 2;\n\t\t\tstack.length = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.hintmask:\n\t\tcase Op.cntrmask:\n\t\t\t// Handled inline in executeCharString to skip mask bytes\n\t\t\tbreak;\n\n\t\tcase Op.rmoveto: {\n\t\t\tif (stack.length > 2 && !state.haveWidth) {\n\t\t\t\tconst width = stack.shift();\n\t\t\t\tif (width === undefined) break;\n\t\t\t\tstate.width = width;\n\t\t\t\tstate.haveWidth = true;\n\t\t\t}\n\t\t\t// Close current contour if any\n\t\t\tif (state.currentContour.length > 0) {\n\t\t\t\tstate.contours.push(state.currentContour);\n\t\t\t\tstate.currentContour = [];\n\t\t\t}\n\t\t\tconst dy = stack.pop();\n\t\t\tif (dy === undefined) break;\n\t\t\tconst dx = stack.pop();\n\t\t\tif (dx === undefined) break;\n\t\t\tstate.x += dx;\n\t\t\tstate.y += dy;\n\t\t\tstate.currentContour.push({ x: state.x, y: state.y, onCurve: true });\n\t\t\tstack.length = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.hmoveto: {\n\t\t\tif (stack.length > 1 && !state.haveWidth) {\n\t\t\t\tconst width = stack.shift();\n\t\t\t\tif (width === undefined) break;\n\t\t\t\tstate.width = width;\n\t\t\t\tstate.haveWidth = true;\n\t\t\t}\n\t\t\tif (state.currentContour.length > 0) {\n\t\t\t\tstate.contours.push(state.currentContour);\n\t\t\t\tstate.currentContour = [];\n\t\t\t}\n\t\t\tconst dx = stack.pop();\n\t\t\tif (dx === undefined) break;\n\t\t\tstate.x += dx;\n\t\t\tstate.currentContour.push({ x: state.x, y: state.y, onCurve: true });\n\t\t\tstack.length = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.vmoveto: {\n\t\t\tif (stack.length > 1 && !state.haveWidth) {\n\t\t\t\tconst width = stack.shift();\n\t\t\t\tif (width === undefined) break;\n\t\t\t\tstate.width = width;\n\t\t\t\tstate.haveWidth = true;\n\t\t\t}\n\t\t\tif (state.currentContour.length > 0) {\n\t\t\t\tstate.contours.push(state.currentContour);\n\t\t\t\tstate.currentContour = [];\n\t\t\t}\n\t\t\tconst dy = stack.pop();\n\t\t\tif (dy === undefined) break;\n\t\t\tstate.y += dy;\n\t\t\tstate.currentContour.push({ x: state.x, y: state.y, onCurve: true });\n\t\t\tstack.length = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.rlineto: {\n\t\t\twhile (stack.length >= 2) {\n\t\t\t\tconst dx = stack.shift();\n\t\t\t\tif (dx === undefined) break;\n\t\t\t\tconst dy = stack.shift();\n\t\t\t\tif (dy === undefined) break;\n\t\t\t\tstate.x += dx;\n\t\t\t\tstate.y += dy;\n\t\t\t\tstate.currentContour.push({ x: state.x, y: state.y, onCurve: true });\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.hlineto: {\n\t\t\tlet isHorizontal = true;\n\t\t\twhile (stack.length >= 1) {\n\t\t\t\tconst val = stack.shift();\n\t\t\t\tif (val === undefined) break;\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tstate.x += val;\n\t\t\t\t} else {\n\t\t\t\t\tstate.y += val;\n\t\t\t\t}\n\t\t\t\tstate.currentContour.push({ x: state.x, y: state.y, onCurve: true });\n\t\t\t\tisHorizontal = !isHorizontal;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.vlineto: {\n\t\t\tlet isVertical = true;\n\t\t\twhile (stack.length >= 1) {\n\t\t\t\tconst val = stack.shift();\n\t\t\t\tif (val === undefined) break;\n\t\t\t\tif (isVertical) {\n\t\t\t\t\tstate.y += val;\n\t\t\t\t} else {\n\t\t\t\t\tstate.x += val;\n\t\t\t\t}\n\t\t\t\tstate.currentContour.push({ x: state.x, y: state.y, onCurve: true });\n\t\t\t\tisVertical = !isVertical;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.rrcurveto: {\n\t\t\twhile (stack.length >= 6) {\n\t\t\t\tconst dx1 = stack.shift();\n\t\t\t\tif (dx1 === undefined) break;\n\t\t\t\tconst dy1 = stack.shift();\n\t\t\t\tif (dy1 === undefined) break;\n\t\t\t\tconst dx2 = stack.shift();\n\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\tconst dy2 = stack.shift();\n\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\tconst dx3 = stack.shift();\n\t\t\t\tif (dx3 === undefined) break;\n\t\t\t\tconst dy3 = stack.shift();\n\t\t\t\tif (dy3 === undefined) break;\n\t\t\t\taddCubicBezier(state, dx1, dy1, dx2, dy2, dx3, dy3);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.hhcurveto: {\n\t\t\tlet dy1 = 0;\n\t\t\tif (stack.length % 4 === 1) {\n\t\t\t\tconst val = stack.shift();\n\t\t\t\tif (val === undefined) break;\n\t\t\t\tdy1 = val;\n\t\t\t}\n\t\t\twhile (stack.length >= 4) {\n\t\t\t\tconst dx1 = stack.shift();\n\t\t\t\tif (dx1 === undefined) break;\n\t\t\t\tconst dx2 = stack.shift();\n\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\tconst dy2 = stack.shift();\n\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\tconst dx3 = stack.shift();\n\t\t\t\tif (dx3 === undefined) break;\n\t\t\t\taddCubicBezier(state, dx1, dy1, dx2, dy2, dx3, 0);\n\t\t\t\tdy1 = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.vvcurveto: {\n\t\t\tlet dx1 = 0;\n\t\t\tif (stack.length % 4 === 1) {\n\t\t\t\tconst val = stack.shift();\n\t\t\t\tif (val === undefined) break;\n\t\t\t\tdx1 = val;\n\t\t\t}\n\t\t\twhile (stack.length >= 4) {\n\t\t\t\tconst dy1 = stack.shift();\n\t\t\t\tif (dy1 === undefined) break;\n\t\t\t\tconst dx2 = stack.shift();\n\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\tconst dy2 = stack.shift();\n\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\tconst dy3 = stack.shift();\n\t\t\t\tif (dy3 === undefined) break;\n\t\t\t\taddCubicBezier(state, dx1, dy1, dx2, dy2, 0, dy3);\n\t\t\t\tdx1 = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.hvcurveto: {\n\t\t\t// Alternates horizontal/vertical starting tangent\n\t\t\tlet isHorizontal = true;\n\t\t\twhile (stack.length >= 4) {\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tconst dx1 = stack.shift();\n\t\t\t\t\tif (dx1 === undefined) break;\n\t\t\t\t\tconst dx2 = stack.shift();\n\t\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\t\tconst dy2 = stack.shift();\n\t\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\t\tconst dy3 = stack.shift();\n\t\t\t\t\tif (dy3 === undefined) break;\n\t\t\t\t\tconst dx3 = stack.length === 1 ? (stack.shift() ?? 0) : 0;\n\t\t\t\t\taddCubicBezier(state, dx1, 0, dx2, dy2, dx3, dy3);\n\t\t\t\t} else {\n\t\t\t\t\tconst dy1 = stack.shift();\n\t\t\t\t\tif (dy1 === undefined) break;\n\t\t\t\t\tconst dx2 = stack.shift();\n\t\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\t\tconst dy2 = stack.shift();\n\t\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\t\tconst dx3 = stack.shift();\n\t\t\t\t\tif (dx3 === undefined) break;\n\t\t\t\t\tconst dy3 = stack.length === 1 ? (stack.shift() ?? 0) : 0;\n\t\t\t\t\taddCubicBezier(state, 0, dy1, dx2, dy2, dx3, dy3);\n\t\t\t\t}\n\t\t\t\tisHorizontal = !isHorizontal;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.vhcurveto: {\n\t\t\t// Alternates vertical/horizontal starting tangent\n\t\t\tlet isVertical = true;\n\t\t\twhile (stack.length >= 4) {\n\t\t\t\tif (isVertical) {\n\t\t\t\t\tconst dy1 = stack.shift();\n\t\t\t\t\tif (dy1 === undefined) break;\n\t\t\t\t\tconst dx2 = stack.shift();\n\t\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\t\tconst dy2 = stack.shift();\n\t\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\t\tconst dx3 = stack.shift();\n\t\t\t\t\tif (dx3 === undefined) break;\n\t\t\t\t\tconst dy3 = stack.length === 1 ? (stack.shift() ?? 0) : 0;\n\t\t\t\t\taddCubicBezier(state, 0, dy1, dx2, dy2, dx3, dy3);\n\t\t\t\t} else {\n\t\t\t\t\tconst dx1 = stack.shift();\n\t\t\t\t\tif (dx1 === undefined) break;\n\t\t\t\t\tconst dx2 = stack.shift();\n\t\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\t\tconst dy2 = stack.shift();\n\t\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\t\tconst dy3 = stack.shift();\n\t\t\t\t\tif (dy3 === undefined) break;\n\t\t\t\t\tconst dx3 = stack.length === 1 ? (stack.shift() ?? 0) : 0;\n\t\t\t\t\taddCubicBezier(state, dx1, 0, dx2, dy2, dx3, dy3);\n\t\t\t\t}\n\t\t\t\tisVertical = !isVertical;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.rcurveline: {\n\t\t\twhile (stack.length >= 8) {\n\t\t\t\tconst dx1 = stack.shift();\n\t\t\t\tif (dx1 === undefined) break;\n\t\t\t\tconst dy1 = stack.shift();\n\t\t\t\tif (dy1 === undefined) break;\n\t\t\t\tconst dx2 = stack.shift();\n\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\tconst dy2 = stack.shift();\n\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\tconst dx3 = stack.shift();\n\t\t\t\tif (dx3 === undefined) break;\n\t\t\t\tconst dy3 = stack.shift();\n\t\t\t\tif (dy3 === undefined) break;\n\t\t\t\taddCubicBezier(state, dx1, dy1, dx2, dy2, dx3, dy3);\n\t\t\t}\n\t\t\t// Final line\n\t\t\tif (stack.length >= 2) {\n\t\t\t\tconst dx = stack.shift();\n\t\t\t\tif (dx === undefined) break;\n\t\t\t\tconst dy = stack.shift();\n\t\t\t\tif (dy === undefined) break;\n\t\t\t\tstate.x += dx;\n\t\t\t\tstate.y += dy;\n\t\t\t\tstate.currentContour.push({ x: state.x, y: state.y, onCurve: true });\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.rlinecurve: {\n\t\t\twhile (stack.length >= 8) {\n\t\t\t\tconst dx = stack.shift();\n\t\t\t\tif (dx === undefined) break;\n\t\t\t\tconst dy = stack.shift();\n\t\t\t\tif (dy === undefined) break;\n\t\t\t\tstate.x += dx;\n\t\t\t\tstate.y += dy;\n\t\t\t\tstate.currentContour.push({ x: state.x, y: state.y, onCurve: true });\n\t\t\t}\n\t\t\t// Final curve\n\t\t\tif (stack.length >= 6) {\n\t\t\t\tconst dx1 = stack.shift();\n\t\t\t\tif (dx1 === undefined) break;\n\t\t\t\tconst dy1 = stack.shift();\n\t\t\t\tif (dy1 === undefined) break;\n\t\t\t\tconst dx2 = stack.shift();\n\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\tconst dy2 = stack.shift();\n\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\tconst dx3 = stack.shift();\n\t\t\t\tif (dx3 === undefined) break;\n\t\t\t\tconst dy3 = stack.shift();\n\t\t\t\tif (dy3 === undefined) break;\n\t\t\t\taddCubicBezier(state, dx1, dy1, dx2, dy2, dx3, dy3);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.callsubr: {\n\t\t\tconst index = stack.pop();\n\t\t\tif (index === undefined) break;\n\t\t\tconst biasedIndex = index + getSubrBias(localSubrs.length);\n\t\t\tconst subr = localSubrs[biasedIndex];\n\t\t\tif (subr) {\n\t\t\t\texecuteCharString(state, subr, globalSubrs, localSubrs);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.callgsubr: {\n\t\t\tconst index = stack.pop();\n\t\t\tif (index === undefined) break;\n\t\t\tconst biasedIndex = index + getSubrBias(globalSubrs.length);\n\t\t\tconst subr = globalSubrs[biasedIndex];\n\t\t\tif (subr) {\n\t\t\t\texecuteCharString(state, subr, globalSubrs, localSubrs);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.return_:\n\t\t\t// Return from subroutine - handled by caller\n\t\t\tbreak;\n\n\t\tcase Op.endchar: {\n\t\t\tif (stack.length > 0 && !state.haveWidth) {\n\t\t\t\tconst width = stack.shift();\n\t\t\t\tif (width === undefined) break;\n\t\t\t\tstate.width = width;\n\t\t\t\tstate.haveWidth = true;\n\t\t\t}\n\t\t\t// Close current contour\n\t\t\tif (state.currentContour.length > 0) {\n\t\t\t\tstate.contours.push(state.currentContour);\n\t\t\t\tstate.currentContour = [];\n\t\t\t}\n\t\t\tstack.length = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Flex operators\n\t\tcase Op.flex: {\n\t\t\t// 12 arguments: dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd\n\t\t\tif (stack.length >= 13) {\n\t\t\t\tconst dx1 = stack.shift();\n\t\t\t\tif (dx1 === undefined) break;\n\t\t\t\tconst dy1 = stack.shift();\n\t\t\t\tif (dy1 === undefined) break;\n\t\t\t\tconst dx2 = stack.shift();\n\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\tconst dy2 = stack.shift();\n\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\tconst dx3 = stack.shift();\n\t\t\t\tif (dx3 === undefined) break;\n\t\t\t\tconst dy3 = stack.shift();\n\t\t\t\tif (dy3 === undefined) break;\n\t\t\t\tconst dx4 = stack.shift();\n\t\t\t\tif (dx4 === undefined) break;\n\t\t\t\tconst dy4 = stack.shift();\n\t\t\t\tif (dy4 === undefined) break;\n\t\t\t\tconst dx5 = stack.shift();\n\t\t\t\tif (dx5 === undefined) break;\n\t\t\t\tconst dy5 = stack.shift();\n\t\t\t\tif (dy5 === undefined) break;\n\t\t\t\tconst dx6 = stack.shift();\n\t\t\t\tif (dx6 === undefined) break;\n\t\t\t\tconst dy6 = stack.shift();\n\t\t\t\tif (dy6 === undefined) break;\n\t\t\t\tstack.shift(); // fd (flex depth) - not used for rendering\n\t\t\t\taddCubicBezier(state, dx1, dy1, dx2, dy2, dx3, dy3);\n\t\t\t\taddCubicBezier(state, dx4, dy4, dx5, dy5, dx6, dy6);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.hflex: {\n\t\t\t// dx1 dx2 dy2 dx3 dx4 dx5 dx6\n\t\t\tif (stack.length >= 7) {\n\t\t\t\tconst dx1 = stack.shift();\n\t\t\t\tif (dx1 === undefined) break;\n\t\t\t\tconst dx2 = stack.shift();\n\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\tconst dy2 = stack.shift();\n\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\tconst dx3 = stack.shift();\n\t\t\t\tif (dx3 === undefined) break;\n\t\t\t\tconst dx4 = stack.shift();\n\t\t\t\tif (dx4 === undefined) break;\n\t\t\t\tconst dx5 = stack.shift();\n\t\t\t\tif (dx5 === undefined) break;\n\t\t\t\tconst dx6 = stack.shift();\n\t\t\t\tif (dx6 === undefined) break;\n\t\t\t\taddCubicBezier(state, dx1, 0, dx2, dy2, dx3, 0);\n\t\t\t\taddCubicBezier(state, dx4, 0, dx5, -dy2, dx6, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.hflex1: {\n\t\t\t// dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6\n\t\t\tif (stack.length >= 9) {\n\t\t\t\tconst dx1 = stack.shift();\n\t\t\t\tif (dx1 === undefined) break;\n\t\t\t\tconst dy1 = stack.shift();\n\t\t\t\tif (dy1 === undefined) break;\n\t\t\t\tconst dx2 = stack.shift();\n\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\tconst dy2 = stack.shift();\n\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\tconst dx3 = stack.shift();\n\t\t\t\tif (dx3 === undefined) break;\n\t\t\t\tconst dx4 = stack.shift();\n\t\t\t\tif (dx4 === undefined) break;\n\t\t\t\tconst dx5 = stack.shift();\n\t\t\t\tif (dx5 === undefined) break;\n\t\t\t\tconst dy5 = stack.shift();\n\t\t\t\tif (dy5 === undefined) break;\n\t\t\t\tconst dx6 = stack.shift();\n\t\t\t\tif (dx6 === undefined) break;\n\t\t\t\taddCubicBezier(state, dx1, dy1, dx2, dy2, dx3, 0);\n\t\t\t\taddCubicBezier(state, dx4, 0, dx5, dy5, dx6, -(dy1 + dy2 + dy5));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.flex1: {\n\t\t\t// dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6\n\t\t\tif (stack.length >= 11) {\n\t\t\t\tconst dx1 = stack.shift();\n\t\t\t\tif (dx1 === undefined) break;\n\t\t\t\tconst dy1 = stack.shift();\n\t\t\t\tif (dy1 === undefined) break;\n\t\t\t\tconst dx2 = stack.shift();\n\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\tconst dy2 = stack.shift();\n\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\tconst dx3 = stack.shift();\n\t\t\t\tif (dx3 === undefined) break;\n\t\t\t\tconst dy3 = stack.shift();\n\t\t\t\tif (dy3 === undefined) break;\n\t\t\t\tconst dx4 = stack.shift();\n\t\t\t\tif (dx4 === undefined) break;\n\t\t\t\tconst dy4 = stack.shift();\n\t\t\t\tif (dy4 === undefined) break;\n\t\t\t\tconst dx5 = stack.shift();\n\t\t\t\tif (dx5 === undefined) break;\n\t\t\t\tconst dy5 = stack.shift();\n\t\t\t\tif (dy5 === undefined) break;\n\t\t\t\tconst d6 = stack.shift();\n\t\t\t\tif (d6 === undefined) break;\n\n\t\t\t\tconst dx = dx1 + dx2 + dx3 + dx4 + dx5;\n\t\t\t\tconst dy = dy1 + dy2 + dy3 + dy4 + dy5;\n\n\t\t\t\tlet dx6: number, dy6: number;\n\t\t\t\tif (Math.abs(dx) > Math.abs(dy)) {\n\t\t\t\t\tdx6 = d6;\n\t\t\t\t\tdy6 = -dy;\n\t\t\t\t} else {\n\t\t\t\t\tdx6 = -dx;\n\t\t\t\t\tdy6 = d6;\n\t\t\t\t}\n\n\t\t\t\taddCubicBezier(state, dx1, dy1, dx2, dy2, dx3, dy3);\n\t\t\t\taddCubicBezier(state, dx4, dy4, dx5, dy5, dx6, dy6);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t// Arithmetic operators\n\t\tcase Op.and_: {\n\t\t\tconst b = stack.pop();\n\t\t\tif (b === undefined) break;\n\t\t\tconst a = stack.pop();\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(a && b ? 1 : 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.or_: {\n\t\t\tconst b = stack.pop();\n\t\t\tif (b === undefined) break;\n\t\t\tconst a = stack.pop();\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(a || b ? 1 : 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.not_: {\n\t\t\tconst a = stack.pop();\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(a ? 0 : 1);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.abs_: {\n\t\t\tconst a = stack.pop();\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(Math.abs(a));\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.add_: {\n\t\t\tconst b = stack.pop();\n\t\t\tif (b === undefined) break;\n\t\t\tconst a = stack.pop();\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(a + b);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.sub_: {\n\t\t\tconst b = stack.pop();\n\t\t\tif (b === undefined) break;\n\t\t\tconst a = stack.pop();\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(a - b);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.div_: {\n\t\t\tconst b = stack.pop();\n\t\t\tif (b === undefined) break;\n\t\t\tconst a = stack.pop();\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(a / b);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.neg_: {\n\t\t\tconst a = stack.pop();\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(-a);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.eq_: {\n\t\t\tconst b = stack.pop();\n\t\t\tif (b === undefined) break;\n\t\t\tconst a = stack.pop();\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(a === b ? 1 : 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.drop_: {\n\t\t\tstack.pop();\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.put_: {\n\t\t\tconst i = stack.pop();\n\t\t\tif (i === undefined) break;\n\t\t\tconst val = stack.pop();\n\t\t\tif (val === undefined) break;\n\t\t\tstate.transientArray[i] = val;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.get_: {\n\t\t\tconst i = stack.pop();\n\t\t\tif (i === undefined) break;\n\t\t\tstack.push(state.transientArray[i] ?? 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.ifelse_: {\n\t\t\tconst v2 = stack.pop();\n\t\t\tif (v2 === undefined) break;\n\t\t\tconst v1 = stack.pop();\n\t\t\tif (v1 === undefined) break;\n\t\t\tconst s2 = stack.pop();\n\t\t\tif (s2 === undefined) break;\n\t\t\tconst s1 = stack.pop();\n\t\t\tif (s1 === undefined) break;\n\t\t\tstack.push(v1 <= v2 ? s1 : s2);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.random_: {\n\t\t\tstack.push(Math.random());\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.mul_: {\n\t\t\tconst b = stack.pop();\n\t\t\tif (b === undefined) break;\n\t\t\tconst a = stack.pop();\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(a * b);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.sqrt_: {\n\t\t\tconst a = stack.pop();\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(Math.sqrt(a));\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.dup_: {\n\t\t\tconst a = stack[stack.length - 1];\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(a);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.exch_: {\n\t\t\tconst b = stack.pop();\n\t\t\tif (b === undefined) break;\n\t\t\tconst a = stack.pop();\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(b, a);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.index_: {\n\t\t\tconst i = stack.pop();\n\t\t\tif (i === undefined) break;\n\t\t\tconst idx = stack.length - 1 - i;\n\t\t\tstack.push(stack[idx] ?? 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.roll_: {\n\t\t\tconst j = stack.pop();\n\t\t\tif (j === undefined) break;\n\t\t\tconst n = stack.pop();\n\t\t\tif (n === undefined) break;\n\t\t\tif (n > 0) {\n\t\t\t\tconst items = stack.splice(-n);\n\t\t\t\tconst shift = ((j % n) + n) % n;\n\t\t\t\tfor (let i = 0; i < n; i++) {\n\t\t\t\t\tconst item = items[(i + shift) % n];\n\t\t\t\t\tif (item !== undefined) {\n\t\t\t\t\t\tstack.push(item);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t// CFF2 blend operator\n\t\tcase Op.blend: {\n\t\t\tif (!state.axisCoords || !state.vstore) break;\n\n\t\t\tconst n = stack.pop();\n\t\t\tif (n === undefined) break;\n\t\t\tconst regionCount =\n\t\t\t\tstate.vstore.itemVariationData[state.vsindex]?.regionIndexCount ?? 0;\n\n\t\t\t// For each of n values, there are regionCount deltas\n\t\t\tconst totalDeltaCount = n * regionCount;\n\t\t\tconst deltas = stack.splice(-totalDeltaCount);\n\t\t\tconst defaults = stack.splice(-n);\n\n\t\t\tfor (let i = 0; i < n; i++) {\n\t\t\t\tconst defaultVal = defaults[i];\n\t\t\t\tif (defaultVal === undefined) continue;\n\t\t\t\tlet value = defaultVal;\n\t\t\t\tfor (let r = 0; r < regionCount; r++) {\n\t\t\t\t\tconst delta = deltas[i * regionCount + r];\n\t\t\t\t\tif (delta === undefined) continue;\n\t\t\t\t\tconst scalar = computeRegionScalar(\n\t\t\t\t\t\tstate.vstore,\n\t\t\t\t\t\tstate.vsindex,\n\t\t\t\t\t\tr,\n\t\t\t\t\t\tstate.axisCoords,\n\t\t\t\t\t);\n\t\t\t\t\tvalue += delta * scalar;\n\t\t\t\t}\n\t\t\t\tstack.push(value);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.vsindex: {\n\t\t\tconst vsindex = stack.pop();\n\t\t\tif (vsindex === undefined) break;\n\t\t\tstate.vsindex = vsindex;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.dotsection:\n\t\t\t// Deprecated, ignore\n\t\t\tbreak;\n\t}\n}\n\nfunction addCubicBezier(\n\tstate: CharStringState,\n\tdx1: number,\n\tdy1: number,\n\tdx2: number,\n\tdy2: number,\n\tdx3: number,\n\tdy3: number,\n): void {\n\t// CFF uses cubic Beziers\n\t// Store control points with onCurve: false and special marker for cubic\n\t// We use a convention: cubic control points are stored as pairs with a special flag\n\n\tconst x0 = state.x;\n\tconst y0 = state.y;\n\tconst x1 = x0 + dx1;\n\tconst y1 = y0 + dy1;\n\tconst x2 = x1 + dx2;\n\tconst y2 = y1 + dy2;\n\tconst x3 = x2 + dx3;\n\tconst y3 = y2 + dy3;\n\n\t// Store as: cp1 (cubic=true), cp2 (cubic=true), endpoint (onCurve=true)\n\t// The 'cubic' property distinguishes this from TrueType quadratic off-curve points\n\tstate.currentContour.push({ x: x1, y: y1, onCurve: false, cubic: true } as GlyphPoint);\n\tstate.currentContour.push({ x: x2, y: y2, onCurve: false, cubic: true } as GlyphPoint);\n\tstate.currentContour.push({ x: x3, y: y3, onCurve: true });\n\n\tstate.x = x3;\n\tstate.y = y3;\n}\n\nfunction approximateCubicWithQuadratics(\n\tstate: CharStringState,\n\tx0: number,\n\ty0: number,\n\tx1: number,\n\ty1: number,\n\tx2: number,\n\ty2: number,\n\tx3: number,\n\ty3: number,\n\tdepth: number,\n): void {\n\t// Maximum recursion depth\n\tif (depth > 4) {\n\t\t// Just use a simple quadratic approximation\n\t\tconst qx = (3 * (x1 + x2) - (x0 + x3)) / 4;\n\t\tconst qy = (3 * (y1 + y2) - (y0 + y3)) / 4;\n\t\tstate.currentContour.push({ x: qx, y: qy, onCurve: false });\n\t\tstate.currentContour.push({ x: x3, y: y3, onCurve: true });\n\t\treturn;\n\t}\n\n\t// Check if cubic is close enough to a quadratic\n\t// by measuring the distance from control points to the line\n\tconst tolerance = 0.5;\n\n\t// Calculate the quadratic control point that would give the same tangents\n\tconst qx = (3 * (x1 + x2) - (x0 + x3)) / 4;\n\tconst qy = (3 * (y1 + y2) - (y0 + y3)) / 4;\n\n\t// Check error - simplified check\n\tconst err1 =\n\t\tMath.abs(x1 - (x0 + 2 * qx) / 3 - x0 / 3) +\n\t\tMath.abs(y1 - (y0 + 2 * qy) / 3 - y0 / 3);\n\tconst err2 =\n\t\tMath.abs(x2 - (2 * qx + x3) / 3 - x3 / 3) +\n\t\tMath.abs(y2 - (2 * qy + y3) / 3 - y3 / 3);\n\n\tif (err1 + err2 < tolerance) {\n\t\t// Good enough approximation\n\t\tstate.currentContour.push({ x: qx, y: qy, onCurve: false });\n\t\tstate.currentContour.push({ x: x3, y: y3, onCurve: true });\n\t} else {\n\t\t// Subdivide the cubic\n\t\tconst mx1 = (x0 + x1) / 2;\n\t\tconst my1 = (y0 + y1) / 2;\n\t\tconst mx2 = (x1 + x2) / 2;\n\t\tconst my2 = (y1 + y2) / 2;\n\t\tconst mx3 = (x2 + x3) / 2;\n\t\tconst my3 = (y2 + y3) / 2;\n\n\t\tconst mmx1 = (mx1 + mx2) / 2;\n\t\tconst mmy1 = (my1 + my2) / 2;\n\t\tconst mmx2 = (mx2 + mx3) / 2;\n\t\tconst mmy2 = (my2 + my3) / 2;\n\n\t\tconst midx = (mmx1 + mmx2) / 2;\n\t\tconst midy = (mmy1 + mmy2) / 2;\n\n\t\t// Recurse on both halves\n\t\tapproximateCubicWithQuadratics(\n\t\t\tstate,\n\t\t\tx0,\n\t\t\ty0,\n\t\t\tmx1,\n\t\t\tmy1,\n\t\t\tmmx1,\n\t\t\tmmy1,\n\t\t\tmidx,\n\t\t\tmidy,\n\t\t\tdepth + 1,\n\t\t);\n\t\tapproximateCubicWithQuadratics(\n\t\t\tstate,\n\t\t\tmidx,\n\t\t\tmidy,\n\t\t\tmmx2,\n\t\t\tmmy2,\n\t\t\tmx3,\n\t\t\tmy3,\n\t\t\tx3,\n\t\t\ty3,\n\t\t\tdepth + 1,\n\t\t);\n\t}\n}\n\nfunction getSubrBias(count: number): number {\n\tif (count < 1240) return 107;\n\tif (count < 33900) return 1131;\n\treturn 32768;\n}\n\nfunction computeRegionScalar(\n\tvstore: ItemVariationStore,\n\tvsindex: number,\n\tregionIndex: number,\n\taxisCoords: number[],\n): number {\n\tconst data = vstore.itemVariationData[vsindex];\n\tif (!data) return 0;\n\n\tconst actualRegionIndex = data.regionIndexes[regionIndex];\n\tif (actualRegionIndex === undefined) return 0;\n\n\tconst region = vstore.variationRegionList.regions[actualRegionIndex];\n\tif (!region) return 0;\n\n\tlet scalar = 1;\n\tfor (let i = 0; i < region.axes.length && i < axisCoords.length; i++) {\n\t\tconst coords = region.axes[i];\n\t\tif (!coords) continue;\n\t\tconst coord = axisCoords[i];\n\t\tif (coord === undefined) continue;\n\n\t\tif (coord < coords.startCoord || coord > coords.endCoord) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (coord === coords.peakCoord) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (coord < coords.peakCoord) {\n\t\t\tscalar *=\n\t\t\t\t(coord - coords.startCoord) / (coords.peakCoord - coords.startCoord);\n\t\t} else {\n\t\t\tscalar *=\n\t\t\t\t(coords.endCoord - coord) / (coords.endCoord - coords.peakCoord);\n\t\t}\n\t}\n\n\treturn scalar;\n}\n\n/**\n * Get glyph width from CFF charstring\n */\nexport function getCffGlyphWidth(\n\tcff: CffTable,\n\t_glyphId: GlyphId,\n\tfontIndex: number = 0,\n): number {\n\t// Would need to parse charstring just enough to get width\n\t// For now, return nominalWidthX as default\n\tconst _topDict = cff.topDicts[fontIndex];\n\treturn 0; // Proper implementation would parse the charstring\n}\n", "import type { Reader } from \"../../font/binary/reader.ts\";\nimport type { GlyphId, uint16 } from \"../../types.ts\";\n\n/** Coverage table - maps glyph IDs to coverage indices */\nexport interface Coverage {\n\t/** Get coverage index for a glyph ID, or null if not covered */\n\tget(glyphId: GlyphId): number | null;\n\n\t/** Check if glyph is covered */\n\tcovers(glyphId: GlyphId): boolean;\n\n\t/** Get all covered glyph IDs */\n\tglyphs(): GlyphId[];\n\n\t/** Number of covered glyphs */\n\treadonly size: number;\n}\n\n/** Format 1: Individual glyph IDs */\nclass CoverageFormat1 implements Coverage {\n\tprivate readonly glyphArray: Uint16Array;\n\tprivate readonly glyphSet: Set<GlyphId>;\n\n\tconstructor(glyphArray: Uint16Array) {\n\t\tthis.glyphArray = glyphArray;\n\t\tthis.glyphSet = new Set(glyphArray);\n\t}\n\n\tget size(): number {\n\t\treturn this.glyphArray.length;\n\t}\n\n\tget(glyphId: GlyphId): number | null {\n\t\t// Binary search since glyphs are sorted\n\t\tlet low = 0;\n\t\tlet high = this.glyphArray.length - 1;\n\n\t\twhile (low <= high) {\n\t\t\tconst mid = (low + high) >>> 1;\n\t\t\tconst midVal = this.glyphArray[mid];\n\t\t\tif (midVal === undefined) continue;\n\n\t\t\tif (midVal < glyphId) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else if (midVal > glyphId) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else {\n\t\t\t\treturn mid; // Found - return coverage index\n\t\t\t}\n\t\t}\n\n\t\treturn null; // Not found\n\t}\n\n\tcovers(glyphId: GlyphId): boolean {\n\t\treturn this.glyphSet.has(glyphId);\n\t}\n\n\tglyphs(): GlyphId[] {\n\t\treturn Array.from(this.glyphArray);\n\t}\n}\n\n/** Range record for Format 2 */\ninterface RangeRecord {\n\tstartGlyphId: GlyphId;\n\tendGlyphId: GlyphId;\n\tstartCoverageIndex: uint16;\n}\n\n/** Format 2: Ranges of glyph IDs */\nclass CoverageFormat2 implements Coverage {\n\tprivate readonly ranges: RangeRecord[];\n\tprivate readonly _size: number;\n\n\tconstructor(ranges: RangeRecord[]) {\n\t\tthis.ranges = ranges;\n\t\t// Calculate total size\n\t\tif (ranges.length === 0) {\n\t\t\tthis._size = 0;\n\t\t} else {\n\t\t\tconst lastRange = ranges[ranges.length - 1];\n\t\t\tif (lastRange) {\n\t\t\t\tthis._size =\n\t\t\t\t\tlastRange.startCoverageIndex +\n\t\t\t\t\t(lastRange.endGlyphId - lastRange.startGlyphId + 1);\n\t\t\t} else {\n\t\t\t\tthis._size = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tget(glyphId: GlyphId): number | null {\n\t\t// Binary search through ranges\n\t\tlet low = 0;\n\t\tlet high = this.ranges.length - 1;\n\n\t\twhile (low <= high) {\n\t\t\tconst mid = (low + high) >>> 1;\n\t\t\tconst range = this.ranges[mid];\n\t\t\tif (!range) continue;\n\n\t\t\tif (glyphId > range.endGlyphId) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else if (glyphId < range.startGlyphId) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else {\n\t\t\t\t// Found - calculate coverage index\n\t\t\t\treturn range.startCoverageIndex + (glyphId - range.startGlyphId);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tcovers(glyphId: GlyphId): boolean {\n\t\treturn this.get(glyphId) !== null;\n\t}\n\n\tglyphs(): GlyphId[] {\n\t\tconst result: GlyphId[] = [];\n\t\tfor (const range of this.ranges) {\n\t\t\tfor (let g = range.startGlyphId; g <= range.endGlyphId; g++) {\n\t\t\t\tresult.push(g);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\n/** Parse a Coverage table */\nexport function parseCoverage(reader: Reader): Coverage {\n\tconst format = reader.uint16();\n\n\tif (format === 1) {\n\t\tconst glyphCount = reader.uint16();\n\t\tconst glyphArray = reader.uint16Array(glyphCount);\n\t\treturn new CoverageFormat1(glyphArray);\n\t}\n\n\tif (format === 2) {\n\t\tconst rangeCount = reader.uint16();\n\t\tconst ranges: RangeRecord[] = new Array(rangeCount);\n\n\t\tfor (let i = 0; i < rangeCount; i++) {\n\t\t\tranges[i] = {\n\t\t\t\tstartGlyphId: reader.uint16(),\n\t\t\t\tendGlyphId: reader.uint16(),\n\t\t\t\tstartCoverageIndex: reader.uint16(),\n\t\t\t};\n\t\t}\n\n\t\treturn new CoverageFormat2(ranges);\n\t}\n\n\tthrow new Error(`Unknown Coverage format: ${format}`);\n}\n\n/** Parse Coverage from offset (creates sub-reader) */\nexport function parseCoverageAt(reader: Reader, offset: number): Coverage {\n\treturn parseCoverage(reader.sliceFrom(offset));\n}\n", "import type { Reader } from \"../../font/binary/reader.ts\";\nimport type { int16, uint16 } from \"../../types.ts\";\n\n/**\n * Device table - pixel-level adjustments for different PPEM sizes\n * Used in GPOS for fine-tuning positioning at specific sizes\n */\n\nexport interface DeviceTable {\n\tstartSize: uint16;\n\tendSize: uint16;\n\tdeltaFormat: uint16;\n\t/** Delta values indexed by (ppem - startSize) */\n\tdeltaValues: int16[];\n}\n\n/** VariationIndex table for variable fonts (shares format with Device) */\nexport interface VariationIndexTable {\n\tdeltaSetOuterIndex: uint16;\n\tdeltaSetInnerIndex: uint16;\n}\n\n/** Combined type - can be either Device or VariationIndex */\nexport type DeviceOrVariationIndex = DeviceTable | VariationIndexTable;\n\n/** Check if this is a VariationIndex table */\nexport function isVariationIndexTable(\n\ttable: DeviceOrVariationIndex,\n): table is VariationIndexTable {\n\treturn \"deltaSetOuterIndex\" in table;\n}\n\n/** Parse Device or VariationIndex table at offset */\nexport function parseDeviceAt(\n\treader: Reader,\n\toffset: number,\n): DeviceOrVariationIndex | null {\n\tif (offset === 0) return null;\n\treturn parseDevice(reader.sliceFrom(offset));\n}\n\n/** Parse Device or VariationIndex table */\nexport function parseDevice(reader: Reader): DeviceOrVariationIndex {\n\tconst startSize = reader.uint16();\n\tconst endSize = reader.uint16();\n\tconst deltaFormat = reader.uint16();\n\n\t// Format 0x8000 indicates VariationIndex table\n\tif (deltaFormat === 0x8000) {\n\t\treturn {\n\t\t\tdeltaSetOuterIndex: startSize,\n\t\t\tdeltaSetInnerIndex: endSize,\n\t\t};\n\t}\n\n\tconst deltaValues: int16[] = [];\n\n\tif (deltaFormat >= 1 && deltaFormat <= 3) {\n\t\tconst count = endSize - startSize + 1;\n\t\tconst bitsPerValue = 1 << deltaFormat; // 2, 4, or 8 bits\n\t\tconst valuesPerWord = 16 / bitsPerValue;\n\t\tconst mask = (1 << bitsPerValue) - 1;\n\t\tconst signBit = 1 << (bitsPerValue - 1);\n\n\t\tconst wordCount = Math.ceil(count / valuesPerWord);\n\t\tlet valueIndex = 0;\n\n\t\tfor (let w = 0; w < wordCount; w++) {\n\t\t\tconst word = reader.uint16();\n\n\t\t\tfor (\n\t\t\t\tlet v = 0;\n\t\t\t\tv < valuesPerWord && valueIndex < count;\n\t\t\t\tv++, valueIndex++\n\t\t\t) {\n\t\t\t\tconst shift = 16 - bitsPerValue * (v + 1);\n\t\t\t\tlet delta = (word >> shift) & mask;\n\n\t\t\t\t// Sign extend\n\t\t\t\tif (delta & signBit) {\n\t\t\t\t\tdelta = delta - (1 << bitsPerValue);\n\t\t\t\t}\n\n\t\t\t\tdeltaValues.push(delta);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tstartSize,\n\t\tendSize,\n\t\tdeltaFormat,\n\t\tdeltaValues,\n\t};\n}\n\n/**\n * Get delta adjustment for a specific PPEM size\n * Returns 0 if the size is outside the table's range\n */\nexport function getDeviceDelta(device: DeviceTable, ppem: number): int16 {\n\tif (ppem < device.startSize || ppem > device.endSize) {\n\t\treturn 0;\n\t}\n\tconst index = ppem - device.startSize;\n\treturn device.deltaValues[index] ?? 0;\n}\n\n/**\n * Apply Device table adjustment to a value\n * For variable fonts, this would need ItemVariationStore lookup instead\n */\nexport function applyDeviceAdjustment(\n\tdevice: DeviceOrVariationIndex | null,\n\tvalue: number,\n\tppem: number,\n): number {\n\tif (!device) return value;\n\n\tif (isVariationIndexTable(device)) {\n\t\t// VariationIndex tables need ItemVariationStore to resolve\n\t\t// For now, return value unchanged (proper support requires fvar integration)\n\t\treturn value;\n\t}\n\n\treturn value + getDeviceDelta(device, ppem);\n}\n\n/**\n * Parsed value record with resolved Device tables\n */\nexport interface ResolvedValueRecord {\n\txPlacement: number;\n\tyPlacement: number;\n\txAdvance: number;\n\tyAdvance: number;\n\txPlaDevice: DeviceOrVariationIndex | null;\n\tyPlaDevice: DeviceOrVariationIndex | null;\n\txAdvDevice: DeviceOrVariationIndex | null;\n\tyAdvDevice: DeviceOrVariationIndex | null;\n}\n\n/**\n * Apply all Device adjustments to a resolved value record\n */\nexport function applyDeviceAdjustments(\n\trecord: ResolvedValueRecord,\n\tppem: number,\n): {\n\txPlacement: number;\n\tyPlacement: number;\n\txAdvance: number;\n\tyAdvance: number;\n} {\n\treturn {\n\t\txPlacement: applyDeviceAdjustment(\n\t\t\trecord.xPlaDevice,\n\t\t\trecord.xPlacement,\n\t\t\tppem,\n\t\t),\n\t\tyPlacement: applyDeviceAdjustment(\n\t\t\trecord.yPlaDevice,\n\t\t\trecord.yPlacement,\n\t\t\tppem,\n\t\t),\n\t\txAdvance: applyDeviceAdjustment(record.xAdvDevice, record.xAdvance, ppem),\n\t\tyAdvance: applyDeviceAdjustment(record.yAdvDevice, record.yAdvance, ppem),\n\t};\n}\n", "import type { Reader } from \"../../font/binary/reader.ts\";\nimport type { Tag, uint16 } from \"../../types.ts\";\n\n/** Language system record */\nexport interface LangSysRecord {\n\tlangSysTag: Tag;\n\tlangSys: LangSys;\n}\n\n/** Language system table */\nexport interface LangSys {\n\t/** Required feature index (0xFFFF if none) */\n\trequiredFeatureIndex: uint16;\n\t/** Feature indices */\n\tfeatureIndices: uint16[];\n}\n\n/** Script record */\nexport interface ScriptRecord {\n\tscriptTag: Tag;\n\tscript: Script;\n}\n\n/** Script table */\nexport interface Script {\n\t/** Default language system (may be null) */\n\tdefaultLangSys: LangSys | null;\n\t/** Language system records */\n\tlangSysRecords: LangSysRecord[];\n}\n\n/** Script list table */\nexport interface ScriptList {\n\tscripts: ScriptRecord[];\n}\n\n/** Feature record */\nexport interface FeatureRecord {\n\tfeatureTag: Tag;\n\tfeature: Feature;\n}\n\n/** Feature table */\nexport interface Feature {\n\t/** Feature parameters offset (usually 0) */\n\tfeatureParamsOffset: uint16;\n\t/** Lookup indices */\n\tlookupListIndices: uint16[];\n}\n\n/** Feature list table */\nexport interface FeatureList {\n\tfeatures: FeatureRecord[];\n}\n\n/** Lookup table header */\nexport interface LookupHeader {\n\tlookupType: uint16;\n\tlookupFlag: uint16;\n\tsubtableOffsets: uint16[];\n\t/** Mark filtering set (if UseMarkFilteringSet flag is set) */\n\tmarkFilteringSet?: uint16;\n}\n\n/** Lookup flags */\nexport const LookupFlag = {\n\tRightToLeft: 0x0001,\n\tIgnoreBaseGlyphs: 0x0002,\n\tIgnoreLigatures: 0x0004,\n\tIgnoreMarks: 0x0008,\n\tUseMarkFilteringSet: 0x0010,\n\t// Bits 5-7 reserved\n\tMarkAttachmentTypeMask: 0xff00,\n} as const;\n\n/** Extract mark attachment type from lookup flag */\nexport function getMarkAttachmentType(lookupFlag: uint16): number {\n\treturn (lookupFlag & LookupFlag.MarkAttachmentTypeMask) >> 8;\n}\n\n/** Parse ScriptList */\nexport function parseScriptList(reader: Reader): ScriptList {\n\tconst scriptCount = reader.uint16();\n\tconst scriptRecords: Array<{ tag: Tag; offset: uint16 }> = [];\n\n\tfor (let i = 0; i < scriptCount; i++) {\n\t\tscriptRecords.push({\n\t\t\ttag: reader.tag(),\n\t\t\toffset: reader.offset16(),\n\t\t});\n\t}\n\n\tconst scripts: ScriptRecord[] = [];\n\tfor (const record of scriptRecords) {\n\t\tconst scriptReader = reader.sliceFrom(record.offset);\n\t\tconst script = parseScript(scriptReader);\n\t\tscripts.push({\n\t\t\tscriptTag: record.tag,\n\t\t\tscript,\n\t\t});\n\t}\n\n\treturn { scripts };\n}\n\nfunction parseScript(reader: Reader): Script {\n\tconst defaultLangSysOffset = reader.offset16();\n\tconst langSysCount = reader.uint16();\n\n\tconst langSysRecords: Array<{ tag: Tag; offset: uint16 }> = [];\n\tfor (let i = 0; i < langSysCount; i++) {\n\t\tlangSysRecords.push({\n\t\t\ttag: reader.tag(),\n\t\t\toffset: reader.offset16(),\n\t\t});\n\t}\n\n\t// Parse default language system\n\tlet defaultLangSys: LangSys | null = null;\n\tif (defaultLangSysOffset !== 0) {\n\t\tdefaultLangSys = parseLangSys(reader.sliceFrom(defaultLangSysOffset));\n\t}\n\n\t// Parse language system records\n\tconst parsedLangSysRecords: LangSysRecord[] = [];\n\tfor (const record of langSysRecords) {\n\t\tconst langSys = parseLangSys(reader.sliceFrom(record.offset));\n\t\tparsedLangSysRecords.push({\n\t\t\tlangSysTag: record.tag,\n\t\t\tlangSys,\n\t\t});\n\t}\n\n\treturn {\n\t\tdefaultLangSys,\n\t\tlangSysRecords: parsedLangSysRecords,\n\t};\n}\n\nfunction parseLangSys(reader: Reader): LangSys {\n\tconst _lookupOrderOffset = reader.offset16(); // Reserved, always 0\n\tconst requiredFeatureIndex = reader.uint16();\n\tconst featureIndexCount = reader.uint16();\n\tconst featureIndices = Array.from(reader.uint16Array(featureIndexCount));\n\n\treturn {\n\t\trequiredFeatureIndex,\n\t\tfeatureIndices,\n\t};\n}\n\n/** Parse FeatureList */\nexport function parseFeatureList(reader: Reader): FeatureList {\n\tconst featureCount = reader.uint16();\n\tconst featureRecords: Array<{ tag: Tag; offset: uint16 }> = [];\n\n\tfor (let i = 0; i < featureCount; i++) {\n\t\tfeatureRecords.push({\n\t\t\ttag: reader.tag(),\n\t\t\toffset: reader.offset16(),\n\t\t});\n\t}\n\n\tconst features: FeatureRecord[] = [];\n\tfor (const record of featureRecords) {\n\t\tconst featureReader = reader.sliceFrom(record.offset);\n\t\tconst feature = parseFeature(featureReader);\n\t\tfeatures.push({\n\t\t\tfeatureTag: record.tag,\n\t\t\tfeature,\n\t\t});\n\t}\n\n\treturn { features };\n}\n\nfunction parseFeature(reader: Reader): Feature {\n\tconst featureParamsOffset = reader.offset16();\n\tconst lookupIndexCount = reader.uint16();\n\tconst lookupListIndices = Array.from(reader.uint16Array(lookupIndexCount));\n\n\treturn {\n\t\tfeatureParamsOffset,\n\t\tlookupListIndices,\n\t};\n}\n\n/** Parse lookup headers (does not parse subtables) */\nexport function parseLookupHeaders(reader: Reader): LookupHeader[] {\n\tconst lookupCount = reader.uint16();\n\tconst lookupOffsets = reader.uint16Array(lookupCount);\n\n\tconst headers: LookupHeader[] = [];\n\tfor (const offset of lookupOffsets) {\n\t\tconst lookupReader = reader.sliceFrom(offset);\n\t\theaders.push(parseLookupHeader(lookupReader));\n\t}\n\n\treturn headers;\n}\n\nfunction parseLookupHeader(reader: Reader): LookupHeader {\n\tconst lookupType = reader.uint16();\n\tconst lookupFlag = reader.uint16();\n\tconst subtableCount = reader.uint16();\n\tconst subtableOffsets = Array.from(reader.uint16Array(subtableCount));\n\n\tlet markFilteringSet: uint16 | undefined;\n\tif (lookupFlag & LookupFlag.UseMarkFilteringSet) {\n\t\tmarkFilteringSet = reader.uint16();\n\t}\n\n\treturn {\n\t\tlookupType,\n\t\tlookupFlag,\n\t\tsubtableOffsets,\n\t\tmarkFilteringSet,\n\t};\n}\n\n/** Find script in script list */\nexport function findScript(\n\tscriptList: ScriptList,\n\tscriptTag: Tag,\n): Script | null {\n\tfor (const record of scriptList.scripts) {\n\t\tif (record.scriptTag === scriptTag) {\n\t\t\treturn record.script;\n\t\t}\n\t}\n\treturn null;\n}\n\n/** Find language system in script */\nexport function findLangSys(\n\tscript: Script,\n\tlangSysTag: Tag | null,\n): LangSys | null {\n\tif (langSysTag === null) {\n\t\treturn script.defaultLangSys;\n\t}\n\n\tfor (const record of script.langSysRecords) {\n\t\tif (record.langSysTag === langSysTag) {\n\t\t\treturn record.langSys;\n\t\t}\n\t}\n\n\treturn script.defaultLangSys;\n}\n\n/** Get feature by index */\nexport function getFeature(\n\tfeatureList: FeatureList,\n\tindex: number,\n): FeatureRecord | null {\n\treturn featureList.features[index] ?? null;\n}\n", "import {\n\ttype ClassDef,\n\tparseClassDefAt,\n} from \"../../layout/structures/class-def.ts\";\nimport {\n\ttype Coverage,\n\tparseCoverageAt,\n} from \"../../layout/structures/coverage.ts\";\nimport type { GlyphId, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\nimport type { GposLookup } from \"./gpos.ts\";\n\n/** Position lookup record - applies a lookup at a position */\nexport interface PosLookupRecord {\n\tsequenceIndex: uint16; // Position in input sequence\n\tlookupListIndex: uint16; // Lookup to apply\n}\n\n/** Context positioning lookup (Type 7) */\nexport interface ContextPosLookup extends GposLookup {\n\ttype: 7;\n\tsubtables: ContextPosSubtable[];\n}\n\nexport type ContextPosSubtable =\n\t| ContextPosFormat1\n\t| ContextPosFormat2\n\t| ContextPosFormat3;\n\n/** Format 1: Simple glyph contexts */\nexport interface ContextPosFormat1 {\n\tformat: 1;\n\tcoverage: Coverage;\n\truleSets: (PosContextRule[] | null)[];\n}\n\nexport interface PosContextRule {\n\tglyphCount: uint16;\n\tinputSequence: GlyphId[]; // Excludes first glyph (in coverage)\n\tlookupRecords: PosLookupRecord[];\n}\n\n/** Format 2: Class-based contexts */\nexport interface ContextPosFormat2 {\n\tformat: 2;\n\tcoverage: Coverage;\n\tclassDef: ClassDef;\n\tclassRuleSets: (PosClassRule[] | null)[];\n}\n\nexport interface PosClassRule {\n\tglyphCount: uint16;\n\tinputClasses: uint16[]; // Excludes first class\n\tlookupRecords: PosLookupRecord[];\n}\n\n/** Format 3: Coverage-based contexts */\nexport interface ContextPosFormat3 {\n\tformat: 3;\n\tcoverages: Coverage[];\n\tlookupRecords: PosLookupRecord[];\n}\n\n/** Chaining context positioning lookup (Type 8) */\nexport interface ChainingContextPosLookup extends GposLookup {\n\ttype: 8;\n\tsubtables: ChainingContextPosSubtable[];\n}\n\nexport type ChainingContextPosSubtable =\n\t| ChainingContextPosFormat1\n\t| ChainingContextPosFormat2\n\t| ChainingContextPosFormat3;\n\n/** Format 1: Simple chaining context */\nexport interface ChainingContextPosFormat1 {\n\tformat: 1;\n\tcoverage: Coverage;\n\tchainRuleSets: (PosChainRule[] | null)[];\n}\n\nexport interface PosChainRule {\n\tbacktrackSequence: GlyphId[];\n\tinputSequence: GlyphId[]; // Excludes first glyph\n\tlookaheadSequence: GlyphId[];\n\tlookupRecords: PosLookupRecord[];\n}\n\n/** Format 2: Class-based chaining context */\nexport interface ChainingContextPosFormat2 {\n\tformat: 2;\n\tcoverage: Coverage;\n\tbacktrackClassDef: ClassDef;\n\tinputClassDef: ClassDef;\n\tlookaheadClassDef: ClassDef;\n\tchainClassRuleSets: (PosChainClassRule[] | null)[];\n}\n\nexport interface PosChainClassRule {\n\tbacktrackClasses: uint16[];\n\tinputClasses: uint16[]; // Excludes first class\n\tlookaheadClasses: uint16[];\n\tlookupRecords: PosLookupRecord[];\n}\n\n/** Format 3: Coverage-based chaining context */\nexport interface ChainingContextPosFormat3 {\n\tformat: 3;\n\tbacktrackCoverages: Coverage[];\n\tinputCoverages: Coverage[];\n\tlookaheadCoverages: Coverage[];\n\tlookupRecords: PosLookupRecord[];\n}\n\nexport function parseContextPos(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): ContextPosSubtable[] {\n\tconst subtables: ContextPosSubtable[] = [];\n\n\tfor (const offset of subtableOffsets) {\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tswitch (format) {\n\t\t\tcase 1:\n\t\t\t\tsubtables.push(parseContextPosFormat1(r));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tsubtables.push(parseContextPosFormat2(r));\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tsubtables.push(parseContextPosFormat3(r));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nfunction parseContextPosFormat1(reader: Reader): ContextPosFormat1 {\n\tconst coverageOffset = reader.offset16();\n\tconst ruleSetCount = reader.uint16();\n\tconst ruleSetOffsets = reader.uint16Array(ruleSetCount);\n\n\tconst coverage = parseCoverageAt(reader, coverageOffset);\n\tconst ruleSets: (PosContextRule[] | null)[] = [];\n\n\tfor (const ruleSetOffset of ruleSetOffsets) {\n\t\tif (ruleSetOffset === 0) {\n\t\t\truleSets.push(null);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst rsReader = reader.sliceFrom(ruleSetOffset);\n\t\tconst ruleCount = rsReader.uint16();\n\t\tconst ruleOffsets = rsReader.uint16Array(ruleCount);\n\n\t\tconst rules: PosContextRule[] = [];\n\t\tfor (const ruleOffset of ruleOffsets) {\n\t\t\tconst ruleReader = rsReader.sliceFrom(ruleOffset);\n\t\t\tconst glyphCount = ruleReader.uint16();\n\t\t\tconst lookupCount = ruleReader.uint16();\n\t\t\tconst inputSequence = Array.from(ruleReader.uint16Array(glyphCount - 1));\n\t\t\tconst lookupRecords = parsePosLookupRecords(ruleReader, lookupCount);\n\n\t\t\trules.push({ glyphCount, inputSequence, lookupRecords });\n\t\t}\n\n\t\truleSets.push(rules);\n\t}\n\n\treturn { format: 1, coverage, ruleSets };\n}\n\nfunction parseContextPosFormat2(reader: Reader): ContextPosFormat2 {\n\tconst coverageOffset = reader.offset16();\n\tconst classDefOffset = reader.offset16();\n\tconst classRuleSetCount = reader.uint16();\n\tconst classRuleSetOffsets = reader.uint16Array(classRuleSetCount);\n\n\tconst coverage = parseCoverageAt(reader, coverageOffset);\n\tconst classDef = parseClassDefAt(reader, classDefOffset);\n\tconst classRuleSets: (PosClassRule[] | null)[] = [];\n\n\tfor (const crsOffset of classRuleSetOffsets) {\n\t\tif (crsOffset === 0) {\n\t\t\tclassRuleSets.push(null);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst crsReader = reader.sliceFrom(crsOffset);\n\t\tconst ruleCount = crsReader.uint16();\n\t\tconst ruleOffsets = crsReader.uint16Array(ruleCount);\n\n\t\tconst rules: PosClassRule[] = [];\n\t\tfor (const ruleOffset of ruleOffsets) {\n\t\t\tconst ruleReader = crsReader.sliceFrom(ruleOffset);\n\t\t\tconst glyphCount = ruleReader.uint16();\n\t\t\tconst lookupCount = ruleReader.uint16();\n\t\t\tconst inputClasses = Array.from(ruleReader.uint16Array(glyphCount - 1));\n\t\t\tconst lookupRecords = parsePosLookupRecords(ruleReader, lookupCount);\n\n\t\t\trules.push({ glyphCount, inputClasses, lookupRecords });\n\t\t}\n\n\t\tclassRuleSets.push(rules);\n\t}\n\n\treturn { format: 2, coverage, classDef, classRuleSets };\n}\n\nfunction parseContextPosFormat3(reader: Reader): ContextPosFormat3 {\n\tconst glyphCount = reader.uint16();\n\tconst lookupCount = reader.uint16();\n\tconst coverageOffsets = reader.uint16Array(glyphCount);\n\n\tconst coverages: Coverage[] = [];\n\tfor (const offset of coverageOffsets) {\n\t\tcoverages.push(parseCoverageAt(reader, offset));\n\t}\n\n\tconst lookupRecords = parsePosLookupRecords(reader, lookupCount);\n\n\treturn { format: 3, coverages, lookupRecords };\n}\n\nexport function parseChainingContextPos(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): ChainingContextPosSubtable[] {\n\tconst subtables: ChainingContextPosSubtable[] = [];\n\n\tfor (const offset of subtableOffsets) {\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tswitch (format) {\n\t\t\tcase 1:\n\t\t\t\tsubtables.push(parseChainingPosFormat1(r));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tsubtables.push(parseChainingPosFormat2(r));\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tsubtables.push(parseChainingPosFormat3(r));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nfunction parseChainingPosFormat1(reader: Reader): ChainingContextPosFormat1 {\n\tconst coverageOffset = reader.offset16();\n\tconst chainRuleSetCount = reader.uint16();\n\tconst chainRuleSetOffsets = reader.uint16Array(chainRuleSetCount);\n\n\tconst coverage = parseCoverageAt(reader, coverageOffset);\n\tconst chainRuleSets: (PosChainRule[] | null)[] = [];\n\n\tfor (const crsOffset of chainRuleSetOffsets) {\n\t\tif (crsOffset === 0) {\n\t\t\tchainRuleSets.push(null);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst crsReader = reader.sliceFrom(crsOffset);\n\t\tconst ruleCount = crsReader.uint16();\n\t\tconst ruleOffsets = crsReader.uint16Array(ruleCount);\n\n\t\tconst rules: PosChainRule[] = [];\n\t\tfor (const ruleOffset of ruleOffsets) {\n\t\t\tconst ruleReader = crsReader.sliceFrom(ruleOffset);\n\n\t\t\tconst backtrackCount = ruleReader.uint16();\n\t\t\tconst backtrackSequence = Array.from(\n\t\t\t\truleReader.uint16Array(backtrackCount),\n\t\t\t);\n\n\t\t\tconst inputCount = ruleReader.uint16();\n\t\t\tconst inputSequence = Array.from(ruleReader.uint16Array(inputCount - 1));\n\n\t\t\tconst lookaheadCount = ruleReader.uint16();\n\t\t\tconst lookaheadSequence = Array.from(\n\t\t\t\truleReader.uint16Array(lookaheadCount),\n\t\t\t);\n\n\t\t\tconst lookupCount = ruleReader.uint16();\n\t\t\tconst lookupRecords = parsePosLookupRecords(ruleReader, lookupCount);\n\n\t\t\trules.push({\n\t\t\t\tbacktrackSequence,\n\t\t\t\tinputSequence,\n\t\t\t\tlookaheadSequence,\n\t\t\t\tlookupRecords,\n\t\t\t});\n\t\t}\n\n\t\tchainRuleSets.push(rules);\n\t}\n\n\treturn { format: 1, coverage, chainRuleSets };\n}\n\nfunction parseChainingPosFormat2(reader: Reader): ChainingContextPosFormat2 {\n\tconst coverageOffset = reader.offset16();\n\tconst backtrackClassDefOffset = reader.offset16();\n\tconst inputClassDefOffset = reader.offset16();\n\tconst lookaheadClassDefOffset = reader.offset16();\n\tconst chainClassRuleSetCount = reader.uint16();\n\tconst chainClassRuleSetOffsets = reader.uint16Array(chainClassRuleSetCount);\n\n\tconst coverage = parseCoverageAt(reader, coverageOffset);\n\tconst backtrackClassDef = parseClassDefAt(reader, backtrackClassDefOffset);\n\tconst inputClassDef = parseClassDefAt(reader, inputClassDefOffset);\n\tconst lookaheadClassDef = parseClassDefAt(reader, lookaheadClassDefOffset);\n\n\tconst chainClassRuleSets: (PosChainClassRule[] | null)[] = [];\n\n\tfor (const ccrsOffset of chainClassRuleSetOffsets) {\n\t\tif (ccrsOffset === 0) {\n\t\t\tchainClassRuleSets.push(null);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst ccrsReader = reader.sliceFrom(ccrsOffset);\n\t\tconst ruleCount = ccrsReader.uint16();\n\t\tconst ruleOffsets = ccrsReader.uint16Array(ruleCount);\n\n\t\tconst rules: PosChainClassRule[] = [];\n\t\tfor (const ruleOffset of ruleOffsets) {\n\t\t\tconst ruleReader = ccrsReader.sliceFrom(ruleOffset);\n\n\t\t\tconst backtrackCount = ruleReader.uint16();\n\t\t\tconst backtrackClasses = Array.from(\n\t\t\t\truleReader.uint16Array(backtrackCount),\n\t\t\t);\n\n\t\t\tconst inputCount = ruleReader.uint16();\n\t\t\tconst inputClasses = Array.from(ruleReader.uint16Array(inputCount - 1));\n\n\t\t\tconst lookaheadCount = ruleReader.uint16();\n\t\t\tconst lookaheadClasses = Array.from(\n\t\t\t\truleReader.uint16Array(lookaheadCount),\n\t\t\t);\n\n\t\t\tconst lookupCount = ruleReader.uint16();\n\t\t\tconst lookupRecords = parsePosLookupRecords(ruleReader, lookupCount);\n\n\t\t\trules.push({\n\t\t\t\tbacktrackClasses,\n\t\t\t\tinputClasses,\n\t\t\t\tlookaheadClasses,\n\t\t\t\tlookupRecords,\n\t\t\t});\n\t\t}\n\n\t\tchainClassRuleSets.push(rules);\n\t}\n\n\treturn {\n\t\tformat: 2,\n\t\tcoverage,\n\t\tbacktrackClassDef,\n\t\tinputClassDef,\n\t\tlookaheadClassDef,\n\t\tchainClassRuleSets,\n\t};\n}\n\nfunction parseChainingPosFormat3(reader: Reader): ChainingContextPosFormat3 {\n\tconst backtrackCount = reader.uint16();\n\tconst backtrackCoverageOffsets = reader.uint16Array(backtrackCount);\n\n\tconst inputCount = reader.uint16();\n\tconst inputCoverageOffsets = reader.uint16Array(inputCount);\n\n\tconst lookaheadCount = reader.uint16();\n\tconst lookaheadCoverageOffsets = reader.uint16Array(lookaheadCount);\n\n\tconst lookupCount = reader.uint16();\n\tconst lookupRecords = parsePosLookupRecords(reader, lookupCount);\n\n\tconst backtrackCoverages: Coverage[] = [];\n\tfor (const offset of backtrackCoverageOffsets) {\n\t\tbacktrackCoverages.push(parseCoverageAt(reader, offset));\n\t}\n\n\tconst inputCoverages: Coverage[] = [];\n\tfor (const offset of inputCoverageOffsets) {\n\t\tinputCoverages.push(parseCoverageAt(reader, offset));\n\t}\n\n\tconst lookaheadCoverages: Coverage[] = [];\n\tfor (const offset of lookaheadCoverageOffsets) {\n\t\tlookaheadCoverages.push(parseCoverageAt(reader, offset));\n\t}\n\n\treturn {\n\t\tformat: 3,\n\t\tbacktrackCoverages,\n\t\tinputCoverages,\n\t\tlookaheadCoverages,\n\t\tlookupRecords,\n\t};\n}\n\nfunction parsePosLookupRecords(\n\treader: Reader,\n\tcount: number,\n): PosLookupRecord[] {\n\tconst records: PosLookupRecord[] = [];\n\tfor (let i = 0; i < count; i++) {\n\t\trecords.push({\n\t\t\tsequenceIndex: reader.uint16(),\n\t\t\tlookupListIndex: reader.uint16(),\n\t\t});\n\t}\n\treturn records;\n}\n", "import {\n\ttype Coverage,\n\tparseCoverageAt,\n} from \"../../layout/structures/coverage.ts\";\nimport type { int16, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\nimport type { GposLookup } from \"./gpos.ts\";\n\n/** Anchor point for attachment */\nexport interface Anchor {\n\txCoordinate: int16;\n\tyCoordinate: int16;\n\t/** Contour point index (format 2) */\n\tanchorPoint?: uint16;\n\t/** Device table offsets (format 3) */\n\txDeviceOffset?: uint16;\n\tyDeviceOffset?: uint16;\n}\n\n/** Mark record */\nexport interface MarkRecord {\n\tmarkClass: uint16;\n\tmarkAnchor: Anchor;\n}\n\n/** Mark array */\nexport interface MarkArray {\n\tmarkRecords: MarkRecord[];\n}\n\n/** Base record for mark-to-base */\nexport interface BaseRecord {\n\tbaseAnchors: (Anchor | null)[]; // One per mark class\n}\n\n/** Ligature attach record */\nexport interface LigatureAttach {\n\tcomponentRecords: ComponentRecord[];\n}\n\n/** Component record for ligature */\nexport interface ComponentRecord {\n\tligatureAnchors: (Anchor | null)[]; // One per mark class\n}\n\n/** Mark2 record for mark-to-mark */\nexport interface Mark2Record {\n\tmark2Anchors: (Anchor | null)[]; // One per mark1 class\n}\n\n/** Cursive attachment lookup (Type 3) */\nexport interface CursivePosLookup extends GposLookup {\n\ttype: 3;\n\tsubtables: CursivePosSubtable[];\n}\n\nexport interface CursivePosSubtable {\n\tcoverage: Coverage;\n\tentryExitRecords: EntryExitRecord[];\n}\n\nexport interface EntryExitRecord {\n\tentryAnchor: Anchor | null;\n\texitAnchor: Anchor | null;\n}\n\n/** Mark-to-base attachment lookup (Type 4) */\nexport interface MarkBasePosLookup extends GposLookup {\n\ttype: 4;\n\tsubtables: MarkBasePosSubtable[];\n}\n\nexport interface MarkBasePosSubtable {\n\tmarkCoverage: Coverage;\n\tbaseCoverage: Coverage;\n\tmarkClassCount: uint16;\n\tmarkArray: MarkArray;\n\tbaseArray: BaseRecord[];\n}\n\n/** Mark-to-ligature attachment lookup (Type 5) */\nexport interface MarkLigaturePosLookup extends GposLookup {\n\ttype: 5;\n\tsubtables: MarkLigaturePosSubtable[];\n}\n\nexport interface MarkLigaturePosSubtable {\n\tmarkCoverage: Coverage;\n\tligatureCoverage: Coverage;\n\tmarkClassCount: uint16;\n\tmarkArray: MarkArray;\n\tligatureArray: LigatureAttach[];\n}\n\n/** Mark-to-mark attachment lookup (Type 6) */\nexport interface MarkMarkPosLookup extends GposLookup {\n\ttype: 6;\n\tsubtables: MarkMarkPosSubtable[];\n}\n\nexport interface MarkMarkPosSubtable {\n\tmark1Coverage: Coverage;\n\tmark2Coverage: Coverage;\n\tmarkClassCount: uint16;\n\tmark1Array: MarkArray;\n\tmark2Array: Mark2Record[];\n}\n\n// Parsing functions\n\nexport function parseAnchor(reader: Reader): Anchor {\n\tconst format = reader.uint16();\n\tconst xCoordinate = reader.int16();\n\tconst yCoordinate = reader.int16();\n\n\tconst anchor: Anchor = { xCoordinate, yCoordinate };\n\n\tif (format === 2) {\n\t\tanchor.anchorPoint = reader.uint16();\n\t} else if (format === 3) {\n\t\tanchor.xDeviceOffset = reader.uint16();\n\t\tanchor.yDeviceOffset = reader.uint16();\n\t}\n\n\treturn anchor;\n}\n\nexport function parseAnchorAt(reader: Reader, offset: number): Anchor | null {\n\tif (offset === 0) return null;\n\treturn parseAnchor(reader.sliceFrom(offset));\n}\n\nexport function parseMarkArray(reader: Reader): MarkArray {\n\tconst markCount = reader.uint16();\n\tconst markRecords: MarkRecord[] = [];\n\n\tconst recordData: Array<{ markClass: uint16; anchorOffset: uint16 }> = [];\n\tfor (let i = 0; i < markCount; i++) {\n\t\trecordData.push({\n\t\t\tmarkClass: reader.uint16(),\n\t\t\tanchorOffset: reader.uint16(),\n\t\t});\n\t}\n\n\tfor (const data of recordData) {\n\t\tconst markAnchor = parseAnchor(reader.sliceFrom(data.anchorOffset));\n\t\tmarkRecords.push({\n\t\t\tmarkClass: data.markClass,\n\t\t\tmarkAnchor,\n\t\t});\n\t}\n\n\treturn { markRecords };\n}\n\nexport function parseCursivePos(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): CursivePosSubtable[] {\n\tconst subtables: CursivePosSubtable[] = [];\n\n\tfor (const offset of subtableOffsets) {\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tif (format === 1) {\n\t\t\tconst coverageOffset = r.offset16();\n\t\t\tconst entryExitCount = r.uint16();\n\n\t\t\tconst entryExitData: Array<{ entryOffset: uint16; exitOffset: uint16 }> =\n\t\t\t\t[];\n\t\t\tfor (let i = 0; i < entryExitCount; i++) {\n\t\t\t\tentryExitData.push({\n\t\t\t\t\tentryOffset: r.uint16(),\n\t\t\t\t\texitOffset: r.uint16(),\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst coverage = parseCoverageAt(r, coverageOffset);\n\t\t\tconst entryExitRecords: EntryExitRecord[] = [];\n\n\t\t\tfor (const data of entryExitData) {\n\t\t\t\tentryExitRecords.push({\n\t\t\t\t\tentryAnchor: parseAnchorAt(r, data.entryOffset),\n\t\t\t\t\texitAnchor: parseAnchorAt(r, data.exitOffset),\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tsubtables.push({ coverage, entryExitRecords });\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nexport function parseMarkBasePos(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): MarkBasePosSubtable[] {\n\tconst subtables: MarkBasePosSubtable[] = [];\n\n\tfor (const offset of subtableOffsets) {\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tif (format === 1) {\n\t\t\tconst markCoverageOffset = r.offset16();\n\t\t\tconst baseCoverageOffset = r.offset16();\n\t\t\tconst markClassCount = r.uint16();\n\t\t\tconst markArrayOffset = r.offset16();\n\t\t\tconst baseArrayOffset = r.offset16();\n\n\t\t\tconst markCoverage = parseCoverageAt(r, markCoverageOffset);\n\t\t\tconst baseCoverage = parseCoverageAt(r, baseCoverageOffset);\n\t\t\tconst markArray = parseMarkArray(r.sliceFrom(markArrayOffset));\n\n\t\t\t// Parse base array\n\t\t\tconst baseArrayReader = r.sliceFrom(baseArrayOffset);\n\t\t\tconst baseCount = baseArrayReader.uint16();\n\t\t\tconst baseArray: BaseRecord[] = [];\n\n\t\t\t// Read anchor offsets first\n\t\t\tconst baseRecordData: Array<uint16[]> = [];\n\t\t\tfor (let i = 0; i < baseCount; i++) {\n\t\t\t\tconst anchorOffsets: uint16[] = [];\n\t\t\t\tfor (let j = 0; j < markClassCount; j++) {\n\t\t\t\t\tanchorOffsets.push(baseArrayReader.uint16());\n\t\t\t\t}\n\t\t\t\tbaseRecordData.push(anchorOffsets);\n\t\t\t}\n\n\t\t\t// Parse anchors\n\t\t\tfor (const anchorOffsets of baseRecordData) {\n\t\t\t\tconst baseAnchors: (Anchor | null)[] = [];\n\t\t\t\tfor (const anchorOffset of anchorOffsets) {\n\t\t\t\t\tbaseAnchors.push(parseAnchorAt(baseArrayReader, anchorOffset));\n\t\t\t\t}\n\t\t\t\tbaseArray.push({ baseAnchors });\n\t\t\t}\n\n\t\t\tsubtables.push({\n\t\t\t\tmarkCoverage,\n\t\t\t\tbaseCoverage,\n\t\t\t\tmarkClassCount,\n\t\t\t\tmarkArray,\n\t\t\t\tbaseArray,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nexport function parseMarkLigaturePos(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): MarkLigaturePosSubtable[] {\n\tconst subtables: MarkLigaturePosSubtable[] = [];\n\n\tfor (const offset of subtableOffsets) {\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tif (format === 1) {\n\t\t\tconst markCoverageOffset = r.offset16();\n\t\t\tconst ligatureCoverageOffset = r.offset16();\n\t\t\tconst markClassCount = r.uint16();\n\t\t\tconst markArrayOffset = r.offset16();\n\t\t\tconst ligatureArrayOffset = r.offset16();\n\n\t\t\tconst markCoverage = parseCoverageAt(r, markCoverageOffset);\n\t\t\tconst ligatureCoverage = parseCoverageAt(r, ligatureCoverageOffset);\n\t\t\tconst markArray = parseMarkArray(r.sliceFrom(markArrayOffset));\n\n\t\t\t// Parse ligature array\n\t\t\tconst ligArrayReader = r.sliceFrom(ligatureArrayOffset);\n\t\t\tconst ligatureCount = ligArrayReader.uint16();\n\t\t\tconst ligatureAttachOffsets = ligArrayReader.uint16Array(ligatureCount);\n\n\t\t\tconst ligatureArray: LigatureAttach[] = [];\n\t\t\tfor (const ligAttachOffset of ligatureAttachOffsets) {\n\t\t\t\tconst ligAttachReader = ligArrayReader.sliceFrom(ligAttachOffset);\n\t\t\t\tconst componentCount = ligAttachReader.uint16();\n\n\t\t\t\tconst componentRecords: ComponentRecord[] = [];\n\t\t\t\t// Read all anchor offsets first\n\t\t\t\tconst componentData: Array<uint16[]> = [];\n\t\t\t\tfor (let i = 0; i < componentCount; i++) {\n\t\t\t\t\tconst anchorOffsets: uint16[] = [];\n\t\t\t\t\tfor (let j = 0; j < markClassCount; j++) {\n\t\t\t\t\t\tanchorOffsets.push(ligAttachReader.uint16());\n\t\t\t\t\t}\n\t\t\t\t\tcomponentData.push(anchorOffsets);\n\t\t\t\t}\n\n\t\t\t\t// Parse anchors\n\t\t\t\tfor (const anchorOffsets of componentData) {\n\t\t\t\t\tconst ligatureAnchors: (Anchor | null)[] = [];\n\t\t\t\t\tfor (const anchorOffset of anchorOffsets) {\n\t\t\t\t\t\tligatureAnchors.push(parseAnchorAt(ligAttachReader, anchorOffset));\n\t\t\t\t\t}\n\t\t\t\t\tcomponentRecords.push({ ligatureAnchors });\n\t\t\t\t}\n\n\t\t\t\tligatureArray.push({ componentRecords });\n\t\t\t}\n\n\t\t\tsubtables.push({\n\t\t\t\tmarkCoverage,\n\t\t\t\tligatureCoverage,\n\t\t\t\tmarkClassCount,\n\t\t\t\tmarkArray,\n\t\t\t\tligatureArray,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nexport function parseMarkMarkPos(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): MarkMarkPosSubtable[] {\n\tconst subtables: MarkMarkPosSubtable[] = [];\n\n\tfor (const offset of subtableOffsets) {\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tif (format === 1) {\n\t\t\tconst mark1CoverageOffset = r.offset16();\n\t\t\tconst mark2CoverageOffset = r.offset16();\n\t\t\tconst markClassCount = r.uint16();\n\t\t\tconst mark1ArrayOffset = r.offset16();\n\t\t\tconst mark2ArrayOffset = r.offset16();\n\n\t\t\tconst mark1Coverage = parseCoverageAt(r, mark1CoverageOffset);\n\t\t\tconst mark2Coverage = parseCoverageAt(r, mark2CoverageOffset);\n\t\t\tconst mark1Array = parseMarkArray(r.sliceFrom(mark1ArrayOffset));\n\n\t\t\t// Parse mark2 array\n\t\t\tconst mark2ArrayReader = r.sliceFrom(mark2ArrayOffset);\n\t\t\tconst mark2Count = mark2ArrayReader.uint16();\n\t\t\tconst mark2Array: Mark2Record[] = [];\n\n\t\t\t// Read anchor offsets\n\t\t\tconst mark2Data: Array<uint16[]> = [];\n\t\t\tfor (let i = 0; i < mark2Count; i++) {\n\t\t\t\tconst anchorOffsets: uint16[] = [];\n\t\t\t\tfor (let j = 0; j < markClassCount; j++) {\n\t\t\t\t\tanchorOffsets.push(mark2ArrayReader.uint16());\n\t\t\t\t}\n\t\t\t\tmark2Data.push(anchorOffsets);\n\t\t\t}\n\n\t\t\t// Parse anchors\n\t\t\tfor (const anchorOffsets of mark2Data) {\n\t\t\t\tconst mark2Anchors: (Anchor | null)[] = [];\n\t\t\t\tfor (const anchorOffset of anchorOffsets) {\n\t\t\t\t\tmark2Anchors.push(parseAnchorAt(mark2ArrayReader, anchorOffset));\n\t\t\t\t}\n\t\t\t\tmark2Array.push({ mark2Anchors });\n\t\t\t}\n\n\t\t\tsubtables.push({\n\t\t\t\tmark1Coverage,\n\t\t\t\tmark2Coverage,\n\t\t\t\tmarkClassCount,\n\t\t\t\tmark1Array,\n\t\t\t\tmark2Array,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn subtables;\n}\n", "import {\n\ttype ClassDef,\n\tparseClassDefAt,\n} from \"../../layout/structures/class-def.ts\";\nimport {\n\ttype Coverage,\n\tparseCoverageAt,\n} from \"../../layout/structures/coverage.ts\";\nimport {\n\ttype DeviceOrVariationIndex,\n\tparseDeviceAt,\n} from \"../../layout/structures/device.ts\";\nimport {\n\ttype FeatureList,\n\tLookupFlag,\n\tparseFeatureList,\n\tparseScriptList,\n\ttype ScriptList,\n} from \"../../layout/structures/layout-common.ts\";\nimport type { GlyphId, int16, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\nimport {\n\ttype ChainingContextPosLookup,\n\ttype ChainingContextPosSubtable,\n\ttype ContextPosLookup,\n\ttype ContextPosSubtable,\n\tparseChainingContextPos,\n\tparseContextPos,\n} from \"./gpos-contextual.ts\";\nimport {\n\ttype CursivePosSubtable,\n\ttype MarkBasePosSubtable,\n\ttype MarkLigaturePosSubtable,\n\ttype MarkMarkPosSubtable,\n\tparseCursivePos,\n\tparseMarkBasePos,\n\tparseMarkLigaturePos,\n\tparseMarkMarkPos,\n} from \"./gpos-mark.ts\";\n\n/** GPOS lookup types */\nexport enum GposLookupType {\n\tSingle = 1,\n\tPair = 2,\n\tCursive = 3,\n\tMarkToBase = 4,\n\tMarkToLigature = 5,\n\tMarkToMark = 6,\n\tContext = 7,\n\tChainingContext = 8,\n\tExtension = 9,\n}\n\n/** Value record - positioning adjustments */\nexport interface ValueRecord {\n\txPlacement?: int16;\n\tyPlacement?: int16;\n\txAdvance?: int16;\n\tyAdvance?: int16;\n\txPlaDevice?: DeviceOrVariationIndex;\n\tyPlaDevice?: DeviceOrVariationIndex;\n\txAdvDevice?: DeviceOrVariationIndex;\n\tyAdvDevice?: DeviceOrVariationIndex;\n}\n\n/** Value format flags */\nexport const ValueFormat = {\n\tXPlacement: 0x0001,\n\tYPlacement: 0x0002,\n\tXAdvance: 0x0004,\n\tYAdvance: 0x0008,\n\tXPlaDevice: 0x0010,\n\tYPlaDevice: 0x0020,\n\tXAdvDevice: 0x0040,\n\tYAdvDevice: 0x0080,\n} as const;\n\n/** Base interface for all GPOS lookups */\nexport interface GposLookup {\n\ttype: GposLookupType;\n\tflag: uint16;\n\tmarkFilteringSet?: uint16;\n}\n\n/** Single adjustment lookup (Type 1) */\nexport interface SinglePosLookup extends GposLookup {\n\ttype: GposLookupType.Single;\n\tsubtables: SinglePosSubtable[];\n}\n\nexport interface SinglePosSubtable {\n\tformat: 1 | 2;\n\tcoverage: Coverage;\n\tvalueFormat: uint16;\n\tvalue?: ValueRecord;\n\tvalues?: ValueRecord[];\n}\n\n/** Pair adjustment lookup (Type 2) - kerning */\nexport interface PairPosLookup extends GposLookup {\n\ttype: GposLookupType.Pair;\n\tsubtables: PairPosSubtable[];\n}\n\nexport type PairPosSubtable = PairPosFormat1 | PairPosFormat2;\n\nexport interface PairPosFormat1 {\n\tformat: 1;\n\tcoverage: Coverage;\n\tvalueFormat1: uint16;\n\tvalueFormat2: uint16;\n\tpairSets: PairSet[];\n}\n\nexport interface PairSet {\n\tpairValueRecords: PairValueRecord[];\n}\n\nexport interface PairValueRecord {\n\tsecondGlyph: GlyphId;\n\tvalue1: ValueRecord;\n\tvalue2: ValueRecord;\n}\n\nexport interface PairPosFormat2 {\n\tformat: 2;\n\tcoverage: Coverage;\n\tvalueFormat1: uint16;\n\tvalueFormat2: uint16;\n\tclassDef1: ClassDef;\n\tclassDef2: ClassDef;\n\tclass1Count: uint16;\n\tclass2Count: uint16;\n\tclass1Records: Class1Record[];\n}\n\nexport interface Class1Record {\n\tclass2Records: Class2Record[];\n}\n\nexport interface Class2Record {\n\tvalue1: ValueRecord;\n\tvalue2: ValueRecord;\n}\n\n/** Cursive attachment lookup (Type 3) */\nexport interface CursivePosLookup extends GposLookup {\n\ttype: GposLookupType.Cursive;\n\tsubtables: CursivePosSubtable[];\n}\n\n/** Mark-to-base attachment lookup (Type 4) */\nexport interface MarkBasePosLookup extends GposLookup {\n\ttype: GposLookupType.MarkToBase;\n\tsubtables: MarkBasePosSubtable[];\n}\n\n/** Mark-to-ligature attachment lookup (Type 5) */\nexport interface MarkLigaturePosLookup extends GposLookup {\n\ttype: GposLookupType.MarkToLigature;\n\tsubtables: MarkLigaturePosSubtable[];\n}\n\n/** Mark-to-mark attachment lookup (Type 6) */\nexport interface MarkMarkPosLookup extends GposLookup {\n\ttype: GposLookupType.MarkToMark;\n\tsubtables: MarkMarkPosSubtable[];\n}\n\n/** Union of all GPOS lookup types */\nexport type AnyGposLookup =\n\t| SinglePosLookup\n\t| PairPosLookup\n\t| CursivePosLookup\n\t| MarkBasePosLookup\n\t| MarkLigaturePosLookup\n\t| MarkMarkPosLookup\n\t| ContextPosLookup\n\t| ChainingContextPosLookup;\n\n/** GPOS table */\nexport interface GposTable {\n\tversion: { major: number; minor: number };\n\tscriptList: ScriptList;\n\tfeatureList: FeatureList;\n\tlookups: AnyGposLookup[];\n}\n\n// Re-export mark types\nexport type { Anchor, MarkArray } from \"./gpos-mark.ts\";\n\nexport function parseGpos(reader: Reader): GposTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\n\tconst scriptListOffset = reader.offset16();\n\tconst featureListOffset = reader.offset16();\n\tconst lookupListOffset = reader.offset16();\n\n\tif (majorVersion === 1 && minorVersion >= 1) {\n\t\treader.offset32(); // featureVariationsOffset\n\t}\n\n\tconst scriptList = parseScriptList(reader.sliceFrom(scriptListOffset));\n\tconst featureList = parseFeatureList(reader.sliceFrom(featureListOffset));\n\n\tconst lookupListReader = reader.sliceFrom(lookupListOffset);\n\tconst lookupCount = lookupListReader.uint16();\n\tconst lookupOffsets = lookupListReader.uint16Array(lookupCount);\n\n\tconst lookups: AnyGposLookup[] = [];\n\tfor (const lookupOffset of lookupOffsets) {\n\t\tconst lookupReader = lookupListReader.sliceFrom(lookupOffset);\n\t\tconst lookup = parseGposLookup(lookupReader);\n\t\tif (lookup) {\n\t\t\tlookups.push(lookup);\n\t\t}\n\t}\n\n\treturn {\n\t\tversion: { major: majorVersion, minor: minorVersion },\n\t\tscriptList,\n\t\tfeatureList,\n\t\tlookups,\n\t};\n}\n\nfunction parseGposLookup(reader: Reader): AnyGposLookup | null {\n\tconst lookupType = reader.uint16();\n\tconst lookupFlag = reader.uint16();\n\tconst subtableCount = reader.uint16();\n\tconst subtableOffsets = Array.from(reader.uint16Array(subtableCount));\n\n\tlet markFilteringSet: uint16 | undefined;\n\tif (lookupFlag & LookupFlag.UseMarkFilteringSet) {\n\t\tmarkFilteringSet = reader.uint16();\n\t}\n\n\tconst baseProps = { flag: lookupFlag, markFilteringSet };\n\n\tswitch (lookupType) {\n\t\tcase GposLookupType.Single:\n\t\t\treturn {\n\t\t\t\ttype: GposLookupType.Single,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables: parseSinglePos(reader, subtableOffsets),\n\t\t\t};\n\n\t\tcase GposLookupType.Pair:\n\t\t\treturn {\n\t\t\t\ttype: GposLookupType.Pair,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables: parsePairPos(reader, subtableOffsets),\n\t\t\t};\n\n\t\tcase GposLookupType.Cursive:\n\t\t\treturn {\n\t\t\t\ttype: GposLookupType.Cursive,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables: parseCursivePos(reader, subtableOffsets),\n\t\t\t};\n\n\t\tcase GposLookupType.MarkToBase:\n\t\t\treturn {\n\t\t\t\ttype: GposLookupType.MarkToBase,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables: parseMarkBasePos(reader, subtableOffsets),\n\t\t\t};\n\n\t\tcase GposLookupType.MarkToLigature:\n\t\t\treturn {\n\t\t\t\ttype: GposLookupType.MarkToLigature,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables: parseMarkLigaturePos(reader, subtableOffsets),\n\t\t\t};\n\n\t\tcase GposLookupType.MarkToMark:\n\t\t\treturn {\n\t\t\t\ttype: GposLookupType.MarkToMark,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables: parseMarkMarkPos(reader, subtableOffsets),\n\t\t\t};\n\n\t\tcase GposLookupType.Context:\n\t\t\treturn {\n\t\t\t\ttype: GposLookupType.Context,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables: parseContextPos(reader, subtableOffsets),\n\t\t\t};\n\n\t\tcase GposLookupType.ChainingContext:\n\t\t\treturn {\n\t\t\t\ttype: GposLookupType.ChainingContext,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables: parseChainingContextPos(reader, subtableOffsets),\n\t\t\t};\n\n\t\tcase GposLookupType.Extension:\n\t\t\treturn parseExtensionLookup(reader, subtableOffsets, baseProps);\n\n\t\tdefault:\n\t\t\treturn null;\n\t}\n}\n\nfunction parseValueRecord(\n\treader: Reader,\n\tvalueFormat: uint16,\n\tsubtableReader?: Reader,\n): ValueRecord {\n\tconst record: ValueRecord = {};\n\n\tif (valueFormat & ValueFormat.XPlacement) record.xPlacement = reader.int16();\n\tif (valueFormat & ValueFormat.YPlacement) record.yPlacement = reader.int16();\n\tif (valueFormat & ValueFormat.XAdvance) record.xAdvance = reader.int16();\n\tif (valueFormat & ValueFormat.YAdvance) record.yAdvance = reader.int16();\n\n\t// Parse Device tables if we have a subtable reader to resolve offsets\n\tconst deviceReader = subtableReader ?? reader;\n\tif (valueFormat & ValueFormat.XPlaDevice) {\n\t\tconst offset = reader.uint16();\n\t\tif (offset !== 0)\n\t\t\trecord.xPlaDevice = parseDeviceAt(deviceReader, offset) ?? undefined;\n\t}\n\tif (valueFormat & ValueFormat.YPlaDevice) {\n\t\tconst offset = reader.uint16();\n\t\tif (offset !== 0)\n\t\t\trecord.yPlaDevice = parseDeviceAt(deviceReader, offset) ?? undefined;\n\t}\n\tif (valueFormat & ValueFormat.XAdvDevice) {\n\t\tconst offset = reader.uint16();\n\t\tif (offset !== 0)\n\t\t\trecord.xAdvDevice = parseDeviceAt(deviceReader, offset) ?? undefined;\n\t}\n\tif (valueFormat & ValueFormat.YAdvDevice) {\n\t\tconst offset = reader.uint16();\n\t\tif (offset !== 0)\n\t\t\trecord.yAdvDevice = parseDeviceAt(deviceReader, offset) ?? undefined;\n\t}\n\n\treturn record;\n}\n\nfunction parseSinglePos(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): SinglePosSubtable[] {\n\tconst subtables: SinglePosSubtable[] = [];\n\n\tfor (const offset of subtableOffsets) {\n\t\tconst subtableReader = reader.sliceFrom(offset);\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tif (format === 1) {\n\t\t\tconst coverageOffset = r.offset16();\n\t\t\tconst valueFormat = r.uint16();\n\t\t\tconst value = parseValueRecord(r, valueFormat, subtableReader);\n\t\t\tconst coverage = parseCoverageAt(subtableReader, coverageOffset);\n\t\t\tsubtables.push({ format: 1, coverage, valueFormat, value });\n\t\t} else if (format === 2) {\n\t\t\tconst coverageOffset = r.offset16();\n\t\t\tconst valueFormat = r.uint16();\n\t\t\tconst valueCount = r.uint16();\n\t\t\tconst values: ValueRecord[] = [];\n\t\t\tfor (let i = 0; i < valueCount; i++) {\n\t\t\t\tvalues.push(parseValueRecord(r, valueFormat, subtableReader));\n\t\t\t}\n\t\t\tconst coverage = parseCoverageAt(subtableReader, coverageOffset);\n\t\t\tsubtables.push({ format: 2, coverage, valueFormat, values });\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nfunction parsePairPos(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): PairPosSubtable[] {\n\tconst subtables: PairPosSubtable[] = [];\n\n\tfor (const offset of subtableOffsets) {\n\t\tconst subtableReader = reader.sliceFrom(offset);\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tif (format === 1) {\n\t\t\tsubtables.push(parsePairPosFormat1(r, subtableReader));\n\t\t} else if (format === 2) {\n\t\t\tsubtables.push(parsePairPosFormat2(r, subtableReader));\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nfunction parsePairPosFormat1(\n\treader: Reader,\n\tsubtableReader: Reader,\n): PairPosFormat1 {\n\tconst coverageOffset = reader.offset16();\n\tconst valueFormat1 = reader.uint16();\n\tconst valueFormat2 = reader.uint16();\n\tconst pairSetCount = reader.uint16();\n\tconst pairSetOffsets = reader.uint16Array(pairSetCount);\n\n\tconst coverage = parseCoverageAt(subtableReader, coverageOffset);\n\tconst pairSets: PairSet[] = [];\n\n\tfor (const pairSetOffset of pairSetOffsets) {\n\t\tconst pairSetReader = subtableReader.sliceFrom(pairSetOffset);\n\t\tconst r = subtableReader.sliceFrom(pairSetOffset);\n\t\tconst pairValueCount = r.uint16();\n\t\tconst pairValueRecords: PairValueRecord[] = [];\n\n\t\tfor (let i = 0; i < pairValueCount; i++) {\n\t\t\tconst secondGlyph = r.uint16();\n\t\t\tconst value1 = parseValueRecord(r, valueFormat1, pairSetReader);\n\t\t\tconst value2 = parseValueRecord(r, valueFormat2, pairSetReader);\n\t\t\tpairValueRecords.push({ secondGlyph, value1, value2 });\n\t\t}\n\n\t\tpairSets.push({ pairValueRecords });\n\t}\n\n\treturn { format: 1, coverage, valueFormat1, valueFormat2, pairSets };\n}\n\nfunction parsePairPosFormat2(\n\treader: Reader,\n\tsubtableReader: Reader,\n): PairPosFormat2 {\n\tconst coverageOffset = reader.offset16();\n\tconst valueFormat1 = reader.uint16();\n\tconst valueFormat2 = reader.uint16();\n\tconst classDef1Offset = reader.offset16();\n\tconst classDef2Offset = reader.offset16();\n\tconst class1Count = reader.uint16();\n\tconst class2Count = reader.uint16();\n\n\tconst coverage = parseCoverageAt(subtableReader, coverageOffset);\n\tconst classDef1 = parseClassDefAt(subtableReader, classDef1Offset);\n\tconst classDef2 = parseClassDefAt(subtableReader, classDef2Offset);\n\n\tconst class1Records: Class1Record[] = [];\n\tfor (let i = 0; i < class1Count; i++) {\n\t\tconst class2Records: Class2Record[] = [];\n\t\tfor (let j = 0; j < class2Count; j++) {\n\t\t\tconst value1 = parseValueRecord(reader, valueFormat1, subtableReader);\n\t\t\tconst value2 = parseValueRecord(reader, valueFormat2, subtableReader);\n\t\t\tclass2Records.push({ value1, value2 });\n\t\t}\n\t\tclass1Records.push({ class2Records });\n\t}\n\n\treturn {\n\t\tformat: 2,\n\t\tcoverage,\n\t\tvalueFormat1,\n\t\tvalueFormat2,\n\t\tclassDef1,\n\t\tclassDef2,\n\t\tclass1Count,\n\t\tclass2Count,\n\t\tclass1Records,\n\t};\n}\n\nfunction parseExtensionLookup(\n\treader: Reader,\n\tsubtableOffsets: number[],\n\tbaseProps: { flag: uint16; markFilteringSet?: uint16 },\n): AnyGposLookup | null {\n\tif (subtableOffsets.length === 0) return null;\n\n\tconst extSubtables: Array<{ type: number; reader: Reader }> = [];\n\n\tfor (const offset of subtableOffsets) {\n\t\tconst extReader = reader.sliceFrom(offset);\n\t\tconst format = extReader.uint16();\n\t\tif (format !== 1) continue;\n\n\t\tconst extensionLookupType = extReader.uint16();\n\t\tconst extensionOffset = extReader.uint32();\n\n\t\t// extensionOffset is relative to start of extension subtable\n\t\textSubtables.push({\n\t\t\ttype: extensionLookupType,\n\t\t\treader: extReader.sliceFrom(extensionOffset),\n\t\t});\n\t}\n\n\tif (extSubtables.length === 0) return null;\n\n\tconst actualType = extSubtables[0]?.type;\n\n\tswitch (actualType) {\n\t\tcase GposLookupType.Single: {\n\t\t\tconst subtables: SinglePosSubtable[] = [];\n\t\t\tfor (const ext of extSubtables) {\n\t\t\t\tsubtables.push(...parseSinglePos(ext.reader, [0]));\n\t\t\t}\n\t\t\treturn { type: GposLookupType.Single, ...baseProps, subtables };\n\t\t}\n\n\t\tcase GposLookupType.Pair: {\n\t\t\tconst subtables: PairPosSubtable[] = [];\n\t\t\tfor (const ext of extSubtables) {\n\t\t\t\tsubtables.push(...parsePairPos(ext.reader, [0]));\n\t\t\t}\n\t\t\treturn { type: GposLookupType.Pair, ...baseProps, subtables };\n\t\t}\n\n\t\tcase GposLookupType.Cursive: {\n\t\t\tconst subtables: CursivePosSubtable[] = [];\n\t\t\tfor (const ext of extSubtables) {\n\t\t\t\tsubtables.push(...parseCursivePos(ext.reader, [0]));\n\t\t\t}\n\t\t\treturn { type: GposLookupType.Cursive, ...baseProps, subtables };\n\t\t}\n\n\t\tcase GposLookupType.MarkToBase: {\n\t\t\tconst subtables: MarkBasePosSubtable[] = [];\n\t\t\tfor (const ext of extSubtables) {\n\t\t\t\tsubtables.push(...parseMarkBasePos(ext.reader, [0]));\n\t\t\t}\n\t\t\treturn { type: GposLookupType.MarkToBase, ...baseProps, subtables };\n\t\t}\n\n\t\tcase GposLookupType.MarkToLigature: {\n\t\t\tconst subtables: MarkLigaturePosSubtable[] = [];\n\t\t\tfor (const ext of extSubtables) {\n\t\t\t\tsubtables.push(...parseMarkLigaturePos(ext.reader, [0]));\n\t\t\t}\n\t\t\treturn { type: GposLookupType.MarkToLigature, ...baseProps, subtables };\n\t\t}\n\n\t\tcase GposLookupType.MarkToMark: {\n\t\t\tconst subtables: MarkMarkPosSubtable[] = [];\n\t\t\tfor (const ext of extSubtables) {\n\t\t\t\tsubtables.push(...parseMarkMarkPos(ext.reader, [0]));\n\t\t\t}\n\t\t\treturn { type: GposLookupType.MarkToMark, ...baseProps, subtables };\n\t\t}\n\n\t\tcase GposLookupType.Context: {\n\t\t\tconst subtables: ContextPosSubtable[] = [];\n\t\t\tfor (const ext of extSubtables) {\n\t\t\t\tsubtables.push(...parseContextPos(ext.reader, [0]));\n\t\t\t}\n\t\t\treturn { type: GposLookupType.Context, ...baseProps, subtables };\n\t\t}\n\n\t\tcase GposLookupType.ChainingContext: {\n\t\t\tconst subtables: ChainingContextPosSubtable[] = [];\n\t\t\tfor (const ext of extSubtables) {\n\t\t\t\tsubtables.push(...parseChainingContextPos(ext.reader, [0]));\n\t\t\t}\n\t\t\treturn { type: GposLookupType.ChainingContext, ...baseProps, subtables };\n\t\t}\n\n\t\tdefault:\n\t\t\treturn null;\n\t}\n}\n\n// Utility functions\n\nexport function getKerning(\n\tlookup: PairPosLookup,\n\tfirstGlyph: GlyphId,\n\tsecondGlyph: GlyphId,\n): { xAdvance1: number; xAdvance2: number } | null {\n\tfor (const subtable of lookup.subtables) {\n\t\tconst coverageIndex = subtable.coverage.get(firstGlyph);\n\t\tif (coverageIndex === null) continue;\n\n\t\tif (subtable.format === 1) {\n\t\t\tconst pairSet = subtable.pairSets[coverageIndex];\n\t\t\tif (!pairSet) continue;\n\n\t\t\tfor (const record of pairSet.pairValueRecords) {\n\t\t\t\tif (record.secondGlyph === secondGlyph) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\txAdvance1: record.value1.xAdvance ?? 0,\n\t\t\t\t\t\txAdvance2: record.value2.xAdvance ?? 0,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (subtable.format === 2) {\n\t\t\tconst class1 = subtable.classDef1.get(firstGlyph);\n\t\t\tconst class2 = subtable.classDef2.get(secondGlyph);\n\n\t\t\tconst class1Record = subtable.class1Records[class1];\n\t\t\tif (!class1Record) continue;\n\n\t\t\tconst class2Record = class1Record.class2Records[class2];\n\t\t\tif (!class2Record) continue;\n\n\t\t\treturn {\n\t\t\t\txAdvance1: class2Record.value1.xAdvance ?? 0,\n\t\t\t\txAdvance2: class2Record.value2.xAdvance ?? 0,\n\t\t\t};\n\t\t}\n\t}\n\n\treturn null;\n}\n", "import {\n\ttype ClassDef,\n\tparseClassDefAt,\n} from \"../../layout/structures/class-def.ts\";\nimport {\n\ttype Coverage,\n\tparseCoverageAt,\n} from \"../../layout/structures/coverage.ts\";\nimport type { GlyphId, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\nimport type { GsubLookup } from \"./gsub.ts\";\n\n/** Sequence lookup record - applies a lookup at a position */\nexport interface SequenceLookupRecord {\n\tsequenceIndex: uint16; // Position in input sequence\n\tlookupListIndex: uint16; // Lookup to apply\n}\n\n/** Context substitution lookup (Type 5) */\nexport interface ContextSubstLookup extends GsubLookup {\n\ttype: 5;\n\tsubtables: ContextSubstSubtable[];\n}\n\nexport type ContextSubstSubtable =\n\t| ContextSubstFormat1\n\t| ContextSubstFormat2\n\t| ContextSubstFormat3;\n\n/** Format 1: Simple glyph contexts */\nexport interface ContextSubstFormat1 {\n\tformat: 1;\n\tcoverage: Coverage;\n\truleSets: (ContextRule[] | null)[];\n}\n\nexport interface ContextRule {\n\tglyphCount: uint16;\n\tinputSequence: GlyphId[]; // Excludes first glyph (in coverage)\n\tlookupRecords: SequenceLookupRecord[];\n}\n\n/** Format 2: Class-based contexts */\nexport interface ContextSubstFormat2 {\n\tformat: 2;\n\tcoverage: Coverage;\n\tclassDef: ClassDef;\n\tclassRuleSets: (ClassRule[] | null)[];\n}\n\nexport interface ClassRule {\n\tglyphCount: uint16;\n\tinputClasses: uint16[]; // Excludes first class\n\tlookupRecords: SequenceLookupRecord[];\n}\n\n/** Format 3: Coverage-based contexts */\nexport interface ContextSubstFormat3 {\n\tformat: 3;\n\tcoverages: Coverage[];\n\tlookupRecords: SequenceLookupRecord[];\n}\n\n/** Chaining context substitution lookup (Type 6) */\nexport interface ChainingContextSubstLookup extends GsubLookup {\n\ttype: 6;\n\tsubtables: ChainingContextSubstSubtable[];\n}\n\nexport type ChainingContextSubstSubtable =\n\t| ChainingContextFormat1\n\t| ChainingContextFormat2\n\t| ChainingContextFormat3;\n\n/** Format 1: Simple chaining context */\nexport interface ChainingContextFormat1 {\n\tformat: 1;\n\tcoverage: Coverage;\n\tchainRuleSets: (ChainRule[] | null)[];\n}\n\nexport interface ChainRule {\n\tbacktrackSequence: GlyphId[];\n\tinputSequence: GlyphId[]; // Excludes first glyph\n\tlookaheadSequence: GlyphId[];\n\tlookupRecords: SequenceLookupRecord[];\n}\n\n/** Format 2: Class-based chaining context */\nexport interface ChainingContextFormat2 {\n\tformat: 2;\n\tcoverage: Coverage;\n\tbacktrackClassDef: ClassDef;\n\tinputClassDef: ClassDef;\n\tlookaheadClassDef: ClassDef;\n\tchainClassRuleSets: (ChainClassRule[] | null)[];\n}\n\nexport interface ChainClassRule {\n\tbacktrackClasses: uint16[];\n\tinputClasses: uint16[]; // Excludes first class\n\tlookaheadClasses: uint16[];\n\tlookupRecords: SequenceLookupRecord[];\n}\n\n/** Format 3: Coverage-based chaining context */\nexport interface ChainingContextFormat3 {\n\tformat: 3;\n\tbacktrackCoverages: Coverage[];\n\tinputCoverages: Coverage[];\n\tlookaheadCoverages: Coverage[];\n\tlookupRecords: SequenceLookupRecord[];\n}\n\nexport function parseContextSubst(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): ContextSubstSubtable[] {\n\tconst subtables: ContextSubstSubtable[] = [];\n\n\tfor (const offset of subtableOffsets) {\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tswitch (format) {\n\t\t\tcase 1:\n\t\t\t\tsubtables.push(parseContextFormat1(r));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tsubtables.push(parseContextFormat2(r));\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tsubtables.push(parseContextFormat3(r));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nfunction parseContextFormat1(reader: Reader): ContextSubstFormat1 {\n\tconst coverageOffset = reader.offset16();\n\tconst ruleSetCount = reader.uint16();\n\tconst ruleSetOffsets = reader.uint16Array(ruleSetCount);\n\n\tconst coverage = parseCoverageAt(reader, coverageOffset);\n\tconst ruleSets: (ContextRule[] | null)[] = [];\n\n\tfor (const ruleSetOffset of ruleSetOffsets) {\n\t\tif (ruleSetOffset === 0) {\n\t\t\truleSets.push(null);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst rsReader = reader.sliceFrom(ruleSetOffset);\n\t\tconst ruleCount = rsReader.uint16();\n\t\tconst ruleOffsets = rsReader.uint16Array(ruleCount);\n\n\t\tconst rules: ContextRule[] = [];\n\t\tfor (const ruleOffset of ruleOffsets) {\n\t\t\tconst ruleReader = rsReader.sliceFrom(ruleOffset);\n\t\t\tconst glyphCount = ruleReader.uint16();\n\t\t\tconst lookupCount = ruleReader.uint16();\n\t\t\tconst inputSequence = Array.from(ruleReader.uint16Array(glyphCount - 1));\n\t\t\tconst lookupRecords = parseLookupRecords(ruleReader, lookupCount);\n\n\t\t\trules.push({ glyphCount, inputSequence, lookupRecords });\n\t\t}\n\n\t\truleSets.push(rules);\n\t}\n\n\treturn { format: 1, coverage, ruleSets };\n}\n\nfunction parseContextFormat2(reader: Reader): ContextSubstFormat2 {\n\tconst coverageOffset = reader.offset16();\n\tconst classDefOffset = reader.offset16();\n\tconst classRuleSetCount = reader.uint16();\n\tconst classRuleSetOffsets = reader.uint16Array(classRuleSetCount);\n\n\tconst coverage = parseCoverageAt(reader, coverageOffset);\n\tconst classDef = parseClassDefAt(reader, classDefOffset);\n\tconst classRuleSets: (ClassRule[] | null)[] = [];\n\n\tfor (const crsOffset of classRuleSetOffsets) {\n\t\tif (crsOffset === 0) {\n\t\t\tclassRuleSets.push(null);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst crsReader = reader.sliceFrom(crsOffset);\n\t\tconst ruleCount = crsReader.uint16();\n\t\tconst ruleOffsets = crsReader.uint16Array(ruleCount);\n\n\t\tconst rules: ClassRule[] = [];\n\t\tfor (const ruleOffset of ruleOffsets) {\n\t\t\tconst ruleReader = crsReader.sliceFrom(ruleOffset);\n\t\t\tconst glyphCount = ruleReader.uint16();\n\t\t\tconst lookupCount = ruleReader.uint16();\n\t\t\tconst inputClasses = Array.from(ruleReader.uint16Array(glyphCount - 1));\n\t\t\tconst lookupRecords = parseLookupRecords(ruleReader, lookupCount);\n\n\t\t\trules.push({ glyphCount, inputClasses, lookupRecords });\n\t\t}\n\n\t\tclassRuleSets.push(rules);\n\t}\n\n\treturn { format: 2, coverage, classDef, classRuleSets };\n}\n\nfunction parseContextFormat3(reader: Reader): ContextSubstFormat3 {\n\tconst glyphCount = reader.uint16();\n\tconst lookupCount = reader.uint16();\n\tconst coverageOffsets = reader.uint16Array(glyphCount);\n\n\tconst coverages: Coverage[] = [];\n\tfor (const offset of coverageOffsets) {\n\t\tcoverages.push(parseCoverageAt(reader, offset));\n\t}\n\n\tconst lookupRecords = parseLookupRecords(reader, lookupCount);\n\n\treturn { format: 3, coverages, lookupRecords };\n}\n\nexport function parseChainingContextSubst(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): ChainingContextSubstSubtable[] {\n\tconst subtables: ChainingContextSubstSubtable[] = [];\n\n\tfor (const offset of subtableOffsets) {\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tswitch (format) {\n\t\t\tcase 1:\n\t\t\t\tsubtables.push(parseChainingFormat1(r));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tsubtables.push(parseChainingFormat2(r));\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tsubtables.push(parseChainingFormat3(r));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nfunction parseChainingFormat1(reader: Reader): ChainingContextFormat1 {\n\tconst coverageOffset = reader.offset16();\n\tconst chainRuleSetCount = reader.uint16();\n\tconst chainRuleSetOffsets = reader.uint16Array(chainRuleSetCount);\n\n\tconst coverage = parseCoverageAt(reader, coverageOffset);\n\tconst chainRuleSets: (ChainRule[] | null)[] = [];\n\n\tfor (const crsOffset of chainRuleSetOffsets) {\n\t\tif (crsOffset === 0) {\n\t\t\tchainRuleSets.push(null);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst crsReader = reader.sliceFrom(crsOffset);\n\t\tconst ruleCount = crsReader.uint16();\n\t\tconst ruleOffsets = crsReader.uint16Array(ruleCount);\n\n\t\tconst rules: ChainRule[] = [];\n\t\tfor (const ruleOffset of ruleOffsets) {\n\t\t\tconst ruleReader = crsReader.sliceFrom(ruleOffset);\n\n\t\t\tconst backtrackCount = ruleReader.uint16();\n\t\t\tconst backtrackSequence = Array.from(\n\t\t\t\truleReader.uint16Array(backtrackCount),\n\t\t\t);\n\n\t\t\tconst inputCount = ruleReader.uint16();\n\t\t\tconst inputSequence = Array.from(ruleReader.uint16Array(inputCount - 1));\n\n\t\t\tconst lookaheadCount = ruleReader.uint16();\n\t\t\tconst lookaheadSequence = Array.from(\n\t\t\t\truleReader.uint16Array(lookaheadCount),\n\t\t\t);\n\n\t\t\tconst lookupCount = ruleReader.uint16();\n\t\t\tconst lookupRecords = parseLookupRecords(ruleReader, lookupCount);\n\n\t\t\trules.push({\n\t\t\t\tbacktrackSequence,\n\t\t\t\tinputSequence,\n\t\t\t\tlookaheadSequence,\n\t\t\t\tlookupRecords,\n\t\t\t});\n\t\t}\n\n\t\tchainRuleSets.push(rules);\n\t}\n\n\treturn { format: 1, coverage, chainRuleSets };\n}\n\nfunction parseChainingFormat2(reader: Reader): ChainingContextFormat2 {\n\tconst coverageOffset = reader.offset16();\n\tconst backtrackClassDefOffset = reader.offset16();\n\tconst inputClassDefOffset = reader.offset16();\n\tconst lookaheadClassDefOffset = reader.offset16();\n\tconst chainClassRuleSetCount = reader.uint16();\n\tconst chainClassRuleSetOffsets = reader.uint16Array(chainClassRuleSetCount);\n\n\tconst coverage = parseCoverageAt(reader, coverageOffset);\n\tconst backtrackClassDef = parseClassDefAt(reader, backtrackClassDefOffset);\n\tconst inputClassDef = parseClassDefAt(reader, inputClassDefOffset);\n\tconst lookaheadClassDef = parseClassDefAt(reader, lookaheadClassDefOffset);\n\n\tconst chainClassRuleSets: (ChainClassRule[] | null)[] = [];\n\n\tfor (const ccrsOffset of chainClassRuleSetOffsets) {\n\t\tif (ccrsOffset === 0) {\n\t\t\tchainClassRuleSets.push(null);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst ccrsReader = reader.sliceFrom(ccrsOffset);\n\t\tconst ruleCount = ccrsReader.uint16();\n\t\tconst ruleOffsets = ccrsReader.uint16Array(ruleCount);\n\n\t\tconst rules: ChainClassRule[] = [];\n\t\tfor (const ruleOffset of ruleOffsets) {\n\t\t\tconst ruleReader = ccrsReader.sliceFrom(ruleOffset);\n\n\t\t\tconst backtrackCount = ruleReader.uint16();\n\t\t\tconst backtrackClasses = Array.from(\n\t\t\t\truleReader.uint16Array(backtrackCount),\n\t\t\t);\n\n\t\t\tconst inputCount = ruleReader.uint16();\n\t\t\tconst inputClasses = Array.from(ruleReader.uint16Array(inputCount - 1));\n\n\t\t\tconst lookaheadCount = ruleReader.uint16();\n\t\t\tconst lookaheadClasses = Array.from(\n\t\t\t\truleReader.uint16Array(lookaheadCount),\n\t\t\t);\n\n\t\t\tconst lookupCount = ruleReader.uint16();\n\t\t\tconst lookupRecords = parseLookupRecords(ruleReader, lookupCount);\n\n\t\t\trules.push({\n\t\t\t\tbacktrackClasses,\n\t\t\t\tinputClasses,\n\t\t\t\tlookaheadClasses,\n\t\t\t\tlookupRecords,\n\t\t\t});\n\t\t}\n\n\t\tchainClassRuleSets.push(rules);\n\t}\n\n\treturn {\n\t\tformat: 2,\n\t\tcoverage,\n\t\tbacktrackClassDef,\n\t\tinputClassDef,\n\t\tlookaheadClassDef,\n\t\tchainClassRuleSets,\n\t};\n}\n\nfunction parseChainingFormat3(reader: Reader): ChainingContextFormat3 {\n\tconst backtrackCount = reader.uint16();\n\tconst backtrackCoverageOffsets = reader.uint16Array(backtrackCount);\n\n\tconst inputCount = reader.uint16();\n\tconst inputCoverageOffsets = reader.uint16Array(inputCount);\n\n\tconst lookaheadCount = reader.uint16();\n\tconst lookaheadCoverageOffsets = reader.uint16Array(lookaheadCount);\n\n\tconst lookupCount = reader.uint16();\n\tconst lookupRecords = parseLookupRecords(reader, lookupCount);\n\n\tconst backtrackCoverages: Coverage[] = [];\n\tfor (const offset of backtrackCoverageOffsets) {\n\t\tbacktrackCoverages.push(parseCoverageAt(reader, offset));\n\t}\n\n\tconst inputCoverages: Coverage[] = [];\n\tfor (const offset of inputCoverageOffsets) {\n\t\tinputCoverages.push(parseCoverageAt(reader, offset));\n\t}\n\n\tconst lookaheadCoverages: Coverage[] = [];\n\tfor (const offset of lookaheadCoverageOffsets) {\n\t\tlookaheadCoverages.push(parseCoverageAt(reader, offset));\n\t}\n\n\treturn {\n\t\tformat: 3,\n\t\tbacktrackCoverages,\n\t\tinputCoverages,\n\t\tlookaheadCoverages,\n\t\tlookupRecords,\n\t};\n}\n\nfunction parseLookupRecords(\n\treader: Reader,\n\tcount: number,\n): SequenceLookupRecord[] {\n\tconst records: SequenceLookupRecord[] = [];\n\tfor (let i = 0; i < count; i++) {\n\t\trecords.push({\n\t\t\tsequenceIndex: reader.uint16(),\n\t\t\tlookupListIndex: reader.uint16(),\n\t\t});\n\t}\n\treturn records;\n}\n", "import {\n\ttype Coverage,\n\tparseCoverageAt,\n} from \"../../layout/structures/coverage.ts\";\nimport {\n\ttype FeatureList,\n\tLookupFlag,\n\tparseFeatureList,\n\tparseScriptList,\n\ttype ScriptList,\n} from \"../../layout/structures/layout-common.ts\";\nimport type { GlyphId, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\nimport {\n\ttype ChainingContextSubstSubtable,\n\ttype ContextSubstSubtable,\n\tparseChainingContextSubst,\n\tparseContextSubst,\n} from \"./gsub-contextual.ts\";\n\n/** GSUB lookup types */\nexport enum GsubLookupType {\n\tSingle = 1,\n\tMultiple = 2,\n\tAlternate = 3,\n\tLigature = 4,\n\tContext = 5,\n\tChainingContext = 6,\n\tExtension = 7,\n\tReverseChainingSingle = 8,\n}\n\n/** Base interface for all GSUB lookups */\nexport interface GsubLookup {\n\ttype: GsubLookupType;\n\tflag: uint16;\n\tmarkFilteringSet?: uint16;\n}\n\n/** Single substitution lookup (Type 1) */\nexport interface SingleSubstLookup extends GsubLookup {\n\ttype: GsubLookupType.Single;\n\tsubtables: SingleSubstSubtable[];\n}\n\nexport interface SingleSubstSubtable {\n\tformat: 1 | 2;\n\tcoverage: Coverage;\n\tdeltaGlyphId?: number;\n\tsubstituteGlyphIds?: GlyphId[];\n}\n\n/** Multiple substitution lookup (Type 2) */\nexport interface MultipleSubstLookup extends GsubLookup {\n\ttype: GsubLookupType.Multiple;\n\tsubtables: MultipleSubstSubtable[];\n}\n\nexport interface MultipleSubstSubtable {\n\tcoverage: Coverage;\n\tsequences: GlyphId[][];\n}\n\n/** Alternate substitution lookup (Type 3) */\nexport interface AlternateSubstLookup extends GsubLookup {\n\ttype: GsubLookupType.Alternate;\n\tsubtables: AlternateSubstSubtable[];\n}\n\nexport interface AlternateSubstSubtable {\n\tcoverage: Coverage;\n\talternateSets: GlyphId[][];\n}\n\n/** Ligature substitution lookup (Type 4) */\nexport interface LigatureSubstLookup extends GsubLookup {\n\ttype: GsubLookupType.Ligature;\n\tsubtables: LigatureSubstSubtable[];\n}\n\nexport interface LigatureSubstSubtable {\n\tcoverage: Coverage;\n\tligatureSets: LigatureSet[];\n}\n\nexport interface LigatureSet {\n\tligatures: Ligature[];\n}\n\nexport interface Ligature {\n\tligatureGlyph: GlyphId;\n\tcomponentGlyphIds: GlyphId[];\n}\n\n/** Context substitution lookup (Type 5) */\nexport interface ContextSubstLookup extends GsubLookup {\n\ttype: GsubLookupType.Context;\n\tsubtables: ContextSubstSubtable[];\n}\n\n/** Chaining context substitution lookup (Type 6) */\nexport interface ChainingContextSubstLookup extends GsubLookup {\n\ttype: GsubLookupType.ChainingContext;\n\tsubtables: ChainingContextSubstSubtable[];\n}\n\n/** Reverse chaining single substitution lookup (Type 8) */\nexport interface ReverseChainingSingleSubstLookup extends GsubLookup {\n\ttype: GsubLookupType.ReverseChainingSingle;\n\tsubtables: ReverseChainingSingleSubstSubtable[];\n}\n\nexport interface ReverseChainingSingleSubstSubtable {\n\tcoverage: Coverage;\n\tbacktrackCoverages: Coverage[];\n\tlookaheadCoverages: Coverage[];\n\tsubstituteGlyphIds: GlyphId[];\n}\n\n/** Union of all GSUB lookup types */\nexport type AnyGsubLookup =\n\t| SingleSubstLookup\n\t| MultipleSubstLookup\n\t| AlternateSubstLookup\n\t| LigatureSubstLookup\n\t| ContextSubstLookup\n\t| ChainingContextSubstLookup\n\t| ReverseChainingSingleSubstLookup;\n\n/** GSUB table */\nexport interface GsubTable {\n\tversion: { major: number; minor: number };\n\tscriptList: ScriptList;\n\tfeatureList: FeatureList;\n\tlookups: AnyGsubLookup[];\n}\n\n// Re-export for use in shaper\nexport type { SequenceLookupRecord } from \"./gsub-contextual.ts\";\n\nexport function parseGsub(reader: Reader): GsubTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\n\tconst scriptListOffset = reader.offset16();\n\tconst featureListOffset = reader.offset16();\n\tconst lookupListOffset = reader.offset16();\n\n\tif (majorVersion === 1 && minorVersion >= 1) {\n\t\treader.offset32(); // featureVariationsOffset\n\t}\n\n\tconst scriptList = parseScriptList(reader.sliceFrom(scriptListOffset));\n\tconst featureList = parseFeatureList(reader.sliceFrom(featureListOffset));\n\n\tconst lookupListReader = reader.sliceFrom(lookupListOffset);\n\tconst lookupCount = lookupListReader.uint16();\n\tconst lookupOffsets = lookupListReader.uint16Array(lookupCount);\n\n\tconst lookups: AnyGsubLookup[] = [];\n\tfor (const lookupOffset of lookupOffsets) {\n\t\tconst lookupReader = lookupListReader.sliceFrom(lookupOffset);\n\t\tconst lookup = parseGsubLookup(\n\t\t\tlookupReader,\n\t\t\tlookupListReader,\n\t\t\tlookupOffset,\n\t\t);\n\t\tif (lookup) {\n\t\t\tlookups.push(lookup);\n\t\t}\n\t}\n\n\treturn {\n\t\tversion: { major: majorVersion, minor: minorVersion },\n\t\tscriptList,\n\t\tfeatureList,\n\t\tlookups,\n\t};\n}\n\nfunction parseGsubLookup(\n\treader: Reader,\n\t_lookupListReader: Reader,\n\t_lookupOffset: number,\n): AnyGsubLookup | null {\n\tconst lookupType = reader.uint16();\n\tconst lookupFlag = reader.uint16();\n\tconst subtableCount = reader.uint16();\n\tconst subtableOffsets = Array.from(reader.uint16Array(subtableCount));\n\n\tlet markFilteringSet: uint16 | undefined;\n\tif (lookupFlag & LookupFlag.UseMarkFilteringSet) {\n\t\tmarkFilteringSet = reader.uint16();\n\t}\n\n\tconst baseProps = { flag: lookupFlag, markFilteringSet };\n\n\tswitch (lookupType) {\n\t\tcase GsubLookupType.Single:\n\t\t\treturn {\n\t\t\t\ttype: GsubLookupType.Single,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables: parseSingleSubst(reader, subtableOffsets),\n\t\t\t};\n\n\t\tcase GsubLookupType.Multiple:\n\t\t\treturn {\n\t\t\t\ttype: GsubLookupType.Multiple,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables: parseMultipleSubst(reader, subtableOffsets),\n\t\t\t};\n\n\t\tcase GsubLookupType.Alternate:\n\t\t\treturn {\n\t\t\t\ttype: GsubLookupType.Alternate,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables: parseAlternateSubst(reader, subtableOffsets),\n\t\t\t};\n\n\t\tcase GsubLookupType.Ligature:\n\t\t\treturn {\n\t\t\t\ttype: GsubLookupType.Ligature,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables: parseLigatureSubst(reader, subtableOffsets),\n\t\t\t};\n\n\t\tcase GsubLookupType.Context:\n\t\t\treturn {\n\t\t\t\ttype: GsubLookupType.Context,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables: parseContextSubst(reader, subtableOffsets),\n\t\t\t};\n\n\t\tcase GsubLookupType.ChainingContext:\n\t\t\treturn {\n\t\t\t\ttype: GsubLookupType.ChainingContext,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables: parseChainingContextSubst(reader, subtableOffsets),\n\t\t\t};\n\n\t\tcase GsubLookupType.Extension:\n\t\t\treturn parseExtensionLookup(reader, subtableOffsets, baseProps);\n\n\t\tcase GsubLookupType.ReverseChainingSingle:\n\t\t\treturn {\n\t\t\t\ttype: GsubLookupType.ReverseChainingSingle,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables: parseReverseChainingSingleSubst(reader, subtableOffsets),\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn null;\n\t}\n}\n\nfunction parseSingleSubst(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): SingleSubstSubtable[] {\n\tconst subtables: SingleSubstSubtable[] = [];\n\n\tfor (const offset of subtableOffsets) {\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tif (format === 1) {\n\t\t\tconst coverageOffset = r.offset16();\n\t\t\tconst deltaGlyphId = r.int16();\n\t\t\tconst coverage = parseCoverageAt(r, coverageOffset);\n\t\t\tsubtables.push({ format: 1, coverage, deltaGlyphId });\n\t\t} else if (format === 2) {\n\t\t\tconst coverageOffset = r.offset16();\n\t\t\tconst glyphCount = r.uint16();\n\t\t\tconst substituteGlyphIds = Array.from(r.uint16Array(glyphCount));\n\t\t\tconst coverage = parseCoverageAt(r, coverageOffset);\n\t\t\tsubtables.push({ format: 2, coverage, substituteGlyphIds });\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nfunction parseMultipleSubst(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): MultipleSubstSubtable[] {\n\tconst subtables: MultipleSubstSubtable[] = [];\n\n\tfor (const offset of subtableOffsets) {\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tif (format === 1) {\n\t\t\tconst coverageOffset = r.offset16();\n\t\t\tconst sequenceCount = r.uint16();\n\t\t\tconst sequenceOffsets = r.uint16Array(sequenceCount);\n\n\t\t\tconst coverage = parseCoverageAt(r, coverageOffset);\n\t\t\tconst sequences: GlyphId[][] = [];\n\n\t\t\tfor (const seqOffset of sequenceOffsets) {\n\t\t\t\tconst seqReader = r.sliceFrom(seqOffset);\n\t\t\t\tconst glyphCount = seqReader.uint16();\n\t\t\t\tsequences.push(Array.from(seqReader.uint16Array(glyphCount)));\n\t\t\t}\n\n\t\t\tsubtables.push({ coverage, sequences });\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nfunction parseAlternateSubst(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): AlternateSubstSubtable[] {\n\tconst subtables: AlternateSubstSubtable[] = [];\n\n\tfor (const offset of subtableOffsets) {\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tif (format === 1) {\n\t\t\tconst coverageOffset = r.offset16();\n\t\t\tconst alternateSetCount = r.uint16();\n\t\t\tconst alternateSetOffsets = r.uint16Array(alternateSetCount);\n\n\t\t\tconst coverage = parseCoverageAt(r, coverageOffset);\n\t\t\tconst alternateSets: GlyphId[][] = [];\n\n\t\t\tfor (const altOffset of alternateSetOffsets) {\n\t\t\t\tconst altReader = r.sliceFrom(altOffset);\n\t\t\t\tconst glyphCount = altReader.uint16();\n\t\t\t\talternateSets.push(Array.from(altReader.uint16Array(glyphCount)));\n\t\t\t}\n\n\t\t\tsubtables.push({ coverage, alternateSets });\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nfunction parseLigatureSubst(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): LigatureSubstSubtable[] {\n\tconst subtables: LigatureSubstSubtable[] = [];\n\n\tfor (const offset of subtableOffsets) {\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tif (format === 1) {\n\t\t\tconst coverageOffset = r.offset16();\n\t\t\tconst ligatureSetCount = r.uint16();\n\t\t\tconst ligatureSetOffsets = r.uint16Array(ligatureSetCount);\n\n\t\t\tconst coverage = parseCoverageAt(r, coverageOffset);\n\t\t\tconst ligatureSets: LigatureSet[] = [];\n\n\t\t\tfor (const setOffset of ligatureSetOffsets) {\n\t\t\t\tconst setReader = r.sliceFrom(setOffset);\n\t\t\t\tconst ligatureCount = setReader.uint16();\n\t\t\t\tconst ligatureOffsets = setReader.uint16Array(ligatureCount);\n\n\t\t\t\tconst ligatures: Ligature[] = [];\n\t\t\t\tfor (const ligOffset of ligatureOffsets) {\n\t\t\t\t\tconst ligReader = setReader.sliceFrom(ligOffset);\n\t\t\t\t\tconst ligatureGlyph = ligReader.uint16();\n\t\t\t\t\tconst componentCount = ligReader.uint16();\n\t\t\t\t\tconst componentGlyphIds = Array.from(\n\t\t\t\t\t\tligReader.uint16Array(componentCount - 1),\n\t\t\t\t\t);\n\t\t\t\t\tligatures.push({ ligatureGlyph, componentGlyphIds });\n\t\t\t\t}\n\n\t\t\t\tligatureSets.push({ ligatures });\n\t\t\t}\n\n\t\t\tsubtables.push({ coverage, ligatureSets });\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nfunction parseReverseChainingSingleSubst(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): ReverseChainingSingleSubstSubtable[] {\n\tconst subtables: ReverseChainingSingleSubstSubtable[] = [];\n\n\tfor (const offset of subtableOffsets) {\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tif (format === 1) {\n\t\t\tconst coverageOffset = r.offset16();\n\n\t\t\tconst backtrackCount = r.uint16();\n\t\t\tconst backtrackCoverageOffsets = r.uint16Array(backtrackCount);\n\n\t\t\tconst lookaheadCount = r.uint16();\n\t\t\tconst lookaheadCoverageOffsets = r.uint16Array(lookaheadCount);\n\n\t\t\tconst glyphCount = r.uint16();\n\t\t\tconst substituteGlyphIds = Array.from(r.uint16Array(glyphCount));\n\n\t\t\tconst coverage = parseCoverageAt(r, coverageOffset);\n\n\t\t\tconst backtrackCoverages: Coverage[] = [];\n\t\t\tfor (const covOffset of backtrackCoverageOffsets) {\n\t\t\t\tbacktrackCoverages.push(parseCoverageAt(r, covOffset));\n\t\t\t}\n\n\t\t\tconst lookaheadCoverages: Coverage[] = [];\n\t\t\tfor (const covOffset of lookaheadCoverageOffsets) {\n\t\t\t\tlookaheadCoverages.push(parseCoverageAt(r, covOffset));\n\t\t\t}\n\n\t\t\tsubtables.push({\n\t\t\t\tcoverage,\n\t\t\t\tbacktrackCoverages,\n\t\t\t\tlookaheadCoverages,\n\t\t\t\tsubstituteGlyphIds,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nfunction parseExtensionLookup(\n\treader: Reader,\n\tsubtableOffsets: number[],\n\tbaseProps: { flag: uint16; markFilteringSet?: uint16 },\n): AnyGsubLookup | null {\n\tif (subtableOffsets.length === 0) return null;\n\n\t// Parse all extension subtables\n\tconst extSubtables: Array<{ type: number; reader: Reader }> = [];\n\n\tfor (const offset of subtableOffsets) {\n\t\tconst extReader = reader.sliceFrom(offset);\n\t\tconst format = extReader.uint16();\n\t\tif (format !== 1) continue;\n\n\t\tconst extensionLookupType = extReader.uint16();\n\t\tconst extensionOffset = extReader.uint32();\n\n\t\t// extensionOffset is relative to start of extension subtable\n\t\textSubtables.push({\n\t\t\ttype: extensionLookupType,\n\t\t\treader: extReader.sliceFrom(extensionOffset),\n\t\t});\n\t}\n\n\tif (extSubtables.length === 0) return null;\n\n\tconst actualType = extSubtables[0]?.type;\n\tconst _actualOffsets = extSubtables.map((_, _i) => 0); // All at offset 0 of their readers\n\n\t// Create a combined reader for all subtables\n\tswitch (actualType) {\n\t\tcase GsubLookupType.Single: {\n\t\t\tconst subtables: SingleSubstSubtable[] = [];\n\t\t\tfor (const ext of extSubtables) {\n\t\t\t\tsubtables.push(...parseSingleSubst(ext.reader, [0]));\n\t\t\t}\n\t\t\treturn { type: GsubLookupType.Single, ...baseProps, subtables };\n\t\t}\n\n\t\tcase GsubLookupType.Multiple: {\n\t\t\tconst subtables: MultipleSubstSubtable[] = [];\n\t\t\tfor (const ext of extSubtables) {\n\t\t\t\tsubtables.push(...parseMultipleSubst(ext.reader, [0]));\n\t\t\t}\n\t\t\treturn { type: GsubLookupType.Multiple, ...baseProps, subtables };\n\t\t}\n\n\t\tcase GsubLookupType.Alternate: {\n\t\t\tconst subtables: AlternateSubstSubtable[] = [];\n\t\t\tfor (const ext of extSubtables) {\n\t\t\t\tsubtables.push(...parseAlternateSubst(ext.reader, [0]));\n\t\t\t}\n\t\t\treturn { type: GsubLookupType.Alternate, ...baseProps, subtables };\n\t\t}\n\n\t\tcase GsubLookupType.Ligature: {\n\t\t\tconst subtables: LigatureSubstSubtable[] = [];\n\t\t\tfor (const ext of extSubtables) {\n\t\t\t\tsubtables.push(...parseLigatureSubst(ext.reader, [0]));\n\t\t\t}\n\t\t\treturn { type: GsubLookupType.Ligature, ...baseProps, subtables };\n\t\t}\n\n\t\tcase GsubLookupType.Context: {\n\t\t\tconst subtables: ContextSubstSubtable[] = [];\n\t\t\tfor (const ext of extSubtables) {\n\t\t\t\tsubtables.push(...parseContextSubst(ext.reader, [0]));\n\t\t\t}\n\t\t\treturn { type: GsubLookupType.Context, ...baseProps, subtables };\n\t\t}\n\n\t\tcase GsubLookupType.ChainingContext: {\n\t\t\tconst subtables: ChainingContextSubstSubtable[] = [];\n\t\t\tfor (const ext of extSubtables) {\n\t\t\t\tsubtables.push(...parseChainingContextSubst(ext.reader, [0]));\n\t\t\t}\n\t\t\treturn { type: GsubLookupType.ChainingContext, ...baseProps, subtables };\n\t\t}\n\n\t\tcase GsubLookupType.ReverseChainingSingle: {\n\t\t\tconst subtables: ReverseChainingSingleSubstSubtable[] = [];\n\t\t\tfor (const ext of extSubtables) {\n\t\t\t\tsubtables.push(...parseReverseChainingSingleSubst(ext.reader, [0]));\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: GsubLookupType.ReverseChainingSingle,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t};\n\t\t}\n\n\t\tdefault:\n\t\t\treturn null;\n\t}\n}\n\n// Utility functions for applying lookups\n\nexport function applySingleSubst(\n\tlookup: SingleSubstLookup,\n\tglyphId: GlyphId,\n): GlyphId | null {\n\tfor (const subtable of lookup.subtables) {\n\t\tconst coverageIndex = subtable.coverage.get(glyphId);\n\t\tif (coverageIndex === null) continue;\n\n\t\tif (subtable.format === 1 && subtable.deltaGlyphId !== undefined) {\n\t\t\treturn (glyphId + subtable.deltaGlyphId) & 0xffff;\n\t\t}\n\n\t\tif (subtable.format === 2 && subtable.substituteGlyphIds) {\n\t\t\treturn subtable.substituteGlyphIds[coverageIndex] ?? null;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nexport function applyLigatureSubst(\n\tlookup: LigatureSubstLookup,\n\tglyphIds: GlyphId[],\n\tstartIndex: number,\n): { ligatureGlyph: GlyphId; consumed: number } | null {\n\tconst firstGlyph = glyphIds[startIndex];\n\tif (firstGlyph === undefined) return null;\n\n\tfor (const subtable of lookup.subtables) {\n\t\tconst coverageIndex = subtable.coverage.get(firstGlyph);\n\t\tif (coverageIndex === null) continue;\n\n\t\tconst ligatureSet = subtable.ligatureSets[coverageIndex];\n\t\tif (!ligatureSet) continue;\n\n\t\tfor (const ligature of ligatureSet.ligatures) {\n\t\t\tconst componentCount = ligature.componentGlyphIds.length;\n\n\t\t\tif (startIndex + 1 + componentCount > glyphIds.length) continue;\n\n\t\t\tlet matches = true;\n\t\t\tfor (let i = 0; i < componentCount; i++) {\n\t\t\t\tif (glyphIds[startIndex + 1 + i] !== ligature.componentGlyphIds[i]) {\n\t\t\t\t\tmatches = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (matches) {\n\t\t\t\treturn {\n\t\t\t\t\tligatureGlyph: ligature.ligatureGlyph,\n\t\t\t\t\tconsumed: 1 + componentCount,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n}\n", "import type { Fixed, FWord, int16, uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\nconst HEAD_MAGIC_NUMBER = 0x5f0f3cf5;\n\n/** Font header table */\nexport interface HeadTable {\n\tmajorVersion: uint16;\n\tminorVersion: uint16;\n\tfontRevision: Fixed;\n\tchecksumAdjustment: uint32;\n\tmagicNumber: uint32;\n\tflags: uint16;\n\tunitsPerEm: uint16;\n\tcreated: bigint;\n\tmodified: bigint;\n\txMin: FWord;\n\tyMin: FWord;\n\txMax: FWord;\n\tyMax: FWord;\n\tmacStyle: uint16;\n\tlowestRecPPEM: uint16;\n\tfontDirectionHint: int16;\n\t/** 0 = short offsets (uint16), 1 = long offsets (uint32) in loca table */\n\tindexToLocFormat: int16;\n\tglyphDataFormat: int16;\n}\n\n/** Head table flags */\nexport const HeadFlags = {\n\tBaselineAtY0: 0x0001,\n\tLeftSidebearingAtX0: 0x0002,\n\tInstructionsDependOnPointSize: 0x0004,\n\tForcePPEMToInteger: 0x0008,\n\tInstructionsAlterAdvanceWidth: 0x0010,\n\tLossless: 0x0800,\n\tConverted: 0x1000,\n\tOptimizedForClearType: 0x2000,\n\tLastResortFont: 0x4000,\n} as const;\n\n/** Mac style flags */\nexport const MacStyle = {\n\tBold: 0x0001,\n\tItalic: 0x0002,\n\tUnderline: 0x0004,\n\tOutline: 0x0008,\n\tShadow: 0x0010,\n\tCondensed: 0x0020,\n\tExtended: 0x0040,\n} as const;\n\nexport function parseHead(reader: Reader): HeadTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst fontRevision = reader.fixed();\n\tconst checksumAdjustment = reader.uint32();\n\tconst magicNumber = reader.uint32();\n\n\tif (magicNumber !== HEAD_MAGIC_NUMBER) {\n\t\tthrow new Error(\n\t\t\t`Invalid head table magic number: 0x${magicNumber.toString(16)}`,\n\t\t);\n\t}\n\n\tconst flags = reader.uint16();\n\tconst unitsPerEm = reader.uint16();\n\tconst created = reader.longDateTime();\n\tconst modified = reader.longDateTime();\n\tconst xMin = reader.fword();\n\tconst yMin = reader.fword();\n\tconst xMax = reader.fword();\n\tconst yMax = reader.fword();\n\tconst macStyle = reader.uint16();\n\tconst lowestRecPPEM = reader.uint16();\n\tconst fontDirectionHint = reader.int16();\n\tconst indexToLocFormat = reader.int16();\n\tconst glyphDataFormat = reader.int16();\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\tfontRevision,\n\t\tchecksumAdjustment,\n\t\tmagicNumber,\n\t\tflags,\n\t\tunitsPerEm,\n\t\tcreated,\n\t\tmodified,\n\t\txMin,\n\t\tyMin,\n\t\txMax,\n\t\tyMax,\n\t\tmacStyle,\n\t\tlowestRecPPEM,\n\t\tfontDirectionHint,\n\t\tindexToLocFormat,\n\t\tglyphDataFormat,\n\t};\n}\n", "import type { FWord, int16, UFWord, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/** Horizontal header table */\nexport interface HheaTable {\n\tmajorVersion: uint16;\n\tminorVersion: uint16;\n\tascender: FWord;\n\tdescender: FWord;\n\tlineGap: FWord;\n\tadvanceWidthMax: UFWord;\n\tminLeftSideBearing: FWord;\n\tminRightSideBearing: FWord;\n\txMaxExtent: FWord;\n\tcaretSlopeRise: int16;\n\tcaretSlopeRun: int16;\n\tcaretOffset: int16;\n\treserved1: int16;\n\treserved2: int16;\n\treserved3: int16;\n\treserved4: int16;\n\tmetricDataFormat: int16;\n\tnumberOfHMetrics: uint16;\n}\n\nexport function parseHhea(reader: Reader): HheaTable {\n\treturn {\n\t\tmajorVersion: reader.uint16(),\n\t\tminorVersion: reader.uint16(),\n\t\tascender: reader.fword(),\n\t\tdescender: reader.fword(),\n\t\tlineGap: reader.fword(),\n\t\tadvanceWidthMax: reader.ufword(),\n\t\tminLeftSideBearing: reader.fword(),\n\t\tminRightSideBearing: reader.fword(),\n\t\txMaxExtent: reader.fword(),\n\t\tcaretSlopeRise: reader.int16(),\n\t\tcaretSlopeRun: reader.int16(),\n\t\tcaretOffset: reader.int16(),\n\t\treserved1: reader.int16(),\n\t\treserved2: reader.int16(),\n\t\treserved3: reader.int16(),\n\t\treserved4: reader.int16(),\n\t\tmetricDataFormat: reader.int16(),\n\t\tnumberOfHMetrics: reader.uint16(),\n\t};\n}\n", "import type { FWord, GlyphId, UFWord } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/** Horizontal metric for a glyph */\nexport interface LongHorMetric {\n\tadvanceWidth: UFWord;\n\tlsb: FWord; // left side bearing\n}\n\n/** Horizontal metrics table */\nexport interface HmtxTable {\n\thMetrics: LongHorMetric[];\n\tleftSideBearings: FWord[];\n}\n\n/**\n * Parse hmtx table.\n * @param reader - Reader positioned at hmtx table start\n * @param numberOfHMetrics - From hhea table\n * @param numGlyphs - From maxp table\n */\nexport function parseHmtx(\n\treader: Reader,\n\tnumberOfHMetrics: number,\n\tnumGlyphs: number,\n): HmtxTable {\n\t// Read full metrics (advanceWidth + lsb)\n\tconst hMetrics: LongHorMetric[] = new Array(numberOfHMetrics);\n\tfor (let i = 0; i < numberOfHMetrics; i++) {\n\t\thMetrics[i] = {\n\t\t\tadvanceWidth: reader.ufword(),\n\t\t\tlsb: reader.fword(),\n\t\t};\n\t}\n\n\t// Remaining glyphs share the last advanceWidth, only store lsb\n\tconst numLeftSideBearings = numGlyphs - numberOfHMetrics;\n\tconst leftSideBearings: FWord[] = new Array(numLeftSideBearings);\n\tfor (let i = 0; i < numLeftSideBearings; i++) {\n\t\tleftSideBearings[i] = reader.fword();\n\t}\n\n\treturn { hMetrics, leftSideBearings };\n}\n\n/** Get advance width for a glyph */\nexport function getAdvanceWidth(hmtx: HmtxTable, glyphId: GlyphId): number {\n\tif (glyphId < hmtx.hMetrics.length) {\n\t\treturn hmtx.hMetrics[glyphId]?.advanceWidth;\n\t}\n\t// Use last advanceWidth for remaining glyphs\n\treturn hmtx.hMetrics[hmtx.hMetrics.length - 1]?.advanceWidth;\n}\n\n/** Get left side bearing for a glyph */\nexport function getLeftSideBearing(hmtx: HmtxTable, glyphId: GlyphId): number {\n\tif (glyphId < hmtx.hMetrics.length) {\n\t\treturn hmtx.hMetrics[glyphId]?.lsb;\n\t}\n\tconst idx = glyphId - hmtx.hMetrics.length;\n\treturn hmtx.leftSideBearings[idx] ?? 0;\n}\n", "import type { uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * JSTF table - Justification data\n * Provides justification alternatives for scripts\n */\n\n/** Justification priority levels */\nexport const JstfPriority = {\n\t/** Shrink GPOS lookups */\n\tShrinkGpos: 0,\n\t/** Disable GPOS lookups */\n\tDisableGpos: 1,\n\t/** Shrink GSUB lookups */\n\tShrinkGsub: 2,\n\t/** Disable GSUB lookups */\n\tDisableGsub: 3,\n\t/** Enable GPOS lookups */\n\tEnableGpos: 4,\n\t/** Enable GSUB lookups */\n\tEnableGsub: 5,\n\t/** Max extension GPOS lookups */\n\tMaxExtendGpos: 6,\n\t/** Max extension GSUB lookups */\n\tMaxExtendGsub: 7,\n} as const;\n\n/** JstfMax table - lookup indices for maximum extension */\nexport interface JstfMax {\n\tlookupIndices: uint16[];\n}\n\n/** JstfModList - enable/disable lookup list */\nexport interface JstfModList {\n\tlookupIndices: uint16[];\n}\n\n/** Justification priority record */\nexport interface JstfPriorityRecord {\n\t/** GSUB lookups to enable for shrinkage */\n\tshrinkageEnableGsub: JstfModList | null;\n\t/** GSUB lookups to disable for shrinkage */\n\tshrinkageDisableGsub: JstfModList | null;\n\t/** GPOS lookups to enable for shrinkage */\n\tshrinkageEnableGpos: JstfModList | null;\n\t/** GPOS lookups to disable for shrinkage */\n\tshrinkageDisableGpos: JstfModList | null;\n\t/** Maximum shrinkage GSUB */\n\tshrinkageJstfMax: JstfMax | null;\n\t/** GSUB lookups to enable for extension */\n\textensionEnableGsub: JstfModList | null;\n\t/** GSUB lookups to disable for extension */\n\textensionDisableGsub: JstfModList | null;\n\t/** GPOS lookups to enable for extension */\n\textensionEnableGpos: JstfModList | null;\n\t/** GPOS lookups to disable for extension */\n\textensionDisableGpos: JstfModList | null;\n\t/** Maximum extension GSUB */\n\textensionJstfMax: JstfMax | null;\n}\n\n/** Justification language system */\nexport interface JstfLangSys {\n\tpriorities: JstfPriorityRecord[];\n}\n\n/** Justification script record */\nexport interface JstfScriptRecord {\n\tscriptTag: number;\n\t/** Extender glyphs for Kashida-like justification */\n\textenderGlyphs: uint16[];\n\t/** Default language system */\n\tdefaultLangSys: JstfLangSys | null;\n\t/** Language-specific systems */\n\tlangSysRecords: Map<number, JstfLangSys>;\n}\n\n/** JSTF table */\nexport interface JstfTable {\n\tmajorVersion: uint16;\n\tminorVersion: uint16;\n\tscripts: JstfScriptRecord[];\n}\n\nfunction parseJstfModList(reader: Reader, offset: number): JstfModList | null {\n\tif (offset === 0) return null;\n\n\tconst modReader = reader.sliceFrom(offset);\n\tconst lookupCount = modReader.uint16();\n\tconst lookupIndices: uint16[] = [];\n\n\tfor (let i = 0; i < lookupCount; i++) {\n\t\tlookupIndices.push(modReader.uint16());\n\t}\n\n\treturn { lookupIndices };\n}\n\nfunction parseJstfMax(reader: Reader, offset: number): JstfMax | null {\n\tif (offset === 0) return null;\n\n\tconst maxReader = reader.sliceFrom(offset);\n\tconst lookupCount = maxReader.uint16();\n\tconst lookupIndices: uint16[] = [];\n\n\tfor (let i = 0; i < lookupCount; i++) {\n\t\tlookupIndices.push(maxReader.uint16());\n\t}\n\n\treturn { lookupIndices };\n}\n\nfunction parseJstfPriority(reader: Reader, offset: number): JstfPriorityRecord {\n\tconst priReader = reader.sliceFrom(offset);\n\n\tconst shrinkageEnableGsubOffset = priReader.uint16();\n\tconst shrinkageDisableGsubOffset = priReader.uint16();\n\tconst shrinkageEnableGposOffset = priReader.uint16();\n\tconst shrinkageDisableGposOffset = priReader.uint16();\n\tconst shrinkageJstfMaxOffset = priReader.uint16();\n\tconst extensionEnableGsubOffset = priReader.uint16();\n\tconst extensionDisableGsubOffset = priReader.uint16();\n\tconst extensionEnableGposOffset = priReader.uint16();\n\tconst extensionDisableGposOffset = priReader.uint16();\n\tconst extensionJstfMaxOffset = priReader.uint16();\n\n\treturn {\n\t\tshrinkageEnableGsub: parseJstfModList(\n\t\t\treader,\n\t\t\toffset + shrinkageEnableGsubOffset,\n\t\t),\n\t\tshrinkageDisableGsub: parseJstfModList(\n\t\t\treader,\n\t\t\toffset + shrinkageDisableGsubOffset,\n\t\t),\n\t\tshrinkageEnableGpos: parseJstfModList(\n\t\t\treader,\n\t\t\toffset + shrinkageEnableGposOffset,\n\t\t),\n\t\tshrinkageDisableGpos: parseJstfModList(\n\t\t\treader,\n\t\t\toffset + shrinkageDisableGposOffset,\n\t\t),\n\t\tshrinkageJstfMax: parseJstfMax(reader, offset + shrinkageJstfMaxOffset),\n\t\textensionEnableGsub: parseJstfModList(\n\t\t\treader,\n\t\t\toffset + extensionEnableGsubOffset,\n\t\t),\n\t\textensionDisableGsub: parseJstfModList(\n\t\t\treader,\n\t\t\toffset + extensionDisableGsubOffset,\n\t\t),\n\t\textensionEnableGpos: parseJstfModList(\n\t\t\treader,\n\t\t\toffset + extensionEnableGposOffset,\n\t\t),\n\t\textensionDisableGpos: parseJstfModList(\n\t\t\treader,\n\t\t\toffset + extensionDisableGposOffset,\n\t\t),\n\t\textensionJstfMax: parseJstfMax(reader, offset + extensionJstfMaxOffset),\n\t};\n}\n\nfunction parseJstfLangSys(reader: Reader, offset: number): JstfLangSys {\n\tconst langReader = reader.sliceFrom(offset);\n\tconst jstfPriorityCount = langReader.uint16();\n\n\tconst priorityOffsets: uint16[] = [];\n\tfor (let i = 0; i < jstfPriorityCount; i++) {\n\t\tpriorityOffsets.push(langReader.uint16());\n\t}\n\n\tconst priorities: JstfPriorityRecord[] = [];\n\tfor (const priOffset of priorityOffsets) {\n\t\tpriorities.push(parseJstfPriority(reader, offset + priOffset));\n\t}\n\n\treturn { priorities };\n}\n\nfunction parseJstfScript(\n\treader: Reader,\n\toffset: number,\n): Omit<JstfScriptRecord, \"scriptTag\"> {\n\tconst scriptReader = reader.sliceFrom(offset);\n\tconst extenderGlyphOffset = scriptReader.uint16();\n\tconst defJstfLangSysOffset = scriptReader.uint16();\n\tconst jstfLangSysCount = scriptReader.uint16();\n\n\t// Parse language system records\n\tconst langSysData: Array<{ tag: number; offset: number }> = [];\n\tfor (let i = 0; i < jstfLangSysCount; i++) {\n\t\tconst tag = scriptReader.uint32();\n\t\tconst langOffset = scriptReader.uint16();\n\t\tlangSysData.push({ tag, offset: langOffset });\n\t}\n\n\t// Parse extender glyphs\n\tconst extenderGlyphs: uint16[] = [];\n\tif (extenderGlyphOffset !== 0) {\n\t\tconst extReader = reader.sliceFrom(offset + extenderGlyphOffset);\n\t\tconst glyphCount = extReader.uint16();\n\t\tfor (let i = 0; i < glyphCount; i++) {\n\t\t\textenderGlyphs.push(extReader.uint16());\n\t\t}\n\t}\n\n\t// Parse default lang sys\n\tconst defaultLangSys =\n\t\tdefJstfLangSysOffset !== 0\n\t\t\t? parseJstfLangSys(reader, offset + defJstfLangSysOffset)\n\t\t\t: null;\n\n\t// Parse language-specific systems\n\tconst langSysRecords = new Map<number, JstfLangSys>();\n\tfor (const { tag, offset: langOffset } of langSysData) {\n\t\tlangSysRecords.set(tag, parseJstfLangSys(reader, offset + langOffset));\n\t}\n\n\treturn { extenderGlyphs, defaultLangSys, langSysRecords };\n}\n\nexport function parseJstf(reader: Reader): JstfTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst jstfScriptCount = reader.uint16();\n\n\t// Read script record offsets\n\tconst scriptData: Array<{ tag: number; offset: number }> = [];\n\tfor (let i = 0; i < jstfScriptCount; i++) {\n\t\tconst tag = reader.uint32();\n\t\tconst offset = reader.uint16();\n\t\tscriptData.push({ tag, offset });\n\t}\n\n\t// Parse scripts\n\tconst scripts: JstfScriptRecord[] = [];\n\tfor (const { tag, offset } of scriptData) {\n\t\tconst script = parseJstfScript(reader, offset);\n\t\tscripts.push({ scriptTag: tag, ...script });\n\t}\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\tscripts,\n\t};\n}\n\n/** Get extender glyphs for a script (e.g., Kashida for Arabic) */\nexport function getExtenderGlyphs(\n\tjstf: JstfTable,\n\tscriptTag: number,\n): uint16[] {\n\tconst script = jstf.scripts.find((s) => s.scriptTag === scriptTag);\n\treturn script?.extenderGlyphs ?? [];\n}\n\n/** Get justification priorities for a script/language */\nexport function getJstfPriorities(\n\tjstf: JstfTable,\n\tscriptTag: number,\n\tlanguageTag?: number,\n): JstfPriorityRecord[] {\n\tconst script = jstf.scripts.find((s) => s.scriptTag === scriptTag);\n\tif (!script) return [];\n\n\t// Try language-specific first\n\tif (languageTag !== undefined) {\n\t\tconst langSys = script.langSysRecords.get(languageTag);\n\t\tif (langSys) return langSys.priorities;\n\t}\n\n\t// Fall back to default\n\treturn script.defaultLangSys?.priorities ?? [];\n}\n\n/** Get lookup modifications for shrinkage at a given priority level */\nexport function getShrinkageMods(priority: JstfPriorityRecord): {\n\tenableGsub: uint16[];\n\tdisableGsub: uint16[];\n\tenableGpos: uint16[];\n\tdisableGpos: uint16[];\n\tmaxLookups: uint16[];\n} {\n\treturn {\n\t\tenableGsub: priority.shrinkageEnableGsub?.lookupIndices ?? [],\n\t\tdisableGsub: priority.shrinkageDisableGsub?.lookupIndices ?? [],\n\t\tenableGpos: priority.shrinkageEnableGpos?.lookupIndices ?? [],\n\t\tdisableGpos: priority.shrinkageDisableGpos?.lookupIndices ?? [],\n\t\tmaxLookups: priority.shrinkageJstfMax?.lookupIndices ?? [],\n\t};\n}\n\n/** Get lookup modifications for extension at a given priority level */\nexport function getExtensionMods(priority: JstfPriorityRecord): {\n\tenableGsub: uint16[];\n\tdisableGsub: uint16[];\n\tenableGpos: uint16[];\n\tdisableGpos: uint16[];\n\tmaxLookups: uint16[];\n} {\n\treturn {\n\t\tenableGsub: priority.extensionEnableGsub?.lookupIndices ?? [],\n\t\tdisableGsub: priority.extensionDisableGsub?.lookupIndices ?? [],\n\t\tenableGpos: priority.extensionEnableGpos?.lookupIndices ?? [],\n\t\tdisableGpos: priority.extensionDisableGpos?.lookupIndices ?? [],\n\t\tmaxLookups: priority.extensionJstfMax?.lookupIndices ?? [],\n\t};\n}\n", "import type { GlyphId, int16, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Legacy kern table for kerning pairs\n * Used when GPOS kerning is not available\n */\nexport interface KernTable {\n\tversion: number;\n\tsubtables: KernSubtable[];\n}\n\nexport type KernSubtable = KernFormat0 | KernFormat2;\n\n/**\n * Format 0: Ordered list of kerning pairs\n */\nexport interface KernFormat0 {\n\tformat: 0;\n\tcoverage: KernCoverage;\n\tpairs: Map<number, int16>; // key = (left << 16) | right, value = kerning\n}\n\n/**\n * Format 2: Class-based kerning (two-dimensional array)\n */\nexport interface KernFormat2 {\n\tformat: 2;\n\tcoverage: KernCoverage;\n\trowWidth: uint16;\n\tleftClassTable: Map<GlyphId, uint16>;\n\trightClassTable: Map<GlyphId, uint16>;\n\tkerningValues: int16[][];\n}\n\nexport interface KernCoverage {\n\thorizontal: boolean;\n\tminimum: boolean;\n\tcrossStream: boolean;\n\toverride: boolean;\n}\n\n/**\n * Parse kern table\n */\nexport function parseKern(reader: Reader): KernTable {\n\tconst version = reader.uint16();\n\tconst subtables: KernSubtable[] = [];\n\n\tif (version === 0) {\n\t\t// Microsoft format\n\t\tconst nTables = reader.uint16();\n\t\tfor (let i = 0; i < nTables; i++) {\n\t\t\tconst subtable = parseKernSubtable(reader);\n\t\t\tif (subtable) subtables.push(subtable);\n\t\t}\n\t} else if (version === 1) {\n\t\t// Apple format (version is actually 0x00010000)\n\t\treader.skip(2); // Skip rest of version\n\t\tconst nTables = reader.uint32();\n\t\tfor (let i = 0; i < nTables; i++) {\n\t\t\tconst subtable = parseAppleKernSubtable(reader);\n\t\t\tif (subtable) subtables.push(subtable);\n\t\t}\n\t}\n\n\treturn { version, subtables };\n}\n\nfunction parseKernSubtable(reader: Reader): KernSubtable | null {\n\tconst _version = reader.uint16();\n\tconst length = reader.uint16();\n\tconst coverageBits = reader.uint16();\n\n\tconst coverage: KernCoverage = {\n\t\thorizontal: (coverageBits & 0x0001) !== 0,\n\t\tminimum: (coverageBits & 0x0002) !== 0,\n\t\tcrossStream: (coverageBits & 0x0004) !== 0,\n\t\toverride: (coverageBits & 0x0008) !== 0,\n\t};\n\n\tconst format = (coverageBits >> 8) & 0xff;\n\n\tif (format === 0) {\n\t\treturn parseKernFormat0(reader, coverage);\n\t} else if (format === 2) {\n\t\treturn parseKernFormat2(reader, coverage, length - 6);\n\t}\n\n\t// Skip unknown format\n\treader.skip(length - 6);\n\treturn null;\n}\n\nfunction parseAppleKernSubtable(reader: Reader): KernSubtable | null {\n\tconst length = reader.uint32();\n\tconst coverageBits = reader.uint16();\n\tconst _tupleIndex = reader.uint16();\n\n\tconst coverage: KernCoverage = {\n\t\thorizontal: (coverageBits & 0x8000) === 0, // bit 15: 0=horizontal\n\t\tminimum: false,\n\t\tcrossStream: (coverageBits & 0x4000) !== 0,\n\t\toverride: (coverageBits & 0x2000) !== 0,\n\t};\n\n\tconst format = coverageBits & 0x00ff;\n\n\tif (format === 0) {\n\t\treturn parseKernFormat0(reader, coverage);\n\t} else if (format === 2) {\n\t\treturn parseKernFormat2(reader, coverage, length - 8);\n\t}\n\n\t// Skip unknown format\n\treader.skip(length - 8);\n\treturn null;\n}\n\nfunction parseKernFormat0(reader: Reader, coverage: KernCoverage): KernFormat0 {\n\tconst nPairs = reader.uint16();\n\treader.skip(6); // searchRange, entrySelector, rangeShift\n\n\tconst pairs = new Map<number, int16>();\n\n\tfor (let i = 0; i < nPairs; i++) {\n\t\tconst left = reader.uint16();\n\t\tconst right = reader.uint16();\n\t\tconst value = reader.int16();\n\t\tconst key = (left << 16) | right;\n\t\tpairs.set(key, value);\n\t}\n\n\treturn { format: 0, coverage, pairs };\n}\n\nfunction parseKernFormat2(\n\treader: Reader,\n\tcoverage: KernCoverage,\n\tdataLength: number,\n): KernFormat2 {\n\tconst startOffset = reader.offset;\n\tconst rowWidth = reader.uint16();\n\tconst leftClassOffset = reader.uint16();\n\tconst rightClassOffset = reader.uint16();\n\tconst arrayOffset = reader.uint16();\n\n\t// Parse left class table\n\tconst leftClassTable = new Map<GlyphId, uint16>();\n\treader.seek(startOffset + leftClassOffset);\n\tconst leftFirstGlyph = reader.uint16();\n\tconst leftNGlyphs = reader.uint16();\n\tfor (let i = 0; i < leftNGlyphs; i++) {\n\t\tconst classValue = reader.uint16();\n\t\tif (classValue !== 0) {\n\t\t\tleftClassTable.set(leftFirstGlyph + i, classValue);\n\t\t}\n\t}\n\n\t// Parse right class table\n\tconst rightClassTable = new Map<GlyphId, uint16>();\n\treader.seek(startOffset + rightClassOffset);\n\tconst rightFirstGlyph = reader.uint16();\n\tconst rightNGlyphs = reader.uint16();\n\tfor (let i = 0; i < rightNGlyphs; i++) {\n\t\tconst classValue = reader.uint16();\n\t\tif (classValue !== 0) {\n\t\t\trightClassTable.set(rightFirstGlyph + i, classValue);\n\t\t}\n\t}\n\n\t// Parse kerning array\n\treader.seek(startOffset + arrayOffset);\n\tconst numRows = rowWidth > 0 ? Math.floor(dataLength / rowWidth) : 0;\n\tconst numCols = rowWidth / 2;\n\tconst kerningValues: int16[][] = [];\n\n\tfor (let row = 0; row < numRows; row++) {\n\t\tconst rowValues: int16[] = [];\n\t\tfor (let col = 0; col < numCols; col++) {\n\t\t\trowValues.push(reader.int16());\n\t\t}\n\t\tkerningValues.push(rowValues);\n\t}\n\n\treturn {\n\t\tformat: 2,\n\t\tcoverage,\n\t\trowWidth,\n\t\tleftClassTable,\n\t\trightClassTable,\n\t\tkerningValues,\n\t};\n}\n\n/**\n * Get kerning value from kern table\n */\nexport function getKernValue(\n\tkern: KernTable,\n\tleft: GlyphId,\n\tright: GlyphId,\n): number {\n\tlet total = 0;\n\n\tfor (const subtable of kern.subtables) {\n\t\tif (!subtable.coverage.horizontal) continue; // Only horizontal for now\n\n\t\tif (subtable.format === 0) {\n\t\t\tconst key = (left << 16) | right;\n\t\t\tconst value = subtable.pairs.get(key);\n\t\t\tif (value !== undefined) {\n\t\t\t\tif (subtable.coverage.override) {\n\t\t\t\t\ttotal = value;\n\t\t\t\t} else {\n\t\t\t\t\ttotal += value;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (subtable.format === 2) {\n\t\t\tconst leftClass = subtable.leftClassTable.get(left) ?? 0;\n\t\t\tconst rightClass = subtable.rightClassTable.get(right) ?? 0;\n\n\t\t\tif (leftClass > 0 && rightClass > 0) {\n\t\t\t\tconst rowIndex = Math.floor(leftClass / 2);\n\t\t\t\tconst colIndex = Math.floor(rightClass / 2);\n\t\t\t\tconst row = subtable.kerningValues[rowIndex];\n\t\t\t\tif (row) {\n\t\t\t\t\tconst value = row[colIndex];\n\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\tif (subtable.coverage.override) {\n\t\t\t\t\t\t\ttotal = value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttotal += value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn total;\n}\n", "import type { GlyphId, int16, uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Extended Kerning table (kerx)\n * Apple Advanced Typography kerning\n */\nexport interface KerxTable {\n\tversion: uint16;\n\tnTables: uint32;\n\tsubtables: KerxSubtable[];\n}\n\n/**\n * kerx subtable types\n */\nexport enum KerxSubtableType {\n\tOrderedList = 0,\n\tStateTable = 1,\n\tSimpleArray = 2,\n\tControlPoint = 4,\n\tFormat6 = 6,\n}\n\n/**\n * Coverage flags\n */\nexport interface KerxCoverage {\n\tvertical: boolean;\n\tcrossStream: boolean;\n\tvariation: boolean;\n}\n\n/**\n * Base subtable\n */\nexport interface KerxSubtableBase {\n\tlength: uint32;\n\tcoverage: KerxCoverage;\n\ttupleCount: uint16;\n}\n\nexport type KerxSubtable =\n\t| KerxOrderedListSubtable\n\t| KerxStateTableSubtable\n\t| KerxSimpleArraySubtable\n\t| KerxControlPointSubtable\n\t| KerxFormat6Subtable;\n\n/**\n * Format 0: Ordered list of kerning pairs\n */\nexport interface KerxOrderedListSubtable extends KerxSubtableBase {\n\tformat: KerxSubtableType.OrderedList;\n\tnPairs: uint32;\n\tpairs: KerxPair[];\n}\n\nexport interface KerxPair {\n\tleft: GlyphId;\n\tright: GlyphId;\n\tvalue: int16;\n}\n\n/**\n * Format 1: State table\n */\nexport interface KerxStateTableSubtable extends KerxSubtableBase {\n\tformat: KerxSubtableType.StateTable;\n\tstateHeader: KerxStateHeader;\n\t// State machine data\n}\n\nexport interface KerxStateHeader {\n\tnClasses: uint32;\n\tclassTableOffset: uint32;\n\tstateArrayOffset: uint32;\n\tentryTableOffset: uint32;\n\tvalueTableOffset: uint32;\n}\n\n/**\n * Format 2: Simple array\n */\nexport interface KerxSimpleArraySubtable extends KerxSubtableBase {\n\tformat: KerxSubtableType.SimpleArray;\n\trowWidth: uint16;\n\tleftClassTable: KerxClassTable;\n\trightClassTable: KerxClassTable;\n\tkerningArray: Int16Array;\n}\n\nexport interface KerxClassTable {\n\tfirstGlyph: GlyphId;\n\tnGlyphs: uint16;\n\tclasses: Uint8Array;\n}\n\n/**\n * Format 4: Control point actions\n */\nexport interface KerxControlPointSubtable extends KerxSubtableBase {\n\tformat: KerxSubtableType.ControlPoint;\n\tflags: uint32;\n\t// Control point data\n}\n\n/**\n * Format 6: Extended kerning pairs\n */\nexport interface KerxFormat6Subtable extends KerxSubtableBase {\n\tformat: KerxSubtableType.Format6;\n\tflags: uint32;\n\trowCount: uint16;\n\tcolumnCount: uint16;\n\trowIndexTableOffset: uint32;\n\tcolumnIndexTableOffset: uint32;\n\tkerningArrayOffset: uint32;\n\tkerningVectorOffset: uint32;\n}\n\n/**\n * Parse kerx table\n */\nexport function parseKerx(reader: Reader): KerxTable {\n\tconst version = reader.uint16();\n\treader.skip(2); // padding\n\tconst nTables = reader.uint32();\n\n\tconst subtables: KerxSubtable[] = [];\n\n\tfor (let i = 0; i < nTables; i++) {\n\t\tconst subtable = parseKerxSubtable(reader);\n\t\tif (subtable) subtables.push(subtable);\n\t}\n\n\treturn { version, nTables, subtables };\n}\n\nfunction parseKerxSubtable(reader: Reader): KerxSubtable | null {\n\tconst length = reader.uint32();\n\tconst coverageAndFormat = reader.uint32();\n\tconst tupleCount = reader.uint16();\n\treader.skip(2); // padding\n\n\tconst format = coverageAndFormat & 0xff;\n\tconst coverage: KerxCoverage = {\n\t\tvertical: (coverageAndFormat & 0x80000000) !== 0,\n\t\tcrossStream: (coverageAndFormat & 0x40000000) !== 0,\n\t\tvariation: (coverageAndFormat & 0x20000000) !== 0,\n\t};\n\n\tconst base: KerxSubtableBase = { length, coverage, tupleCount };\n\tconst subtableEnd = reader.offset + length - 12; // Already read 12 bytes\n\n\tlet subtable: KerxSubtable | null = null;\n\n\tswitch (format) {\n\t\tcase KerxSubtableType.OrderedList:\n\t\t\tsubtable = parseKerxFormat0(reader, base);\n\t\t\tbreak;\n\t\tcase KerxSubtableType.StateTable:\n\t\t\tsubtable = parseKerxFormat1(reader, base);\n\t\t\tbreak;\n\t\tcase KerxSubtableType.SimpleArray:\n\t\t\tsubtable = parseKerxFormat2(reader, base);\n\t\t\tbreak;\n\t\tcase KerxSubtableType.Format6:\n\t\t\tsubtable = parseKerxFormat6(reader, base);\n\t\t\tbreak;\n\t}\n\n\t// Skip to end of subtable\n\treader.seek(subtableEnd);\n\n\treturn subtable;\n}\n\nfunction parseKerxFormat0(\n\treader: Reader,\n\tbase: KerxSubtableBase,\n): KerxOrderedListSubtable {\n\tconst nPairs = reader.uint32();\n\treader.skip(12); // searchRange, entrySelector, rangeShift\n\n\tconst pairs: KerxPair[] = [];\n\tfor (let i = 0; i < nPairs; i++) {\n\t\tpairs.push({\n\t\t\tleft: reader.uint16(),\n\t\t\tright: reader.uint16(),\n\t\t\tvalue: reader.int16(),\n\t\t});\n\t\treader.skip(2); // padding\n\t}\n\n\treturn {\n\t\t...base,\n\t\tformat: KerxSubtableType.OrderedList,\n\t\tnPairs,\n\t\tpairs,\n\t};\n}\n\nfunction parseKerxFormat1(\n\treader: Reader,\n\tbase: KerxSubtableBase,\n): KerxStateTableSubtable {\n\tconst stateHeader: KerxStateHeader = {\n\t\tnClasses: reader.uint32(),\n\t\tclassTableOffset: reader.offset32(),\n\t\tstateArrayOffset: reader.offset32(),\n\t\tentryTableOffset: reader.offset32(),\n\t\tvalueTableOffset: reader.offset32(),\n\t};\n\n\treturn {\n\t\t...base,\n\t\tformat: KerxSubtableType.StateTable,\n\t\tstateHeader,\n\t};\n}\n\nfunction parseKerxFormat2(\n\treader: Reader,\n\tbase: KerxSubtableBase,\n): KerxSimpleArraySubtable {\n\tconst rowWidth = reader.uint16();\n\treader.skip(2); // padding\n\n\tconst leftClassTableOffset = reader.offset32();\n\tconst rightClassTableOffset = reader.offset32();\n\tconst kerningArrayOffset = reader.offset32();\n\n\t// Parse class tables\n\tconst leftClassTable = parseKerxClassTable(\n\t\treader.sliceFrom(leftClassTableOffset),\n\t);\n\tconst rightClassTable = parseKerxClassTable(\n\t\treader.sliceFrom(rightClassTableOffset),\n\t);\n\n\t// Parse kerning array\n\tconst arrayReader = reader.sliceFrom(kerningArrayOffset);\n\tconst numRows =\n\t\tleftClassTable.nGlyphs > 0\n\t\t\t? Math.max(...Array.from(leftClassTable.classes)) + 1\n\t\t\t: 0;\n\tconst numCols = rowWidth / 2;\n\tconst kerningArray = new Int16Array(numRows * numCols);\n\n\tfor (const [i, _] of kerningArray.entries()) {\n\t\tkerningArray[i] = arrayReader.int16();\n\t}\n\n\treturn {\n\t\t...base,\n\t\tformat: KerxSubtableType.SimpleArray,\n\t\trowWidth,\n\t\tleftClassTable,\n\t\trightClassTable,\n\t\tkerningArray,\n\t};\n}\n\nfunction parseKerxClassTable(reader: Reader): KerxClassTable {\n\tconst firstGlyph = reader.uint16();\n\tconst nGlyphs = reader.uint16();\n\tconst classes = new Uint8Array(nGlyphs);\n\n\tfor (let i = 0; i < nGlyphs; i++) {\n\t\tclasses[i] = reader.uint8();\n\t}\n\n\treturn { firstGlyph, nGlyphs, classes };\n}\n\nfunction parseKerxFormat6(\n\treader: Reader,\n\tbase: KerxSubtableBase,\n): KerxFormat6Subtable {\n\tconst flags = reader.uint32();\n\tconst rowCount = reader.uint16();\n\tconst columnCount = reader.uint16();\n\tconst rowIndexTableOffset = reader.offset32();\n\tconst columnIndexTableOffset = reader.offset32();\n\tconst kerningArrayOffset = reader.offset32();\n\tconst kerningVectorOffset = reader.offset32();\n\n\treturn {\n\t\t...base,\n\t\tformat: KerxSubtableType.Format6,\n\t\tflags,\n\t\trowCount,\n\t\tcolumnCount,\n\t\trowIndexTableOffset,\n\t\tcolumnIndexTableOffset,\n\t\tkerningArrayOffset,\n\t\tkerningVectorOffset,\n\t};\n}\n\n/**\n * Get kerning value from kerx table\n */\nexport function getKerxValue(\n\tkerx: KerxTable,\n\tleft: GlyphId,\n\tright: GlyphId,\n): number {\n\tfor (const subtable of kerx.subtables) {\n\t\tif (subtable.coverage.vertical) continue; // Skip vertical kerning\n\n\t\tswitch (subtable.format) {\n\t\t\tcase KerxSubtableType.OrderedList: {\n\t\t\t\t// Binary search for the pair\n\t\t\t\tconst pairs = subtable.pairs;\n\t\t\t\tlet lo = 0;\n\t\t\t\tlet hi = pairs.length - 1;\n\n\t\t\t\twhile (lo <= hi) {\n\t\t\t\t\tconst mid = (lo + hi) >> 1;\n\t\t\t\t\tconst pair = pairs[mid];\n\t\t\t\t\tif (!pair) break;\n\n\t\t\t\t\tconst key = (pair.left << 16) | pair.right;\n\t\t\t\t\tconst target = (left << 16) | right;\n\n\t\t\t\t\tif (key === target) {\n\t\t\t\t\t\treturn pair.value;\n\t\t\t\t\t} else if (key < target) {\n\t\t\t\t\t\tlo = mid + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thi = mid - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase KerxSubtableType.SimpleArray: {\n\t\t\t\tconst leftTable = subtable.leftClassTable;\n\t\t\t\tconst rightTable = subtable.rightClassTable;\n\n\t\t\t\tif (\n\t\t\t\t\tleft < leftTable.firstGlyph ||\n\t\t\t\t\tleft >= leftTable.firstGlyph + leftTable.nGlyphs\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tright < rightTable.firstGlyph ||\n\t\t\t\t\tright >= rightTable.firstGlyph + rightTable.nGlyphs\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst leftClass = leftTable.classes[left - leftTable.firstGlyph];\n\t\t\t\tconst rightClass = rightTable.classes[right - rightTable.firstGlyph];\n\t\t\t\tif (leftClass === undefined || rightClass === undefined) continue;\n\n\t\t\t\tconst numCols = subtable.rowWidth / 2;\n\t\t\t\tconst index = leftClass * numCols + rightClass;\n\n\t\t\t\tif (index < subtable.kerningArray.length) {\n\t\t\t\t\tconst value = subtable.kerningArray[index];\n\t\t\t\t\tif (value !== undefined && value !== 0) return value;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n", "import {\n\ttype Coverage,\n\tparseCoverageAt,\n} from \"../../layout/structures/coverage.ts\";\nimport {\n\ttype DeviceOrVariationIndex,\n\tparseDeviceAt,\n} from \"../../layout/structures/device.ts\";\nimport type { GlyphId, int16, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * MATH table - Mathematical typesetting data\n * Provides metrics and glyph information for math layout\n */\n\n/** MathValueRecord - value with optional device correction */\nexport interface MathValueRecord {\n\tvalue: int16;\n\tdevice: DeviceOrVariationIndex | null;\n}\n\n/** MathConstants - global math constants */\nexport interface MathConstants {\n\tscriptPercentScaleDown: int16;\n\tscriptScriptPercentScaleDown: int16;\n\tdelimitedSubFormulaMinHeight: uint16;\n\tdisplayOperatorMinHeight: uint16;\n\tmathLeading: MathValueRecord;\n\taxisHeight: MathValueRecord;\n\taccentBaseHeight: MathValueRecord;\n\tflattenedAccentBaseHeight: MathValueRecord;\n\tsubscriptShiftDown: MathValueRecord;\n\tsubscriptTopMax: MathValueRecord;\n\tsubscriptBaselineDropMin: MathValueRecord;\n\tsuperscriptShiftUp: MathValueRecord;\n\tsuperscriptShiftUpCramped: MathValueRecord;\n\tsuperscriptBottomMin: MathValueRecord;\n\tsuperscriptBaselineDropMax: MathValueRecord;\n\tsubSuperscriptGapMin: MathValueRecord;\n\tsuperscriptBottomMaxWithSubscript: MathValueRecord;\n\tspaceAfterScript: MathValueRecord;\n\tupperLimitGapMin: MathValueRecord;\n\tupperLimitBaselineRiseMin: MathValueRecord;\n\tlowerLimitGapMin: MathValueRecord;\n\tlowerLimitBaselineDropMin: MathValueRecord;\n\tstackTopShiftUp: MathValueRecord;\n\tstackTopDisplayStyleShiftUp: MathValueRecord;\n\tstackBottomShiftDown: MathValueRecord;\n\tstackBottomDisplayStyleShiftDown: MathValueRecord;\n\tstackGapMin: MathValueRecord;\n\tstackDisplayStyleGapMin: MathValueRecord;\n\tstretchStackTopShiftUp: MathValueRecord;\n\tstretchStackBottomShiftDown: MathValueRecord;\n\tstretchStackGapAboveMin: MathValueRecord;\n\tstretchStackGapBelowMin: MathValueRecord;\n\tfractionNumeratorShiftUp: MathValueRecord;\n\tfractionNumeratorDisplayStyleShiftUp: MathValueRecord;\n\tfractionDenominatorShiftDown: MathValueRecord;\n\tfractionDenominatorDisplayStyleShiftDown: MathValueRecord;\n\tfractionNumeratorGapMin: MathValueRecord;\n\tfractionNumDisplayStyleGapMin: MathValueRecord;\n\tfractionRuleThickness: MathValueRecord;\n\tfractionDenominatorGapMin: MathValueRecord;\n\tfractionDenomDisplayStyleGapMin: MathValueRecord;\n\tskewedFractionHorizontalGap: MathValueRecord;\n\tskewedFractionVerticalGap: MathValueRecord;\n\toverbarVerticalGap: MathValueRecord;\n\toverbarRuleThickness: MathValueRecord;\n\toverbarExtraAscender: MathValueRecord;\n\tunderbarVerticalGap: MathValueRecord;\n\tunderbarRuleThickness: MathValueRecord;\n\tunderbarExtraDescender: MathValueRecord;\n\tradicalVerticalGap: MathValueRecord;\n\tradicalDisplayStyleVerticalGap: MathValueRecord;\n\tradicalRuleThickness: MathValueRecord;\n\tradicalExtraAscender: MathValueRecord;\n\tradicalKernBeforeDegree: MathValueRecord;\n\tradicalKernAfterDegree: MathValueRecord;\n\tradicalDegreeBottomRaisePercent: int16;\n}\n\n/** Italic correction info */\nexport interface MathItalicsCorrection {\n\tcoverage: Coverage;\n\tvalues: MathValueRecord[];\n}\n\n/** Top accent attachment */\nexport interface MathTopAccentAttachment {\n\tcoverage: Coverage;\n\tvalues: MathValueRecord[];\n}\n\n/** Extended shape coverage */\nexport interface ExtendedShapeCoverage {\n\tcoverage: Coverage;\n}\n\n/** Math kern record for corner kerns */\nexport interface MathKernRecord {\n\tcorrectionHeights: MathValueRecord[];\n\tkernValues: MathValueRecord[];\n}\n\n/** Math kern info for a glyph */\nexport interface MathKernInfo {\n\ttopRight: MathKernRecord | null;\n\ttopLeft: MathKernRecord | null;\n\tbottomRight: MathKernRecord | null;\n\tbottomLeft: MathKernRecord | null;\n}\n\n/** Math kern info table */\nexport interface MathKernInfoTable {\n\tcoverage: Coverage;\n\tkernInfo: MathKernInfo[];\n}\n\n/** MathGlyphInfo - per-glyph math info */\nexport interface MathGlyphInfo {\n\titalicsCorrection: MathItalicsCorrection | null;\n\ttopAccentAttachment: MathTopAccentAttachment | null;\n\textendedShapeCoverage: ExtendedShapeCoverage | null;\n\tkernInfo: MathKernInfoTable | null;\n}\n\n/** Glyph part record for assembly */\nexport interface GlyphPartRecord {\n\tglyphId: GlyphId;\n\tstartConnectorLength: uint16;\n\tendConnectorLength: uint16;\n\tfullAdvance: uint16;\n\tpartFlags: uint16;\n}\n\n/** Glyph assembly */\nexport interface GlyphAssembly {\n\titalicsCorrection: MathValueRecord;\n\tparts: GlyphPartRecord[];\n}\n\n/** Math glyph construction */\nexport interface MathGlyphConstruction {\n\tglyphAssembly: GlyphAssembly | null;\n\tvariants: Array<{ variantGlyph: GlyphId; advanceMeasurement: uint16 }>;\n}\n\n/** MathVariants - glyph variants and construction */\nexport interface MathVariants {\n\tminConnectorOverlap: uint16;\n\tvertGlyphCoverage: Coverage | null;\n\thorizGlyphCoverage: Coverage | null;\n\tvertGlyphConstruction: MathGlyphConstruction[];\n\thorizGlyphConstruction: MathGlyphConstruction[];\n}\n\n/** MATH table */\nexport interface MathTable {\n\tmajorVersion: uint16;\n\tminorVersion: uint16;\n\tconstants: MathConstants | null;\n\tglyphInfo: MathGlyphInfo | null;\n\tvariants: MathVariants | null;\n}\n\nfunction parseMathValueRecord(\n\treader: Reader,\n\ttableReader: Reader,\n): MathValueRecord {\n\tconst value = reader.int16();\n\tconst deviceOffset = reader.uint16();\n\treturn {\n\t\tvalue,\n\t\tdevice: parseDeviceAt(tableReader, deviceOffset),\n\t};\n}\n\nfunction parseMathConstants(reader: Reader): MathConstants {\n\tconst tableReader = reader;\n\tconst scriptPercentScaleDown = reader.int16();\n\tconst scriptScriptPercentScaleDown = reader.int16();\n\tconst delimitedSubFormulaMinHeight = reader.uint16();\n\tconst displayOperatorMinHeight = reader.uint16();\n\n\treturn {\n\t\tscriptPercentScaleDown,\n\t\tscriptScriptPercentScaleDown,\n\t\tdelimitedSubFormulaMinHeight,\n\t\tdisplayOperatorMinHeight,\n\t\tmathLeading: parseMathValueRecord(reader, tableReader),\n\t\taxisHeight: parseMathValueRecord(reader, tableReader),\n\t\taccentBaseHeight: parseMathValueRecord(reader, tableReader),\n\t\tflattenedAccentBaseHeight: parseMathValueRecord(reader, tableReader),\n\t\tsubscriptShiftDown: parseMathValueRecord(reader, tableReader),\n\t\tsubscriptTopMax: parseMathValueRecord(reader, tableReader),\n\t\tsubscriptBaselineDropMin: parseMathValueRecord(reader, tableReader),\n\t\tsuperscriptShiftUp: parseMathValueRecord(reader, tableReader),\n\t\tsuperscriptShiftUpCramped: parseMathValueRecord(reader, tableReader),\n\t\tsuperscriptBottomMin: parseMathValueRecord(reader, tableReader),\n\t\tsuperscriptBaselineDropMax: parseMathValueRecord(reader, tableReader),\n\t\tsubSuperscriptGapMin: parseMathValueRecord(reader, tableReader),\n\t\tsuperscriptBottomMaxWithSubscript: parseMathValueRecord(\n\t\t\treader,\n\t\t\ttableReader,\n\t\t),\n\t\tspaceAfterScript: parseMathValueRecord(reader, tableReader),\n\t\tupperLimitGapMin: parseMathValueRecord(reader, tableReader),\n\t\tupperLimitBaselineRiseMin: parseMathValueRecord(reader, tableReader),\n\t\tlowerLimitGapMin: parseMathValueRecord(reader, tableReader),\n\t\tlowerLimitBaselineDropMin: parseMathValueRecord(reader, tableReader),\n\t\tstackTopShiftUp: parseMathValueRecord(reader, tableReader),\n\t\tstackTopDisplayStyleShiftUp: parseMathValueRecord(reader, tableReader),\n\t\tstackBottomShiftDown: parseMathValueRecord(reader, tableReader),\n\t\tstackBottomDisplayStyleShiftDown: parseMathValueRecord(reader, tableReader),\n\t\tstackGapMin: parseMathValueRecord(reader, tableReader),\n\t\tstackDisplayStyleGapMin: parseMathValueRecord(reader, tableReader),\n\t\tstretchStackTopShiftUp: parseMathValueRecord(reader, tableReader),\n\t\tstretchStackBottomShiftDown: parseMathValueRecord(reader, tableReader),\n\t\tstretchStackGapAboveMin: parseMathValueRecord(reader, tableReader),\n\t\tstretchStackGapBelowMin: parseMathValueRecord(reader, tableReader),\n\t\tfractionNumeratorShiftUp: parseMathValueRecord(reader, tableReader),\n\t\tfractionNumeratorDisplayStyleShiftUp: parseMathValueRecord(\n\t\t\treader,\n\t\t\ttableReader,\n\t\t),\n\t\tfractionDenominatorShiftDown: parseMathValueRecord(reader, tableReader),\n\t\tfractionDenominatorDisplayStyleShiftDown: parseMathValueRecord(\n\t\t\treader,\n\t\t\ttableReader,\n\t\t),\n\t\tfractionNumeratorGapMin: parseMathValueRecord(reader, tableReader),\n\t\tfractionNumDisplayStyleGapMin: parseMathValueRecord(reader, tableReader),\n\t\tfractionRuleThickness: parseMathValueRecord(reader, tableReader),\n\t\tfractionDenominatorGapMin: parseMathValueRecord(reader, tableReader),\n\t\tfractionDenomDisplayStyleGapMin: parseMathValueRecord(reader, tableReader),\n\t\tskewedFractionHorizontalGap: parseMathValueRecord(reader, tableReader),\n\t\tskewedFractionVerticalGap: parseMathValueRecord(reader, tableReader),\n\t\toverbarVerticalGap: parseMathValueRecord(reader, tableReader),\n\t\toverbarRuleThickness: parseMathValueRecord(reader, tableReader),\n\t\toverbarExtraAscender: parseMathValueRecord(reader, tableReader),\n\t\tunderbarVerticalGap: parseMathValueRecord(reader, tableReader),\n\t\tunderbarRuleThickness: parseMathValueRecord(reader, tableReader),\n\t\tunderbarExtraDescender: parseMathValueRecord(reader, tableReader),\n\t\tradicalVerticalGap: parseMathValueRecord(reader, tableReader),\n\t\tradicalDisplayStyleVerticalGap: parseMathValueRecord(reader, tableReader),\n\t\tradicalRuleThickness: parseMathValueRecord(reader, tableReader),\n\t\tradicalExtraAscender: parseMathValueRecord(reader, tableReader),\n\t\tradicalKernBeforeDegree: parseMathValueRecord(reader, tableReader),\n\t\tradicalKernAfterDegree: parseMathValueRecord(reader, tableReader),\n\t\tradicalDegreeBottomRaisePercent: reader.int16(),\n\t};\n}\n\nfunction parseMathItalicsCorrection(reader: Reader): MathItalicsCorrection {\n\tconst coverageOffset = reader.uint16();\n\tconst count = reader.uint16();\n\n\tconst values: MathValueRecord[] = [];\n\tfor (let i = 0; i < count; i++) {\n\t\tvalues.push(parseMathValueRecord(reader, reader));\n\t}\n\n\tconst coverage = parseCoverageAt(reader, coverageOffset);\n\n\treturn { coverage, values };\n}\n\nfunction parseMathTopAccentAttachment(reader: Reader): MathTopAccentAttachment {\n\tconst coverageOffset = reader.uint16();\n\tconst count = reader.uint16();\n\n\tconst values: MathValueRecord[] = [];\n\tfor (let i = 0; i < count; i++) {\n\t\tvalues.push(parseMathValueRecord(reader, reader));\n\t}\n\n\tconst coverage = parseCoverageAt(reader, coverageOffset);\n\n\treturn { coverage, values };\n}\n\nfunction parseMathKernRecord(reader: Reader, offset: number): MathKernRecord {\n\tconst kernReader = reader.sliceFrom(offset);\n\tconst heightCount = kernReader.uint16();\n\n\tconst correctionHeights: MathValueRecord[] = [];\n\tfor (let i = 0; i < heightCount; i++) {\n\t\tcorrectionHeights.push(parseMathValueRecord(kernReader, kernReader));\n\t}\n\n\tconst kernValues: MathValueRecord[] = [];\n\tfor (let i = 0; i < heightCount + 1; i++) {\n\t\tkernValues.push(parseMathValueRecord(kernReader, kernReader));\n\t}\n\n\treturn { correctionHeights, kernValues };\n}\n\nfunction parseMathKernInfoTable(reader: Reader): MathKernInfoTable {\n\tconst coverageOffset = reader.uint16();\n\tconst count = reader.uint16();\n\n\tconst kernInfoRecords: Array<{\n\t\ttopRightOffset: uint16;\n\t\ttopLeftOffset: uint16;\n\t\tbottomRightOffset: uint16;\n\t\tbottomLeftOffset: uint16;\n\t}> = [];\n\n\tfor (let i = 0; i < count; i++) {\n\t\tkernInfoRecords.push({\n\t\t\ttopRightOffset: reader.uint16(),\n\t\t\ttopLeftOffset: reader.uint16(),\n\t\t\tbottomRightOffset: reader.uint16(),\n\t\t\tbottomLeftOffset: reader.uint16(),\n\t\t});\n\t}\n\n\tconst coverage = parseCoverageAt(reader, coverageOffset);\n\n\tconst kernInfo: MathKernInfo[] = kernInfoRecords.map((record) => ({\n\t\ttopRight:\n\t\t\trecord.topRightOffset !== 0\n\t\t\t\t? parseMathKernRecord(reader, record.topRightOffset)\n\t\t\t\t: null,\n\t\ttopLeft:\n\t\t\trecord.topLeftOffset !== 0\n\t\t\t\t? parseMathKernRecord(reader, record.topLeftOffset)\n\t\t\t\t: null,\n\t\tbottomRight:\n\t\t\trecord.bottomRightOffset !== 0\n\t\t\t\t? parseMathKernRecord(reader, record.bottomRightOffset)\n\t\t\t\t: null,\n\t\tbottomLeft:\n\t\t\trecord.bottomLeftOffset !== 0\n\t\t\t\t? parseMathKernRecord(reader, record.bottomLeftOffset)\n\t\t\t\t: null,\n\t}));\n\n\treturn { coverage, kernInfo };\n}\n\nfunction parseMathGlyphInfo(reader: Reader): MathGlyphInfo {\n\tconst italicsCorrectionOffset = reader.uint16();\n\tconst topAccentAttachmentOffset = reader.uint16();\n\tconst extendedShapeCoverageOffset = reader.uint16();\n\tconst kernInfoOffset = reader.uint16();\n\n\tlet italicsCorrection: MathItalicsCorrection | null = null;\n\tif (italicsCorrectionOffset !== 0) {\n\t\titalicsCorrection = parseMathItalicsCorrection(\n\t\t\treader.sliceFrom(italicsCorrectionOffset),\n\t\t);\n\t}\n\n\tlet topAccentAttachment: MathTopAccentAttachment | null = null;\n\tif (topAccentAttachmentOffset !== 0) {\n\t\ttopAccentAttachment = parseMathTopAccentAttachment(\n\t\t\treader.sliceFrom(topAccentAttachmentOffset),\n\t\t);\n\t}\n\n\tlet extendedShapeCoverage: ExtendedShapeCoverage | null = null;\n\tif (extendedShapeCoverageOffset !== 0) {\n\t\tconst coverage = parseCoverageAt(reader, extendedShapeCoverageOffset);\n\t\textendedShapeCoverage = { coverage };\n\t}\n\n\tlet kernInfo: MathKernInfoTable | null = null;\n\tif (kernInfoOffset !== 0) {\n\t\tkernInfo = parseMathKernInfoTable(reader.sliceFrom(kernInfoOffset));\n\t}\n\n\treturn {\n\t\titalicsCorrection,\n\t\ttopAccentAttachment,\n\t\textendedShapeCoverage,\n\t\tkernInfo,\n\t};\n}\n\nfunction parseGlyphAssembly(reader: Reader): GlyphAssembly {\n\tconst italicsCorrection = parseMathValueRecord(reader, reader);\n\tconst partCount = reader.uint16();\n\n\tconst parts: GlyphPartRecord[] = [];\n\tfor (let i = 0; i < partCount; i++) {\n\t\tparts.push({\n\t\t\tglyphId: reader.uint16(),\n\t\t\tstartConnectorLength: reader.uint16(),\n\t\t\tendConnectorLength: reader.uint16(),\n\t\t\tfullAdvance: reader.uint16(),\n\t\t\tpartFlags: reader.uint16(),\n\t\t});\n\t}\n\n\treturn { italicsCorrection, parts };\n}\n\nfunction parseMathGlyphConstruction(reader: Reader): MathGlyphConstruction {\n\tconst glyphAssemblyOffset = reader.uint16();\n\tconst variantCount = reader.uint16();\n\n\tconst variants: Array<{ variantGlyph: GlyphId; advanceMeasurement: uint16 }> =\n\t\t[];\n\tfor (let i = 0; i < variantCount; i++) {\n\t\tvariants.push({\n\t\t\tvariantGlyph: reader.uint16(),\n\t\t\tadvanceMeasurement: reader.uint16(),\n\t\t});\n\t}\n\n\tlet glyphAssembly: GlyphAssembly | null = null;\n\tif (glyphAssemblyOffset !== 0) {\n\t\tglyphAssembly = parseGlyphAssembly(reader.sliceFrom(glyphAssemblyOffset));\n\t}\n\n\treturn { glyphAssembly, variants };\n}\n\nfunction parseMathVariants(reader: Reader): MathVariants {\n\tconst minConnectorOverlap = reader.uint16();\n\tconst vertGlyphCoverageOffset = reader.uint16();\n\tconst horizGlyphCoverageOffset = reader.uint16();\n\tconst vertGlyphCount = reader.uint16();\n\tconst horizGlyphCount = reader.uint16();\n\n\tconst vertGlyphConstructionOffsets: uint16[] = [];\n\tfor (let i = 0; i < vertGlyphCount; i++) {\n\t\tvertGlyphConstructionOffsets.push(reader.uint16());\n\t}\n\n\tconst horizGlyphConstructionOffsets: uint16[] = [];\n\tfor (let i = 0; i < horizGlyphCount; i++) {\n\t\thorizGlyphConstructionOffsets.push(reader.uint16());\n\t}\n\n\tconst vertGlyphCoverage =\n\t\tvertGlyphCoverageOffset !== 0\n\t\t\t? parseCoverageAt(reader, vertGlyphCoverageOffset)\n\t\t\t: null;\n\n\tconst horizGlyphCoverage =\n\t\thorizGlyphCoverageOffset !== 0\n\t\t\t? parseCoverageAt(reader, horizGlyphCoverageOffset)\n\t\t\t: null;\n\n\tconst vertGlyphConstruction = vertGlyphConstructionOffsets.map((offset) =>\n\t\tparseMathGlyphConstruction(reader.sliceFrom(offset)),\n\t);\n\n\tconst horizGlyphConstruction = horizGlyphConstructionOffsets.map((offset) =>\n\t\tparseMathGlyphConstruction(reader.sliceFrom(offset)),\n\t);\n\n\treturn {\n\t\tminConnectorOverlap,\n\t\tvertGlyphCoverage,\n\t\thorizGlyphCoverage,\n\t\tvertGlyphConstruction,\n\t\thorizGlyphConstruction,\n\t};\n}\n\nexport function parseMath(reader: Reader): MathTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst mathConstantsOffset = reader.uint16();\n\tconst mathGlyphInfoOffset = reader.uint16();\n\tconst mathVariantsOffset = reader.uint16();\n\n\tlet constants: MathConstants | null = null;\n\tif (mathConstantsOffset !== 0) {\n\t\tconstants = parseMathConstants(reader.sliceFrom(mathConstantsOffset));\n\t}\n\n\tlet glyphInfo: MathGlyphInfo | null = null;\n\tif (mathGlyphInfoOffset !== 0) {\n\t\tglyphInfo = parseMathGlyphInfo(reader.sliceFrom(mathGlyphInfoOffset));\n\t}\n\n\tlet variants: MathVariants | null = null;\n\tif (mathVariantsOffset !== 0) {\n\t\tvariants = parseMathVariants(reader.sliceFrom(mathVariantsOffset));\n\t}\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\tconstants,\n\t\tglyphInfo,\n\t\tvariants,\n\t};\n}\n\n// Helper functions\n\n/** Get italic correction for a glyph */\nexport function getItalicsCorrection(\n\tmath: MathTable,\n\tglyphId: GlyphId,\n): MathValueRecord | null {\n\tconst italics = math.glyphInfo?.italicsCorrection;\n\tif (!italics) return null;\n\n\tconst index = italics.coverage.get(glyphId);\n\tif (index === null) return null;\n\n\treturn italics.values[index] ?? null;\n}\n\n/** Get top accent attachment for a glyph */\nexport function getTopAccentAttachment(\n\tmath: MathTable,\n\tglyphId: GlyphId,\n): MathValueRecord | null {\n\tconst attachment = math.glyphInfo?.topAccentAttachment;\n\tif (!attachment) return null;\n\n\tconst index = attachment.coverage.get(glyphId);\n\tif (index === null) return null;\n\n\treturn attachment.values[index] ?? null;\n}\n\n/** Check if glyph is an extended shape */\nexport function isExtendedShape(math: MathTable, glyphId: GlyphId): boolean {\n\tconst extended = math.glyphInfo?.extendedShapeCoverage;\n\tif (!extended) return false;\n\n\treturn extended.coverage.get(glyphId) !== null;\n}\n\n/** Get vertical glyph variants */\nexport function getVerticalVariants(\n\tmath: MathTable,\n\tglyphId: GlyphId,\n): Array<{ variantGlyph: GlyphId; advanceMeasurement: uint16 }> | null {\n\tconst variants = math.variants;\n\tif (!variants?.vertGlyphCoverage) return null;\n\n\tconst index = variants.vertGlyphCoverage.get(glyphId);\n\tif (index === null) return null;\n\n\treturn variants.vertGlyphConstruction[index]?.variants ?? null;\n}\n\n/** Get horizontal glyph variants */\nexport function getHorizontalVariants(\n\tmath: MathTable,\n\tglyphId: GlyphId,\n): Array<{ variantGlyph: GlyphId; advanceMeasurement: uint16 }> | null {\n\tconst variants = math.variants;\n\tif (!variants?.horizGlyphCoverage) return null;\n\n\tconst index = variants.horizGlyphCoverage.get(glyphId);\n\tif (index === null) return null;\n\n\treturn variants.horizGlyphConstruction[index]?.variants ?? null;\n}\n\n/** Get vertical glyph assembly */\nexport function getVerticalAssembly(\n\tmath: MathTable,\n\tglyphId: GlyphId,\n): GlyphAssembly | null {\n\tconst variants = math.variants;\n\tif (!variants?.vertGlyphCoverage) return null;\n\n\tconst index = variants.vertGlyphCoverage.get(glyphId);\n\tif (index === null) return null;\n\n\treturn variants.vertGlyphConstruction[index]?.glyphAssembly ?? null;\n}\n\n/** Get horizontal glyph assembly */\nexport function getHorizontalAssembly(\n\tmath: MathTable,\n\tglyphId: GlyphId,\n): GlyphAssembly | null {\n\tconst variants = math.variants;\n\tif (!variants?.horizGlyphCoverage) return null;\n\n\tconst index = variants.horizGlyphCoverage.get(glyphId);\n\tif (index === null) return null;\n\n\treturn variants.horizGlyphConstruction[index]?.glyphAssembly ?? null;\n}\n", "import type { uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/** Maximum profile table (version 0.5 - CFF) */\nexport interface MaxpTable05 {\n\tversion: 0x00005000;\n\tnumGlyphs: uint16;\n}\n\n/** Maximum profile table (version 1.0 - TrueType) */\nexport interface MaxpTable10 {\n\tversion: 0x00010000;\n\tnumGlyphs: uint16;\n\tmaxPoints: uint16;\n\tmaxContours: uint16;\n\tmaxCompositePoints: uint16;\n\tmaxCompositeContours: uint16;\n\tmaxZones: uint16;\n\tmaxTwilightPoints: uint16;\n\tmaxStorage: uint16;\n\tmaxFunctionDefs: uint16;\n\tmaxInstructionDefs: uint16;\n\tmaxStackElements: uint16;\n\tmaxSizeOfInstructions: uint16;\n\tmaxComponentElements: uint16;\n\tmaxComponentDepth: uint16;\n}\n\nexport type MaxpTable = MaxpTable05 | MaxpTable10;\n\nexport function parseMaxp(reader: Reader): MaxpTable {\n\tconst version = reader.uint32();\n\tconst numGlyphs = reader.uint16();\n\n\tif (version === 0x00005000) {\n\t\t// Version 0.5 (CFF fonts)\n\t\treturn { version, numGlyphs };\n\t}\n\n\tif (version === 0x00010000) {\n\t\t// Version 1.0 (TrueType fonts)\n\t\treturn {\n\t\t\tversion,\n\t\t\tnumGlyphs,\n\t\t\tmaxPoints: reader.uint16(),\n\t\t\tmaxContours: reader.uint16(),\n\t\t\tmaxCompositePoints: reader.uint16(),\n\t\t\tmaxCompositeContours: reader.uint16(),\n\t\t\tmaxZones: reader.uint16(),\n\t\t\tmaxTwilightPoints: reader.uint16(),\n\t\t\tmaxStorage: reader.uint16(),\n\t\t\tmaxFunctionDefs: reader.uint16(),\n\t\t\tmaxInstructionDefs: reader.uint16(),\n\t\t\tmaxStackElements: reader.uint16(),\n\t\t\tmaxSizeOfInstructions: reader.uint16(),\n\t\t\tmaxComponentElements: reader.uint16(),\n\t\t\tmaxComponentDepth: reader.uint16(),\n\t\t};\n\t}\n\n\tthrow new Error(`Unknown maxp version: 0x${version.toString(16)}`);\n}\n", "import type { GlyphId, uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Extended Glyph Metamorphosis table (morx)\n * Apple Advanced Typography substitution\n */\nexport interface MorxTable {\n\tversion: number;\n\tchains: MorxChain[];\n}\n\n/**\n * Feature chain in morx\n */\nexport interface MorxChain {\n\tdefaultFlags: uint32;\n\tfeatures: MorxFeature[];\n\tsubtables: MorxSubtable[];\n}\n\n/**\n * Feature entry\n */\nexport interface MorxFeature {\n\tfeatureType: uint16;\n\tfeatureSetting: uint16;\n\tenableFlags: uint32;\n\tdisableFlags: uint32;\n}\n\n/**\n * Subtable types\n */\nexport enum MorxSubtableType {\n\tRearrangement = 0,\n\tContextual = 1,\n\tLigature = 2,\n\tNonContextual = 4,\n\tInsertion = 5,\n}\n\n/**\n * Base subtable\n */\nexport interface MorxSubtableBase {\n\ttype: MorxSubtableType;\n\tcoverage: MorxCoverage;\n\tsubFeatureFlags: uint32;\n}\n\nexport interface MorxCoverage {\n\tvertical: boolean;\n\tdescending: boolean;\n\tlogical: boolean;\n}\n\nexport type MorxSubtable =\n\t| MorxRearrangementSubtable\n\t| MorxContextualSubtable\n\t| MorxLigatureSubtable\n\t| MorxNonContextualSubtable\n\t| MorxInsertionSubtable;\n\n/**\n * Type 0: Rearrangement (reorders glyphs)\n */\nexport interface MorxRearrangementSubtable extends MorxSubtableBase {\n\ttype: MorxSubtableType.Rearrangement;\n\tstateTable: StateTable<RearrangementEntry>;\n}\n\nexport interface RearrangementEntry {\n\tnewState: uint16;\n\tflags: uint16;\n}\n\n/**\n * Type 1: Contextual substitution\n */\nexport interface MorxContextualSubtable extends MorxSubtableBase {\n\ttype: MorxSubtableType.Contextual;\n\tstateTable: StateTable<ContextualEntry>;\n\tsubstitutionTable: Map<GlyphId, GlyphId>[];\n}\n\nexport interface ContextualEntry {\n\tnewState: uint16;\n\tflags: uint16;\n\tmarkIndex: uint16;\n\tcurrentIndex: uint16;\n}\n\n/**\n * Type 2: Ligature\n */\nexport interface MorxLigatureSubtable extends MorxSubtableBase {\n\ttype: MorxSubtableType.Ligature;\n\tstateTable: StateTable<LigatureEntry>;\n\tligatureActions: uint32[];\n\tcomponents: uint16[];\n\tligatures: GlyphId[];\n}\n\nexport interface LigatureEntry {\n\tnewState: uint16;\n\tflags: uint16;\n\tligActionIndex: uint16;\n}\n\n/**\n * Type 4: Non-contextual (simple substitution)\n */\nexport interface MorxNonContextualSubtable extends MorxSubtableBase {\n\ttype: MorxSubtableType.NonContextual;\n\tlookupTable: LookupTable;\n}\n\n/**\n * Type 5: Insertion\n */\nexport interface MorxInsertionSubtable extends MorxSubtableBase {\n\ttype: MorxSubtableType.Insertion;\n\tstateTable: StateTable<InsertionEntry>;\n\tinsertionGlyphs: GlyphId[];\n}\n\nexport interface InsertionEntry {\n\tnewState: uint16;\n\tflags: uint16;\n\tcurrentInsertIndex: uint16;\n\tmarkedInsertIndex: uint16;\n}\n\n/**\n * State table for state machine processing\n */\nexport interface StateTable<E> {\n\tnClasses: uint32;\n\tclassTable: ClassTable;\n\tstateArray: E[][];\n}\n\n/**\n * Class lookup table\n */\nexport interface ClassTable {\n\tformat: number;\n\tclassArray: number[]; // Maps glyph ID to class\n}\n\n/**\n * Lookup table for substitutions\n */\nexport interface LookupTable {\n\tformat: number;\n\tmapping: Map<GlyphId, GlyphId>;\n}\n\n/**\n * Parse morx table\n */\nexport function parseMorx(reader: Reader): MorxTable {\n\tconst version = reader.uint16();\n\treader.skip(2); // unused\n\n\tif (version < 2) {\n\t\t// Version 1 (mort) - not supported\n\t\treturn { version, chains: [] };\n\t}\n\n\tconst nChains = reader.uint32();\n\tconst chains: MorxChain[] = [];\n\n\tfor (let i = 0; i < nChains; i++) {\n\t\tconst chain = parseMorxChain(reader);\n\t\tchains.push(chain);\n\t}\n\n\treturn { version, chains };\n}\n\nfunction parseMorxChain(reader: Reader): MorxChain {\n\tconst defaultFlags = reader.uint32();\n\tconst _chainLength = reader.uint32();\n\tconst nFeatureEntries = reader.uint32();\n\tconst nSubtables = reader.uint32();\n\n\t// Parse features\n\tconst features: MorxFeature[] = [];\n\tfor (let i = 0; i < nFeatureEntries; i++) {\n\t\tfeatures.push({\n\t\t\tfeatureType: reader.uint16(),\n\t\t\tfeatureSetting: reader.uint16(),\n\t\t\tenableFlags: reader.uint32(),\n\t\t\tdisableFlags: reader.uint32(),\n\t\t});\n\t}\n\n\t// Parse subtables\n\tconst subtables: MorxSubtable[] = [];\n\tfor (let i = 0; i < nSubtables; i++) {\n\t\tconst subtable = parseMorxSubtable(reader);\n\t\tif (subtable) subtables.push(subtable);\n\t}\n\n\treturn { defaultFlags, features, subtables };\n}\n\nfunction parseMorxSubtable(reader: Reader): MorxSubtable | null {\n\tconst length = reader.uint32();\n\tconst coverageBits = reader.uint32();\n\tconst subFeatureFlags = reader.uint32();\n\n\tconst type = coverageBits & 0xff;\n\tconst coverage: MorxCoverage = {\n\t\tvertical: (coverageBits & 0x80000000) !== 0,\n\t\tdescending: (coverageBits & 0x40000000) !== 0,\n\t\tlogical: (coverageBits & 0x10000000) !== 0,\n\t};\n\n\tconst subtableStart = reader.offset;\n\tconst subtableEnd = subtableStart + length - 12;\n\n\tlet subtable: MorxSubtable | null = null;\n\n\tswitch (type) {\n\t\tcase MorxSubtableType.Rearrangement:\n\t\t\tsubtable = parseRearrangementSubtable(reader, coverage, subFeatureFlags);\n\t\t\tbreak;\n\t\tcase MorxSubtableType.Contextual:\n\t\t\tsubtable = parseContextualSubtable(reader, coverage, subFeatureFlags);\n\t\t\tbreak;\n\t\tcase MorxSubtableType.Ligature:\n\t\t\tsubtable = parseLigatureSubtable(reader, coverage, subFeatureFlags);\n\t\t\tbreak;\n\t\tcase MorxSubtableType.NonContextual:\n\t\t\tsubtable = parseNonContextualSubtable(reader, coverage, subFeatureFlags);\n\t\t\tbreak;\n\t\tcase MorxSubtableType.Insertion:\n\t\t\tsubtable = parseInsertionSubtable(reader, coverage, subFeatureFlags);\n\t\t\tbreak;\n\t}\n\n\t// Skip to end of subtable\n\treader.seek(subtableEnd);\n\n\treturn subtable;\n}\n\nfunction parseNonContextualSubtable(\n\treader: Reader,\n\tcoverage: MorxCoverage,\n\tsubFeatureFlags: uint32,\n): MorxNonContextualSubtable {\n\tconst lookupTable = parseLookupTable(reader);\n\n\treturn {\n\t\ttype: MorxSubtableType.NonContextual,\n\t\tcoverage,\n\t\tsubFeatureFlags,\n\t\tlookupTable,\n\t};\n}\n\nfunction parseContextualSubtable(\n\treader: Reader,\n\tcoverage: MorxCoverage,\n\tsubFeatureFlags: uint32,\n): MorxContextualSubtable {\n\tconst stateTableOffset = reader.offset;\n\tconst nClasses = reader.uint32();\n\tconst classTableOffset = reader.offset32();\n\tconst _stateArrayOffset = reader.offset32();\n\tconst _entryTableOffset = reader.offset32();\n\tconst _substitutionTableOffset = reader.offset32();\n\n\t// Parse class table\n\tconst classTable = parseClassTable(\n\t\treader.sliceFrom(stateTableOffset + classTableOffset),\n\t);\n\n\t// Parse state array and entries (simplified)\n\tconst stateTable: StateTable<ContextualEntry> = {\n\t\tnClasses,\n\t\tclassTable,\n\t\tstateArray: [],\n\t};\n\n\tconst substitutionTable: Map<GlyphId, GlyphId>[] = [];\n\n\treturn {\n\t\ttype: MorxSubtableType.Contextual,\n\t\tcoverage,\n\t\tsubFeatureFlags,\n\t\tstateTable,\n\t\tsubstitutionTable,\n\t};\n}\n\nfunction parseLigatureSubtable(\n\treader: Reader,\n\tcoverage: MorxCoverage,\n\tsubFeatureFlags: uint32,\n): MorxLigatureSubtable {\n\tconst stateTableOffset = reader.offset;\n\tconst nClasses = reader.uint32();\n\tconst classTableOffset = reader.offset32();\n\tconst _stateArrayOffset = reader.offset32();\n\tconst _entryTableOffset = reader.offset32();\n\tconst _ligatureActionsOffset = reader.offset32();\n\tconst _componentsOffset = reader.offset32();\n\tconst _ligaturesOffset = reader.offset32();\n\n\t// Parse class table\n\tconst classTable = parseClassTable(\n\t\treader.sliceFrom(stateTableOffset + classTableOffset),\n\t);\n\n\t// State table (simplified)\n\tconst stateTable: StateTable<LigatureEntry> = {\n\t\tnClasses,\n\t\tclassTable,\n\t\tstateArray: [],\n\t};\n\n\treturn {\n\t\ttype: MorxSubtableType.Ligature,\n\t\tcoverage,\n\t\tsubFeatureFlags,\n\t\tstateTable,\n\t\tligatureActions: [],\n\t\tcomponents: [],\n\t\tligatures: [],\n\t};\n}\n\nfunction parseRearrangementSubtable(\n\treader: Reader,\n\tcoverage: MorxCoverage,\n\tsubFeatureFlags: uint32,\n): MorxRearrangementSubtable {\n\tconst stateTableOffset = reader.offset;\n\tconst nClasses = reader.uint32();\n\tconst classTableOffset = reader.offset32();\n\tconst stateArrayOffset = reader.offset32();\n\tconst entryTableOffset = reader.offset32();\n\n\t// Parse class table\n\tconst classTable = parseClassTable(\n\t\treader.sliceFrom(stateTableOffset + classTableOffset),\n\t);\n\n\t// Parse state array\n\tconst stateArrayReader = reader.sliceFrom(\n\t\tstateTableOffset + stateArrayOffset,\n\t);\n\tconst entryReader = reader.sliceFrom(stateTableOffset + entryTableOffset);\n\n\t// Parse entries (each entry is 4 bytes: newState uint16, flags uint16)\n\tconst entries: RearrangementEntry[] = [];\n\tconst entryCount = 256; // Reasonable max\n\tfor (let i = 0; i < entryCount; i++) {\n\t\tentries.push({\n\t\t\tnewState: entryReader.uint16(),\n\t\t\tflags: entryReader.uint16(),\n\t\t});\n\t}\n\n\t// Build state array\n\tconst stateArray: RearrangementEntry[][] = [];\n\tconst stateCount = Math.min(\n\t\t256,\n\t\tMath.ceil((entryTableOffset - stateArrayOffset) / (nClasses * 2)),\n\t);\n\tfor (let s = 0; s < stateCount; s++) {\n\t\tconst row: RearrangementEntry[] = [];\n\t\tfor (let c = 0; c < nClasses; c++) {\n\t\t\tconst entryIndex = stateArrayReader.uint16();\n\t\t\trow.push(entries[entryIndex] ?? { newState: 0, flags: 0 });\n\t\t}\n\t\tstateArray.push(row);\n\t}\n\n\treturn {\n\t\ttype: MorxSubtableType.Rearrangement,\n\t\tcoverage,\n\t\tsubFeatureFlags,\n\t\tstateTable: {\n\t\t\tnClasses,\n\t\t\tclassTable,\n\t\t\tstateArray,\n\t\t},\n\t};\n}\n\nfunction parseInsertionSubtable(\n\treader: Reader,\n\tcoverage: MorxCoverage,\n\tsubFeatureFlags: uint32,\n): MorxInsertionSubtable {\n\tconst stateTableOffset = reader.offset;\n\tconst nClasses = reader.uint32();\n\tconst classTableOffset = reader.offset32();\n\tconst stateArrayOffset = reader.offset32();\n\tconst entryTableOffset = reader.offset32();\n\tconst insertionActionOffset = reader.offset32();\n\n\t// Parse class table\n\tconst classTable = parseClassTable(\n\t\treader.sliceFrom(stateTableOffset + classTableOffset),\n\t);\n\n\t// Parse insertion glyphs array\n\tconst insertionReader = reader.sliceFrom(\n\t\tstateTableOffset + insertionActionOffset,\n\t);\n\tconst insertionGlyphs: GlyphId[] = [];\n\t// Read a reasonable number of insertion glyphs\n\tconst maxInsertionGlyphs = 1024;\n\tfor (let i = 0; i < maxInsertionGlyphs; i++) {\n\t\ttry {\n\t\t\tinsertionGlyphs.push(insertionReader.uint16());\n\t\t} catch {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Parse entries\n\tconst entryReader = reader.sliceFrom(stateTableOffset + entryTableOffset);\n\tconst entries: InsertionEntry[] = [];\n\tconst entryCount = 256;\n\tfor (let i = 0; i < entryCount; i++) {\n\t\tentries.push({\n\t\t\tnewState: entryReader.uint16(),\n\t\t\tflags: entryReader.uint16(),\n\t\t\tcurrentInsertIndex: entryReader.uint16(),\n\t\t\tmarkedInsertIndex: entryReader.uint16(),\n\t\t});\n\t}\n\n\t// Build state array\n\tconst stateArrayReader = reader.sliceFrom(\n\t\tstateTableOffset + stateArrayOffset,\n\t);\n\tconst stateArray: InsertionEntry[][] = [];\n\tconst stateCount = Math.min(\n\t\t256,\n\t\tMath.ceil((entryTableOffset - stateArrayOffset) / (nClasses * 2)),\n\t);\n\tfor (let s = 0; s < stateCount; s++) {\n\t\tconst row: InsertionEntry[] = [];\n\t\tfor (let c = 0; c < nClasses; c++) {\n\t\t\tconst entryIndex = stateArrayReader.uint16();\n\t\t\trow.push(\n\t\t\t\tentries[entryIndex] ?? {\n\t\t\t\t\tnewState: 0,\n\t\t\t\t\tflags: 0,\n\t\t\t\t\tcurrentInsertIndex: 0xffff,\n\t\t\t\t\tmarkedInsertIndex: 0xffff,\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\t\tstateArray.push(row);\n\t}\n\n\treturn {\n\t\ttype: MorxSubtableType.Insertion,\n\t\tcoverage,\n\t\tsubFeatureFlags,\n\t\tstateTable: {\n\t\t\tnClasses,\n\t\t\tclassTable,\n\t\t\tstateArray,\n\t\t},\n\t\tinsertionGlyphs,\n\t};\n}\n\nfunction parseLookupTable(reader: Reader): LookupTable {\n\tconst format = reader.uint16();\n\tconst mapping = new Map<GlyphId, GlyphId>();\n\n\tswitch (format) {\n\t\tcase 0: {\n\t\t\t// Simple array\n\t\t\t// Format 0 uses lookup by glyph index directly\n\t\t\tbreak;\n\t\t}\n\t\tcase 2: {\n\t\t\t// Segment single\n\t\t\tconst _unitSize = reader.uint16();\n\t\t\tconst nUnits = reader.uint16();\n\t\t\treader.skip(6); // searchRange, entrySelector, rangeShift\n\n\t\t\tfor (let i = 0; i < nUnits; i++) {\n\t\t\t\tconst lastGlyph = reader.uint16();\n\t\t\t\tconst firstGlyph = reader.uint16();\n\t\t\t\tconst value = reader.uint16();\n\n\t\t\t\tfor (let g = firstGlyph; g <= lastGlyph; g++) {\n\t\t\t\t\tmapping.set(g, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 4: {\n\t\t\t// Segment array\n\t\t\tconst _unitSize = reader.uint16();\n\t\t\tconst nUnits = reader.uint16();\n\t\t\treader.skip(6);\n\n\t\t\tfor (let i = 0; i < nUnits; i++) {\n\t\t\t\tconst _lastGlyph = reader.uint16();\n\t\t\t\tconst _firstGlyph = reader.uint16();\n\t\t\t\tconst _valueOffset = reader.uint16();\n\n\t\t\t\t// Values would be read from valueOffset\n\t\t\t\t// Simplified: skip for now\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 6: {\n\t\t\t// Single table\n\t\t\tconst _unitSize = reader.uint16();\n\t\t\tconst nUnits = reader.uint16();\n\t\t\treader.skip(6);\n\n\t\t\tfor (let i = 0; i < nUnits; i++) {\n\t\t\t\tconst glyph = reader.uint16();\n\t\t\t\tconst value = reader.uint16();\n\t\t\t\tmapping.set(glyph, value);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 8: {\n\t\t\t// Trimmed array\n\t\t\tconst firstGlyph = reader.uint16();\n\t\t\tconst glyphCount = reader.uint16();\n\n\t\t\tfor (let i = 0; i < glyphCount; i++) {\n\t\t\t\tconst value = reader.uint16();\n\t\t\t\tif (value !== 0) {\n\t\t\t\t\tmapping.set(firstGlyph + i, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn { format, mapping };\n}\n\nfunction parseClassTable(reader: Reader): ClassTable {\n\tconst format = reader.uint16();\n\tconst classArray: number[] = [];\n\n\tif (format === 2) {\n\t\t// Binary search segments\n\t\tconst _unitSize = reader.uint16();\n\t\tconst nUnits = reader.uint16();\n\t\treader.skip(6);\n\n\t\tconst segments: { first: number; last: number; classValue: number }[] = [];\n\t\tfor (let i = 0; i < nUnits; i++) {\n\t\t\tsegments.push({\n\t\t\t\tlast: reader.uint16(),\n\t\t\t\tfirst: reader.uint16(),\n\t\t\t\tclassValue: reader.uint16(),\n\t\t\t});\n\t\t}\n\n\t\t// Build class array (simplified, might be large)\n\t\tconst maxGlyph = Math.max(...segments.map((s) => s.last), 0);\n\t\tfor (let g = 0; g <= maxGlyph; g++) {\n\t\t\tconst seg = segments.find((s) => g >= s.first && g <= s.last);\n\t\t\tclassArray[g] = seg?.classValue ?? 1; // Class 1 = out of bounds\n\t\t}\n\t}\n\n\treturn { format, classArray };\n}\n\n/**\n * Apply non-contextual substitution\n */\nexport function applyNonContextual(\n\tsubtable: MorxNonContextualSubtable,\n\tglyphId: GlyphId,\n): GlyphId | null {\n\treturn subtable.lookupTable.mapping.get(glyphId) ?? null;\n}\n", "import type { Tag, uint16, uint32 } from \"../../types.ts\";\nimport { tag } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\nimport {\n\tcalculateRegionScalar,\n\ttype ItemVariationStore,\n\ttype VariationRegion,\n} from \"./hvar.ts\";\n\n/**\n * Metrics Variations table (MVAR)\n * Provides variations for global font metrics\n */\nexport interface MvarTable {\n\tmajorVersion: number;\n\tminorVersion: number;\n\titemVariationStore: ItemVariationStore;\n\tvalueRecords: MvarValueRecord[];\n}\n\nexport interface MvarValueRecord {\n\tvalueTag: Tag;\n\tdeltaSetOuterIndex: number;\n\tdeltaSetInnerIndex: number;\n}\n\n/**\n * Common MVAR value tags\n */\nexport const MvarTags = {\n\t// Horizontal metrics\n\thasc: tag(\"hasc\"), // horizontal ascender\n\thdsc: tag(\"hdsc\"), // horizontal descender\n\thlgp: tag(\"hlgp\"), // horizontal line gap\n\thcla: tag(\"hcla\"), // horizontal clipping ascent\n\thcld: tag(\"hcld\"), // horizontal clipping descent\n\thcof: tag(\"hcof\"), // horizontal caret offset\n\thcrn: tag(\"hcrn\"), // horizontal caret run\n\thcrs: tag(\"hcrs\"), // horizontal caret rise\n\n\t// Vertical metrics\n\tvasc: tag(\"vasc\"), // vertical ascender\n\tvdsc: tag(\"vdsc\"), // vertical descender\n\tvlgp: tag(\"vlgp\"), // vertical line gap\n\tvcof: tag(\"vcof\"), // vertical caret offset\n\tvcrn: tag(\"vcrn\"), // vertical caret run\n\tvcrs: tag(\"vcrs\"), // vertical caret rise\n\n\t// OS/2 table values\n\txhgt: tag(\"xhgt\"), // x height\n\tcpht: tag(\"cpht\"), // cap height\n\tsbxs: tag(\"sbxs\"), // subscript x size\n\tsbys: tag(\"sbys\"), // subscript y size\n\tsbxo: tag(\"sbxo\"), // subscript x offset\n\tsbyo: tag(\"sbyo\"), // subscript y offset\n\tspxs: tag(\"spxs\"), // superscript x size\n\tspys: tag(\"spys\"), // superscript y size\n\tspxo: tag(\"spxo\"), // superscript x offset\n\tspyo: tag(\"spyo\"), // superscript y offset\n\tstrs: tag(\"strs\"), // strikeout size\n\tstro: tag(\"stro\"), // strikeout offset\n\tundo: tag(\"undo\"), // underline offset\n\tunds: tag(\"unds\"), // underline size\n\n\t// Glyph bounds\n\tgsp0: tag(\"gsp0\"), // glyph bounding box x min\n\tgsp1: tag(\"gsp1\"), // glyph bounding box y min\n\tgsp2: tag(\"gsp2\"), // glyph bounding box x max\n\tgsp3: tag(\"gsp3\"), // glyph bounding box y max\n} as const;\n\n/**\n * Parse MVAR table\n */\nexport function parseMvar(reader: Reader): MvarTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\treader.uint16(); // reserved\n\tconst valueRecordSize = reader.uint16();\n\tconst valueRecordCount = reader.uint16();\n\tconst itemVariationStoreOffset = reader.offset16();\n\n\t// Parse value records\n\tconst valueRecords: MvarValueRecord[] = [];\n\tfor (let i = 0; i < valueRecordCount; i++) {\n\t\tvalueRecords.push({\n\t\t\tvalueTag: reader.tag(),\n\t\t\tdeltaSetOuterIndex: reader.uint16(),\n\t\t\tdeltaSetInnerIndex: reader.uint16(),\n\t\t});\n\t\t// Skip any additional bytes if valueRecordSize > 8\n\t\tif (valueRecordSize > 8) {\n\t\t\treader.skip(valueRecordSize - 8);\n\t\t}\n\t}\n\n\t// Parse item variation store\n\tconst itemVariationStore = parseItemVariationStore(\n\t\treader.sliceFrom(itemVariationStoreOffset),\n\t);\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\titemVariationStore,\n\t\tvalueRecords,\n\t};\n}\n\nfunction parseItemVariationStore(reader: Reader): ItemVariationStore {\n\tconst format = reader.uint16();\n\tconst variationRegionListOffset = reader.offset32();\n\tconst itemVariationDataCount = reader.uint16();\n\n\tconst itemVariationDataOffsets: uint32[] = [];\n\tfor (let i = 0; i < itemVariationDataCount; i++) {\n\t\titemVariationDataOffsets.push(reader.offset32());\n\t}\n\n\t// Parse variation regions\n\tconst regionReader = reader.sliceFrom(variationRegionListOffset);\n\tconst axisCount = regionReader.uint16();\n\tconst regionCount = regionReader.uint16();\n\n\tconst variationRegions: VariationRegion[] = [];\n\tfor (let i = 0; i < regionCount; i++) {\n\t\tconst regionAxes: {\n\t\t\tstartCoord: number;\n\t\t\tpeakCoord: number;\n\t\t\tendCoord: number;\n\t\t}[] = [];\n\t\tfor (let j = 0; j < axisCount; j++) {\n\t\t\tregionAxes.push({\n\t\t\t\tstartCoord: regionReader.f2dot14(),\n\t\t\t\tpeakCoord: regionReader.f2dot14(),\n\t\t\t\tendCoord: regionReader.f2dot14(),\n\t\t\t});\n\t\t}\n\t\tvariationRegions.push({ regionAxes });\n\t}\n\n\t// Parse item variation data\n\tconst itemVariationData: {\n\t\titemCount: uint16;\n\t\tregionIndexes: uint16[];\n\t\tdeltaSets: number[][];\n\t}[] = [];\n\tfor (const offset of itemVariationDataOffsets) {\n\t\tconst dataReader = reader.sliceFrom(offset);\n\t\tconst itemCount = dataReader.uint16();\n\t\tconst wordDeltaCount = dataReader.uint16();\n\t\tconst regionIndexCount = dataReader.uint16();\n\n\t\tconst regionIndexes: uint16[] = [];\n\t\tfor (let i = 0; i < regionIndexCount; i++) {\n\t\t\tregionIndexes.push(dataReader.uint16());\n\t\t}\n\n\t\t// Parse delta sets\n\t\tconst longWords = (wordDeltaCount & 0x8000) !== 0;\n\t\tconst wordCount = wordDeltaCount & 0x7fff;\n\t\tconst shortCount = regionIndexCount - wordCount;\n\n\t\tconst deltaSets: number[][] = [];\n\t\tfor (let i = 0; i < itemCount; i++) {\n\t\t\tconst deltas: number[] = [];\n\t\t\t// Read word-sized deltas\n\t\t\tfor (let j = 0; j < wordCount; j++) {\n\t\t\t\tif (longWords) {\n\t\t\t\t\tdeltas.push(dataReader.int32());\n\t\t\t\t} else {\n\t\t\t\t\tdeltas.push(dataReader.int16());\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Read short-sized deltas\n\t\t\tfor (let j = 0; j < shortCount; j++) {\n\t\t\t\tif (longWords) {\n\t\t\t\t\tdeltas.push(dataReader.int16());\n\t\t\t\t} else {\n\t\t\t\t\tdeltas.push(dataReader.int8());\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeltaSets.push(deltas);\n\t\t}\n\n\t\titemVariationData.push({ itemCount, regionIndexes, deltaSets });\n\t}\n\n\treturn { format, variationRegions, itemVariationData };\n}\n\n/**\n * Get metric delta by tag\n */\nexport function getMetricDelta(\n\tmvar: MvarTable,\n\tvalueTag: Tag,\n\tcoords: number[],\n): number {\n\t// Find value record for this tag\n\tconst record = mvar.valueRecords.find((r) => r.valueTag === valueTag);\n\tif (!record) return 0;\n\n\tconst outer = record.deltaSetOuterIndex;\n\tconst inner = record.deltaSetInnerIndex;\n\n\tconst varData = mvar.itemVariationStore.itemVariationData[outer];\n\tif (!varData || inner >= varData.itemCount) {\n\t\treturn 0;\n\t}\n\n\tconst deltaSet = varData.deltaSets[inner];\n\tif (!deltaSet) {\n\t\treturn 0;\n\t}\n\n\t// Calculate total delta\n\tlet delta = 0;\n\tfor (const [i, regionIndex] of varData.regionIndexes.entries()) {\n\t\tconst region = mvar.itemVariationStore.variationRegions[regionIndex];\n\t\tif (!region) continue;\n\n\t\tconst scalar = calculateRegionScalar(region, coords);\n\t\tconst regionDelta = deltaSet[i] ?? 0;\n\t\tdelta += scalar * regionDelta;\n\t}\n\n\treturn Math.round(delta);\n}\n\n/**\n * Get horizontal ascender delta\n */\nexport function getHAscenderDelta(mvar: MvarTable, coords: number[]): number {\n\treturn getMetricDelta(mvar, MvarTags.hasc, coords);\n}\n\n/**\n * Get horizontal descender delta\n */\nexport function getHDescenderDelta(mvar: MvarTable, coords: number[]): number {\n\treturn getMetricDelta(mvar, MvarTags.hdsc, coords);\n}\n\n/**\n * Get horizontal line gap delta\n */\nexport function getHLineGapDelta(mvar: MvarTable, coords: number[]): number {\n\treturn getMetricDelta(mvar, MvarTags.hlgp, coords);\n}\n\n/**\n * Get x-height delta\n */\nexport function getXHeightDelta(mvar: MvarTable, coords: number[]): number {\n\treturn getMetricDelta(mvar, MvarTags.xhgt, coords);\n}\n\n/**\n * Get cap height delta\n */\nexport function getCapHeightDelta(mvar: MvarTable, coords: number[]): number {\n\treturn getMetricDelta(mvar, MvarTags.cpht, coords);\n}\n\n/**\n * Get underline offset delta\n */\nexport function getUnderlineOffsetDelta(\n\tmvar: MvarTable,\n\tcoords: number[],\n): number {\n\treturn getMetricDelta(mvar, MvarTags.undo, coords);\n}\n\n/**\n * Get underline size delta\n */\nexport function getUnderlineSizeDelta(\n\tmvar: MvarTable,\n\tcoords: number[],\n): number {\n\treturn getMetricDelta(mvar, MvarTags.unds, coords);\n}\n\n/**\n * Get strikeout offset delta\n */\nexport function getStrikeoutOffsetDelta(\n\tmvar: MvarTable,\n\tcoords: number[],\n): number {\n\treturn getMetricDelta(mvar, MvarTags.stro, coords);\n}\n\n/**\n * Get strikeout size delta\n */\nexport function getStrikeoutSizeDelta(\n\tmvar: MvarTable,\n\tcoords: number[],\n): number {\n\treturn getMetricDelta(mvar, MvarTags.strs, coords);\n}\n", "import type { uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/** Name IDs */\nexport const NameId = {\n\tCopyright: 0,\n\tFontFamily: 1,\n\tFontSubfamily: 2,\n\tUniqueID: 3,\n\tFullName: 4,\n\tVersion: 5,\n\tPostScriptName: 6,\n\tTrademark: 7,\n\tManufacturer: 8,\n\tDesigner: 9,\n\tDescription: 10,\n\tManufacturerURL: 11,\n\tDesignerURL: 12,\n\tLicense: 13,\n\tLicenseURL: 14,\n\tReserved: 15,\n\tTypographicFamily: 16,\n\tTypographicSubfamily: 17,\n\tCompatibleFullName: 18,\n\tSampleText: 19,\n\tPostScriptCIDFindfontName: 20,\n\tWWSFamily: 21,\n\tWWSSubfamily: 22,\n\tLightBackgroundPalette: 23,\n\tDarkBackgroundPalette: 24,\n\tVariationsPostScriptNamePrefix: 25,\n} as const;\n\n/** Platform IDs */\nexport const PlatformId = {\n\tUnicode: 0,\n\tMacintosh: 1,\n\tReserved: 2,\n\tWindows: 3,\n} as const;\n\n/** Windows encoding IDs */\nexport const WindowsEncodingId = {\n\tSymbol: 0,\n\tUnicodeBMP: 1,\n\tShiftJIS: 2,\n\tPRC: 3,\n\tBig5: 4,\n\tWansung: 5,\n\tJohab: 6,\n\tUnicodeFullRepertoire: 10,\n} as const;\n\n/** A single name record */\nexport interface NameRecord {\n\tplatformId: uint16;\n\tencodingId: uint16;\n\tlanguageId: uint16;\n\tnameId: uint16;\n\tvalue: string;\n}\n\n/** Name table */\nexport interface NameTable {\n\tformat: uint16;\n\trecords: NameRecord[];\n}\n\nexport function parseName(reader: Reader): NameTable {\n\tconst format = reader.uint16();\n\tconst count = reader.uint16();\n\tconst stringOffset = reader.uint16();\n\n\tconst records: NameRecord[] = [];\n\n\t// Parse name records\n\tconst recordData: Array<{\n\t\tplatformId: uint16;\n\t\tencodingId: uint16;\n\t\tlanguageId: uint16;\n\t\tnameId: uint16;\n\t\tlength: uint16;\n\t\toffset: uint16;\n\t}> = [];\n\n\tfor (let i = 0; i < count; i++) {\n\t\trecordData.push({\n\t\t\tplatformId: reader.uint16(),\n\t\t\tencodingId: reader.uint16(),\n\t\t\tlanguageId: reader.uint16(),\n\t\t\tnameId: reader.uint16(),\n\t\t\tlength: reader.uint16(),\n\t\t\toffset: reader.uint16(),\n\t\t});\n\t}\n\n\t// Decode strings\n\tfor (const rd of recordData) {\n\t\tconst strReader = reader.sliceFrom(stringOffset + rd.offset);\n\t\tconst value = decodeNameString(\n\t\t\tstrReader,\n\t\t\trd.length,\n\t\t\trd.platformId,\n\t\t\trd.encodingId,\n\t\t);\n\n\t\tif (value !== null) {\n\t\t\trecords.push({\n\t\t\t\tplatformId: rd.platformId,\n\t\t\t\tencodingId: rd.encodingId,\n\t\t\t\tlanguageId: rd.languageId,\n\t\t\t\tnameId: rd.nameId,\n\t\t\t\tvalue,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn { format, records };\n}\n\n/** Decode name string based on platform and encoding */\nfunction decodeNameString(\n\treader: Reader,\n\tlength: number,\n\tplatformId: number,\n\tencodingId: number,\n): string | null {\n\t// Unicode platform or Windows platform with Unicode encoding\n\tif (\n\t\tplatformId === PlatformId.Unicode ||\n\t\t(platformId === PlatformId.Windows &&\n\t\t\t(encodingId === 1 || encodingId === 10))\n\t) {\n\t\t// UTF-16BE\n\t\tconst chars: string[] = [];\n\t\tfor (let i = 0; i < length; i += 2) {\n\t\t\tconst code = reader.uint16();\n\t\t\tchars.push(String.fromCharCode(code));\n\t\t}\n\t\treturn chars.join(\"\");\n\t}\n\n\t// Macintosh Roman (basic ASCII-compatible)\n\tif (platformId === PlatformId.Macintosh && encodingId === 0) {\n\t\tconst bytes: number[] = [];\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tbytes.push(reader.uint8());\n\t\t}\n\t\t// Simple ASCII decoding for Mac Roman (limited support)\n\t\treturn String.fromCharCode(...bytes);\n\t}\n\n\t// Skip unsupported encodings\n\treturn null;\n}\n\n/** Get a specific name by ID, preferring Windows Unicode */\nexport function getNameById(\n\ttable: NameTable,\n\tnameId: number,\n\tlanguageId?: number,\n): string | null {\n\t// Prefer Windows Unicode (platform 3, encoding 1)\n\tfor (const record of table.records) {\n\t\tif (record.nameId !== nameId) continue;\n\t\tif (record.platformId === PlatformId.Windows && record.encodingId === 1) {\n\t\t\tif (languageId === undefined || record.languageId === languageId) {\n\t\t\t\treturn record.value;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Fallback to Unicode platform\n\tfor (const record of table.records) {\n\t\tif (record.nameId !== nameId) continue;\n\t\tif (record.platformId === PlatformId.Unicode) {\n\t\t\tif (languageId === undefined || record.languageId === languageId) {\n\t\t\t\treturn record.value;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Fallback to any platform\n\tfor (const record of table.records) {\n\t\tif (record.nameId !== nameId) continue;\n\t\tif (languageId === undefined || record.languageId === languageId) {\n\t\t\treturn record.value;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/** Get font family name */\nexport function getFontFamily(table: NameTable): string | null {\n\t// Prefer typographic family (16) over basic family (1)\n\treturn (\n\t\tgetNameById(table, NameId.TypographicFamily) ??\n\t\tgetNameById(table, NameId.FontFamily)\n\t);\n}\n\n/** Get font subfamily (style) */\nexport function getFontSubfamily(table: NameTable): string | null {\n\treturn (\n\t\tgetNameById(table, NameId.TypographicSubfamily) ??\n\t\tgetNameById(table, NameId.FontSubfamily)\n\t);\n}\n\n/** Get full font name */\nexport function getFullName(table: NameTable): string | null {\n\treturn getNameById(table, NameId.FullName);\n}\n\n/** Get PostScript name */\nexport function getPostScriptName(table: NameTable): string | null {\n\treturn getNameById(table, NameId.PostScriptName);\n}\n\n/** Get version string */\nexport function getVersion(table: NameTable): string | null {\n\treturn getNameById(table, NameId.Version);\n}\n", "import type { int16, uint8, uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * OS/2 table - Font metrics and classification\n * Contains Windows-specific metrics and font embedding information\n */\nexport interface Os2Table {\n\tversion: uint16;\n\txAvgCharWidth: int16;\n\tusWeightClass: uint16;\n\tusWidthClass: uint16;\n\tfsType: uint16;\n\tySubscriptXSize: int16;\n\tySubscriptYSize: int16;\n\tySubscriptXOffset: int16;\n\tySubscriptYOffset: int16;\n\tySuperscriptXSize: int16;\n\tySuperscriptYSize: int16;\n\tySuperscriptXOffset: int16;\n\tySuperscriptYOffset: int16;\n\tyStrikeoutSize: int16;\n\tyStrikeoutPosition: int16;\n\tsFamilyClass: int16;\n\tpanose: uint8[];\n\tulUnicodeRange1: uint32;\n\tulUnicodeRange2: uint32;\n\tulUnicodeRange3: uint32;\n\tulUnicodeRange4: uint32;\n\tachVendID: string;\n\tfsSelection: uint16;\n\tusFirstCharIndex: uint16;\n\tusLastCharIndex: uint16;\n\tsTypoAscender: int16;\n\tsTypoDescender: int16;\n\tsTypoLineGap: int16;\n\tusWinAscent: uint16;\n\tusWinDescent: uint16;\n\t// Version 1+\n\tulCodePageRange1?: uint32;\n\tulCodePageRange2?: uint32;\n\t// Version 2+\n\tsxHeight?: int16;\n\tsCapHeight?: int16;\n\tusDefaultChar?: uint16;\n\tusBreakChar?: uint16;\n\tusMaxContext?: uint16;\n\t// Version 5+\n\tusLowerOpticalPointSize?: uint16;\n\tusUpperOpticalPointSize?: uint16;\n}\n\n/** Weight class constants */\nexport const WeightClass = {\n\tThin: 100,\n\tExtraLight: 200,\n\tLight: 300,\n\tNormal: 400,\n\tMedium: 500,\n\tSemiBold: 600,\n\tBold: 700,\n\tExtraBold: 800,\n\tBlack: 900,\n} as const;\n\n/** Width class constants */\nexport const WidthClass = {\n\tUltraCondensed: 1,\n\tExtraCondensed: 2,\n\tCondensed: 3,\n\tSemiCondensed: 4,\n\tNormal: 5,\n\tSemiExpanded: 6,\n\tExpanded: 7,\n\tExtraExpanded: 8,\n\tUltraExpanded: 9,\n} as const;\n\n/** Font selection flags (fsSelection) */\nexport const FsSelection = {\n\tItalic: 0x0001,\n\tUnderscore: 0x0002,\n\tNegative: 0x0004,\n\tOutlined: 0x0008,\n\tStrikeout: 0x0010,\n\tBold: 0x0020,\n\tRegular: 0x0040,\n\tUseTypoMetrics: 0x0080,\n\tWWS: 0x0100,\n\tOblique: 0x0200,\n} as const;\n\n/** Font embedding permissions (fsType) */\nexport const FsType = {\n\tInstallableEmbedding: 0x0000,\n\tRestrictedLicense: 0x0002,\n\tPreviewAndPrint: 0x0004,\n\tEditable: 0x0008,\n\tNoSubsetting: 0x0100,\n\tBitmapOnly: 0x0200,\n} as const;\n\nexport function parseOs2(reader: Reader): Os2Table {\n\tconst version = reader.uint16();\n\tconst xAvgCharWidth = reader.int16();\n\tconst usWeightClass = reader.uint16();\n\tconst usWidthClass = reader.uint16();\n\tconst fsType = reader.uint16();\n\tconst ySubscriptXSize = reader.int16();\n\tconst ySubscriptYSize = reader.int16();\n\tconst ySubscriptXOffset = reader.int16();\n\tconst ySubscriptYOffset = reader.int16();\n\tconst ySuperscriptXSize = reader.int16();\n\tconst ySuperscriptYSize = reader.int16();\n\tconst ySuperscriptXOffset = reader.int16();\n\tconst ySuperscriptYOffset = reader.int16();\n\tconst yStrikeoutSize = reader.int16();\n\tconst yStrikeoutPosition = reader.int16();\n\tconst sFamilyClass = reader.int16();\n\n\t// PANOSE classification (10 bytes)\n\tconst panose: uint8[] = [];\n\tfor (let i = 0; i < 10; i++) {\n\t\tpanose.push(reader.uint8());\n\t}\n\n\tconst ulUnicodeRange1 = reader.uint32();\n\tconst ulUnicodeRange2 = reader.uint32();\n\tconst ulUnicodeRange3 = reader.uint32();\n\tconst ulUnicodeRange4 = reader.uint32();\n\n\t// Vendor ID (4 bytes as ASCII)\n\tconst achVendID = String.fromCharCode(\n\t\treader.uint8(),\n\t\treader.uint8(),\n\t\treader.uint8(),\n\t\treader.uint8(),\n\t);\n\n\tconst fsSelection = reader.uint16();\n\tconst usFirstCharIndex = reader.uint16();\n\tconst usLastCharIndex = reader.uint16();\n\tconst sTypoAscender = reader.int16();\n\tconst sTypoDescender = reader.int16();\n\tconst sTypoLineGap = reader.int16();\n\tconst usWinAscent = reader.uint16();\n\tconst usWinDescent = reader.uint16();\n\n\tconst result: Os2Table = {\n\t\tversion,\n\t\txAvgCharWidth,\n\t\tusWeightClass,\n\t\tusWidthClass,\n\t\tfsType,\n\t\tySubscriptXSize,\n\t\tySubscriptYSize,\n\t\tySubscriptXOffset,\n\t\tySubscriptYOffset,\n\t\tySuperscriptXSize,\n\t\tySuperscriptYSize,\n\t\tySuperscriptXOffset,\n\t\tySuperscriptYOffset,\n\t\tyStrikeoutSize,\n\t\tyStrikeoutPosition,\n\t\tsFamilyClass,\n\t\tpanose,\n\t\tulUnicodeRange1,\n\t\tulUnicodeRange2,\n\t\tulUnicodeRange3,\n\t\tulUnicodeRange4,\n\t\tachVendID,\n\t\tfsSelection,\n\t\tusFirstCharIndex,\n\t\tusLastCharIndex,\n\t\tsTypoAscender,\n\t\tsTypoDescender,\n\t\tsTypoLineGap,\n\t\tusWinAscent,\n\t\tusWinDescent,\n\t};\n\n\t// Version 1+ fields\n\tif (version >= 1) {\n\t\tresult.ulCodePageRange1 = reader.uint32();\n\t\tresult.ulCodePageRange2 = reader.uint32();\n\t}\n\n\t// Version 2+ fields\n\tif (version >= 2) {\n\t\tresult.sxHeight = reader.int16();\n\t\tresult.sCapHeight = reader.int16();\n\t\tresult.usDefaultChar = reader.uint16();\n\t\tresult.usBreakChar = reader.uint16();\n\t\tresult.usMaxContext = reader.uint16();\n\t}\n\n\t// Version 5+ fields\n\tif (version >= 5) {\n\t\tresult.usLowerOpticalPointSize = reader.uint16();\n\t\tresult.usUpperOpticalPointSize = reader.uint16();\n\t}\n\n\treturn result;\n}\n\n/** Check if font is italic */\nexport function isItalic(os2: Os2Table): boolean {\n\treturn (os2.fsSelection & FsSelection.Italic) !== 0;\n}\n\n/** Check if font is bold */\nexport function isBold(os2: Os2Table): boolean {\n\treturn (os2.fsSelection & FsSelection.Bold) !== 0;\n}\n\n/** Check if USE_TYPO_METRICS flag is set */\nexport function useTypoMetrics(os2: Os2Table): boolean {\n\treturn (os2.fsSelection & FsSelection.UseTypoMetrics) !== 0;\n}\n\n/** Get embedding permission level */\nexport function getEmbeddingPermission(\n\tos2: Os2Table,\n): \"installable\" | \"restricted\" | \"preview\" | \"editable\" {\n\tconst fsType = os2.fsType;\n\tif ((fsType & FsType.RestrictedLicense) !== 0) return \"restricted\";\n\tif ((fsType & FsType.PreviewAndPrint) !== 0) return \"preview\";\n\tif ((fsType & FsType.Editable) !== 0) return \"editable\";\n\treturn \"installable\";\n}\n", "import type { int16, uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * post table - PostScript font information\n * Contains additional PostScript info like glyph names and italic angle\n */\nexport interface PostTable {\n\tversion: number;\n\titalicAngle: number;\n\tunderlinePosition: int16;\n\tunderlineThickness: int16;\n\tisFixedPitch: uint32;\n\tminMemType42: uint32;\n\tmaxMemType42: uint32;\n\tminMemType1: uint32;\n\tmaxMemType1: uint32;\n\t// Version 2.0 only\n\tnumberOfGlyphs?: uint16;\n\tglyphNameIndex?: uint16[];\n\tnames?: string[];\n}\n\n/** Standard PostScript glyph names (first 258) */\nconst standardNames: string[] = [\n\t\".notdef\",\n\t\".null\",\n\t\"nonmarkingreturn\",\n\t\"space\",\n\t\"exclam\",\n\t\"quotedbl\",\n\t\"numbersign\",\n\t\"dollar\",\n\t\"percent\",\n\t\"ampersand\",\n\t\"quotesingle\",\n\t\"parenleft\",\n\t\"parenright\",\n\t\"asterisk\",\n\t\"plus\",\n\t\"comma\",\n\t\"hyphen\",\n\t\"period\",\n\t\"slash\",\n\t\"zero\",\n\t\"one\",\n\t\"two\",\n\t\"three\",\n\t\"four\",\n\t\"five\",\n\t\"six\",\n\t\"seven\",\n\t\"eight\",\n\t\"nine\",\n\t\"colon\",\n\t\"semicolon\",\n\t\"less\",\n\t\"equal\",\n\t\"greater\",\n\t\"question\",\n\t\"at\",\n\t\"A\",\n\t\"B\",\n\t\"C\",\n\t\"D\",\n\t\"E\",\n\t\"F\",\n\t\"G\",\n\t\"H\",\n\t\"I\",\n\t\"J\",\n\t\"K\",\n\t\"L\",\n\t\"M\",\n\t\"N\",\n\t\"O\",\n\t\"P\",\n\t\"Q\",\n\t\"R\",\n\t\"S\",\n\t\"T\",\n\t\"U\",\n\t\"V\",\n\t\"W\",\n\t\"X\",\n\t\"Y\",\n\t\"Z\",\n\t\"bracketleft\",\n\t\"backslash\",\n\t\"bracketright\",\n\t\"asciicircum\",\n\t\"underscore\",\n\t\"grave\",\n\t\"a\",\n\t\"b\",\n\t\"c\",\n\t\"d\",\n\t\"e\",\n\t\"f\",\n\t\"g\",\n\t\"h\",\n\t\"i\",\n\t\"j\",\n\t\"k\",\n\t\"l\",\n\t\"m\",\n\t\"n\",\n\t\"o\",\n\t\"p\",\n\t\"q\",\n\t\"r\",\n\t\"s\",\n\t\"t\",\n\t\"u\",\n\t\"v\",\n\t\"w\",\n\t\"x\",\n\t\"y\",\n\t\"z\",\n\t\"braceleft\",\n\t\"bar\",\n\t\"braceright\",\n\t\"asciitilde\",\n\t\"Adieresis\",\n\t\"Aring\",\n\t\"Ccedilla\",\n\t\"Eacute\",\n\t\"Ntilde\",\n\t\"Odieresis\",\n\t\"Udieresis\",\n\t\"aacute\",\n\t\"agrave\",\n\t\"acircumflex\",\n\t\"adieresis\",\n\t\"atilde\",\n\t\"aring\",\n\t\"ccedilla\",\n\t\"eacute\",\n\t\"egrave\",\n\t\"ecircumflex\",\n\t\"edieresis\",\n\t\"iacute\",\n\t\"igrave\",\n\t\"icircumflex\",\n\t\"idieresis\",\n\t\"ntilde\",\n\t\"oacute\",\n\t\"ograve\",\n\t\"ocircumflex\",\n\t\"odieresis\",\n\t\"otilde\",\n\t\"uacute\",\n\t\"ugrave\",\n\t\"ucircumflex\",\n\t\"udieresis\",\n\t\"dagger\",\n\t\"degree\",\n\t\"cent\",\n\t\"sterling\",\n\t\"section\",\n\t\"bullet\",\n\t\"paragraph\",\n\t\"germandbls\",\n\t\"registered\",\n\t\"copyright\",\n\t\"trademark\",\n\t\"acute\",\n\t\"dieresis\",\n\t\"notequal\",\n\t\"AE\",\n\t\"Oslash\",\n\t\"infinity\",\n\t\"plusminus\",\n\t\"lessequal\",\n\t\"greaterequal\",\n\t\"yen\",\n\t\"mu\",\n\t\"partialdiff\",\n\t\"summation\",\n\t\"product\",\n\t\"pi\",\n\t\"integral\",\n\t\"ordfeminine\",\n\t\"ordmasculine\",\n\t\"Omega\",\n\t\"ae\",\n\t\"oslash\",\n\t\"questiondown\",\n\t\"exclamdown\",\n\t\"logicalnot\",\n\t\"radical\",\n\t\"florin\",\n\t\"approxequal\",\n\t\"Delta\",\n\t\"guillemotleft\",\n\t\"guillemotright\",\n\t\"ellipsis\",\n\t\"nonbreakingspace\",\n\t\"Agrave\",\n\t\"Atilde\",\n\t\"Otilde\",\n\t\"OE\",\n\t\"oe\",\n\t\"endash\",\n\t\"emdash\",\n\t\"quotedblleft\",\n\t\"quotedblright\",\n\t\"quoteleft\",\n\t\"quoteright\",\n\t\"divide\",\n\t\"lozenge\",\n\t\"ydieresis\",\n\t\"Ydieresis\",\n\t\"fraction\",\n\t\"currency\",\n\t\"guilsinglleft\",\n\t\"guilsinglright\",\n\t\"fi\",\n\t\"fl\",\n\t\"daggerdbl\",\n\t\"periodcentered\",\n\t\"quotesinglbase\",\n\t\"quotedblbase\",\n\t\"perthousand\",\n\t\"Acircumflex\",\n\t\"Ecircumflex\",\n\t\"Aacute\",\n\t\"Edieresis\",\n\t\"Egrave\",\n\t\"Iacute\",\n\t\"Icircumflex\",\n\t\"Idieresis\",\n\t\"Igrave\",\n\t\"Oacute\",\n\t\"Ocircumflex\",\n\t\"apple\",\n\t\"Ograve\",\n\t\"Uacute\",\n\t\"Ucircumflex\",\n\t\"Ugrave\",\n\t\"dotlessi\",\n\t\"circumflex\",\n\t\"tilde\",\n\t\"macron\",\n\t\"breve\",\n\t\"dotaccent\",\n\t\"ring\",\n\t\"cedilla\",\n\t\"hungarumlaut\",\n\t\"ogonek\",\n\t\"caron\",\n\t\"Lslash\",\n\t\"lslash\",\n\t\"Scaron\",\n\t\"scaron\",\n\t\"Zcaron\",\n\t\"zcaron\",\n\t\"brokenbar\",\n\t\"Eth\",\n\t\"eth\",\n\t\"Yacute\",\n\t\"yacute\",\n\t\"Thorn\",\n\t\"thorn\",\n\t\"minus\",\n\t\"multiply\",\n\t\"onesuperior\",\n\t\"twosuperior\",\n\t\"threesuperior\",\n\t\"onehalf\",\n\t\"onequarter\",\n\t\"threequarters\",\n\t\"franc\",\n\t\"Gbreve\",\n\t\"gbreve\",\n\t\"Idotaccent\",\n\t\"Scedilla\",\n\t\"scedilla\",\n\t\"Cacute\",\n\t\"cacute\",\n\t\"Ccaron\",\n\t\"ccaron\",\n\t\"dcroat\",\n];\n\nexport function parsePost(reader: Reader): PostTable {\n\tconst versionMajor = reader.uint16();\n\tconst versionMinor = reader.uint16();\n\tconst version = versionMajor + versionMinor / 0x10000;\n\n\tconst italicAngle = reader.fixed();\n\tconst underlinePosition = reader.int16();\n\tconst underlineThickness = reader.int16();\n\tconst isFixedPitch = reader.uint32();\n\tconst minMemType42 = reader.uint32();\n\tconst maxMemType42 = reader.uint32();\n\tconst minMemType1 = reader.uint32();\n\tconst maxMemType1 = reader.uint32();\n\n\tconst result: PostTable = {\n\t\tversion,\n\t\titalicAngle,\n\t\tunderlinePosition,\n\t\tunderlineThickness,\n\t\tisFixedPitch,\n\t\tminMemType42,\n\t\tmaxMemType42,\n\t\tminMemType1,\n\t\tmaxMemType1,\n\t};\n\n\t// Version 2.0: includes glyph names\n\tif (version === 2.0) {\n\t\tconst numberOfGlyphs = reader.uint16();\n\t\tconst glyphNameIndex: uint16[] = [];\n\n\t\tfor (let i = 0; i < numberOfGlyphs; i++) {\n\t\t\tglyphNameIndex.push(reader.uint16());\n\t\t}\n\n\t\t// Collect custom names (indexes >= 258)\n\t\tconst customNames: string[] = [];\n\t\tlet maxIndex = 0;\n\t\tfor (const idx of glyphNameIndex) {\n\t\t\tif (idx >= 258 && idx > maxIndex) {\n\t\t\t\tmaxIndex = idx;\n\t\t\t}\n\t\t}\n\n\t\t// Read custom names\n\t\tconst numCustomNames = maxIndex >= 258 ? maxIndex - 257 : 0;\n\t\tfor (let i = 0; i < numCustomNames; i++) {\n\t\t\tconst length = reader.uint8();\n\t\t\tconst chars: string[] = [];\n\t\t\tfor (let j = 0; j < length; j++) {\n\t\t\t\tchars.push(String.fromCharCode(reader.uint8()));\n\t\t\t}\n\t\t\tcustomNames.push(chars.join(\"\"));\n\t\t}\n\n\t\tresult.numberOfGlyphs = numberOfGlyphs;\n\t\tresult.glyphNameIndex = glyphNameIndex;\n\t\tresult.names = customNames;\n\t}\n\n\treturn result;\n}\n\n/** Get glyph name by glyph ID */\nexport function getGlyphName(post: PostTable, glyphId: number): string | null {\n\t// Version 1: standard 258 names\n\tif (post.version === 1.0) {\n\t\tconst name = standardNames[glyphId];\n\t\treturn name !== undefined ? name : null;\n\t}\n\n\t// Version 2: indexed names\n\tif (post.version === 2.0 && post.glyphNameIndex) {\n\t\tconst index = post.glyphNameIndex[glyphId];\n\t\tif (index === undefined) return null;\n\n\t\t// Standard name\n\t\tif (index < 258) {\n\t\t\treturn standardNames[index] ?? null;\n\t\t}\n\n\t\t// Custom name\n\t\tconst customIndex = index - 258;\n\t\treturn post.names?.[customIndex] ?? null;\n\t}\n\n\t// Version 3: no names stored\n\treturn null;\n}\n\n/** Check if font is monospaced */\nexport function isMonospaced(post: PostTable): boolean {\n\treturn post.isFixedPitch !== 0;\n}\n", "import type { GlyphId, int16, uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Standard Bitmap Graphics table (sbix)\n * Apple's bitmap/PNG glyph table for color emoji and bitmap fonts\n */\nexport interface SbixTable {\n\tversion: uint16;\n\tflags: uint16;\n\tstrikes: SbixStrike[];\n}\n\n/**\n * Strike (bitmap size) in sbix\n */\nexport interface SbixStrike {\n\tppem: uint16;\n\tppi: uint16;\n\tglyphData: Map<GlyphId, SbixGlyph>;\n}\n\n/**\n * Glyph data in sbix\n */\nexport interface SbixGlyph {\n\toriginOffsetX: int16;\n\toriginOffsetY: int16;\n\tgraphicType: string; // 4-char tag: 'png ', 'jpg ', 'tiff', 'pdf ', etc.\n\tdata: Uint8Array;\n}\n\n/**\n * Common graphic types in sbix\n */\nexport const SbixGraphicType = {\n\tPNG: \"png \",\n\tJPG: \"jpg \",\n\tTIFF: \"tiff\",\n\tPDF: \"pdf \",\n\tMASK: \"mask\", // Mask for another glyph\n\tDUPE: \"dupe\", // Duplicate of another glyph (data is glyph ID)\n} as const;\n\n/**\n * Parse sbix table\n */\nexport function parseSbix(reader: Reader, numGlyphs: number): SbixTable {\n\tconst tableStart = reader.offset;\n\tconst version = reader.uint16();\n\tconst flags = reader.uint16();\n\tconst numStrikes = reader.uint32();\n\n\t// Read strike offsets\n\tconst strikeOffsets: uint32[] = [];\n\tfor (let i = 0; i < numStrikes; i++) {\n\t\tstrikeOffsets.push(reader.uint32());\n\t}\n\n\t// Parse each strike\n\tconst strikes: SbixStrike[] = [];\n\tfor (const strikeOffset of strikeOffsets) {\n\t\tconst strike = parseStrike(reader, tableStart + strikeOffset, numGlyphs);\n\t\tstrikes.push(strike);\n\t}\n\n\treturn { version, flags, strikes };\n}\n\nfunction parseStrike(\n\treader: Reader,\n\tstrikeOffset: number,\n\tnumGlyphs: number,\n): SbixStrike {\n\tconst strikeReader = reader.sliceFrom(strikeOffset);\n\tconst ppem = strikeReader.uint16();\n\tconst ppi = strikeReader.uint16();\n\n\t// Read glyph data offsets (numGlyphs + 1 for sentinel)\n\tconst glyphDataOffsets: uint32[] = [];\n\tfor (let i = 0; i <= numGlyphs; i++) {\n\t\tglyphDataOffsets.push(strikeReader.uint32());\n\t}\n\n\t// Parse glyph data\n\tconst glyphData = new Map<GlyphId, SbixGlyph>();\n\n\tfor (let glyphId = 0; glyphId < numGlyphs; glyphId++) {\n\t\tconst offset = glyphDataOffsets[glyphId]!;\n\t\tconst nextOffset = glyphDataOffsets[glyphId + 1]!;\n\t\tconst dataLength = nextOffset - offset;\n\n\t\tif (dataLength <= 8) {\n\t\t\t// No data or just header (minimum is 8 bytes for header)\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst glyphReader = reader.sliceFrom(strikeOffset + offset);\n\t\tconst originOffsetX = glyphReader.int16();\n\t\tconst originOffsetY = glyphReader.int16();\n\t\tconst graphicType = glyphReader.tagString();\n\n\t\t// Read actual image data\n\t\tconst imageDataLength = dataLength - 8;\n\t\tconst data = glyphReader.bytes(imageDataLength);\n\n\t\tglyphData.set(glyphId, {\n\t\t\toriginOffsetX,\n\t\t\toriginOffsetY,\n\t\t\tgraphicType,\n\t\t\tdata,\n\t\t});\n\t}\n\n\treturn { ppem, ppi, glyphData };\n}\n\n/**\n * Get glyph bitmap for a specific ppem\n * Returns the best matching strike\n */\nexport function getGlyphBitmap(\n\tsbix: SbixTable,\n\tglyphId: GlyphId,\n\tppem: number,\n): SbixGlyph | null {\n\t// Find best matching strike\n\tlet bestStrike: SbixStrike | null = null;\n\tlet bestDiff = Infinity;\n\n\tfor (const strike of sbix.strikes) {\n\t\tconst diff = Math.abs(strike.ppem - ppem);\n\t\tif (diff < bestDiff) {\n\t\t\tbestDiff = diff;\n\t\t\tbestStrike = strike;\n\t\t}\n\t}\n\n\tif (!bestStrike) return null;\n\n\treturn bestStrike.glyphData.get(glyphId) ?? null;\n}\n\n/**\n * Get exact ppem strike\n */\nexport function getStrikeForPpem(\n\tsbix: SbixTable,\n\tppem: number,\n): SbixStrike | null {\n\treturn sbix.strikes.find((s) => s.ppem === ppem) ?? null;\n}\n\n/**\n * Get all available ppem sizes\n */\nexport function getAvailablePpemSizes(sbix: SbixTable): number[] {\n\treturn sbix.strikes.map((s) => s.ppem).sort((a, b) => a - b);\n}\n\n/**\n * Check if glyph has bitmap data\n */\nexport function hasGlyphBitmap(\n\tsbix: SbixTable,\n\tglyphId: GlyphId,\n\tppem?: number,\n): boolean {\n\tif (ppem !== undefined) {\n\t\tconst strike = getStrikeForPpem(sbix, ppem);\n\t\treturn strike?.glyphData.has(glyphId) ?? false;\n\t}\n\n\t// Check any strike\n\tfor (const strike of sbix.strikes) {\n\t\tif (strike.glyphData.has(glyphId)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * Resolve dupe graphic type\n * Returns the actual glyph data for duplicates\n */\nexport function resolveDupeGlyph(\n\tsbix: SbixTable,\n\tstrike: SbixStrike,\n\tglyph: SbixGlyph,\n): SbixGlyph | null {\n\tif (glyph.graphicType !== SbixGraphicType.DUPE) {\n\t\treturn glyph;\n\t}\n\n\t// Data contains the glyph ID to reference\n\tif (glyph.data.length < 2) return null;\n\n\tconst dupeGlyphId = (glyph.data[0]! << 8) | glyph.data[1]!;\n\tconst resolved = strike.glyphData.get(dupeGlyphId);\n\n\tif (!resolved) return null;\n\n\t// Recursively resolve if it's also a dupe\n\tif (resolved.graphicType === SbixGraphicType.DUPE) {\n\t\treturn resolveDupeGlyph(sbix, strike, resolved);\n\t}\n\n\treturn resolved;\n}\n", "import type { TableRecord, Tag } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/** Supported sfnt version tags */\nconst SFNT_VERSION_TRUETYPE = 0x00010000; // TrueType\nconst SFNT_VERSION_OPENTYPE = 0x4f54544f; // 'OTTO' - CFF\nconst SFNT_VERSION_TRUE = 0x74727565; // 'true' - Apple TrueType\n\n/** Font directory containing table records */\nexport interface FontDirectory {\n\tsfntVersion: number;\n\tnumTables: number;\n\tsearchRange: number;\n\tentrySelector: number;\n\trangeShift: number;\n\ttables: Map<Tag, TableRecord>;\n}\n\n/**\n * Parse the sfnt font directory (table of contents).\n * This is the first thing read from any TrueType/OpenType font.\n */\nexport function parseFontDirectory(reader: Reader): FontDirectory {\n\tconst sfntVersion = reader.uint32();\n\n\t// Validate sfnt version\n\tif (\n\t\tsfntVersion !== SFNT_VERSION_TRUETYPE &&\n\t\tsfntVersion !== SFNT_VERSION_OPENTYPE &&\n\t\tsfntVersion !== SFNT_VERSION_TRUE\n\t) {\n\t\tthrow new Error(\n\t\t\t`Invalid sfnt version: 0x${sfntVersion.toString(16).padStart(8, \"0\")}`,\n\t\t);\n\t}\n\n\tconst numTables = reader.uint16();\n\tconst searchRange = reader.uint16();\n\tconst entrySelector = reader.uint16();\n\tconst rangeShift = reader.uint16();\n\n\tconst tables = new Map<Tag, TableRecord>();\n\n\tfor (let i = 0; i < numTables; i++) {\n\t\tconst tag = reader.tag();\n\t\tconst checksum = reader.uint32();\n\t\tconst offset = reader.uint32();\n\t\tconst length = reader.uint32();\n\n\t\ttables.set(tag, { tag, checksum, offset, length });\n\t}\n\n\treturn {\n\t\tsfntVersion,\n\t\tnumTables,\n\t\tsearchRange,\n\t\tentrySelector,\n\t\trangeShift,\n\t\ttables,\n\t};\n}\n\n/** Check if this is a TrueType font (vs CFF) */\nexport function isTrueType(directory: FontDirectory): boolean {\n\treturn (\n\t\tdirectory.sfntVersion === SFNT_VERSION_TRUETYPE ||\n\t\tdirectory.sfntVersion === SFNT_VERSION_TRUE\n\t);\n}\n\n/** Check if this is a CFF font */\nexport function isCFF(directory: FontDirectory): boolean {\n\treturn directory.sfntVersion === SFNT_VERSION_OPENTYPE;\n}\n", "import type { uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * AAT Feature Name table (feat)\n * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6feat.html\n *\n * Defines the font's typographic features that can be controlled by the user.\n * Each feature has a type and settings with human-readable names.\n */\nexport interface FeatTable {\n\tversion: number;\n\tfeatures: FeatureRecord[];\n}\n\n/**\n * A single feature record\n */\nexport interface FeatureRecord {\n\t/** Feature type (e.g., 1 = ligatures, 2 = cursive connection) */\n\tfeatureType: uint16;\n\t/** Number of settings for this feature */\n\tnSettings: uint16;\n\t/** Offset to setting name array */\n\tsettingTableOffset: uint32;\n\t/** Feature flags */\n\tfeatureFlags: uint16;\n\t/** Default setting index */\n\tdefaultSettingIndex: uint16;\n\t/** Name table ID for feature name */\n\tnameId: uint16;\n\t/** Parsed settings */\n\tsettings: FeatureSetting[];\n}\n\n/**\n * A single feature setting\n */\nexport interface FeatureSetting {\n\t/** Setting value to use in morx feature table */\n\tsettingValue: uint16;\n\t/** Name table ID for setting name */\n\tnameId: uint16;\n}\n\n/**\n * Feature type constants (Apple-defined)\n */\nexport enum FeatureType {\n\t/** All typographic features */\n\tAllTypographicFeatures = 0,\n\t/** Ligatures */\n\tLigatures = 1,\n\t/** Cursive connection */\n\tCursiveConnection = 2,\n\t/** Letter case */\n\tLetterCase = 3,\n\t/** Vertical substitution */\n\tVerticalSubstitution = 4,\n\t/** Linguistic rearrangement */\n\tLinguisticRearrangement = 5,\n\t/** Number spacing */\n\tNumberSpacing = 6,\n\t/** Smart swashes */\n\tSmartSwashes = 8,\n\t/** Diacritics */\n\tDiacritics = 9,\n\t/** Vertical position */\n\tVerticalPosition = 10,\n\t/** Fractions */\n\tFractions = 11,\n\t/** Overlapping characters */\n\tOverlappingCharacters = 13,\n\t/** Typographic extras */\n\tTypographicExtras = 14,\n\t/** Mathematical extras */\n\tMathematicalExtras = 15,\n\t/** Ornament sets */\n\tOrnamentSets = 16,\n\t/** Character alternatives */\n\tCharacterAlternatives = 17,\n\t/** Design complexity */\n\tDesignComplexity = 18,\n\t/** Style options */\n\tStyleOptions = 19,\n\t/** Character shape */\n\tCharacterShape = 20,\n\t/** Number case */\n\tNumberCase = 21,\n\t/** Text spacing */\n\tTextSpacing = 22,\n\t/** Transliteration */\n\tTransliteration = 23,\n\t/** Annotation */\n\tAnnotation = 24,\n\t/** Kana spacing */\n\tKanaSpacing = 25,\n\t/** Ideographic spacing */\n\tIdeographicSpacing = 26,\n\t/** Unicode decomposition */\n\tUnicodeDecomposition = 27,\n\t/** Ruby kana */\n\tRubyKana = 28,\n\t/** CJK symbol alternatives */\n\tCJKSymbolAlternatives = 29,\n\t/** Ideographic alternatives */\n\tIdeographicAlternatives = 30,\n\t/** CJK vertical roman placement */\n\tCJKVerticalRomanPlacement = 31,\n\t/** Italic CJK roman */\n\tItalicCJKRoman = 32,\n\t/** Case-sensitive layout */\n\tCaseSensitiveLayout = 33,\n\t/** Alternate kana */\n\tAlternateKana = 34,\n\t/** Stylistic alternatives */\n\tStylisticAlternatives = 35,\n\t/** Contextual alternatives */\n\tContextualAlternatives = 36,\n\t/** Lower case */\n\tLowerCase = 37,\n\t/** Upper case */\n\tUpperCase = 38,\n\t/** Language tag */\n\tLanguageTag = 39,\n\t/** CJK roman spacing */\n\tCJKRomanSpacing = 103,\n}\n\n/**\n * Common ligature settings\n */\nexport enum LigatureSetting {\n\tRequiredLigaturesOn = 0,\n\tRequiredLigaturesOff = 1,\n\tCommonLigaturesOn = 2,\n\tCommonLigaturesOff = 3,\n\tRareLigaturesOn = 4,\n\tRareLigaturesOff = 5,\n\tLogosOn = 6,\n\tLogosOff = 7,\n\tRebusPicturesOn = 8,\n\tRebusPicturesOff = 9,\n\tDiphthongLigaturesOn = 10,\n\tDiphthongLigaturesOff = 11,\n\tSquaredLigaturesOn = 12,\n\tSquaredLigaturesOff = 13,\n\tAbbrevSquaredLigaturesOn = 14,\n\tAbbrevSquaredLigaturesOff = 15,\n\tSymbolLigaturesOn = 16,\n\tSymbolLigaturesOff = 17,\n\tContextualLigaturesOn = 18,\n\tContextualLigaturesOff = 19,\n\tHistoricalLigaturesOn = 20,\n\tHistoricalLigaturesOff = 21,\n}\n\n/**\n * Vertical position settings\n */\nexport enum VerticalPositionSetting {\n\tNormalPosition = 0,\n\tSuperiors = 1,\n\tInferiors = 2,\n\tOrdinals = 3,\n\tScientificInferiors = 4,\n}\n\n/**\n * Number case settings\n */\nexport enum NumberCaseSetting {\n\tLowerCaseNumbers = 0,\n\tUpperCaseNumbers = 1,\n}\n\n/**\n * Number spacing settings\n */\nexport enum NumberSpacingSetting {\n\tMonospacedNumbers = 0,\n\tProportionalNumbers = 1,\n\tThirdWidthNumbers = 2,\n\tQuarterWidthNumbers = 3,\n}\n\n/**\n * Fractions settings\n */\nexport enum FractionsSetting {\n\tNoFractions = 0,\n\tVerticalFractions = 1,\n\tDiagonalFractions = 2,\n}\n\n/**\n * Case-sensitive layout settings\n */\nexport enum CaseSensitiveLayoutSetting {\n\tCaseSensitiveLayoutOn = 0,\n\tCaseSensitiveLayoutOff = 1,\n\tCaseSensitiveSpacingOn = 2,\n\tCaseSensitiveSpacingOff = 3,\n}\n\n/**\n * Stylistic alternatives settings\n */\nexport enum StylisticAlternativesSetting {\n\tNoStylisticAlternates = 0,\n\tStylisticAltOneOn = 2,\n\tStylisticAltOneOff = 3,\n\tStylisticAltTwoOn = 4,\n\tStylisticAltTwoOff = 5,\n\tStylisticAltThreeOn = 6,\n\tStylisticAltThreeOff = 7,\n\tStylisticAltFourOn = 8,\n\tStylisticAltFourOff = 9,\n\tStylisticAltFiveOn = 10,\n\tStylisticAltFiveOff = 11,\n\tStylisticAltSixOn = 12,\n\tStylisticAltSixOff = 13,\n\tStylisticAltSevenOn = 14,\n\tStylisticAltSevenOff = 15,\n\tStylisticAltEightOn = 16,\n\tStylisticAltEightOff = 17,\n\tStylisticAltNineOn = 18,\n\tStylisticAltNineOff = 19,\n\tStylisticAltTenOn = 20,\n\tStylisticAltTenOff = 21,\n\tStylisticAltElevenOn = 22,\n\tStylisticAltElevenOff = 23,\n\tStylisticAltTwelveOn = 24,\n\tStylisticAltTwelveOff = 25,\n\tStylisticAltThirteenOn = 26,\n\tStylisticAltThirteenOff = 27,\n\tStylisticAltFourteenOn = 28,\n\tStylisticAltFourteenOff = 29,\n\tStylisticAltFifteenOn = 30,\n\tStylisticAltFifteenOff = 31,\n\tStylisticAltSixteenOn = 32,\n\tStylisticAltSixteenOff = 33,\n\tStylisticAltSeventeenOn = 34,\n\tStylisticAltSeventeenOff = 35,\n\tStylisticAltEighteenOn = 36,\n\tStylisticAltEighteenOff = 37,\n\tStylisticAltNineteenOn = 38,\n\tStylisticAltNineteenOff = 39,\n\tStylisticAltTwentyOn = 40,\n\tStylisticAltTwentyOff = 41,\n}\n\n/**\n * Contextual alternatives settings\n */\nexport enum ContextualAlternativesSetting {\n\tContextualAlternatesOn = 0,\n\tContextualAlternatesOff = 1,\n\tSwashAlternatesOn = 2,\n\tSwashAlternatesOff = 3,\n\tContextualSwashAlternatesOn = 4,\n\tContextualSwashAlternatesOff = 5,\n}\n\n/**\n * Lower case settings\n */\nexport enum LowerCaseSetting {\n\tDefaultLowerCase = 0,\n\tLowerCaseSmallCaps = 1,\n\tLowerCasePetiteCaps = 2,\n}\n\n/**\n * Upper case settings\n */\nexport enum UpperCaseSetting {\n\tDefaultUpperCase = 0,\n\tUpperCaseSmallCaps = 1,\n\tUpperCasePetiteCaps = 2,\n}\n\n/**\n * Smart swash settings\n */\nexport enum SmartSwashSetting {\n\tWordInitialSwashesOn = 0,\n\tWordInitialSwashesOff = 1,\n\tWordFinalSwashesOn = 2,\n\tWordFinalSwashesOff = 3,\n\tLineInitialSwashesOn = 4,\n\tLineInitialSwashesOff = 5,\n\tLineFinalSwashesOn = 6,\n\tLineFinalSwashesOff = 7,\n\tNonFinalSwashesOn = 8,\n\tNonFinalSwashesOff = 9,\n}\n\n/**\n * Diacritics settings\n */\nexport enum DiacriticsSetting {\n\tShowDiacritics = 0,\n\tHideDiacritics = 1,\n\tDecomposeDiacritics = 2,\n}\n\n/**\n * Character shape settings (CJK)\n */\nexport enum CharacterShapeSetting {\n\tTraditionalCharacters = 0,\n\tSimplifiedCharacters = 1,\n\tJIS1978Characters = 2,\n\tJIS1983Characters = 3,\n\tJIS1990Characters = 4,\n\tTraditionalAltOne = 5,\n\tTraditionalAltTwo = 6,\n\tTraditionalAltThree = 7,\n\tTraditionalAltFour = 8,\n\tTraditionalAltFive = 9,\n\tExpertCharacters = 10,\n\tNLCCharacters = 13,\n\tJIS2004Characters = 11,\n\tHojoCharacters = 12,\n}\n\n/**\n * Feature flag bits\n */\nexport enum FeatureFlags {\n\t/** Feature settings are mutually exclusive */\n\tExclusive = 0x8000,\n\t/** Use default setting index if not specified */\n\tUseDefault = 0x4000,\n}\n\n/**\n * Parse feat table\n */\nexport function parseFeat(reader: Reader): FeatTable {\n\tconst tableStart = reader.offset;\n\n\tconst version = reader.fixed();\n\tconst featureNameCount = reader.uint16();\n\treader.skip(2); // reserved\n\treader.skip(4); // reserved\n\n\tconst features: FeatureRecord[] = [];\n\n\tfor (let i = 0; i < featureNameCount; i++) {\n\t\tconst featureType = reader.uint16();\n\t\tconst nSettings = reader.uint16();\n\t\tconst settingTableOffset = reader.offset32();\n\t\tconst featureFlags = reader.uint16();\n\t\tconst defaultSettingIndex = featureFlags & 0xff;\n\t\tconst nameId = reader.uint16();\n\n\t\t// Parse settings\n\t\tconst settings: FeatureSetting[] = [];\n\t\tconst savedOffset = reader.offset;\n\n\t\treader.seek(tableStart + settingTableOffset);\n\t\tfor (let j = 0; j < nSettings; j++) {\n\t\t\tsettings.push({\n\t\t\t\tsettingValue: reader.uint16(),\n\t\t\t\tnameId: reader.uint16(),\n\t\t\t});\n\t\t}\n\n\t\treader.seek(savedOffset);\n\n\t\tfeatures.push({\n\t\t\tfeatureType,\n\t\t\tnSettings,\n\t\t\tsettingTableOffset,\n\t\t\tfeatureFlags,\n\t\t\tdefaultSettingIndex,\n\t\t\tnameId,\n\t\t\tsettings,\n\t\t});\n\t}\n\n\treturn { version, features };\n}\n\n/**\n * Get a feature by type\n */\nexport function getFeature(\n\ttable: FeatTable,\n\tfeatureType: FeatureType | uint16,\n): FeatureRecord | undefined {\n\treturn table.features.find((f) => f.featureType === featureType);\n}\n\n/**\n * Get all features of a given type\n */\nexport function getAllFeatures(table: FeatTable): FeatureRecord[] {\n\treturn table.features;\n}\n\n/**\n * Check if a feature is exclusive (only one setting can be active)\n */\nexport function isExclusiveFeature(feature: FeatureRecord): boolean {\n\treturn (feature.featureFlags & FeatureFlags.Exclusive) !== 0;\n}\n\n/**\n * Get the default setting for a feature\n */\nexport function getDefaultSetting(\n\tfeature: FeatureRecord,\n): FeatureSetting | undefined {\n\treturn feature.settings[feature.defaultSettingIndex];\n}\n\n/**\n * Get a setting by value\n */\nexport function getSettingByValue(\n\tfeature: FeatureRecord,\n\tsettingValue: uint16,\n): FeatureSetting | undefined {\n\treturn feature.settings.find((s) => s.settingValue === settingValue);\n}\n\n/**\n * Check if a feature has a specific setting\n */\nexport function hasSettingValue(\n\tfeature: FeatureRecord,\n\tsettingValue: uint16,\n): boolean {\n\treturn feature.settings.some((s) => s.settingValue === settingValue);\n}\n\n/**\n * Convert AAT feature type/setting to OpenType feature tag\n * This is a best-effort mapping as there's no 1:1 correspondence\n */\nexport function aatToOpenTypeTag(\n\tfeatureType: FeatureType | uint16,\n\tsettingValue: uint16,\n): string | null {\n\tswitch (featureType) {\n\t\tcase FeatureType.Ligatures:\n\t\t\tswitch (settingValue) {\n\t\t\t\tcase LigatureSetting.CommonLigaturesOn:\n\t\t\t\t\treturn \"liga\";\n\t\t\t\tcase LigatureSetting.RareLigaturesOn:\n\t\t\t\t\treturn \"dlig\";\n\t\t\t\tcase LigatureSetting.HistoricalLigaturesOn:\n\t\t\t\t\treturn \"hlig\";\n\t\t\t\tcase LigatureSetting.ContextualLigaturesOn:\n\t\t\t\t\treturn \"clig\";\n\t\t\t\tcase LigatureSetting.RequiredLigaturesOn:\n\t\t\t\t\treturn \"rlig\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FeatureType.VerticalPosition:\n\t\t\tswitch (settingValue) {\n\t\t\t\tcase VerticalPositionSetting.Superiors:\n\t\t\t\t\treturn \"sups\";\n\t\t\t\tcase VerticalPositionSetting.Inferiors:\n\t\t\t\t\treturn \"subs\";\n\t\t\t\tcase VerticalPositionSetting.Ordinals:\n\t\t\t\t\treturn \"ordn\";\n\t\t\t\tcase VerticalPositionSetting.ScientificInferiors:\n\t\t\t\t\treturn \"sinf\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FeatureType.Fractions:\n\t\t\tif (\n\t\t\t\tsettingValue === FractionsSetting.VerticalFractions ||\n\t\t\t\tsettingValue === FractionsSetting.DiagonalFractions\n\t\t\t) {\n\t\t\t\treturn \"frac\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FeatureType.NumberCase:\n\t\t\tswitch (settingValue) {\n\t\t\t\tcase NumberCaseSetting.LowerCaseNumbers:\n\t\t\t\t\treturn \"onum\";\n\t\t\t\tcase NumberCaseSetting.UpperCaseNumbers:\n\t\t\t\t\treturn \"lnum\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FeatureType.NumberSpacing:\n\t\t\tswitch (settingValue) {\n\t\t\t\tcase NumberSpacingSetting.MonospacedNumbers:\n\t\t\t\t\treturn \"tnum\";\n\t\t\t\tcase NumberSpacingSetting.ProportionalNumbers:\n\t\t\t\t\treturn \"pnum\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FeatureType.CaseSensitiveLayout:\n\t\t\tif (settingValue === CaseSensitiveLayoutSetting.CaseSensitiveLayoutOn) {\n\t\t\t\treturn \"case\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FeatureType.LowerCase:\n\t\t\tswitch (settingValue) {\n\t\t\t\tcase LowerCaseSetting.LowerCaseSmallCaps:\n\t\t\t\t\treturn \"smcp\";\n\t\t\t\tcase LowerCaseSetting.LowerCasePetiteCaps:\n\t\t\t\t\treturn \"pcap\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FeatureType.UpperCase:\n\t\t\tswitch (settingValue) {\n\t\t\t\tcase UpperCaseSetting.UpperCaseSmallCaps:\n\t\t\t\t\treturn \"c2sc\";\n\t\t\t\tcase UpperCaseSetting.UpperCasePetiteCaps:\n\t\t\t\t\treturn \"c2pc\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FeatureType.SmartSwashes:\n\t\t\tif (\n\t\t\t\tsettingValue === SmartSwashSetting.WordInitialSwashesOn ||\n\t\t\t\tsettingValue === SmartSwashSetting.WordFinalSwashesOn\n\t\t\t) {\n\t\t\t\treturn \"swsh\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FeatureType.ContextualAlternatives:\n\t\t\tswitch (settingValue) {\n\t\t\t\tcase ContextualAlternativesSetting.ContextualAlternatesOn:\n\t\t\t\t\treturn \"calt\";\n\t\t\t\tcase ContextualAlternativesSetting.SwashAlternatesOn:\n\t\t\t\t\treturn \"swsh\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FeatureType.StylisticAlternatives:\n\t\t\t// Stylistic sets ss01-ss20\n\t\t\tif (settingValue >= 2 && settingValue <= 41) {\n\t\t\t\tconst setNum = Math.floor((settingValue - 2) / 2) + 1;\n\t\t\t\tif (setNum <= 20) {\n\t\t\t\t\treturn `ss${setNum.toString().padStart(2, \"0\")}`;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FeatureType.CharacterShape:\n\t\t\tswitch (settingValue) {\n\t\t\t\tcase CharacterShapeSetting.TraditionalCharacters:\n\t\t\t\t\treturn \"trad\";\n\t\t\t\tcase CharacterShapeSetting.SimplifiedCharacters:\n\t\t\t\t\treturn \"smpl\";\n\t\t\t\tcase CharacterShapeSetting.JIS1978Characters:\n\t\t\t\t\treturn \"jp78\";\n\t\t\t\tcase CharacterShapeSetting.JIS1983Characters:\n\t\t\t\t\treturn \"jp83\";\n\t\t\t\tcase CharacterShapeSetting.JIS1990Characters:\n\t\t\t\t\treturn \"jp90\";\n\t\t\t\tcase CharacterShapeSetting.JIS2004Characters:\n\t\t\t\t\treturn \"jp04\";\n\t\t\t\tcase CharacterShapeSetting.NLCCharacters:\n\t\t\t\t\treturn \"nlck\";\n\t\t\t\tcase CharacterShapeSetting.ExpertCharacters:\n\t\t\t\t\treturn \"expt\";\n\t\t\t\tcase CharacterShapeSetting.HojoCharacters:\n\t\t\t\t\treturn \"hojo\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FeatureType.VerticalSubstitution:\n\t\t\treturn \"vert\";\n\t\tcase FeatureType.Annotation:\n\t\t\treturn \"nalt\";\n\t\tcase FeatureType.RubyKana:\n\t\t\treturn \"ruby\";\n\t}\n\n\treturn null;\n}\n\n/**\n * Convert OpenType feature tag to AAT feature type/setting\n * Returns null if no mapping exists\n */\nexport function openTypeTagToAat(\n\ttag: string,\n): { featureType: FeatureType; settingValue: uint16 } | null {\n\tswitch (tag) {\n\t\tcase \"liga\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.Ligatures,\n\t\t\t\tsettingValue: LigatureSetting.CommonLigaturesOn,\n\t\t\t};\n\t\tcase \"dlig\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.Ligatures,\n\t\t\t\tsettingValue: LigatureSetting.RareLigaturesOn,\n\t\t\t};\n\t\tcase \"hlig\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.Ligatures,\n\t\t\t\tsettingValue: LigatureSetting.HistoricalLigaturesOn,\n\t\t\t};\n\t\tcase \"clig\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.Ligatures,\n\t\t\t\tsettingValue: LigatureSetting.ContextualLigaturesOn,\n\t\t\t};\n\t\tcase \"rlig\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.Ligatures,\n\t\t\t\tsettingValue: LigatureSetting.RequiredLigaturesOn,\n\t\t\t};\n\t\tcase \"sups\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.VerticalPosition,\n\t\t\t\tsettingValue: VerticalPositionSetting.Superiors,\n\t\t\t};\n\t\tcase \"subs\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.VerticalPosition,\n\t\t\t\tsettingValue: VerticalPositionSetting.Inferiors,\n\t\t\t};\n\t\tcase \"ordn\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.VerticalPosition,\n\t\t\t\tsettingValue: VerticalPositionSetting.Ordinals,\n\t\t\t};\n\t\tcase \"sinf\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.VerticalPosition,\n\t\t\t\tsettingValue: VerticalPositionSetting.ScientificInferiors,\n\t\t\t};\n\t\tcase \"frac\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.Fractions,\n\t\t\t\tsettingValue: FractionsSetting.DiagonalFractions,\n\t\t\t};\n\t\tcase \"onum\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.NumberCase,\n\t\t\t\tsettingValue: NumberCaseSetting.LowerCaseNumbers,\n\t\t\t};\n\t\tcase \"lnum\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.NumberCase,\n\t\t\t\tsettingValue: NumberCaseSetting.UpperCaseNumbers,\n\t\t\t};\n\t\tcase \"tnum\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.NumberSpacing,\n\t\t\t\tsettingValue: NumberSpacingSetting.MonospacedNumbers,\n\t\t\t};\n\t\tcase \"pnum\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.NumberSpacing,\n\t\t\t\tsettingValue: NumberSpacingSetting.ProportionalNumbers,\n\t\t\t};\n\t\tcase \"case\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.CaseSensitiveLayout,\n\t\t\t\tsettingValue: CaseSensitiveLayoutSetting.CaseSensitiveLayoutOn,\n\t\t\t};\n\t\tcase \"smcp\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.LowerCase,\n\t\t\t\tsettingValue: LowerCaseSetting.LowerCaseSmallCaps,\n\t\t\t};\n\t\tcase \"pcap\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.LowerCase,\n\t\t\t\tsettingValue: LowerCaseSetting.LowerCasePetiteCaps,\n\t\t\t};\n\t\tcase \"c2sc\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.UpperCase,\n\t\t\t\tsettingValue: UpperCaseSetting.UpperCaseSmallCaps,\n\t\t\t};\n\t\tcase \"c2pc\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.UpperCase,\n\t\t\t\tsettingValue: UpperCaseSetting.UpperCasePetiteCaps,\n\t\t\t};\n\t\tcase \"swsh\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.SmartSwashes,\n\t\t\t\tsettingValue: SmartSwashSetting.WordInitialSwashesOn,\n\t\t\t};\n\t\tcase \"calt\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.ContextualAlternatives,\n\t\t\t\tsettingValue: ContextualAlternativesSetting.ContextualAlternatesOn,\n\t\t\t};\n\t\tcase \"trad\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.CharacterShape,\n\t\t\t\tsettingValue: CharacterShapeSetting.TraditionalCharacters,\n\t\t\t};\n\t\tcase \"smpl\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.CharacterShape,\n\t\t\t\tsettingValue: CharacterShapeSetting.SimplifiedCharacters,\n\t\t\t};\n\t\tcase \"jp78\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.CharacterShape,\n\t\t\t\tsettingValue: CharacterShapeSetting.JIS1978Characters,\n\t\t\t};\n\t\tcase \"jp83\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.CharacterShape,\n\t\t\t\tsettingValue: CharacterShapeSetting.JIS1983Characters,\n\t\t\t};\n\t\tcase \"jp90\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.CharacterShape,\n\t\t\t\tsettingValue: CharacterShapeSetting.JIS1990Characters,\n\t\t\t};\n\t\tcase \"jp04\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.CharacterShape,\n\t\t\t\tsettingValue: CharacterShapeSetting.JIS2004Characters,\n\t\t\t};\n\t\tcase \"nlck\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.CharacterShape,\n\t\t\t\tsettingValue: CharacterShapeSetting.NLCCharacters,\n\t\t\t};\n\t\tcase \"expt\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.CharacterShape,\n\t\t\t\tsettingValue: CharacterShapeSetting.ExpertCharacters,\n\t\t\t};\n\t\tcase \"hojo\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.CharacterShape,\n\t\t\t\tsettingValue: CharacterShapeSetting.HojoCharacters,\n\t\t\t};\n\t\tcase \"vert\":\n\t\t\treturn { featureType: FeatureType.VerticalSubstitution, settingValue: 0 };\n\t\tcase \"nalt\":\n\t\t\treturn { featureType: FeatureType.Annotation, settingValue: 0 };\n\t\tcase \"ruby\":\n\t\t\treturn { featureType: FeatureType.RubyKana, settingValue: 0 };\n\t}\n\n\t// Handle stylistic sets ss01-ss20\n\tif (tag.startsWith(\"ss\") && tag.length === 4) {\n\t\tconst num = parseInt(tag.slice(2), 10);\n\t\tif (num >= 1 && num <= 20) {\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.StylisticAlternatives,\n\t\t\t\tsettingValue: (num - 1) * 2 + 2,\n\t\t\t};\n\t\t}\n\t}\n\n\treturn null;\n}\n", "import type { Tag, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Style Attributes table (STAT)\n * Provides style information for variable fonts\n * Used for font selection and naming\n */\nexport interface StatTable {\n\tmajorVersion: uint16;\n\tminorVersion: uint16;\n\tdesignAxisCount: uint16;\n\tdesignAxes: AxisRecord[];\n\taxisValueCount: uint16;\n\taxisValues: AxisValue[];\n\telidedFallbackNameID?: uint16;\n}\n\n/**\n * Design axis record\n */\nexport interface AxisRecord {\n\taxisTag: Tag;\n\taxisNameID: uint16;\n\taxisOrdering: uint16;\n}\n\n/**\n * Axis value flags\n */\nexport const AxisValueFlags = {\n\tOlderSiblingFontAttribute: 0x0001,\n\tElidableAxisValueName: 0x0002,\n} as const;\n\n/**\n * Base axis value\n */\nexport interface AxisValueBase {\n\tformat: number;\n\taxisIndex: uint16;\n\tflags: uint16;\n\tvalueNameID: uint16;\n}\n\n/**\n * Format 1: Single axis value\n */\nexport interface AxisValueFormat1 extends AxisValueBase {\n\tformat: 1;\n\tvalue: number; // Fixed 16.16\n}\n\n/**\n * Format 2: Axis value range\n */\nexport interface AxisValueFormat2 extends AxisValueBase {\n\tformat: 2;\n\tnominalValue: number;\n\trangeMinValue: number;\n\trangeMaxValue: number;\n}\n\n/**\n * Format 3: Linked axis value\n */\nexport interface AxisValueFormat3 extends AxisValueBase {\n\tformat: 3;\n\tvalue: number;\n\tlinkedValue: number;\n}\n\n/**\n * Format 4: Multiple axis values\n */\nexport interface AxisValueFormat4 {\n\tformat: 4;\n\taxisCount: uint16;\n\tflags: uint16;\n\tvalueNameID: uint16;\n\taxisValues: { axisIndex: uint16; value: number }[];\n}\n\nexport type AxisValue =\n\t| AxisValueFormat1\n\t| AxisValueFormat2\n\t| AxisValueFormat3\n\t| AxisValueFormat4;\n\n/**\n * Parse STAT table\n */\nexport function parseStat(reader: Reader): StatTable {\n\tconst tableStart = reader.offset;\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst designAxisSize = reader.uint16();\n\tconst designAxisCount = reader.uint16();\n\tconst designAxesOffset = reader.offset32();\n\tconst axisValueCount = reader.uint16();\n\tconst axisValueArrayOffset = reader.offset32();\n\n\tlet elidedFallbackNameID: uint16 | undefined;\n\tif (majorVersion >= 1 && minorVersion >= 1) {\n\t\telidedFallbackNameID = reader.uint16();\n\t}\n\n\t// Parse design axes\n\tconst designAxes: AxisRecord[] = [];\n\tif (designAxesOffset !== 0) {\n\t\tconst axesReader = reader.sliceFrom(tableStart + designAxesOffset);\n\t\tfor (let i = 0; i < designAxisCount; i++) {\n\t\t\tdesignAxes.push({\n\t\t\t\taxisTag: axesReader.tag(),\n\t\t\t\taxisNameID: axesReader.uint16(),\n\t\t\t\taxisOrdering: axesReader.uint16(),\n\t\t\t});\n\t\t\t// Skip any additional bytes if designAxisSize > 8\n\t\t\tif (designAxisSize > 8) {\n\t\t\t\taxesReader.skip(designAxisSize - 8);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Parse axis values\n\tconst axisValues: AxisValue[] = [];\n\tif (axisValueArrayOffset !== 0 && axisValueCount > 0) {\n\t\tconst arrayReader = reader.sliceFrom(tableStart + axisValueArrayOffset);\n\n\t\t// Read axis value offsets\n\t\tconst axisValueOffsets: uint16[] = [];\n\t\tfor (let i = 0; i < axisValueCount; i++) {\n\t\t\taxisValueOffsets.push(arrayReader.uint16());\n\t\t}\n\n\t\t// Parse each axis value\n\t\tfor (const offset of axisValueOffsets) {\n\t\t\tconst valueReader = reader.sliceFrom(\n\t\t\t\ttableStart + axisValueArrayOffset + offset,\n\t\t\t);\n\t\t\tconst axisValue = parseAxisValue(valueReader);\n\t\t\tif (axisValue) {\n\t\t\t\taxisValues.push(axisValue);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\tdesignAxisCount,\n\t\tdesignAxes,\n\t\taxisValueCount,\n\t\taxisValues,\n\t\telidedFallbackNameID,\n\t};\n}\n\nfunction parseAxisValue(reader: Reader): AxisValue | null {\n\tconst format = reader.uint16();\n\n\tswitch (format) {\n\t\tcase 1: {\n\t\t\treturn {\n\t\t\t\tformat: 1,\n\t\t\t\taxisIndex: reader.uint16(),\n\t\t\t\tflags: reader.uint16(),\n\t\t\t\tvalueNameID: reader.uint16(),\n\t\t\t\tvalue: reader.fixed(),\n\t\t\t};\n\t\t}\n\t\tcase 2: {\n\t\t\treturn {\n\t\t\t\tformat: 2,\n\t\t\t\taxisIndex: reader.uint16(),\n\t\t\t\tflags: reader.uint16(),\n\t\t\t\tvalueNameID: reader.uint16(),\n\t\t\t\tnominalValue: reader.fixed(),\n\t\t\t\trangeMinValue: reader.fixed(),\n\t\t\t\trangeMaxValue: reader.fixed(),\n\t\t\t};\n\t\t}\n\t\tcase 3: {\n\t\t\treturn {\n\t\t\t\tformat: 3,\n\t\t\t\taxisIndex: reader.uint16(),\n\t\t\t\tflags: reader.uint16(),\n\t\t\t\tvalueNameID: reader.uint16(),\n\t\t\t\tvalue: reader.fixed(),\n\t\t\t\tlinkedValue: reader.fixed(),\n\t\t\t};\n\t\t}\n\t\tcase 4: {\n\t\t\tconst axisCount = reader.uint16();\n\t\t\tconst flags = reader.uint16();\n\t\t\tconst valueNameID = reader.uint16();\n\n\t\t\tconst axisValues: { axisIndex: uint16; value: number }[] = [];\n\t\t\tfor (let i = 0; i < axisCount; i++) {\n\t\t\t\taxisValues.push({\n\t\t\t\t\taxisIndex: reader.uint16(),\n\t\t\t\t\tvalue: reader.fixed(),\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tformat: 4,\n\t\t\t\taxisCount,\n\t\t\t\tflags,\n\t\t\t\tvalueNameID,\n\t\t\t\taxisValues,\n\t\t\t};\n\t\t}\n\t\tdefault:\n\t\t\treturn null;\n\t}\n}\n\n/**\n * Get axis record by tag\n */\nexport function getAxisRecord(\n\tstat: StatTable,\n\taxisTag: Tag,\n): AxisRecord | null {\n\treturn stat.designAxes.find((a) => a.axisTag === axisTag) ?? null;\n}\n\n/**\n * Get axis index by tag\n */\nexport function getAxisIndex(stat: StatTable, axisTag: Tag): number {\n\treturn stat.designAxes.findIndex((a) => a.axisTag === axisTag);\n}\n\n/**\n * Get axis values for a specific axis\n */\nexport function getAxisValuesForAxis(\n\tstat: StatTable,\n\taxisIndex: number,\n): AxisValue[] {\n\treturn stat.axisValues.filter((v) => {\n\t\tif (v.format === 4) {\n\t\t\treturn v.axisValues.some((av) => av.axisIndex === axisIndex);\n\t\t}\n\t\treturn v.axisIndex === axisIndex;\n\t});\n}\n\n/**\n * Find axis value by name ID\n */\nexport function findAxisValueByNameId(\n\tstat: StatTable,\n\tnameId: uint16,\n): AxisValue | null {\n\treturn stat.axisValues.find((v) => v.valueNameID === nameId) ?? null;\n}\n\n/**\n * Check if axis value is elidable\n */\nexport function isElidableAxisValue(axisValue: AxisValue): boolean {\n\treturn (axisValue.flags & AxisValueFlags.ElidableAxisValueName) !== 0;\n}\n\n/**\n * Check if axis value represents an older sibling font\n */\nexport function isOlderSiblingFont(axisValue: AxisValue): boolean {\n\treturn (axisValue.flags & AxisValueFlags.OlderSiblingFontAttribute) !== 0;\n}\n\n/**\n * Get the value for a format 1-3 axis value\n */\nexport function getAxisValueNumber(axisValue: AxisValue): number | null {\n\tswitch (axisValue.format) {\n\t\tcase 1:\n\t\tcase 3:\n\t\t\treturn axisValue.value;\n\t\tcase 2:\n\t\t\treturn axisValue.nominalValue;\n\t\tcase 4:\n\t\t\treturn null; // Format 4 has multiple values\n\t}\n}\n\n/**\n * Match axis value to coordinates\n * Returns true if the axis value matches the given coordinates\n */\nexport function matchAxisValue(\n\taxisValue: AxisValue,\n\tcoords: Map<number, number>,\n): boolean {\n\tswitch (axisValue.format) {\n\t\tcase 1:\n\t\tcase 3: {\n\t\t\tconst coord = coords.get(axisValue.axisIndex);\n\t\t\treturn coord !== undefined && coord === axisValue.value;\n\t\t}\n\t\tcase 2: {\n\t\t\tconst coord = coords.get(axisValue.axisIndex);\n\t\t\treturn (\n\t\t\t\tcoord !== undefined &&\n\t\t\t\tcoord >= axisValue.rangeMinValue &&\n\t\t\t\tcoord <= axisValue.rangeMaxValue\n\t\t\t);\n\t\t}\n\t\tcase 4: {\n\t\t\treturn axisValue.axisValues.every((av) => {\n\t\t\t\tconst coord = coords.get(av.axisIndex);\n\t\t\t\treturn coord !== undefined && coord === av.value;\n\t\t\t});\n\t\t}\n\t}\n}\n", "import type { GlyphId, uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * SVG table\n * Contains SVG documents for color glyph rendering\n */\nexport interface SvgTable {\n\tversion: uint16;\n\tdocumentRecords: SvgDocumentRecord[];\n}\n\n/**\n * SVG document record\n * Maps a range of glyphs to an SVG document\n */\nexport interface SvgDocumentRecord {\n\tstartGlyphID: GlyphId;\n\tendGlyphID: GlyphId;\n\tsvgDoc: string;\n}\n\n/**\n * Parse SVG table\n */\nexport function parseSvg(reader: Reader): SvgTable {\n\tconst version = reader.uint16();\n\n\t// SVG Document List offset (from start of SVG table)\n\tconst svgDocumentListOffset = reader.offset32();\n\n\t// Reserved\n\treader.skip(4);\n\n\t// Parse document list\n\tconst listReader = reader.sliceFrom(svgDocumentListOffset);\n\tconst numEntries = listReader.uint16();\n\n\t// Read document index entries\n\tconst entries: {\n\t\tstartGlyphID: uint16;\n\t\tendGlyphID: uint16;\n\t\tsvgDocOffset: uint32;\n\t\tsvgDocLength: uint32;\n\t}[] = [];\n\n\tfor (let i = 0; i < numEntries; i++) {\n\t\tentries.push({\n\t\t\tstartGlyphID: listReader.uint16(),\n\t\t\tendGlyphID: listReader.uint16(),\n\t\t\tsvgDocOffset: listReader.offset32(),\n\t\t\tsvgDocLength: listReader.uint32(),\n\t\t});\n\t}\n\n\t// Parse SVG documents\n\tconst documentRecords: SvgDocumentRecord[] = [];\n\tconst decoder = new TextDecoder(\"utf-8\");\n\n\tfor (const entry of entries) {\n\t\t// SVG doc offset is relative to SVG Document List\n\t\tconst docReader = listReader.sliceFrom(entry.svgDocOffset);\n\t\tconst svgBytes = docReader.bytes(entry.svgDocLength);\n\n\t\t// Decompress if gzipped (starts with 0x1F 0x8B)\n\t\tlet svgDoc: string;\n\t\tif (svgBytes[0] === 0x1f && svgBytes[1] === 0x8b) {\n\t\t\t// Gzipped SVG - need to decompress\n\t\t\ttry {\n\t\t\t\tconst decompressed = decompressGzip(svgBytes);\n\t\t\t\tsvgDoc = decoder.decode(decompressed);\n\t\t\t} catch {\n\t\t\t\t// If decompression fails, try as plain text\n\t\t\t\tsvgDoc = decoder.decode(svgBytes);\n\t\t\t}\n\t\t} else {\n\t\t\tsvgDoc = decoder.decode(svgBytes);\n\t\t}\n\n\t\tdocumentRecords.push({\n\t\t\tstartGlyphID: entry.startGlyphID,\n\t\t\tendGlyphID: entry.endGlyphID,\n\t\t\tsvgDoc,\n\t\t});\n\t}\n\n\treturn { version, documentRecords };\n}\n\n/**\n * Get SVG document for a glyph\n * Returns null if no SVG exists for this glyph\n */\nexport function getSvgDocument(svg: SvgTable, glyphId: GlyphId): string | null {\n\tfor (const record of svg.documentRecords) {\n\t\tif (glyphId >= record.startGlyphID && glyphId <= record.endGlyphID) {\n\t\t\treturn record.svgDoc;\n\t\t}\n\t}\n\treturn null;\n}\n\n/**\n * Check if a glyph has an SVG representation\n */\nexport function hasSvgGlyph(svg: SvgTable, glyphId: GlyphId): boolean {\n\treturn getSvgDocument(svg, glyphId) !== null;\n}\n\n/**\n * Get all glyph IDs that have SVG representations\n */\nexport function getSvgGlyphIds(svg: SvgTable): GlyphId[] {\n\tconst glyphIds: GlyphId[] = [];\n\n\tfor (const record of svg.documentRecords) {\n\t\tfor (let gid = record.startGlyphID; gid <= record.endGlyphID; gid++) {\n\t\t\tglyphIds.push(gid);\n\t\t}\n\t}\n\n\treturn glyphIds;\n}\n\n/**\n * Simple gzip decompression using DecompressionStream (if available)\n * Falls back to returning original data if not supported\n */\nfunction decompressGzip(data: Uint8Array): Uint8Array {\n\t// Use DecompressionStream if available (modern browsers/Bun)\n\tif (typeof DecompressionStream !== \"undefined\") {\n\t\t// This is async in nature, but we need sync.\n\t\t// For now, return original - proper implementation needs async\n\t\t// In practice, most SVG fonts use uncompressed SVG\n\t\treturn data;\n\t}\n\n\t// No decompression available, return as-is\n\treturn data;\n}\n\n/**\n * Async version of gzip decompression\n */\nexport async function decompressSvgDocument(data: Uint8Array): Promise<string> {\n\tconst decoder = new TextDecoder(\"utf-8\");\n\n\t// Check for gzip magic bytes\n\tif (data[0] === 0x1f && data[1] === 0x8b) {\n\t\tif (typeof DecompressionStream !== \"undefined\") {\n\t\t\tconst stream = new DecompressionStream(\"gzip\");\n\t\t\tconst writer = stream.writable.getWriter();\n\t\t\tconst reader = stream.readable.getReader();\n\n\t\t\twriter.write(data as unknown as BufferSource);\n\t\t\twriter.close();\n\n\t\t\tconst chunks: Uint8Array[] = [];\n\t\t\tlet result = await reader.read();\n\t\t\twhile (!result.done) {\n\t\t\t\tchunks.push(result.value);\n\t\t\t\tresult = await reader.read();\n\t\t\t}\n\n\t\t\tconst totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);\n\t\t\tconst decompressed = new Uint8Array(totalLength);\n\t\t\tlet offset = 0;\n\t\t\tfor (const chunk of chunks) {\n\t\t\t\tdecompressed.set(chunk, offset);\n\t\t\t\toffset += chunk.length;\n\t\t\t}\n\n\t\t\treturn decoder.decode(decompressed);\n\t\t}\n\t}\n\n\treturn decoder.decode(data);\n}\n", "import type { int16, uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Tracking table (trak)\n * Apple Advanced Typography tracking\n */\nexport interface TrakTable {\n\tversion: number;\n\tformat: uint16;\n\thorizData: TrackData | null;\n\tvertData: TrackData | null;\n}\n\n/**\n * Track data for one direction\n */\nexport interface TrackData {\n\tnTracks: uint16;\n\tnSizes: uint16;\n\tsizeTableOffset: uint32;\n\ttrackTable: TrackTableEntry[];\n\tsizeTable: number[]; // Fixed point sizes\n}\n\n/**\n * Track table entry\n */\nexport interface TrackTableEntry {\n\ttrack: number; // Fixed 16.16\n\tnameIndex: uint16;\n\toffset: uint16;\n\tperSizeTracking: int16[];\n}\n\n/**\n * Parse trak table\n */\nexport function parseTrak(reader: Reader): TrakTable {\n\tconst version = reader.uint32() / 65536; // Fixed 16.16\n\tconst format = reader.uint16();\n\tconst horizOffset = reader.offset16();\n\tconst vertOffset = reader.offset16();\n\treader.skip(2); // reserved\n\n\tlet horizData: TrackData | null = null;\n\tlet vertData: TrackData | null = null;\n\n\tif (horizOffset !== 0) {\n\t\thorizData = parseTrackData(reader.sliceFrom(horizOffset));\n\t}\n\n\tif (vertOffset !== 0) {\n\t\tvertData = parseTrackData(reader.sliceFrom(vertOffset));\n\t}\n\n\treturn {\n\t\tversion,\n\t\tformat,\n\t\thorizData,\n\t\tvertData,\n\t};\n}\n\nfunction parseTrackData(reader: Reader): TrackData {\n\tconst nTracks = reader.uint16();\n\tconst nSizes = reader.uint16();\n\tconst sizeTableOffset = reader.offset32();\n\n\tconst trackTable: TrackTableEntry[] = [];\n\n\t// Read track entries\n\tfor (let i = 0; i < nTracks; i++) {\n\t\tconst track = reader.int32() / 65536; // Fixed 16.16\n\t\tconst nameIndex = reader.uint16();\n\t\tconst offset = reader.uint16();\n\n\t\ttrackTable.push({\n\t\t\ttrack,\n\t\t\tnameIndex,\n\t\t\toffset,\n\t\t\tperSizeTracking: [],\n\t\t});\n\t}\n\n\t// Read per-size tracking values for each track\n\tfor (const entry of trackTable) {\n\t\tconst trackReader = reader.sliceFrom(entry.offset);\n\t\tentry.perSizeTracking = [];\n\t\tfor (let i = 0; i < nSizes; i++) {\n\t\t\tentry.perSizeTracking.push(trackReader.int16());\n\t\t}\n\t}\n\n\t// Read size table\n\tconst sizeReader = reader.sliceFrom(sizeTableOffset);\n\tconst sizeTable: number[] = [];\n\tfor (let i = 0; i < nSizes; i++) {\n\t\tsizeTable.push(sizeReader.int32() / 65536); // Fixed 16.16\n\t}\n\n\treturn {\n\t\tnTracks,\n\t\tnSizes,\n\t\tsizeTableOffset,\n\t\ttrackTable,\n\t\tsizeTable,\n\t};\n}\n\n/**\n * Get tracking value for a given track and point size\n */\nexport function getTrackingValue(\n\ttrackData: TrackData,\n\ttrack: number,\n\tpointSize: number,\n): number {\n\t// Find the track entry\n\tlet trackEntry: TrackTableEntry | null = null;\n\n\tfor (const entry of trackData.trackTable) {\n\t\tif (entry.track === track) {\n\t\t\ttrackEntry = entry;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// If exact track not found, interpolate between nearest\n\tif (!trackEntry) {\n\t\tlet lower: TrackTableEntry | null = null;\n\t\tlet upper: TrackTableEntry | null = null;\n\n\t\tfor (const entry of trackData.trackTable) {\n\t\t\tif (entry.track <= track && (!lower || entry.track > lower.track)) {\n\t\t\t\tlower = entry;\n\t\t\t}\n\t\t\tif (entry.track >= track && (!upper || entry.track < upper.track)) {\n\t\t\t\tupper = entry;\n\t\t\t}\n\t\t}\n\n\t\tif (lower && upper && lower !== upper) {\n\t\t\t// Interpolate between tracks\n\t\t\tconst t = (track - lower.track) / (upper.track - lower.track);\n\t\t\tconst lowerValue = getSizeValue(trackData, lower, pointSize);\n\t\t\tconst upperValue = getSizeValue(trackData, upper, pointSize);\n\t\t\treturn Math.round(lowerValue + t * (upperValue - lowerValue));\n\t\t} else if (lower) {\n\t\t\ttrackEntry = lower;\n\t\t} else if (upper) {\n\t\t\ttrackEntry = upper;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!trackEntry) return 0;\n\n\treturn getSizeValue(trackData, trackEntry, pointSize);\n}\n\nfunction getSizeValue(\n\ttrackData: TrackData,\n\tentry: TrackTableEntry,\n\tpointSize: number,\n): number {\n\tconst sizes = trackData.sizeTable;\n\tconst values = entry.perSizeTracking;\n\n\tif (sizes.length === 0 || values.length === 0) return 0;\n\n\tconst firstSize = sizes[0];\n\tconst firstValue = values[0];\n\tif (firstSize === undefined || firstValue === undefined) return 0;\n\n\t// Find size range\n\tif (pointSize <= firstSize) {\n\t\treturn firstValue;\n\t}\n\n\tconst lastSize = sizes[sizes.length - 1];\n\tconst lastValue = values[values.length - 1];\n\tif (lastSize === undefined || lastValue === undefined) return 0;\n\n\tif (pointSize >= lastSize) {\n\t\treturn lastValue;\n\t}\n\n\t// Interpolate\n\tfor (let i = 0; i < sizes.length - 1; i++) {\n\t\tconst size1 = sizes[i];\n\t\tconst size2 = sizes[i + 1];\n\t\tconst value1 = values[i];\n\t\tconst value2 = values[i + 1];\n\t\tif (\n\t\t\tsize1 === undefined ||\n\t\t\tsize2 === undefined ||\n\t\t\tvalue1 === undefined ||\n\t\t\tvalue2 === undefined\n\t\t)\n\t\t\tcontinue;\n\n\t\tif (pointSize >= size1 && pointSize <= size2) {\n\t\t\tconst t = (pointSize - size1) / (size2 - size1);\n\t\t\treturn Math.round(value1 + t * (value2 - value1));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * Apply tracking to advance widths\n */\nexport function applyTracking(\n\ttrak: TrakTable,\n\tadvances: number[],\n\tpointSize: number,\n\ttrack: number = 0,\n\tvertical: boolean = false,\n): void {\n\tconst trackData = vertical ? trak.vertData : trak.horizData;\n\tif (!trackData) return;\n\n\tconst trackingValue = getTrackingValue(trackData, track, pointSize);\n\tif (trackingValue === 0) return;\n\n\t// Add tracking to each advance\n\tfor (const [i, advance] of advances.entries()) {\n\t\tadvances[i] = (advance ?? 0) + trackingValue;\n\t}\n}\n", "import type { FWord, int16, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Vertical Header table (vhea)\n * Contains information for vertical layout\n */\nexport interface VheaTable {\n\t/** Table version (1.0 or 1.1) */\n\tversion: { major: number; minor: number };\n\t/** Typographic ascent (vertical) */\n\tascender: FWord;\n\t/** Typographic descent (vertical) */\n\tdescender: FWord;\n\t/** Typographic line gap (vertical) */\n\tlineGap: FWord;\n\t/** Maximum advance height */\n\tadvanceHeightMax: uint16;\n\t/** Minimum top side bearing */\n\tminTopSideBearing: FWord;\n\t/** Minimum bottom side bearing */\n\tminBottomSideBearing: FWord;\n\t/** Maximum y extent (yMax - yMin) */\n\tyMaxExtent: FWord;\n\t/** Caret slope rise (for vertical text) */\n\tcaretSlopeRise: int16;\n\t/** Caret slope run */\n\tcaretSlopeRun: int16;\n\t/** Caret offset */\n\tcaretOffset: int16;\n\t/** Metric data format (0 for current) */\n\tmetricDataFormat: int16;\n\t/** Number of vertical metrics in vmtx */\n\tnumberOfVMetrics: uint16;\n}\n\n/**\n * Parse vhea table\n */\nexport function parseVhea(reader: Reader): VheaTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst ascender = reader.fword();\n\tconst descender = reader.fword();\n\tconst lineGap = reader.fword();\n\tconst advanceHeightMax = reader.uint16();\n\tconst minTopSideBearing = reader.fword();\n\tconst minBottomSideBearing = reader.fword();\n\tconst yMaxExtent = reader.fword();\n\tconst caretSlopeRise = reader.int16();\n\tconst caretSlopeRun = reader.int16();\n\tconst caretOffset = reader.int16();\n\n\t// Skip reserved fields\n\treader.skip(8);\n\n\tconst metricDataFormat = reader.int16();\n\tconst numberOfVMetrics = reader.uint16();\n\n\treturn {\n\t\tversion: { major: majorVersion, minor: minorVersion },\n\t\tascender,\n\t\tdescender,\n\t\tlineGap,\n\t\tadvanceHeightMax,\n\t\tminTopSideBearing,\n\t\tminBottomSideBearing,\n\t\tyMaxExtent,\n\t\tcaretSlopeRise,\n\t\tcaretSlopeRun,\n\t\tcaretOffset,\n\t\tmetricDataFormat,\n\t\tnumberOfVMetrics,\n\t};\n}\n", "import type { GlyphId, int16, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Vertical Metrics table (vmtx)\n * Contains vertical metrics for each glyph\n */\nexport interface VmtxTable {\n\t/** Vertical metrics (advance height + top side bearing) */\n\tvMetrics: VerticalMetric[];\n\t/** Top side bearings for remaining glyphs */\n\ttopSideBearings: int16[];\n}\n\n/**\n * Vertical metric record\n */\nexport interface VerticalMetric {\n\t/** Advance height in font units */\n\tadvanceHeight: uint16;\n\t/** Top side bearing in font units */\n\ttopSideBearing: int16;\n}\n\n/**\n * Parse vmtx table\n * @param reader Binary reader\n * @param numberOfVMetrics From vhea table\n * @param numGlyphs Total number of glyphs\n */\nexport function parseVmtx(\n\treader: Reader,\n\tnumberOfVMetrics: number,\n\tnumGlyphs: number,\n): VmtxTable {\n\tconst vMetrics: VerticalMetric[] = [];\n\n\t// Read full vertical metrics\n\tfor (let i = 0; i < numberOfVMetrics; i++) {\n\t\tvMetrics.push({\n\t\t\tadvanceHeight: reader.uint16(),\n\t\t\ttopSideBearing: reader.int16(),\n\t\t});\n\t}\n\n\t// Read additional top side bearings\n\tconst topSideBearings: int16[] = [];\n\tconst remaining = numGlyphs - numberOfVMetrics;\n\n\tfor (let i = 0; i < remaining; i++) {\n\t\ttopSideBearings.push(reader.int16());\n\t}\n\n\treturn { vMetrics, topSideBearings };\n}\n\n/**\n * Get vertical metrics for a glyph\n */\nexport function getVerticalMetrics(\n\tvmtx: VmtxTable,\n\tglyphId: GlyphId,\n): { advanceHeight: number; topSideBearing: number } {\n\tif (glyphId < vmtx.vMetrics.length) {\n\t\tconst metric = vmtx.vMetrics[glyphId];\n\t\tif (metric) {\n\t\t\treturn {\n\t\t\t\tadvanceHeight: metric.advanceHeight,\n\t\t\t\ttopSideBearing: metric.topSideBearing,\n\t\t\t};\n\t\t}\n\t}\n\n\t// Use last advance height, get TSB from array\n\tconst lastMetric = vmtx.vMetrics[vmtx.vMetrics.length - 1];\n\tconst advanceHeight = lastMetric?.advanceHeight ?? 0;\n\tconst tsbIndex = glyphId - vmtx.vMetrics.length;\n\tconst topSideBearing = vmtx.topSideBearings[tsbIndex] ?? 0;\n\n\treturn { advanceHeight, topSideBearing };\n}\n", "import type { GlyphId, int16, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Vertical Origin table (VORG)\n * Provides y-coordinate of vertical origin for CFF fonts\n * Used for proper vertical text layout in CJK fonts\n */\nexport interface VorgTable {\n\tmajorVersion: uint16;\n\tminorVersion: uint16;\n\tdefaultVertOriginY: int16;\n\tvertOriginYMetrics: VertOriginYMetric[];\n}\n\n/**\n * Vertical origin metric for a specific glyph\n */\nexport interface VertOriginYMetric {\n\tglyphIndex: GlyphId;\n\tvertOriginY: int16;\n}\n\n/**\n * Parse VORG table\n */\nexport function parseVorg(reader: Reader): VorgTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst defaultVertOriginY = reader.int16();\n\tconst numVertOriginYMetrics = reader.uint16();\n\n\tconst vertOriginYMetrics: VertOriginYMetric[] = [];\n\tfor (let i = 0; i < numVertOriginYMetrics; i++) {\n\t\tvertOriginYMetrics.push({\n\t\t\tglyphIndex: reader.uint16(),\n\t\t\tvertOriginY: reader.int16(),\n\t\t});\n\t}\n\n\t// Sort by glyph index for binary search\n\tvertOriginYMetrics.sort((a, b) => a.glyphIndex - b.glyphIndex);\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\tdefaultVertOriginY,\n\t\tvertOriginYMetrics,\n\t};\n}\n\n/**\n * Get vertical origin Y coordinate for a glyph\n * Returns the y-coordinate of the glyph's vertical origin\n */\nexport function getVertOriginY(vorg: VorgTable, glyphId: GlyphId): int16 {\n\t// Binary search for the glyph\n\tconst metrics = vorg.vertOriginYMetrics;\n\tlet lo = 0;\n\tlet hi = metrics.length - 1;\n\n\twhile (lo <= hi) {\n\t\tconst mid = (lo + hi) >>> 1;\n\t\tconst metric = metrics[mid]!;\n\n\t\tif (metric.glyphIndex === glyphId) {\n\t\t\treturn metric.vertOriginY;\n\t\t} else if (metric.glyphIndex < glyphId) {\n\t\t\tlo = mid + 1;\n\t\t} else {\n\t\t\thi = mid - 1;\n\t\t}\n\t}\n\n\t// Not found, use default\n\treturn vorg.defaultVertOriginY;\n}\n\n/**\n * Check if a glyph has a specific vertical origin entry\n */\nexport function hasVertOriginY(vorg: VorgTable, glyphId: GlyphId): boolean {\n\tconst metrics = vorg.vertOriginYMetrics;\n\tlet lo = 0;\n\tlet hi = metrics.length - 1;\n\n\twhile (lo <= hi) {\n\t\tconst mid = (lo + hi) >>> 1;\n\t\tconst metric = metrics[mid]!;\n\n\t\tif (metric.glyphIndex === glyphId) {\n\t\t\treturn true;\n\t\t} else if (metric.glyphIndex < glyphId) {\n\t\t\tlo = mid + 1;\n\t\t} else {\n\t\t\thi = mid - 1;\n\t\t}\n\t}\n\n\treturn false;\n}\n", "import type { GlyphId, uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\nimport {\n\tcalculateRegionScalar,\n\ttype DeltaSetIndexMap,\n\ttype ItemVariationStore,\n\ttype VariationRegion,\n} from \"./hvar.ts\";\n\n/**\n * Vertical Metrics Variations table (VVAR)\n * Provides variations for vertical advance heights and side bearings\n */\nexport interface VvarTable {\n\tmajorVersion: number;\n\tminorVersion: number;\n\titemVariationStore: ItemVariationStore;\n\tadvanceHeightMapping: DeltaSetIndexMap | null;\n\ttsbMapping: DeltaSetIndexMap | null; // Top side bearing\n\tbsbMapping: DeltaSetIndexMap | null; // Bottom side bearing\n\tvOrgMapping: DeltaSetIndexMap | null; // Vertical origin\n}\n\n/**\n * Parse VVAR table\n */\nexport function parseVvar(reader: Reader): VvarTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst itemVariationStoreOffset = reader.offset32();\n\tconst advanceHeightMappingOffset = reader.offset32();\n\tconst tsbMappingOffset = reader.offset32();\n\tconst bsbMappingOffset = reader.offset32();\n\tconst vOrgMappingOffset = reader.offset32();\n\n\t// Parse item variation store\n\tconst itemVariationStore = parseItemVariationStore(\n\t\treader.sliceFrom(itemVariationStoreOffset),\n\t);\n\n\t// Parse mappings\n\tconst advanceHeightMapping =\n\t\tadvanceHeightMappingOffset !== 0\n\t\t\t? parseDeltaSetIndexMap(reader.sliceFrom(advanceHeightMappingOffset))\n\t\t\t: null;\n\n\tconst tsbMapping =\n\t\ttsbMappingOffset !== 0\n\t\t\t? parseDeltaSetIndexMap(reader.sliceFrom(tsbMappingOffset))\n\t\t\t: null;\n\n\tconst bsbMapping =\n\t\tbsbMappingOffset !== 0\n\t\t\t? parseDeltaSetIndexMap(reader.sliceFrom(bsbMappingOffset))\n\t\t\t: null;\n\n\tconst vOrgMapping =\n\t\tvOrgMappingOffset !== 0\n\t\t\t? parseDeltaSetIndexMap(reader.sliceFrom(vOrgMappingOffset))\n\t\t\t: null;\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\titemVariationStore,\n\t\tadvanceHeightMapping,\n\t\ttsbMapping,\n\t\tbsbMapping,\n\t\tvOrgMapping,\n\t};\n}\n\nfunction parseItemVariationStore(reader: Reader): ItemVariationStore {\n\tconst format = reader.uint16();\n\tconst variationRegionListOffset = reader.offset32();\n\tconst itemVariationDataCount = reader.uint16();\n\n\tconst itemVariationDataOffsets: uint32[] = [];\n\tfor (let i = 0; i < itemVariationDataCount; i++) {\n\t\titemVariationDataOffsets.push(reader.offset32());\n\t}\n\n\t// Parse variation regions\n\tconst regionReader = reader.sliceFrom(variationRegionListOffset);\n\tconst axisCount = regionReader.uint16();\n\tconst regionCount = regionReader.uint16();\n\n\tconst variationRegions: VariationRegion[] = [];\n\tfor (let i = 0; i < regionCount; i++) {\n\t\tconst regionAxes: {\n\t\t\tstartCoord: number;\n\t\t\tpeakCoord: number;\n\t\t\tendCoord: number;\n\t\t}[] = [];\n\t\tfor (let j = 0; j < axisCount; j++) {\n\t\t\tregionAxes.push({\n\t\t\t\tstartCoord: regionReader.f2dot14(),\n\t\t\t\tpeakCoord: regionReader.f2dot14(),\n\t\t\t\tendCoord: regionReader.f2dot14(),\n\t\t\t});\n\t\t}\n\t\tvariationRegions.push({ regionAxes });\n\t}\n\n\t// Parse item variation data\n\tconst itemVariationData: {\n\t\titemCount: uint16;\n\t\tregionIndexes: uint16[];\n\t\tdeltaSets: number[][];\n\t}[] = [];\n\tfor (const offset of itemVariationDataOffsets) {\n\t\tconst dataReader = reader.sliceFrom(offset);\n\t\tconst itemCount = dataReader.uint16();\n\t\tconst wordDeltaCount = dataReader.uint16();\n\t\tconst regionIndexCount = dataReader.uint16();\n\n\t\tconst regionIndexes: uint16[] = [];\n\t\tfor (let i = 0; i < regionIndexCount; i++) {\n\t\t\tregionIndexes.push(dataReader.uint16());\n\t\t}\n\n\t\t// Parse delta sets\n\t\tconst longWords = (wordDeltaCount & 0x8000) !== 0;\n\t\tconst wordCount = wordDeltaCount & 0x7fff;\n\t\tconst shortCount = regionIndexCount - wordCount;\n\n\t\tconst deltaSets: number[][] = [];\n\t\tfor (let i = 0; i < itemCount; i++) {\n\t\t\tconst deltas: number[] = [];\n\t\t\t// Read word-sized deltas\n\t\t\tfor (let j = 0; j < wordCount; j++) {\n\t\t\t\tif (longWords) {\n\t\t\t\t\tdeltas.push(dataReader.int32());\n\t\t\t\t} else {\n\t\t\t\t\tdeltas.push(dataReader.int16());\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Read short-sized deltas\n\t\t\tfor (let j = 0; j < shortCount; j++) {\n\t\t\t\tif (longWords) {\n\t\t\t\t\tdeltas.push(dataReader.int16());\n\t\t\t\t} else {\n\t\t\t\t\tdeltas.push(dataReader.int8());\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeltaSets.push(deltas);\n\t\t}\n\n\t\titemVariationData.push({ itemCount, regionIndexes, deltaSets });\n\t}\n\n\treturn { format, variationRegions, itemVariationData };\n}\n\nfunction parseDeltaSetIndexMap(reader: Reader): DeltaSetIndexMap {\n\tconst format = reader.uint8();\n\tconst entryFormat = reader.uint8();\n\tconst mapCount = format === 0 ? reader.uint16() : reader.uint32();\n\n\tconst innerIndexBitCount = (entryFormat & 0x0f) + 1;\n\tconst mapEntrySize = ((entryFormat >> 4) & 0x03) + 1;\n\n\tconst mapData: { outer: number; inner: number }[] = [];\n\tfor (let i = 0; i < mapCount; i++) {\n\t\tlet entry = 0;\n\t\tfor (let j = 0; j < mapEntrySize; j++) {\n\t\t\tentry = (entry << 8) | reader.uint8();\n\t\t}\n\n\t\tconst inner = entry & ((1 << innerIndexBitCount) - 1);\n\t\tconst outer = entry >> innerIndexBitCount;\n\t\tmapData.push({ outer, inner });\n\t}\n\n\treturn { format, mapCount, entryFormat, innerIndexBitCount, mapData };\n}\n\n/**\n * Get advance height delta for a glyph at given variation coordinates\n */\nexport function getAdvanceHeightDelta(\n\tvvar: VvarTable,\n\tglyphId: GlyphId,\n\tcoords: number[],\n): number {\n\tconst mapping = vvar.advanceHeightMapping;\n\n\t// Get outer/inner index\n\tlet outer: number;\n\tlet inner: number;\n\n\tif (mapping && glyphId < mapping.mapData.length) {\n\t\tconst entry = mapping.mapData[glyphId];\n\t\tif (!entry) {\n\t\t\treturn 0;\n\t\t}\n\t\touter = entry.outer;\n\t\tinner = entry.inner;\n\t} else {\n\t\t// Direct mapping: outer = 0, inner = glyphId\n\t\touter = 0;\n\t\tinner = glyphId;\n\t}\n\n\treturn calculateDelta(vvar.itemVariationStore, outer, inner, coords);\n}\n\n/**\n * Get top side bearing delta for a glyph at given variation coordinates\n */\nexport function getTsbDelta(\n\tvvar: VvarTable,\n\tglyphId: GlyphId,\n\tcoords: number[],\n): number {\n\tconst mapping = vvar.tsbMapping;\n\tif (!mapping) return 0;\n\n\tif (glyphId >= mapping.mapData.length) return 0;\n\n\tconst entry = mapping.mapData[glyphId];\n\tif (!entry) return 0;\n\n\treturn calculateDelta(\n\t\tvvar.itemVariationStore,\n\t\tentry.outer,\n\t\tentry.inner,\n\t\tcoords,\n\t);\n}\n\n/**\n * Get bottom side bearing delta for a glyph at given variation coordinates\n */\nexport function getBsbDelta(\n\tvvar: VvarTable,\n\tglyphId: GlyphId,\n\tcoords: number[],\n): number {\n\tconst mapping = vvar.bsbMapping;\n\tif (!mapping) return 0;\n\n\tif (glyphId >= mapping.mapData.length) return 0;\n\n\tconst entry = mapping.mapData[glyphId];\n\tif (!entry) return 0;\n\n\treturn calculateDelta(\n\t\tvvar.itemVariationStore,\n\t\tentry.outer,\n\t\tentry.inner,\n\t\tcoords,\n\t);\n}\n\n/**\n * Get vertical origin delta for a glyph at given variation coordinates\n */\nexport function getVorgDelta(\n\tvvar: VvarTable,\n\tglyphId: GlyphId,\n\tcoords: number[],\n): number {\n\tconst mapping = vvar.vOrgMapping;\n\tif (!mapping) return 0;\n\n\tif (glyphId >= mapping.mapData.length) return 0;\n\n\tconst entry = mapping.mapData[glyphId];\n\tif (!entry) return 0;\n\n\treturn calculateDelta(\n\t\tvvar.itemVariationStore,\n\t\tentry.outer,\n\t\tentry.inner,\n\t\tcoords,\n\t);\n}\n\n/**\n * Calculate delta from variation store\n */\nfunction calculateDelta(\n\tstore: ItemVariationStore,\n\touter: number,\n\tinner: number,\n\tcoords: number[],\n): number {\n\tconst varData = store.itemVariationData[outer];\n\tif (!varData || inner >= varData.itemCount) {\n\t\treturn 0;\n\t}\n\n\tconst deltaSet = varData.deltaSets[inner];\n\tif (!deltaSet) {\n\t\treturn 0;\n\t}\n\n\t// Calculate total delta\n\tlet delta = 0;\n\tfor (const [i, regionIndex] of varData.regionIndexes.entries()) {\n\t\tconst region = store.variationRegions[regionIndex];\n\t\tif (!region) continue;\n\n\t\tconst scalar = calculateRegionScalar(region, coords);\n\t\tconst regionDelta = deltaSet[i] ?? 0;\n\t\tdelta += scalar * regionDelta;\n\t}\n\n\treturn Math.round(delta);\n}\n", "import type { Reader } from \"../binary/reader.ts\";\n\n/**\n * fpgm table - Font program\n * Contains TrueType instructions to be executed once when the font is loaded\n */\nexport interface FpgmTable {\n\t/** Raw bytecode instructions */\n\tinstructions: Uint8Array;\n}\n\n/**\n * prep table - CVT program (Control Value Program)\n * Contains TrueType instructions executed whenever the font size or transformation changes\n */\nexport interface PrepTable {\n\t/** Raw bytecode instructions */\n\tinstructions: Uint8Array;\n}\n\n/**\n * cvt table - Control Value Table\n * Contains values referenced by TrueType instructions for consistent spacing/positioning\n * Values are in FUnits (font design units)\n */\nexport interface CvtTable {\n\t/** Control values (FWORD, i.e., int16 in font units) */\n\tvalues: Int16Array;\n}\n\n/**\n * Parse fpgm table\n */\nexport function parseFpgm(reader: Reader): FpgmTable {\n\tconst instructions = reader.bytes(reader.remaining);\n\treturn { instructions };\n}\n\n/**\n * Parse prep table\n */\nexport function parsePrep(reader: Reader): PrepTable {\n\tconst instructions = reader.bytes(reader.remaining);\n\treturn { instructions };\n}\n\n/**\n * Parse cvt table\n */\nexport function parseCvt(reader: Reader): CvtTable {\n\tconst count = Math.floor(reader.remaining / 2);\n\tconst values = new Int16Array(count);\n\tfor (let i = 0; i < count; i++) {\n\t\tvalues[i] = reader.int16();\n\t}\n\treturn { values };\n}\n", "/**\n * gasp table - Grid-fitting And Scan-conversion Procedure\n *\n * This table controls when grid-fitting (hinting) and anti-aliasing\n * should be applied based on the rendering size (ppem).\n */\n\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Gasp behavior flags\n */\nexport const GaspFlag = {\n\t/** Use grid-fitting (hinting) */\n\tGridFit: 0x0001,\n\t/** Use gray-scale rendering (anti-aliasing) */\n\tDoGray: 0x0002,\n\t/** Use symmetric grid-fitting (ClearType) */\n\tSymmetricGridFit: 0x0004,\n\t/** Use symmetric smoothing (ClearType) */\n\tSymmetricSmoothing: 0x0008,\n} as const;\n\n/**\n * A ppem range with associated behavior\n */\nexport interface GaspRange {\n\t/** Maximum ppem for this range (inclusive) */\n\tmaxPPEM: number;\n\t/** Behavior flags for this range */\n\tbehavior: number;\n}\n\n/**\n * gasp table\n */\nexport interface GaspTable {\n\t/** Version (0 or 1) */\n\tversion: number;\n\t/** Ranges sorted by maxPPEM */\n\tranges: GaspRange[];\n}\n\n/**\n * Parse gasp table\n */\nexport function parseGasp(reader: Reader): GaspTable {\n\tconst version = reader.uint16();\n\tconst numRanges = reader.uint16();\n\n\tconst ranges: GaspRange[] = [];\n\tfor (let i = 0; i < numRanges; i++) {\n\t\tconst maxPPEM = reader.uint16();\n\t\tconst behavior = reader.uint16();\n\t\tranges.push({ maxPPEM, behavior });\n\t}\n\n\t// Ranges should be sorted by maxPPEM\n\tranges.sort((a, b) => a.maxPPEM - b.maxPPEM);\n\n\treturn { version, ranges };\n}\n\n/**\n * Get behavior flags for a specific ppem\n */\nexport function getGaspBehavior(gasp: GaspTable, ppem: number): number {\n\tfor (const range of gasp.ranges) {\n\t\tif (ppem <= range.maxPPEM) {\n\t\t\treturn range.behavior;\n\t\t}\n\t}\n\n\t// Above all ranges - use last range or default to all features\n\tif (gasp.ranges.length > 0) {\n\t\treturn gasp.ranges[gasp.ranges.length - 1]!.behavior;\n\t}\n\n\treturn GaspFlag.GridFit | GaspFlag.DoGray;\n}\n\n/**\n * Check if grid-fitting should be used\n */\nexport function shouldGridFit(gasp: GaspTable, ppem: number): boolean {\n\treturn (getGaspBehavior(gasp, ppem) & GaspFlag.GridFit) !== 0;\n}\n\n/**\n * Check if gray-scale rendering should be used\n */\nexport function shouldDoGray(gasp: GaspTable, ppem: number): boolean {\n\treturn (getGaspBehavior(gasp, ppem) & GaspFlag.DoGray) !== 0;\n}\n", "import type { GlyphId, TableRecord, Tag } from \"../types.ts\";\nimport { Tags, tagToString } from \"../types.ts\";\nimport { Reader } from \"./binary/reader.ts\";\nimport { woff2ToSfnt } from \"./woff2.ts\";\n\n// WOFF/WOFF2 magic numbers\nconst WOFF_MAGIC = 0x774f4646; // 'wOFF'\nconst WOFF2_MAGIC = 0x774f4632; // 'wOF2'\n\n/** Check if buffer is WOFF2 format */\nfunction isWoff2(buffer: ArrayBuffer): boolean {\n\tconst view = new DataView(buffer);\n\treturn view.getUint32(0, false) === WOFF2_MAGIC;\n}\n\n/** Check if buffer is WOFF format */\nfunction isWoff(buffer: ArrayBuffer): boolean {\n\tconst view = new DataView(buffer);\n\treturn view.getUint32(0, false) === WOFF_MAGIC;\n}\nimport { type AvarTable, parseAvar } from \"./tables/avar.ts\";\nimport { type BaseTable, parseBase } from \"./tables/base.ts\";\nimport {\n\ttype CbdtTable,\n\ttype CblcTable,\n\tparseCbdt,\n\tparseCblc,\n} from \"./tables/cbdt.ts\";\nimport { type CffTable, parseCff } from \"./tables/cff.ts\";\nimport { type Cff2Table, parseCff2 } from \"./tables/cff2.ts\";\nimport { type CmapTable, getGlyphId, parseCmap } from \"./tables/cmap.ts\";\nimport { type ColrTable, parseColr } from \"./tables/colr.ts\";\nimport { type CpalTable, parseCpal } from \"./tables/cpal.ts\";\nimport { type FvarTable, parseFvar } from \"./tables/fvar.ts\";\nimport { type GdefTable, parseGdef } from \"./tables/gdef.ts\";\nimport {\n\ttype Contour,\n\ttype GlyfTable,\n\ttype Glyph,\n\tgetGlyphBounds,\n\tgetGlyphContours,\n\tgetGlyphContoursWithVariation,\n\tparseGlyf,\n\tparseGlyph,\n} from \"./tables/glyf.ts\";\nimport {\n\texecuteCffCharString,\n\texecuteCff2CharString,\n} from \"./tables/cff-charstring.ts\";\nimport { type GposTable, parseGpos } from \"./tables/gpos.ts\";\nimport { type GsubTable, parseGsub } from \"./tables/gsub.ts\";\nimport { type GvarTable, parseGvar } from \"./tables/gvar.ts\";\nimport { type HeadTable, parseHead } from \"./tables/head.ts\";\nimport { type HheaTable, parseHhea } from \"./tables/hhea.ts\";\nimport {\n\tgetAdvanceWidth,\n\tgetLeftSideBearing,\n\ttype HmtxTable,\n\tparseHmtx,\n} from \"./tables/hmtx.ts\";\nimport { type HvarTable, parseHvar } from \"./tables/hvar.ts\";\nimport { type JstfTable, parseJstf } from \"./tables/jstf.ts\";\nimport { type KernTable, parseKern } from \"./tables/kern.ts\";\nimport { type KerxTable, parseKerx } from \"./tables/kerx.ts\";\nimport { type LocaTable, parseLoca } from \"./tables/loca.ts\";\nimport { type MathTable, parseMath } from \"./tables/math.ts\";\nimport { type MaxpTable, parseMaxp } from \"./tables/maxp.ts\";\nimport { type MorxTable, parseMorx } from \"./tables/morx.ts\";\nimport { type MvarTable, parseMvar } from \"./tables/mvar.ts\";\nimport { type NameTable, parseName } from \"./tables/name.ts\";\nimport { type Os2Table, parseOs2 } from \"./tables/os2.ts\";\nimport { type PostTable, parsePost } from \"./tables/post.ts\";\nimport { parseSbix, type SbixTable } from \"./tables/sbix.ts\";\nimport {\n\ttype FontDirectory,\n\tisTrueType,\n\tparseFontDirectory,\n} from \"./tables/sfnt.ts\";\nimport { parseFeat, type FeatTable } from \"./tables/feat.ts\";\nimport { parseStat, type StatTable } from \"./tables/stat.ts\";\nimport { parseSvg, type SvgTable } from \"./tables/svg.ts\";\nimport { parseTrak, type TrakTable } from \"./tables/trak.ts\";\nimport { parseVhea, type VheaTable } from \"./tables/vhea.ts\";\nimport { parseVmtx, type VmtxTable } from \"./tables/vmtx.ts\";\nimport { parseVorg, type VorgTable } from \"./tables/vorg.ts\";\nimport { parseVvar, type VvarTable } from \"./tables/vvar.ts\";\nimport {\n\tparseFpgm,\n\tparsePrep,\n\tparseCvt,\n\ttype FpgmTable,\n\ttype PrepTable,\n\ttype CvtTable,\n} from \"./tables/hinting.ts\";\nimport { parseGasp, type GaspTable } from \"./tables/gasp.ts\";\n\n/** Font loading options */\nexport interface FontLoadOptions {\n\t/** Tables to parse eagerly (default: lazy) */\n\teagerTables?: Tag[];\n}\n\n/**\n * Represents a loaded font file.\n * Tables are parsed lazily on first access.\n */\nexport class Font {\n\tprivate readonly reader: Reader;\n\tprivate readonly directory: FontDirectory;\n\n\t// Lazy-loaded tables\n\tprivate _head: HeadTable | null = null;\n\tprivate _maxp: MaxpTable | null = null;\n\tprivate _hhea: HheaTable | null = null;\n\tprivate _hmtx: HmtxTable | null = null;\n\tprivate _cmap: CmapTable | null = null;\n\tprivate _gdef: GdefTable | null | undefined = undefined;\n\tprivate _gsub: GsubTable | null | undefined = undefined;\n\tprivate _gpos: GposTable | null | undefined = undefined;\n\tprivate _kern: KernTable | null | undefined = undefined;\n\tprivate _fvar: FvarTable | null | undefined = undefined;\n\tprivate _hvar: HvarTable | null | undefined = undefined;\n\tprivate _vhea: VheaTable | null | undefined = undefined;\n\tprivate _vmtx: VmtxTable | null | undefined = undefined;\n\tprivate _morx: MorxTable | null | undefined = undefined;\n\tprivate _gvar: GvarTable | null | undefined = undefined;\n\tprivate _avar: AvarTable | null | undefined = undefined;\n\tprivate _kerx: KerxTable | null | undefined = undefined;\n\tprivate _trak: TrakTable | null | undefined = undefined;\n\tprivate _cff: CffTable | null | undefined = undefined;\n\tprivate _cff2: Cff2Table | null | undefined = undefined;\n\tprivate _colr: ColrTable | null | undefined = undefined;\n\tprivate _cpal: CpalTable | null | undefined = undefined;\n\tprivate _vvar: VvarTable | null | undefined = undefined;\n\tprivate _mvar: MvarTable | null | undefined = undefined;\n\tprivate _os2: Os2Table | null | undefined = undefined;\n\tprivate _name: NameTable | null | undefined = undefined;\n\tprivate _post: PostTable | null | undefined = undefined;\n\tprivate _base: BaseTable | null | undefined = undefined;\n\tprivate _jstf: JstfTable | null | undefined = undefined;\n\tprivate _math: MathTable | null | undefined = undefined;\n\tprivate _loca: LocaTable | null | undefined = undefined;\n\tprivate _glyf: GlyfTable | null | undefined = undefined;\n\tprivate _svg: SvgTable | null | undefined = undefined;\n\tprivate _vorg: VorgTable | null | undefined = undefined;\n\tprivate _sbix: SbixTable | null | undefined = undefined;\n\tprivate _stat: StatTable | null | undefined = undefined;\n\tprivate _cbdt: CbdtTable | null | undefined = undefined;\n\tprivate _cblc: CblcTable | null | undefined = undefined;\n\tprivate _feat: FeatTable | null | undefined = undefined;\n\tprivate _fpgm: FpgmTable | null | undefined = undefined;\n\tprivate _prep: PrepTable | null | undefined = undefined;\n\tprivate _cvt: CvtTable | null | undefined = undefined;\n\tprivate _gasp: GaspTable | null | undefined = undefined;\n\n\tprivate constructor(buffer: ArrayBuffer, _options: FontLoadOptions = {}) {\n\t\tthis.reader = new Reader(buffer);\n\t\tthis.directory = parseFontDirectory(this.reader);\n\t}\n\n\t/** Load font from ArrayBuffer (sync - does not support WOFF2) */\n\tstatic load(buffer: ArrayBuffer, options?: FontLoadOptions): Font {\n\t\tif (isWoff2(buffer)) {\n\t\t\tthrow new Error(\"WOFF2 requires async loading. Use Font.loadAsync() instead.\");\n\t\t}\n\t\tif (isWoff(buffer)) {\n\t\t\tthrow new Error(\"WOFF format is not supported. Please use TTF, OTF, or WOFF2.\");\n\t\t}\n\t\treturn new Font(buffer, options);\n\t}\n\n\t/** Load font from ArrayBuffer with WOFF2 support (async) */\n\tstatic async loadAsync(buffer: ArrayBuffer, options?: FontLoadOptions): Promise<Font> {\n\t\tif (isWoff2(buffer)) {\n\t\t\tbuffer = await woff2ToSfnt(buffer);\n\t\t} else if (isWoff(buffer)) {\n\t\t\tthrow new Error(\"WOFF format is not supported. Please use TTF, OTF, or WOFF2.\");\n\t\t}\n\t\treturn new Font(buffer, options);\n\t}\n\n\t/** Load font from URL (works in browser and Bun, supports WOFF2) */\n\tstatic async fromURL(url: string, options?: FontLoadOptions): Promise<Font> {\n\t\tconst response = await fetch(url);\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(\n\t\t\t\t`Failed to fetch font: ${response.status} ${response.statusText}`,\n\t\t\t);\n\t\t}\n\t\tconst buffer = await response.arrayBuffer();\n\t\treturn Font.loadAsync(buffer, options);\n\t}\n\n\t/** Load font from file path (Bun only, supports WOFF2) */\n\tstatic async fromFile(\n\t\tpath: string,\n\t\toptions?: FontLoadOptions,\n\t): Promise<Font> {\n\t\tconst file = Bun.file(path);\n\t\tconst buffer = await file.arrayBuffer();\n\t\treturn Font.loadAsync(buffer, options);\n\t}\n\n\t// Table accessors\n\n\t/** Check if font has a specific table */\n\thasTable(tag: Tag): boolean {\n\t\treturn this.directory.tables.has(tag);\n\t}\n\n\t/** Get table record */\n\tgetTableRecord(tag: Tag): TableRecord | undefined {\n\t\treturn this.directory.tables.get(tag);\n\t}\n\n\t/** Get reader for a table */\n\tgetTableReader(tag: Tag): Reader | null {\n\t\tconst record = this.directory.tables.get(tag);\n\t\tif (!record) return null;\n\t\treturn this.reader.slice(record.offset, record.length);\n\t}\n\n\t// Required tables (lazy-loaded)\n\n\tget head(): HeadTable {\n\t\tif (!this._head) {\n\t\t\tconst reader = this.getTableReader(Tags.head);\n\t\t\tif (!reader) throw new Error(\"Missing required 'head' table\");\n\t\t\tthis._head = parseHead(reader);\n\t\t}\n\t\treturn this._head;\n\t}\n\n\tget maxp(): MaxpTable {\n\t\tif (!this._maxp) {\n\t\t\tconst reader = this.getTableReader(Tags.maxp);\n\t\t\tif (!reader) throw new Error(\"Missing required 'maxp' table\");\n\t\t\tthis._maxp = parseMaxp(reader);\n\t\t}\n\t\treturn this._maxp;\n\t}\n\n\tget hhea(): HheaTable {\n\t\tif (!this._hhea) {\n\t\t\tconst reader = this.getTableReader(Tags.hhea);\n\t\t\tif (!reader) throw new Error(\"Missing required 'hhea' table\");\n\t\t\tthis._hhea = parseHhea(reader);\n\t\t}\n\t\treturn this._hhea;\n\t}\n\n\tget hmtx(): HmtxTable {\n\t\tif (!this._hmtx) {\n\t\t\tconst reader = this.getTableReader(Tags.hmtx);\n\t\t\tif (!reader) throw new Error(\"Missing required 'hmtx' table\");\n\t\t\tthis._hmtx = parseHmtx(\n\t\t\t\treader,\n\t\t\t\tthis.hhea.numberOfHMetrics,\n\t\t\t\tthis.numGlyphs,\n\t\t\t);\n\t\t}\n\t\treturn this._hmtx;\n\t}\n\n\tget cmap(): CmapTable {\n\t\tif (!this._cmap) {\n\t\t\tconst record = this.getTableRecord(Tags.cmap);\n\t\t\tconst reader = this.getTableReader(Tags.cmap);\n\t\t\tif (!reader || !record) throw new Error(\"Missing required 'cmap' table\");\n\t\t\tthis._cmap = parseCmap(reader, record.length);\n\t\t}\n\t\treturn this._cmap;\n\t}\n\n\tget gdef(): GdefTable | null {\n\t\tif (this._gdef === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.GDEF);\n\t\t\tthis._gdef = reader ? parseGdef(reader) : null;\n\t\t}\n\t\treturn this._gdef;\n\t}\n\n\tget gsub(): GsubTable | null {\n\t\tif (this._gsub === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.GSUB);\n\t\t\tthis._gsub = reader ? parseGsub(reader) : null;\n\t\t}\n\t\treturn this._gsub;\n\t}\n\n\tget gpos(): GposTable | null {\n\t\tif (this._gpos === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.GPOS);\n\t\t\tthis._gpos = reader ? parseGpos(reader) : null;\n\t\t}\n\t\treturn this._gpos;\n\t}\n\n\tget kern(): KernTable | null {\n\t\tif (this._kern === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.kern);\n\t\t\tthis._kern = reader ? parseKern(reader) : null;\n\t\t}\n\t\treturn this._kern;\n\t}\n\n\tget fvar(): FvarTable | null {\n\t\tif (this._fvar === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.fvar);\n\t\t\tthis._fvar = reader ? parseFvar(reader) : null;\n\t\t}\n\t\treturn this._fvar;\n\t}\n\n\tget hvar(): HvarTable | null {\n\t\tif (this._hvar === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.HVAR);\n\t\t\tthis._hvar = reader ? parseHvar(reader) : null;\n\t\t}\n\t\treturn this._hvar;\n\t}\n\n\tget vhea(): VheaTable | null {\n\t\tif (this._vhea === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.vhea);\n\t\t\tthis._vhea = reader ? parseVhea(reader) : null;\n\t\t}\n\t\treturn this._vhea;\n\t}\n\n\tget vmtx(): VmtxTable | null {\n\t\tif (this._vmtx === undefined) {\n\t\t\tconst vhea = this.vhea;\n\t\t\tif (!vhea) {\n\t\t\t\tthis._vmtx = null;\n\t\t\t} else {\n\t\t\t\tconst reader = this.getTableReader(Tags.vmtx);\n\t\t\t\tthis._vmtx = reader\n\t\t\t\t\t? parseVmtx(reader, vhea.numberOfVMetrics, this.numGlyphs)\n\t\t\t\t\t: null;\n\t\t\t}\n\t\t}\n\t\treturn this._vmtx;\n\t}\n\n\tget morx(): MorxTable | null {\n\t\tif (this._morx === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.morx);\n\t\t\tthis._morx = reader ? parseMorx(reader) : null;\n\t\t}\n\t\treturn this._morx;\n\t}\n\n\tget gvar(): GvarTable | null {\n\t\tif (this._gvar === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.gvar);\n\t\t\tthis._gvar = reader ? parseGvar(reader, this.numGlyphs) : null;\n\t\t}\n\t\treturn this._gvar;\n\t}\n\n\tget avar(): AvarTable | null {\n\t\tif (this._avar === undefined) {\n\t\t\tconst fvar = this.fvar;\n\t\t\tif (!fvar) {\n\t\t\t\tthis._avar = null;\n\t\t\t} else {\n\t\t\t\tconst reader = this.getTableReader(Tags.avar);\n\t\t\t\tthis._avar = reader ? parseAvar(reader, fvar.axes.length) : null;\n\t\t\t}\n\t\t}\n\t\treturn this._avar;\n\t}\n\n\tget kerx(): KerxTable | null {\n\t\tif (this._kerx === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.kerx);\n\t\t\tthis._kerx = reader ? parseKerx(reader) : null;\n\t\t}\n\t\treturn this._kerx;\n\t}\n\n\tget trak(): TrakTable | null {\n\t\tif (this._trak === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.trak);\n\t\t\tthis._trak = reader ? parseTrak(reader) : null;\n\t\t}\n\t\treturn this._trak;\n\t}\n\n\tget cff(): CffTable | null {\n\t\tif (this._cff === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.CFF);\n\t\t\tthis._cff = reader ? parseCff(reader) : null;\n\t\t}\n\t\treturn this._cff;\n\t}\n\n\tget cff2(): Cff2Table | null {\n\t\tif (this._cff2 === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.CFF2);\n\t\t\tthis._cff2 = reader ? parseCff2(reader) : null;\n\t\t}\n\t\treturn this._cff2;\n\t}\n\n\tget colr(): ColrTable | null {\n\t\tif (this._colr === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.COLR);\n\t\t\tthis._colr = reader ? parseColr(reader) : null;\n\t\t}\n\t\treturn this._colr;\n\t}\n\n\tget cpal(): CpalTable | null {\n\t\tif (this._cpal === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.CPAL);\n\t\t\tthis._cpal = reader ? parseCpal(reader) : null;\n\t\t}\n\t\treturn this._cpal;\n\t}\n\n\tget vvar(): VvarTable | null {\n\t\tif (this._vvar === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.VVAR);\n\t\t\tthis._vvar = reader ? parseVvar(reader) : null;\n\t\t}\n\t\treturn this._vvar;\n\t}\n\n\tget mvar(): MvarTable | null {\n\t\tif (this._mvar === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.MVAR);\n\t\t\tthis._mvar = reader ? parseMvar(reader) : null;\n\t\t}\n\t\treturn this._mvar;\n\t}\n\n\tget os2(): Os2Table | null {\n\t\tif (this._os2 === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.OS2);\n\t\t\tthis._os2 = reader ? parseOs2(reader) : null;\n\t\t}\n\t\treturn this._os2;\n\t}\n\n\tget name(): NameTable | null {\n\t\tif (this._name === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.name);\n\t\t\tthis._name = reader ? parseName(reader) : null;\n\t\t}\n\t\treturn this._name;\n\t}\n\n\tget post(): PostTable | null {\n\t\tif (this._post === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.post);\n\t\t\tthis._post = reader ? parsePost(reader) : null;\n\t\t}\n\t\treturn this._post;\n\t}\n\n\tget base(): BaseTable | null {\n\t\tif (this._base === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.BASE);\n\t\t\tthis._base = reader ? parseBase(reader) : null;\n\t\t}\n\t\treturn this._base;\n\t}\n\n\tget jstf(): JstfTable | null {\n\t\tif (this._jstf === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.JSTF);\n\t\t\tthis._jstf = reader ? parseJstf(reader) : null;\n\t\t}\n\t\treturn this._jstf;\n\t}\n\n\tget math(): MathTable | null {\n\t\tif (this._math === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.MATH);\n\t\t\tthis._math = reader ? parseMath(reader) : null;\n\t\t}\n\t\treturn this._math;\n\t}\n\n\tget loca(): LocaTable | null {\n\t\tif (this._loca === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.loca);\n\t\t\tthis._loca = reader\n\t\t\t\t? parseLoca(reader, this.numGlyphs, this.head.indexToLocFormat)\n\t\t\t\t: null;\n\t\t}\n\t\treturn this._loca;\n\t}\n\n\tget glyf(): GlyfTable | null {\n\t\tif (this._glyf === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.glyf);\n\t\t\tthis._glyf = reader ? parseGlyf(reader) : null;\n\t\t}\n\t\treturn this._glyf;\n\t}\n\n\tget svg(): SvgTable | null {\n\t\tif (this._svg === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.SVG);\n\t\t\tthis._svg = reader ? parseSvg(reader) : null;\n\t\t}\n\t\treturn this._svg;\n\t}\n\n\tget vorg(): VorgTable | null {\n\t\tif (this._vorg === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.VORG);\n\t\t\tthis._vorg = reader ? parseVorg(reader) : null;\n\t\t}\n\t\treturn this._vorg;\n\t}\n\n\tget sbix(): SbixTable | null {\n\t\tif (this._sbix === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.sbix);\n\t\t\tthis._sbix = reader ? parseSbix(reader, this.numGlyphs) : null;\n\t\t}\n\t\treturn this._sbix;\n\t}\n\n\tget stat(): StatTable | null {\n\t\tif (this._stat === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.STAT);\n\t\t\tthis._stat = reader ? parseStat(reader) : null;\n\t\t}\n\t\treturn this._stat;\n\t}\n\n\tget cblc(): CblcTable | null {\n\t\tif (this._cblc === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.CBLC);\n\t\t\tthis._cblc = reader ? parseCblc(reader) : null;\n\t\t}\n\t\treturn this._cblc;\n\t}\n\n\tget cbdt(): CbdtTable | null {\n\t\tif (this._cbdt === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.CBDT);\n\t\t\tthis._cbdt = reader ? parseCbdt(reader) : null;\n\t\t}\n\t\treturn this._cbdt;\n\t}\n\n\tget feat(): FeatTable | null {\n\t\tif (this._feat === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.feat);\n\t\t\tthis._feat = reader ? parseFeat(reader) : null;\n\t\t}\n\t\treturn this._feat;\n\t}\n\n\tget fpgm(): FpgmTable | null {\n\t\tif (this._fpgm === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.fpgm);\n\t\t\tthis._fpgm = reader ? parseFpgm(reader) : null;\n\t\t}\n\t\treturn this._fpgm;\n\t}\n\n\tget prep(): PrepTable | null {\n\t\tif (this._prep === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.prep);\n\t\t\tthis._prep = reader ? parsePrep(reader) : null;\n\t\t}\n\t\treturn this._prep;\n\t}\n\n\tget cvtTable(): CvtTable | null {\n\t\tif (this._cvt === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.cvt);\n\t\t\tthis._cvt = reader ? parseCvt(reader) : null;\n\t\t}\n\t\treturn this._cvt;\n\t}\n\n\tget gasp(): GaspTable | null {\n\t\tif (this._gasp === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.gasp);\n\t\t\tthis._gasp = reader ? parseGasp(reader) : null;\n\t\t}\n\t\treturn this._gasp;\n\t}\n\n\t// Convenience properties\n\n\t/** Number of glyphs in the font */\n\tget numGlyphs(): number {\n\t\treturn this.maxp.numGlyphs;\n\t}\n\n\t/** Units per em */\n\tget unitsPerEm(): number {\n\t\treturn this.head.unitsPerEm;\n\t}\n\n\t/** Ascender (from hhea) */\n\tget ascender(): number {\n\t\treturn this.hhea.ascender;\n\t}\n\n\t/** Descender (from hhea) */\n\tget descender(): number {\n\t\treturn this.hhea.descender;\n\t}\n\n\t/** Line gap (from hhea) */\n\tget lineGap(): number {\n\t\treturn this.hhea.lineGap;\n\t}\n\n\t/** Is this a TrueType font (vs CFF)? */\n\tget isTrueType(): boolean {\n\t\treturn isTrueType(this.directory);\n\t}\n\n\t/** Is this a CFF font? */\n\tget isCFF(): boolean {\n\t\treturn this.hasTable(Tags.CFF) || this.hasTable(Tags.CFF2);\n\t}\n\n\t/** Is this a variable font? */\n\tget isVariable(): boolean {\n\t\treturn this.hasTable(Tags.fvar);\n\t}\n\n\t/** Has OpenType layout tables? */\n\tget hasOpenTypeLayout(): boolean {\n\t\treturn this.hasTable(Tags.GSUB) || this.hasTable(Tags.GPOS);\n\t}\n\n\t/** Has AAT layout tables? */\n\tget hasAATLayout(): boolean {\n\t\treturn this.hasTable(Tags.morx) || this.hasTable(Tags.kerx);\n\t}\n\n\t/** Is this a color font? */\n\tget isColorFont(): boolean {\n\t\treturn (\n\t\t\tthis.hasTable(Tags.COLR) ||\n\t\t\tthis.hasTable(Tags.SVG) ||\n\t\t\tthis.hasTable(Tags.sbix) ||\n\t\t\tthis.hasTable(Tags.CBDT)\n\t\t);\n\t}\n\n\t/** Does this font have TrueType hinting? */\n\tget hasHinting(): boolean {\n\t\treturn this.isTrueType && (this.hasTable(Tags.fpgm) || this.hasTable(Tags.prep));\n\t}\n\n\t// Glyph operations\n\n\t/** Get glyph ID for a Unicode codepoint */\n\tglyphId(codepoint: number): GlyphId {\n\t\treturn getGlyphId(this.cmap, codepoint);\n\t}\n\n\t/** Get glyph ID for a character */\n\tglyphIdForChar(char: string): GlyphId {\n\t\tconst codepoint = char.codePointAt(0);\n\t\tif (codepoint === undefined) return 0;\n\t\treturn this.glyphId(codepoint);\n\t}\n\n\t/** Get advance width for a glyph */\n\tadvanceWidth(glyphId: GlyphId): number {\n\t\treturn getAdvanceWidth(this.hmtx, glyphId);\n\t}\n\n\t/** Get left side bearing for a glyph */\n\tleftSideBearing(glyphId: GlyphId): number {\n\t\treturn getLeftSideBearing(this.hmtx, glyphId);\n\t}\n\n\t/** List all table tags in the font */\n\tlistTables(): string[] {\n\t\treturn Array.from(this.directory.tables.keys()).map(tagToString);\n\t}\n\n\t// Glyph outline operations\n\n\t/** Get raw glyph data (simple or composite) - TrueType only */\n\tgetGlyph(glyphId: GlyphId): Glyph | null {\n\t\tif (!this.glyf || !this.loca) return null;\n\t\treturn parseGlyph(this.glyf, this.loca, glyphId);\n\t}\n\n\t/** Get flattened contours for a glyph (resolves composites) */\n\tgetGlyphContours(glyphId: GlyphId): Contour[] | null {\n\t\t// Try TrueType first\n\t\tif (this.glyf && this.loca) {\n\t\t\treturn getGlyphContours(this.glyf, this.loca, glyphId);\n\t\t}\n\t\t// Try CFF\n\t\tif (this.cff) {\n\t\t\treturn executeCffCharString(this.cff, glyphId, 0);\n\t\t}\n\t\t// Try CFF2\n\t\tif (this.cff2) {\n\t\t\treturn executeCff2CharString(this.cff2, glyphId, null);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Get bounding box for a glyph */\n\tgetGlyphBounds(\n\t\tglyphId: GlyphId,\n\t): { xMin: number; yMin: number; xMax: number; yMax: number } | null {\n\t\t// Try TrueType first\n\t\tif (this.glyf && this.loca) {\n\t\t\treturn getGlyphBounds(this.glyf, this.loca, glyphId);\n\t\t}\n\t\t// For CFF, compute bounds from contours\n\t\tconst contours = this.getGlyphContours(glyphId);\n\t\tif (!contours || contours.length === 0) return null;\n\n\t\tlet xMin = Infinity;\n\t\tlet yMin = Infinity;\n\t\tlet xMax = -Infinity;\n\t\tlet yMax = -Infinity;\n\n\t\tfor (const contour of contours) {\n\t\t\tfor (const point of contour) {\n\t\t\t\txMin = Math.min(xMin, point.x);\n\t\t\t\tyMin = Math.min(yMin, point.y);\n\t\t\t\txMax = Math.max(xMax, point.x);\n\t\t\t\tyMax = Math.max(yMax, point.y);\n\t\t\t}\n\t\t}\n\n\t\tif (xMin === Infinity) return null;\n\t\treturn { xMin, yMin, xMax, yMax };\n\t}\n\n\t/** Get contours for a glyph with variation applied */\n\tgetGlyphContoursWithVariation(\n\t\tglyphId: GlyphId,\n\t\taxisCoords: number[],\n\t): Contour[] | null {\n\t\t// Try TrueType first\n\t\tif (this.glyf && this.loca) {\n\t\t\treturn getGlyphContoursWithVariation(\n\t\t\t\tthis.glyf,\n\t\t\t\tthis.loca,\n\t\t\t\tthis.gvar,\n\t\t\t\tglyphId,\n\t\t\t\taxisCoords,\n\t\t\t);\n\t\t}\n\t\t// Try CFF2 with variation\n\t\tif (this.cff2) {\n\t\t\treturn executeCff2CharString(this.cff2, glyphId, axisCoords);\n\t\t}\n\t\t// CFF doesn't support variations\n\t\treturn this.getGlyphContours(glyphId);\n\t}\n}\n", "import { GlyphBuffer } from \"../buffer/glyph-buffer.ts\";\nimport type { Font } from \"../font/font.ts\";\nimport {\n\tgetExtenderGlyphs,\n\tgetExtensionMods,\n\tgetJstfPriorities,\n\tgetShrinkageMods,\n} from \"../font/tables/jstf.ts\";\nimport type { GlyphId, Tag } from \"../types.ts\";\nimport { tag } from \"../types.ts\";\n\n/**\n * Justification mode\n */\nexport enum JustifyMode {\n\t/** Shrink text to fit */\n\tShrink = \"shrink\",\n\t/** Extend text to fit */\n\tExtend = \"extend\",\n\t/** Auto-select based on delta */\n\tAuto = \"auto\",\n}\n\n/**\n * Justification options\n */\nexport interface JustifyOptions {\n\t/** Target line width */\n\ttargetWidth: number;\n\t/** Script tag */\n\tscript?: Tag;\n\t/** Language tag */\n\tlanguage?: Tag;\n\t/** Justification mode */\n\tmode?: JustifyMode;\n\t/** Maximum priority level to use (0-based) */\n\tmaxPriority?: number;\n\t/** Enable Kashida insertion for Arabic */\n\tenableKashida?: boolean;\n\t/** Minimum word spacing factor (default: 0.8) */\n\tminWordSpacingFactor?: number;\n\t/** Maximum word spacing factor (default: 1.5) */\n\tmaxWordSpacingFactor?: number;\n\t/** Enable inter-character spacing adjustment */\n\tenableLetterSpacing?: boolean;\n\t/** Maximum letter spacing in font units */\n\tmaxLetterSpacing?: number;\n}\n\n/**\n * Justification result\n */\nexport interface JustifyResult {\n\t/** Whether justification succeeded */\n\tsuccess: boolean;\n\t/** Final line width after justification */\n\tfinalWidth: number;\n\t/** Delta from target (positive = too wide, negative = too narrow) */\n\tdelta: number;\n\t/** Priority level used */\n\tpriorityLevel: number;\n\t/** Adjustments applied */\n\tadjustments: JustifyAdjustment[];\n}\n\n/**\n * Individual justification adjustment\n */\nexport interface JustifyAdjustment {\n\ttype: \"spacing\" | \"kashida\" | \"lookup\";\n\t/** Glyph indices affected */\n\tglyphIndices: number[];\n\t/** Adjustment value */\n\tvalue: number;\n}\n\n/**\n * Calculate current line width from glyph buffer\n */\nexport function calculateLineWidth(buffer: GlyphBuffer): number {\n\tlet width = 0;\n\tfor (const pos of buffer.positions) {\n\t\twidth += pos.xAdvance;\n\t}\n\treturn width;\n}\n\n/**\n * Justify a shaped glyph buffer to fit a target width\n */\nexport function justify(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\toptions: JustifyOptions,\n): JustifyResult {\n\tconst {\n\t\ttargetWidth,\n\t\tscript = tag(\"DFLT\"),\n\t\tlanguage,\n\t\tmode = JustifyMode.Auto,\n\t\tmaxPriority = 10,\n\t\tenableKashida = true,\n\t\tminWordSpacingFactor = 0.8,\n\t\tmaxWordSpacingFactor = 1.5,\n\t\tenableLetterSpacing = true,\n\t\tmaxLetterSpacing = 100,\n\t} = options;\n\n\tconst currentWidth = calculateLineWidth(buffer);\n\tconst delta = targetWidth - currentWidth;\n\n\t// Already at target width\n\tif (Math.abs(delta) < 1) {\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tfinalWidth: currentWidth,\n\t\t\tdelta: 0,\n\t\t\tpriorityLevel: 0,\n\t\t\tadjustments: [],\n\t\t};\n\t}\n\n\t// Determine mode\n\tlet actualMode: JustifyMode.Shrink | JustifyMode.Extend;\n\tif (mode === JustifyMode.Auto) {\n\t\tactualMode = delta > 0 ? JustifyMode.Extend : JustifyMode.Shrink;\n\t} else {\n\t\tactualMode = mode as JustifyMode.Shrink | JustifyMode.Extend;\n\t}\n\n\tconst adjustments: JustifyAdjustment[] = [];\n\tlet remainingDelta = delta;\n\tlet priorityLevel = 0;\n\n\t// Try JSTF-based justification first\n\tconst jstf = font.jstf;\n\tif (jstf) {\n\t\tconst priorities = getJstfPriorities(jstf, script, language);\n\n\t\tfor (let i = 0; i < Math.min(priorities.length, maxPriority); i++) {\n\t\t\tconst priority = priorities[i]!;\n\t\t\tconst mods =\n\t\t\t\tactualMode === JustifyMode.Shrink\n\t\t\t\t\t? getShrinkageMods(priority)\n\t\t\t\t\t: getExtensionMods(priority);\n\n\t\t\t// Apply JSTF lookup modifications\n\t\t\t// Note: This would require reshaping with modified lookups\n\t\t\t// For now, we just record the modifications needed\n\t\t\tif (\n\t\t\t\tmods.enableGsub.length > 0 ||\n\t\t\t\tmods.disableGsub.length > 0 ||\n\t\t\t\tmods.enableGpos.length > 0 ||\n\t\t\t\tmods.disableGpos.length > 0\n\t\t\t) {\n\t\t\t\tadjustments.push({\n\t\t\t\t\ttype: \"lookup\",\n\t\t\t\t\tglyphIndices: [],\n\t\t\t\t\tvalue: i,\n\t\t\t\t});\n\t\t\t\tpriorityLevel = i;\n\t\t\t}\n\t\t}\n\n\t\t// Kashida insertion for Arabic\n\t\tif (enableKashida && actualMode === JustifyMode.Extend) {\n\t\t\tconst extenderGlyphs = getExtenderGlyphs(jstf, script);\n\t\t\tif (extenderGlyphs.length > 0) {\n\t\t\t\tconst kashidaResult = insertKashida(\n\t\t\t\t\tbuffer,\n\t\t\t\t\textenderGlyphs[0]!,\n\t\t\t\t\tremainingDelta,\n\t\t\t\t\tfont,\n\t\t\t\t);\n\t\t\t\tremainingDelta -= kashidaResult.totalExtension;\n\t\t\t\tadjustments.push(...kashidaResult.adjustments);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Apply word spacing adjustment\n\tconst spaceGlyphId = font.glyphId(0x0020); // Space character\n\tif (spaceGlyphId !== 0) {\n\t\tconst spaceResult = adjustWordSpacing(\n\t\t\tbuffer,\n\t\t\tspaceGlyphId,\n\t\t\tremainingDelta,\n\t\t\tactualMode === JustifyMode.Shrink\n\t\t\t\t? minWordSpacingFactor\n\t\t\t\t: maxWordSpacingFactor,\n\t\t);\n\t\tremainingDelta -= spaceResult.totalAdjustment;\n\t\tadjustments.push(...spaceResult.adjustments);\n\t}\n\n\t// Apply letter spacing if still needed\n\tif (enableLetterSpacing && Math.abs(remainingDelta) > 1) {\n\t\tconst letterResult = adjustLetterSpacing(\n\t\t\tbuffer,\n\t\t\tremainingDelta,\n\t\t\tmaxLetterSpacing,\n\t\t);\n\t\tremainingDelta -= letterResult.totalAdjustment;\n\t\tadjustments.push(...letterResult.adjustments);\n\t}\n\n\tconst finalWidth = calculateLineWidth(buffer);\n\n\treturn {\n\t\tsuccess: Math.abs(remainingDelta) < 1,\n\t\tfinalWidth,\n\t\tdelta: targetWidth - finalWidth,\n\t\tpriorityLevel,\n\t\tadjustments,\n\t};\n}\n\n/**\n * Insert Kashida (tatweel) characters for Arabic justification\n */\nfunction insertKashida(\n\tbuffer: GlyphBuffer,\n\tkashidaGlyph: GlyphId,\n\ttargetExtension: number,\n\tfont: Font,\n): { totalExtension: number; adjustments: JustifyAdjustment[] } {\n\tconst adjustments: JustifyAdjustment[] = [];\n\tlet totalExtension = 0;\n\n\t// Find valid Kashida insertion points (between Arabic letters)\n\tconst insertionPoints: number[] = [];\n\tfor (let i = 0; i < buffer.infos.length - 1; i++) {\n\t\tconst info = buffer.infos[i]!;\n\t\t// Check if this is a valid insertion point\n\t\t// (between joining Arabic characters)\n\t\tif (isValidKashidaPoint(info.codepoint)) {\n\t\t\tinsertionPoints.push(i);\n\t\t}\n\t}\n\n\tif (insertionPoints.length === 0) {\n\t\treturn { totalExtension: 0, adjustments: [] };\n\t}\n\n\t// Get Kashida width\n\tconst kashidaWidth = font.advanceWidth(kashidaGlyph);\n\tif (kashidaWidth <= 0) {\n\t\treturn { totalExtension: 0, adjustments: [] };\n\t}\n\n\t// Distribute Kashida evenly\n\tconst kashidaPerPoint = Math.ceil(\n\t\ttargetExtension / kashidaWidth / insertionPoints.length,\n\t);\n\tconst adjustmentPerPoint = Math.min(\n\t\tkashidaPerPoint * kashidaWidth,\n\t\ttargetExtension / insertionPoints.length,\n\t);\n\n\tfor (const point of insertionPoints) {\n\t\tif (totalExtension >= targetExtension) break;\n\n\t\t// Add Kashida extension via xAdvance\n\t\tbuffer.positions[point]!.xAdvance += adjustmentPerPoint;\n\t\ttotalExtension += adjustmentPerPoint;\n\n\t\tadjustments.push({\n\t\t\ttype: \"kashida\",\n\t\t\tglyphIndices: [point],\n\t\t\tvalue: adjustmentPerPoint,\n\t\t});\n\t}\n\n\treturn { totalExtension, adjustments };\n}\n\n/**\n * Check if a codepoint is a valid Kashida insertion point\n */\nfunction isValidKashidaPoint(codepoint: number): boolean {\n\t// Arabic letters that can have Kashida after them\n\t// Simplified check - in reality need to check joining behavior\n\treturn codepoint >= 0x0620 && codepoint <= 0x06ff;\n}\n\n/**\n * Adjust word spacing (space character width)\n */\nfunction adjustWordSpacing(\n\tbuffer: GlyphBuffer,\n\tspaceGlyph: GlyphId,\n\ttargetAdjustment: number,\n\tlimitFactor: number,\n): { totalAdjustment: number; adjustments: JustifyAdjustment[] } {\n\tconst adjustments: JustifyAdjustment[] = [];\n\tlet totalAdjustment = 0;\n\n\t// Find all space glyphs\n\tconst spaceIndices: number[] = [];\n\tlet totalSpaceWidth = 0;\n\n\tfor (let i = 0; i < buffer.infos.length; i++) {\n\t\tif (buffer.infos[i]?.glyphId === spaceGlyph) {\n\t\t\tspaceIndices.push(i);\n\t\t\ttotalSpaceWidth += buffer.positions[i]?.xAdvance;\n\t\t}\n\t}\n\n\tif (spaceIndices.length === 0) {\n\t\treturn { totalAdjustment: 0, adjustments: [] };\n\t}\n\n\t// Calculate adjustment per space\n\tconst adjustmentPerSpace = targetAdjustment / spaceIndices.length;\n\tconst originalSpaceWidth = totalSpaceWidth / spaceIndices.length;\n\tconst maxAdjustment = originalSpaceWidth * (limitFactor - 1);\n\n\tconst clampedAdjustment =\n\t\ttargetAdjustment > 0\n\t\t\t? Math.min(adjustmentPerSpace, maxAdjustment)\n\t\t\t: Math.max(adjustmentPerSpace, -maxAdjustment);\n\n\tfor (const idx of spaceIndices) {\n\t\tbuffer.positions[idx]!.xAdvance += clampedAdjustment;\n\t\ttotalAdjustment += clampedAdjustment;\n\t}\n\n\tif (totalAdjustment !== 0) {\n\t\tadjustments.push({\n\t\t\ttype: \"spacing\",\n\t\t\tglyphIndices: spaceIndices,\n\t\t\tvalue: clampedAdjustment,\n\t\t});\n\t}\n\n\treturn { totalAdjustment, adjustments };\n}\n\n/**\n * Adjust letter spacing (inter-character spacing)\n */\nfunction adjustLetterSpacing(\n\tbuffer: GlyphBuffer,\n\ttargetAdjustment: number,\n\tmaxAdjustment: number,\n): { totalAdjustment: number; adjustments: JustifyAdjustment[] } {\n\tconst adjustments: JustifyAdjustment[] = [];\n\n\tconst numGlyphs = buffer.infos.length;\n\tif (numGlyphs <= 1) {\n\t\treturn { totalAdjustment: 0, adjustments: [] };\n\t}\n\n\t// Distribute across all inter-glyph gaps (n-1 gaps for n glyphs)\n\tconst numGaps = numGlyphs - 1;\n\tconst adjustmentPerGap = targetAdjustment / numGaps;\n\n\t// Clamp to max\n\tconst clampedAdjustment =\n\t\ttargetAdjustment > 0\n\t\t\t? Math.min(adjustmentPerGap, maxAdjustment)\n\t\t\t: Math.max(adjustmentPerGap, -maxAdjustment);\n\n\tconst affectedIndices: number[] = [];\n\tlet totalAdjustment = 0;\n\n\tfor (let i = 0; i < numGlyphs - 1; i++) {\n\t\tbuffer.positions[i]!.xAdvance += clampedAdjustment;\n\t\ttotalAdjustment += clampedAdjustment;\n\t\taffectedIndices.push(i);\n\t}\n\n\tif (totalAdjustment !== 0) {\n\t\tadjustments.push({\n\t\t\ttype: \"spacing\",\n\t\t\tglyphIndices: affectedIndices,\n\t\t\tvalue: clampedAdjustment,\n\t\t});\n\t}\n\n\treturn { totalAdjustment, adjustments };\n}\n\n/**\n * Simple line breaking for multi-line text\n */\nexport interface LineBreakResult {\n\tlines: GlyphBuffer[];\n\tbreakPoints: number[];\n}\n\n/**\n * Break shaped text into lines at a given width\n * Uses simple greedy algorithm\n */\nexport function breakIntoLines(\n\tbuffer: GlyphBuffer,\n\tmaxWidth: number,\n\tspaceGlyph?: GlyphId,\n): LineBreakResult {\n\tconst lines: GlyphBuffer[] = [];\n\tconst breakPoints: number[] = [];\n\n\tif (buffer.infos.length === 0) {\n\t\treturn { lines: [], breakPoints: [] };\n\t}\n\n\tlet lineStart = 0;\n\tlet currentWidth = 0;\n\tlet lastBreakPoint = -1;\n\tlet _lastBreakWidth = 0;\n\n\tfor (let i = 0; i < buffer.infos.length; i++) {\n\t\tconst pos = buffer.positions[i]!;\n\t\tconst info = buffer.infos[i]!;\n\n\t\tcurrentWidth += pos.xAdvance;\n\n\t\t// Track potential break points (after spaces)\n\t\tif (spaceGlyph !== undefined && info.glyphId === spaceGlyph) {\n\t\t\tlastBreakPoint = i;\n\t\t\t_lastBreakWidth = currentWidth;\n\t\t}\n\n\t\t// Check if we need to break\n\t\tif (currentWidth > maxWidth && lineStart < i) {\n\t\t\tlet breakAt: number;\n\n\t\t\tif (lastBreakPoint > lineStart) {\n\t\t\t\t// Break at last space\n\t\t\t\tbreakAt = lastBreakPoint + 1;\n\t\t\t} else {\n\t\t\t\t// Force break at current position\n\t\t\t\tbreakAt = i;\n\t\t\t}\n\n\t\t\t// Create line buffer\n\t\t\tconst lineBuffer = createLineBuffer(buffer, lineStart, breakAt);\n\t\t\tlines.push(lineBuffer);\n\t\t\tbreakPoints.push(breakAt);\n\n\t\t\t// Start new line\n\t\t\tlineStart = breakAt;\n\t\t\tcurrentWidth = 0;\n\t\t\tlastBreakPoint = -1;\n\n\t\t\t// Recalculate width from line start\n\t\t\tfor (let j = lineStart; j <= i; j++) {\n\t\t\t\tcurrentWidth += buffer.positions[j]?.xAdvance;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Add final line\n\tif (lineStart < buffer.infos.length) {\n\t\tconst lineBuffer = createLineBuffer(buffer, lineStart, buffer.infos.length);\n\t\tlines.push(lineBuffer);\n\t}\n\n\treturn { lines, breakPoints };\n}\n\n/**\n * Create a new GlyphBuffer from a slice of an existing buffer\n */\nfunction createLineBuffer(\n\tsource: GlyphBuffer,\n\tstart: number,\n\tend: number,\n): GlyphBuffer {\n\tconst lineBuffer = new GlyphBuffer();\n\tlineBuffer.direction = source.direction;\n\tlineBuffer.script = source.script;\n\tlineBuffer.language = source.language;\n\n\tfor (let i = start; i < end; i++) {\n\t\tlineBuffer.infos.push({ ...source.infos[i]! });\n\t\tlineBuffer.positions.push({ ...source.positions[i]! });\n\t}\n\n\treturn lineBuffer;\n}\n\n/**\n * Justify all lines in a paragraph to the same width\n */\nexport function justifyParagraph(\n\tfont: Font,\n\tlines: GlyphBuffer[],\n\toptions: JustifyOptions,\n): JustifyResult[] {\n\tconst results: JustifyResult[] = [];\n\n\tfor (let i = 0; i < lines.length; i++) {\n\t\tconst line = lines[i]!;\n\t\tconst isLastLine = i === lines.length - 1;\n\n\t\t// Don't justify the last line (or justify less aggressively)\n\t\tif (isLastLine) {\n\t\t\tresults.push({\n\t\t\t\tsuccess: true,\n\t\t\t\tfinalWidth: calculateLineWidth(line),\n\t\t\t\tdelta: 0,\n\t\t\t\tpriorityLevel: 0,\n\t\t\t\tadjustments: [],\n\t\t\t});\n\t\t} else {\n\t\t\tresults.push(justify(font, line, options));\n\t\t}\n\t}\n\n\treturn results;\n}\n", "import type { Reader } from \"../../font/binary/reader.ts\";\nimport type { Tag, uint16, uint32 } from \"../../types.ts\";\n\n/**\n * FeatureVariations table\n * Allows different feature substitutions based on variation axis coordinates\n * Used in GSUB/GPOS for variable fonts\n */\nexport interface FeatureVariations {\n\tmajorVersion: number;\n\tminorVersion: number;\n\tfeatureVariationRecords: FeatureVariationRecord[];\n}\n\n/**\n * Feature variation record\n * Contains a condition set and feature substitutions to apply when conditions are met\n */\nexport interface FeatureVariationRecord {\n\tconditionSet: ConditionSet;\n\tfeatureTableSubstitution: FeatureTableSubstitution;\n}\n\n/**\n * Condition set - all conditions must be met\n */\nexport interface ConditionSet {\n\tconditions: Condition[];\n}\n\n/**\n * Single axis condition\n */\nexport interface Condition {\n\tformat: number;\n\taxisIndex: uint16;\n\tfilterRangeMinValue: number; // F2DOT14\n\tfilterRangeMaxValue: number; // F2DOT14\n}\n\n/**\n * Feature table substitution\n * Maps feature indices to replacement feature tables\n */\nexport interface FeatureTableSubstitution {\n\tmajorVersion: number;\n\tminorVersion: number;\n\tsubstitutions: FeatureSubstitutionRecord[];\n}\n\n/**\n * Single feature substitution record\n */\nexport interface FeatureSubstitutionRecord {\n\tfeatureIndex: uint16;\n\talternateFeature: AlternateFeature;\n}\n\n/**\n * Alternate feature table\n */\nexport interface AlternateFeature {\n\tfeatureParamsOffset: uint16;\n\tlookupListIndices: uint16[];\n}\n\n/**\n * Parse FeatureVariations table\n */\nexport function parseFeatureVariations(reader: Reader): FeatureVariations {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst featureVariationRecordCount = reader.uint32();\n\n\tconst recordOffsets: {\n\t\tconditionSetOffset: uint32;\n\t\tfeatureSubstOffset: uint32;\n\t}[] = [];\n\tfor (let i = 0; i < featureVariationRecordCount; i++) {\n\t\trecordOffsets.push({\n\t\t\tconditionSetOffset: reader.offset32(),\n\t\t\tfeatureSubstOffset: reader.offset32(),\n\t\t});\n\t}\n\n\tconst featureVariationRecords: FeatureVariationRecord[] = [];\n\tfor (const offsets of recordOffsets) {\n\t\tconst conditionSet = parseConditionSet(\n\t\t\treader.sliceFrom(offsets.conditionSetOffset),\n\t\t);\n\t\tconst featureTableSubstitution = parseFeatureTableSubstitution(\n\t\t\treader.sliceFrom(offsets.featureSubstOffset),\n\t\t);\n\n\t\tfeatureVariationRecords.push({\n\t\t\tconditionSet,\n\t\t\tfeatureTableSubstitution,\n\t\t});\n\t}\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\tfeatureVariationRecords,\n\t};\n}\n\nfunction parseConditionSet(reader: Reader): ConditionSet {\n\tconst conditionCount = reader.uint16();\n\tconst conditionOffsets: uint32[] = [];\n\tfor (let i = 0; i < conditionCount; i++) {\n\t\tconditionOffsets.push(reader.offset32());\n\t}\n\n\tconst conditions: Condition[] = [];\n\tfor (const offset of conditionOffsets) {\n\t\tconst condReader = reader.sliceFrom(offset);\n\t\tconst format = condReader.uint16();\n\n\t\tif (format === 1) {\n\t\t\tconditions.push({\n\t\t\t\tformat,\n\t\t\t\taxisIndex: condReader.uint16(),\n\t\t\t\tfilterRangeMinValue: condReader.f2dot14(),\n\t\t\t\tfilterRangeMaxValue: condReader.f2dot14(),\n\t\t\t});\n\t\t}\n\t}\n\n\treturn { conditions };\n}\n\nfunction parseFeatureTableSubstitution(\n\treader: Reader,\n): FeatureTableSubstitution {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst substitutionCount = reader.uint16();\n\n\tconst substitutionRecords: { featureIndex: uint16; offset: uint32 }[] = [];\n\tfor (let i = 0; i < substitutionCount; i++) {\n\t\tsubstitutionRecords.push({\n\t\t\tfeatureIndex: reader.uint16(),\n\t\t\toffset: reader.offset32(),\n\t\t});\n\t}\n\n\tconst substitutions: FeatureSubstitutionRecord[] = [];\n\tfor (const record of substitutionRecords) {\n\t\tconst featureReader = reader.sliceFrom(record.offset);\n\t\tconst featureParamsOffset = featureReader.offset16();\n\t\tconst lookupIndexCount = featureReader.uint16();\n\t\tconst lookupListIndices = Array.from(\n\t\t\tfeatureReader.uint16Array(lookupIndexCount),\n\t\t);\n\n\t\tsubstitutions.push({\n\t\t\tfeatureIndex: record.featureIndex,\n\t\t\talternateFeature: {\n\t\t\t\tfeatureParamsOffset,\n\t\t\t\tlookupListIndices,\n\t\t\t},\n\t\t});\n\t}\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\tsubstitutions,\n\t};\n}\n\n/**\n * Evaluate condition set against axis coordinates\n * Returns true if all conditions are met\n */\nexport function evaluateConditionSet(\n\tconditionSet: ConditionSet,\n\taxisCoords: number[],\n): boolean {\n\tfor (const condition of conditionSet.conditions) {\n\t\tconst axisValue = axisCoords[condition.axisIndex] ?? 0;\n\t\tif (\n\t\t\taxisValue < condition.filterRangeMinValue ||\n\t\t\taxisValue > condition.filterRangeMaxValue\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Find matching feature variation record for given axis coordinates\n * Returns the first matching record, or null if none match\n */\nexport function findMatchingFeatureVariation(\n\tfeatureVariations: FeatureVariations,\n\taxisCoords: number[],\n): FeatureVariationRecord | null {\n\tfor (const record of featureVariations.featureVariationRecords) {\n\t\tif (evaluateConditionSet(record.conditionSet, axisCoords)) {\n\t\t\treturn record;\n\t\t}\n\t}\n\treturn null;\n}\n\n/**\n * Get substituted lookup list indices for a feature\n * Returns the original lookups if no substitution applies\n */\nexport function getSubstitutedLookups(\n\tfeatureVariations: FeatureVariations | null,\n\tfeatureIndex: number,\n\toriginalLookups: uint16[],\n\taxisCoords: number[] | null,\n): uint16[] {\n\tif (!featureVariations || !axisCoords) {\n\t\treturn originalLookups;\n\t}\n\n\tconst matchingRecord = findMatchingFeatureVariation(\n\t\tfeatureVariations,\n\t\taxisCoords,\n\t);\n\tif (!matchingRecord) {\n\t\treturn originalLookups;\n\t}\n\n\t// Check if this feature has a substitution\n\tconst substitution =\n\t\tmatchingRecord.featureTableSubstitution.substitutions.find(\n\t\t\t(s) => s.featureIndex === featureIndex,\n\t\t);\n\n\tif (substitution) {\n\t\treturn substitution.alternateFeature.lookupListIndices;\n\t}\n\n\treturn originalLookups;\n}\n\n/**\n * Apply feature variations to a feature list\n * Returns a modified feature list with substituted lookup indices\n */\nexport function applyFeatureVariations(\n\tfeatureVariations: FeatureVariations | null,\n\tfeatureLookups: Map<Tag, uint16[]>,\n\tfeatureIndices: Map<Tag, number>,\n\taxisCoords: number[] | null,\n): Map<Tag, uint16[]> {\n\tif (!featureVariations || !axisCoords) {\n\t\treturn featureLookups;\n\t}\n\n\tconst matchingRecord = findMatchingFeatureVariation(\n\t\tfeatureVariations,\n\t\taxisCoords,\n\t);\n\tif (!matchingRecord) {\n\t\treturn featureLookups;\n\t}\n\n\t// Create a new map with substituted lookups\n\tconst result = new Map(featureLookups);\n\n\tfor (const substitution of matchingRecord.featureTableSubstitution\n\t\t.substitutions) {\n\t\t// Find the feature tag for this index\n\t\tfor (const [tag, index] of featureIndices) {\n\t\t\tif (index === substitution.featureIndex) {\n\t\t\t\tresult.set(tag, substitution.alternateFeature.lookupListIndices);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n", "import type { GlyphBuffer } from \"../buffer/glyph-buffer.ts\";\nimport type { Font } from \"../font/font.ts\";\nimport type { Contour, GlyphPoint } from \"../font/tables/glyf.ts\";\nimport type { GlyphId } from \"../types.ts\";\n\n/**\n * Path command types for glyph rendering\n */\nexport type PathCommand =\n\t| { type: \"M\"; x: number; y: number }\n\t| { type: \"L\"; x: number; y: number }\n\t| { type: \"Q\"; x1: number; y1: number; x: number; y: number }\n\t| {\n\t\t\ttype: \"C\";\n\t\t\tx1: number;\n\t\t\ty1: number;\n\t\t\tx2: number;\n\t\t\ty2: number;\n\t\t\tx: number;\n\t\t\ty: number;\n\t  }\n\t| { type: \"Z\" };\n\n/**\n * Outline flags (like FreeType's FT_OUTLINE_* flags)\n */\nexport enum OutlineFlags {\n\t/** No flags */\n\tNone = 0,\n\t/** Use even-odd fill rule instead of non-zero winding */\n\tEvenOddFill = 1 << 0,\n\t/** Outline has been hinted */\n\tHighPrecision = 1 << 1,\n\t/** Outline is a single stroke (not filled) */\n\tSinglePass = 1 << 2,\n}\n\n/**\n * A glyph path is a series of drawing commands\n */\nexport interface GlyphPath {\n\tcommands: PathCommand[];\n\tbounds: { xMin: number; yMin: number; xMax: number; yMax: number } | null;\n\t/** Outline flags (like FreeType's FT_OUTLINE_* flags) */\n\tflags?: OutlineFlags;\n}\n\n/**\n * Convert contours to path commands\n * Handles both TrueType (quadratic Bziers) and CFF (cubic Bziers)\n */\nexport function contourToPath(contour: Contour): PathCommand[] {\n\tif (contour.length === 0) return [];\n\n\tconst commands: PathCommand[] = [];\n\n\t// Check if this contour uses cubic beziers (CFF font)\n\tconst hasCubic = contour.some((p) => p.cubic);\n\n\tif (hasCubic) {\n\t\t// CFF-style contour with cubic beziers\n\t\treturn contourToPathCubic(contour);\n\t}\n\n\t// TrueType-style contour with quadratic beziers\n\treturn contourToPathQuadratic(contour);\n}\n\n/**\n * Convert CFF contour (cubic beziers) to path commands\n */\nfunction contourToPathCubic(contour: Contour): PathCommand[] {\n\tif (contour.length === 0) return [];\n\n\tconst commands: PathCommand[] = [];\n\tlet i = 0;\n\n\t// First point should be on-curve (moveto)\n\tconst first = contour[0];\n\tif (!first) return [];\n\n\tcommands.push({ type: \"M\", x: first.x, y: first.y });\n\ti = 1;\n\n\twhile (i < contour.length) {\n\t\tconst point = contour[i];\n\t\tif (!point) break;\n\n\t\tif (point.onCurve) {\n\t\t\t// Line to\n\t\t\tcommands.push({ type: \"L\", x: point.x, y: point.y });\n\t\t\ti++;\n\t\t} else if (point.cubic) {\n\t\t\t// Cubic bezier: expect cp1, cp2, endpoint\n\t\t\tconst cp1 = point;\n\t\t\tconst cp2 = contour[i + 1];\n\t\t\tconst end = contour[i + 2];\n\n\t\t\tif (!cp2 || !end) {\n\t\t\t\t// Malformed, skip\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcommands.push({\n\t\t\t\ttype: \"C\",\n\t\t\t\tx1: cp1.x,\n\t\t\t\ty1: cp1.y,\n\t\t\t\tx2: cp2.x,\n\t\t\t\ty2: cp2.y,\n\t\t\t\tx: end.x,\n\t\t\t\ty: end.y,\n\t\t\t});\n\t\t\ti += 3;\n\t\t} else {\n\t\t\t// Quadratic bezier (shouldn't happen in CFF but handle anyway)\n\t\t\tconst cp = point;\n\t\t\tconst next = contour[i + 1];\n\t\t\tif (!next) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet endPoint: GlyphPoint;\n\t\t\tif (next.onCurve) {\n\t\t\t\tendPoint = next;\n\t\t\t\ti += 2;\n\t\t\t} else {\n\t\t\t\tendPoint = {\n\t\t\t\t\tx: (cp.x + next.x) / 2,\n\t\t\t\t\ty: (cp.y + next.y) / 2,\n\t\t\t\t\tonCurve: true,\n\t\t\t\t};\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tcommands.push({\n\t\t\t\ttype: \"Q\",\n\t\t\t\tx1: cp.x,\n\t\t\t\ty1: cp.y,\n\t\t\t\tx: endPoint.x,\n\t\t\t\ty: endPoint.y,\n\t\t\t});\n\t\t}\n\t}\n\n\tcommands.push({ type: \"Z\" });\n\treturn commands;\n}\n\n/**\n * Convert TrueType contour (quadratic beziers) to path commands\n */\nfunction contourToPathQuadratic(contour: Contour): PathCommand[] {\n\tif (contour.length === 0) return [];\n\n\tconst commands: PathCommand[] = [];\n\n\t// Find the first on-curve point to start\n\tlet startIndex = 0;\n\tfor (const [i, point] of contour.entries()) {\n\t\tif (point.onCurve) {\n\t\t\tstartIndex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// If all points are off-curve, calculate implied on-curve point\n\tconst allOffCurve = contour.every((p) => !p.onCurve);\n\tlet startPoint: GlyphPoint;\n\n\tif (allOffCurve) {\n\t\t// Start at midpoint between first and last off-curve points\n\t\tconst first = contour[0];\n\t\tconst last = contour[contour.length - 1];\n\t\tif (!first || !last) return [];\n\t\tstartPoint = {\n\t\t\tx: (first.x + last.x) / 2,\n\t\t\ty: (first.y + last.y) / 2,\n\t\t\tonCurve: true,\n\t\t};\n\t\tstartIndex = 0;\n\t} else {\n\t\tconst point = contour[startIndex];\n\t\tif (!point) return [];\n\t\tstartPoint = point;\n\t}\n\n\tcommands.push({ type: \"M\", x: startPoint.x, y: startPoint.y });\n\n\tconst n = contour.length;\n\tlet i = allOffCurve ? 0 : (startIndex + 1) % n;\n\tlet current = startPoint;\n\tlet iterations = 0;\n\n\twhile (iterations < n) {\n\t\tconst point = contour[i];\n\t\tif (!point) break;\n\n\t\tif (point.onCurve) {\n\t\t\t// Line to on-curve point\n\t\t\tcommands.push({ type: \"L\", x: point.x, y: point.y });\n\t\t\tcurrent = point;\n\t\t} else {\n\t\t\t// Off-curve point - need to find the end point\n\t\t\tconst nextIndex = (i + 1) % n;\n\t\t\tconst nextPoint = contour[nextIndex];\n\t\t\tif (!nextPoint) break;\n\n\t\t\tlet endPoint: GlyphPoint;\n\t\t\tif (nextPoint.onCurve) {\n\t\t\t\t// Next point is on-curve, use it directly\n\t\t\t\tendPoint = nextPoint;\n\t\t\t\ti = nextIndex;\n\t\t\t\titerations++;\n\t\t\t} else {\n\t\t\t\t// Next point is also off-curve, calculate implied on-curve point\n\t\t\t\tendPoint = {\n\t\t\t\t\tx: (point.x + nextPoint.x) / 2,\n\t\t\t\t\ty: (point.y + nextPoint.y) / 2,\n\t\t\t\t\tonCurve: true,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Quadratic Bzier curve\n\t\t\tcommands.push({\n\t\t\t\ttype: \"Q\",\n\t\t\t\tx1: point.x,\n\t\t\t\ty1: point.y,\n\t\t\t\tx: endPoint.x,\n\t\t\t\ty: endPoint.y,\n\t\t\t});\n\t\t\tcurrent = endPoint;\n\t\t}\n\n\t\ti = (i + 1) % n;\n\t\titerations++;\n\n\t\t// Check if we've returned to start\n\t\tif (current.x === startPoint.x && current.y === startPoint.y) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Close the path\n\tcommands.push({ type: \"Z\" });\n\n\treturn commands;\n}\n\n/**\n * Get path commands for a glyph\n */\nexport function getGlyphPath(font: Font, glyphId: GlyphId): GlyphPath | null {\n\tconst contours = font.getGlyphContours(glyphId);\n\tif (!contours) return null;\n\n\tconst commands: PathCommand[] = [];\n\tfor (const contour of contours) {\n\t\tcommands.push(...contourToPath(contour));\n\t}\n\n\tconst bounds = font.getGlyphBounds(glyphId);\n\n\treturn { commands, bounds };\n}\n\n/**\n * Convert path commands to SVG path data string\n */\nexport function pathToSVG(\n\tpath: GlyphPath,\n\toptions?: { flipY?: boolean; scale?: number },\n): string {\n\tconst scale = options?.scale ?? 1;\n\tconst flipY = options?.flipY ?? true;\n\n\tconst parts: string[] = [];\n\n\tfor (const cmd of path.commands) {\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\":\n\t\t\t\tparts.push(\n\t\t\t\t\t`M ${cmd.x * scale} ${flipY ? -cmd.y * scale : cmd.y * scale}`,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"L\":\n\t\t\t\tparts.push(\n\t\t\t\t\t`L ${cmd.x * scale} ${flipY ? -cmd.y * scale : cmd.y * scale}`,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"Q\":\n\t\t\t\tparts.push(\n\t\t\t\t\t`Q ${cmd.x1 * scale} ${flipY ? -cmd.y1 * scale : cmd.y1 * scale} ${cmd.x * scale} ${flipY ? -cmd.y * scale : cmd.y * scale}`,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"C\":\n\t\t\t\tparts.push(\n\t\t\t\t\t`C ${cmd.x1 * scale} ${flipY ? -cmd.y1 * scale : cmd.y1 * scale} ${cmd.x2 * scale} ${flipY ? -cmd.y2 * scale : cmd.y2 * scale} ${cmd.x * scale} ${flipY ? -cmd.y * scale : cmd.y * scale}`,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"Z\":\n\t\t\t\tparts.push(\"Z\");\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn parts.join(\" \");\n}\n\n/**\n * Render path commands to a Canvas 2D context\n */\nexport function pathToCanvas(\n\tctx: CanvasRenderingContext2D | Path2D,\n\tpath: GlyphPath,\n\toptions?: {\n\t\tflipY?: boolean;\n\t\tscale?: number;\n\t\toffsetX?: number;\n\t\toffsetY?: number;\n\t},\n): void {\n\tconst scale = options?.scale ?? 1;\n\tconst flipY = options?.flipY ?? true;\n\tconst offsetX = options?.offsetX ?? 0;\n\tconst offsetY = options?.offsetY ?? 0;\n\n\tfor (const cmd of path.commands) {\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\":\n\t\t\t\tctx.moveTo(\n\t\t\t\t\tcmd.x * scale + offsetX,\n\t\t\t\t\t(flipY ? -cmd.y : cmd.y) * scale + offsetY,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"L\":\n\t\t\t\tctx.lineTo(\n\t\t\t\t\tcmd.x * scale + offsetX,\n\t\t\t\t\t(flipY ? -cmd.y : cmd.y) * scale + offsetY,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"Q\":\n\t\t\t\tctx.quadraticCurveTo(\n\t\t\t\t\tcmd.x1 * scale + offsetX,\n\t\t\t\t\t(flipY ? -cmd.y1 : cmd.y1) * scale + offsetY,\n\t\t\t\t\tcmd.x * scale + offsetX,\n\t\t\t\t\t(flipY ? -cmd.y : cmd.y) * scale + offsetY,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"C\":\n\t\t\t\tctx.bezierCurveTo(\n\t\t\t\t\tcmd.x1 * scale + offsetX,\n\t\t\t\t\t(flipY ? -cmd.y1 : cmd.y1) * scale + offsetY,\n\t\t\t\t\tcmd.x2 * scale + offsetX,\n\t\t\t\t\t(flipY ? -cmd.y2 : cmd.y2) * scale + offsetY,\n\t\t\t\t\tcmd.x * scale + offsetX,\n\t\t\t\t\t(flipY ? -cmd.y : cmd.y) * scale + offsetY,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"Z\":\n\t\t\t\tctx.closePath();\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * Generate an SVG element for a glyph\n */\nexport function glyphToSVG(\n\tfont: Font,\n\tglyphId: GlyphId,\n\toptions?: { fontSize?: number; fill?: string },\n): string | null {\n\tconst path = getGlyphPath(font, glyphId);\n\tif (!path) return null;\n\n\tconst fontSize = options?.fontSize ?? 100;\n\tconst fill = options?.fill ?? \"currentColor\";\n\tconst scale = fontSize / font.unitsPerEm;\n\n\tconst bounds = path.bounds;\n\tif (!bounds) return null;\n\n\tconst width = Math.ceil((bounds.xMax - bounds.xMin) * scale);\n\tconst height = Math.ceil((bounds.yMax - bounds.yMin) * scale);\n\tconst viewBox = `${bounds.xMin} ${-bounds.yMax} ${bounds.xMax - bounds.xMin} ${bounds.yMax - bounds.yMin}`;\n\n\tconst pathData = pathToSVG(path, { flipY: true, scale: 1 });\n\n\treturn `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${width}\" height=\"${height}\" viewBox=\"${viewBox}\">\n  <path d=\"${pathData}\" fill=\"${fill}\"/>\n</svg>`;\n}\n\n/**\n * Render shaped text to Canvas\n */\nexport interface ShapedGlyph {\n\tglyphId: GlyphId;\n\txOffset: number;\n\tyOffset: number;\n\txAdvance: number;\n\tyAdvance: number;\n}\n\nexport function renderShapedText(\n\tctx: CanvasRenderingContext2D,\n\tfont: Font,\n\tglyphs: ShapedGlyph[],\n\toptions?: { fontSize?: number; x?: number; y?: number; fill?: string },\n): void {\n\tconst fontSize = options?.fontSize ?? 16;\n\tconst startX = options?.x ?? 0;\n\tconst startY = options?.y ?? 0;\n\tconst fill = options?.fill ?? \"black\";\n\n\tconst scale = fontSize / font.unitsPerEm;\n\n\tctx.fillStyle = fill;\n\n\tlet x = startX;\n\tlet y = startY;\n\n\tfor (const glyph of glyphs) {\n\t\tconst path = getGlyphPath(font, glyph.glyphId);\n\t\tif (path) {\n\t\t\tctx.beginPath();\n\t\t\tpathToCanvas(ctx, path, {\n\t\t\t\tscale,\n\t\t\t\tflipY: true,\n\t\t\t\toffsetX: x + glyph.xOffset * scale,\n\t\t\t\toffsetY: y - glyph.yOffset * scale,\n\t\t\t});\n\t\t\tctx.fill();\n\t\t}\n\n\t\tx += glyph.xAdvance * scale;\n\t\ty += glyph.yAdvance * scale;\n\t}\n}\n\n/**\n * Generate SVG for shaped text\n */\nexport function shapedTextToSVG(\n\tfont: Font,\n\tglyphs: ShapedGlyph[],\n\toptions?: { fontSize?: number; fill?: string },\n): string {\n\tconst fontSize = options?.fontSize ?? 100;\n\tconst fill = options?.fill ?? \"currentColor\";\n\tconst scale = fontSize / font.unitsPerEm;\n\n\tconst paths: string[] = [];\n\tlet x = 0;\n\tlet y = 0;\n\tlet minX = Infinity;\n\tlet maxX = -Infinity;\n\tlet minY = Infinity;\n\tlet maxY = -Infinity;\n\n\tfor (const glyph of glyphs) {\n\t\tconst path = getGlyphPath(font, glyph.glyphId);\n\t\tif (path?.bounds) {\n\t\t\tconst offsetX = x + glyph.xOffset * scale;\n\t\t\tconst offsetY = y - glyph.yOffset * scale;\n\n\t\t\t// Transform commands with offset\n\t\t\tconst transformedCommands = path.commands.map((cmd): PathCommand => {\n\t\t\t\tswitch (cmd.type) {\n\t\t\t\t\tcase \"M\":\n\t\t\t\t\tcase \"L\":\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: cmd.type,\n\t\t\t\t\t\t\tx: cmd.x * scale + offsetX,\n\t\t\t\t\t\t\ty: -cmd.y * scale + offsetY,\n\t\t\t\t\t\t};\n\t\t\t\t\tcase \"Q\":\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: \"Q\",\n\t\t\t\t\t\t\tx1: cmd.x1 * scale + offsetX,\n\t\t\t\t\t\t\ty1: -cmd.y1 * scale + offsetY,\n\t\t\t\t\t\t\tx: cmd.x * scale + offsetX,\n\t\t\t\t\t\t\ty: -cmd.y * scale + offsetY,\n\t\t\t\t\t\t};\n\t\t\t\t\tcase \"C\":\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: \"C\",\n\t\t\t\t\t\t\tx1: cmd.x1 * scale + offsetX,\n\t\t\t\t\t\t\ty1: -cmd.y1 * scale + offsetY,\n\t\t\t\t\t\t\tx2: cmd.x2 * scale + offsetX,\n\t\t\t\t\t\t\ty2: -cmd.y2 * scale + offsetY,\n\t\t\t\t\t\t\tx: cmd.x * scale + offsetX,\n\t\t\t\t\t\t\ty: -cmd.y * scale + offsetY,\n\t\t\t\t\t\t};\n\t\t\t\t\tcase \"Z\":\n\t\t\t\t\t\treturn { type: \"Z\" };\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn cmd;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconst pathStr = pathToSVG(\n\t\t\t\t{ commands: transformedCommands, bounds: null },\n\t\t\t\t{ flipY: false, scale: 1 },\n\t\t\t);\n\t\t\tpaths.push(pathStr);\n\n\t\t\t// Update bounds\n\t\t\tconst b = path.bounds;\n\t\t\tminX = Math.min(minX, offsetX + b.xMin * scale);\n\t\t\tmaxX = Math.max(maxX, offsetX + b.xMax * scale);\n\t\t\tminY = Math.min(minY, offsetY - b.yMax * scale);\n\t\t\tmaxY = Math.max(maxY, offsetY - b.yMin * scale);\n\t\t}\n\n\t\tx += glyph.xAdvance * scale;\n\t\ty += glyph.yAdvance * scale;\n\t}\n\n\tif (paths.length === 0) {\n\t\treturn '<svg xmlns=\"http://www.w3.org/2000/svg\"></svg>';\n\t}\n\n\tconst width = Math.ceil(maxX - minX);\n\tconst height = Math.ceil(maxY - minY);\n\tconst viewBox = `${Math.floor(minX)} ${Math.floor(minY)} ${width} ${height}`;\n\n\treturn `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${width}\" height=\"${height}\" viewBox=\"${viewBox}\">\n  <path d=\"${paths.join(\" \")}\" fill=\"${fill}\"/>\n</svg>`;\n}\n\n/**\n * Convert GlyphBuffer output to ShapedGlyph array\n */\nexport function glyphBufferToShapedGlyphs(buffer: GlyphBuffer): ShapedGlyph[] {\n\tconst result: ShapedGlyph[] = [];\n\tfor (const [i, info] of buffer.infos.entries()) {\n\t\tconst pos = buffer.positions[i];\n\t\tif (!pos) continue;\n\t\tresult.push({\n\t\t\tglyphId: info.glyphId,\n\t\t\txOffset: pos.xOffset,\n\t\t\tyOffset: pos.yOffset,\n\t\t\txAdvance: pos.xAdvance,\n\t\t\tyAdvance: pos.yAdvance,\n\t\t});\n\t}\n\treturn result;\n}\n\n/**\n * Get glyph path with variable font variation applied\n */\nexport function getGlyphPathWithVariation(\n\tfont: Font,\n\tglyphId: GlyphId,\n\taxisCoords: number[],\n): GlyphPath | null {\n\tconst contours = font.getGlyphContoursWithVariation(glyphId, axisCoords);\n\tif (!contours) return null;\n\n\tconst commands: PathCommand[] = [];\n\tfor (const contour of contours) {\n\t\tcommands.push(...contourToPath(contour));\n\t}\n\n\tconst bounds = font.getGlyphBounds(glyphId);\n\n\treturn { commands, bounds };\n}\n\n/**\n * Render shaped text with variable font support\n */\nexport function renderShapedTextWithVariation(\n\tctx: CanvasRenderingContext2D,\n\tfont: Font,\n\tglyphs: ShapedGlyph[],\n\taxisCoords: number[],\n\toptions?: { fontSize?: number; x?: number; y?: number; fill?: string },\n): void {\n\tconst fontSize = options?.fontSize ?? 16;\n\tconst startX = options?.x ?? 0;\n\tconst startY = options?.y ?? 0;\n\tconst fill = options?.fill ?? \"black\";\n\n\tconst scale = fontSize / font.unitsPerEm;\n\n\tctx.fillStyle = fill;\n\n\tlet x = startX;\n\tlet y = startY;\n\n\tfor (const glyph of glyphs) {\n\t\tconst path = getGlyphPathWithVariation(font, glyph.glyphId, axisCoords);\n\t\tif (path) {\n\t\t\tctx.beginPath();\n\t\t\tpathToCanvas(ctx, path, {\n\t\t\t\tscale,\n\t\t\t\tflipY: true,\n\t\t\t\toffsetX: x + glyph.xOffset * scale,\n\t\t\t\toffsetY: y - glyph.yOffset * scale,\n\t\t\t});\n\t\t\tctx.fill();\n\t\t}\n\n\t\tx += glyph.xAdvance * scale;\n\t\ty += glyph.yAdvance * scale;\n\t}\n}\n\n/**\n * Generate SVG for shaped text with variable font support\n */\nexport function shapedTextToSVGWithVariation(\n\tfont: Font,\n\tglyphs: ShapedGlyph[],\n\taxisCoords: number[],\n\toptions?: { fontSize?: number; fill?: string },\n): string {\n\tconst fontSize = options?.fontSize ?? 100;\n\tconst fill = options?.fill ?? \"currentColor\";\n\tconst scale = fontSize / font.unitsPerEm;\n\n\tconst paths: string[] = [];\n\tlet x = 0;\n\tlet y = 0;\n\tlet minX = Infinity;\n\tlet maxX = -Infinity;\n\tlet minY = Infinity;\n\tlet maxY = -Infinity;\n\n\tfor (const glyph of glyphs) {\n\t\tconst path = getGlyphPathWithVariation(font, glyph.glyphId, axisCoords);\n\t\tif (path?.bounds) {\n\t\t\tconst offsetX = x + glyph.xOffset * scale;\n\t\t\tconst offsetY = y - glyph.yOffset * scale;\n\n\t\t\tconst transformedCommands = path.commands.map((cmd): PathCommand => {\n\t\t\t\tswitch (cmd.type) {\n\t\t\t\t\tcase \"M\":\n\t\t\t\t\tcase \"L\":\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: cmd.type,\n\t\t\t\t\t\t\tx: cmd.x * scale + offsetX,\n\t\t\t\t\t\t\ty: -cmd.y * scale + offsetY,\n\t\t\t\t\t\t};\n\t\t\t\t\tcase \"Q\":\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: \"Q\",\n\t\t\t\t\t\t\tx1: cmd.x1 * scale + offsetX,\n\t\t\t\t\t\t\ty1: -cmd.y1 * scale + offsetY,\n\t\t\t\t\t\t\tx: cmd.x * scale + offsetX,\n\t\t\t\t\t\t\ty: -cmd.y * scale + offsetY,\n\t\t\t\t\t\t};\n\t\t\t\t\tcase \"C\":\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: \"C\",\n\t\t\t\t\t\t\tx1: cmd.x1 * scale + offsetX,\n\t\t\t\t\t\t\ty1: -cmd.y1 * scale + offsetY,\n\t\t\t\t\t\t\tx2: cmd.x2 * scale + offsetX,\n\t\t\t\t\t\t\ty2: -cmd.y2 * scale + offsetY,\n\t\t\t\t\t\t\tx: cmd.x * scale + offsetX,\n\t\t\t\t\t\t\ty: -cmd.y * scale + offsetY,\n\t\t\t\t\t\t};\n\t\t\t\t\tcase \"Z\":\n\t\t\t\t\t\treturn { type: \"Z\" };\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn cmd;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconst pathStr = pathToSVG(\n\t\t\t\t{ commands: transformedCommands, bounds: null },\n\t\t\t\t{ flipY: false, scale: 1 },\n\t\t\t);\n\t\t\tpaths.push(pathStr);\n\n\t\t\tconst b = path.bounds;\n\t\t\tminX = Math.min(minX, offsetX + b.xMin * scale);\n\t\t\tmaxX = Math.max(maxX, offsetX + b.xMax * scale);\n\t\t\tminY = Math.min(minY, offsetY - b.yMax * scale);\n\t\t\tmaxY = Math.max(maxY, offsetY - b.yMin * scale);\n\t\t}\n\n\t\tx += glyph.xAdvance * scale;\n\t\ty += glyph.yAdvance * scale;\n\t}\n\n\tif (paths.length === 0) {\n\t\treturn '<svg xmlns=\"http://www.w3.org/2000/svg\"></svg>';\n\t}\n\n\tconst width = Math.ceil(maxX - minX);\n\tconst height = Math.ceil(maxY - minY);\n\tconst viewBox = `${Math.floor(minX)} ${Math.floor(minY)} ${width} ${height}`;\n\n\treturn `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${width}\" height=\"${height}\" viewBox=\"${viewBox}\">\n  <path d=\"${paths.join(\" \")}\" fill=\"${fill}\"/>\n</svg>`;\n}\n\n/**\n * Calculate the total advance width of shaped text\n */\nexport function getTextWidth(\n\tglyphs: ShapedGlyph[],\n\tfont: Font,\n\tfontSize: number,\n): number {\n\tconst scale = fontSize / font.unitsPerEm;\n\tlet width = 0;\n\tfor (const glyph of glyphs) {\n\t\twidth += glyph.xAdvance;\n\t}\n\treturn width * scale;\n}\n\n/**\n * Create a Path2D object from glyph path\n */\nexport function createPath2D(\n\tpath: GlyphPath,\n\toptions?: {\n\t\tflipY?: boolean;\n\t\tscale?: number;\n\t\toffsetX?: number;\n\t\toffsetY?: number;\n\t},\n): Path2D {\n\tconst p = new Path2D();\n\tpathToCanvas(p, path, options);\n\treturn p;\n}\n", "import type { GlyphInfo } from \"../types.ts\";\n\n/**\n * Normalization mode for shaping\n */\nexport enum NormalizationMode {\n\t/** No normalization */\n\tNone = 0,\n\t/** Decompose (NFD-like) */\n\tDecompose = 1,\n\t/** Compose (NFC-like) */\n\tCompose = 2,\n\t/** Auto-detect based on script */\n\tAuto = 3,\n}\n\n/**\n * Canonical Combining Class (ccc) for combining marks\n * Based on Unicode 15.0\n */\nexport function getCombiningClass(cp: number): number {\n\t// Common combining classes\n\t// 0 = Not_Reordered (base characters, most characters)\n\t// 1 = Overlay\n\t// 7 = Nukta\n\t// 8 = Kana_Voicing\n\t// 9 = Virama\n\t// 200-240 = Various marks\n\n\t// Hebrew combining marks (0591-05BD, 05BF, 05C1-05C2, 05C4-05C5, 05C7)\n\tif (cp >= 0x0591 && cp <= 0x05bd) return getHebrewCcc(cp);\n\tif (cp === 0x05bf) return 23;\n\tif (cp === 0x05c1) return 24;\n\tif (cp === 0x05c2) return 25;\n\tif (cp === 0x05c4) return 230;\n\tif (cp === 0x05c5) return 220;\n\tif (cp === 0x05c7) return 18;\n\n\t// Arabic combining marks (064B-065F, 0670)\n\tif (cp >= 0x064b && cp <= 0x065f) return getArabicCcc(cp);\n\tif (cp === 0x0670) return 35;\n\t// Extended Arabic marks\n\tif (cp >= 0x0610 && cp <= 0x061a) return 230;\n\tif (cp >= 0x06d6 && cp <= 0x06dc) return 230;\n\tif (cp >= 0x06df && cp <= 0x06e4) return 230;\n\tif (cp >= 0x06e7 && cp <= 0x06e8) return 230;\n\tif (cp >= 0x06ea && cp <= 0x06ed) return 220;\n\tif (cp === 0x08d4) return 230;\n\tif (cp >= 0x08e3 && cp <= 0x08ff) return 220;\n\n\t// Devanagari nukta and signs\n\tif (cp === 0x093c) return 7; // Nukta\n\tif (cp === 0x094d) return 9; // Virama\n\tif (cp >= 0x0951 && cp <= 0x0954) return 230; // Accent marks\n\tif (cp === 0x0955) return 0;\n\tif (cp >= 0x0956 && cp <= 0x0957) return 0;\n\n\t// Bengali nukta and virama\n\tif (cp === 0x09bc) return 7;\n\tif (cp === 0x09cd) return 9;\n\tif (cp === 0x09fe) return 230;\n\n\t// Gurmukhi\n\tif (cp === 0x0a3c) return 7; // Nukta\n\tif (cp === 0x0a4d) return 9; // Virama\n\n\t// Gujarati\n\tif (cp === 0x0abc) return 7; // Nukta\n\tif (cp === 0x0acd) return 9; // Virama\n\n\t// Oriya\n\tif (cp === 0x0b3c) return 7; // Nukta\n\tif (cp === 0x0b4d) return 9; // Virama\n\n\t// Tamil\n\tif (cp === 0x0bcd) return 9; // Virama\n\n\t// Telugu\n\tif (cp === 0x0c4d) return 9; // Virama\n\tif (cp === 0x0c55) return 84;\n\tif (cp === 0x0c56) return 91;\n\n\t// Kannada\n\tif (cp === 0x0cbc) return 7; // Nukta\n\tif (cp === 0x0ccd) return 9; // Virama\n\n\t// Malayalam\n\tif (cp === 0x0d4d) return 9; // Virama\n\n\t// Sinhala\n\tif (cp === 0x0dca) return 9; // Virama\n\n\t// Thai/Lao vowels and tone marks\n\tif (cp >= 0x0e31 && cp <= 0x0e3a) return 0; // Positioned, not reordered\n\tif (cp >= 0x0e47 && cp <= 0x0e4e) return getThaiCcc(cp);\n\tif (cp >= 0x0eb1 && cp <= 0x0ebc) return 0;\n\tif (cp >= 0x0ec8 && cp <= 0x0ecd) return getThaiCcc(cp);\n\n\t// Tibetan\n\tif (cp >= 0x0f18 && cp <= 0x0f19) return 220;\n\tif (cp === 0x0f35) return 220;\n\tif (cp === 0x0f37) return 220;\n\tif (cp === 0x0f39) return 216;\n\tif (cp >= 0x0f71 && cp <= 0x0f7e) return getTibetanCcc(cp);\n\tif (cp >= 0x0f80 && cp <= 0x0f84) return getTibetanCcc(cp);\n\tif (cp >= 0x0f86 && cp <= 0x0f87) return 230;\n\n\t// Myanmar\n\tif (cp === 0x1037) return 7; // Nukta\n\tif (cp === 0x1039) return 9; // Virama\n\tif (cp === 0x103a) return 9;\n\n\t// Hangul Jamo (combining)\n\tif (cp >= 0x302a && cp <= 0x302f) return getHangulCcc(cp);\n\tif (cp >= 0x3099 && cp <= 0x309a) return 8; // Kana voicing\n\n\t// General combining marks (0300-036F)\n\tif (cp >= 0x0300 && cp <= 0x036f) return getLatinCcc(cp);\n\n\t// Combining Diacritical Marks Extended (1AB0-1AFF)\n\tif (cp >= 0x1ab0 && cp <= 0x1aff) return getCdmeClass(cp);\n\n\t// Combining Diacritical Marks Supplement (1DC0-1DFF)\n\tif (cp >= 0x1dc0 && cp <= 0x1dff) return getCdmsClass(cp);\n\n\t// Combining Half Marks (FE20-FE2F)\n\tif (cp >= 0xfe20 && cp <= 0xfe2f) return 230;\n\n\treturn 0;\n}\n\nfunction getThaiCcc(cp: number): number {\n\t// Thai tone marks and vowel signs above\n\tif (cp >= 0x0e48 && cp <= 0x0e4b) return 107; // Tone marks\n\tif (cp === 0x0e4c) return 0; // Thanthakhat\n\tif (cp === 0x0e4d) return 0; // Nikhahit\n\tif (cp === 0x0e4e) return 0; // Yamakkan\n\t// Lao tone marks\n\tif (cp >= 0x0ec8 && cp <= 0x0ecb) return 122;\n\treturn 0;\n}\n\nfunction getTibetanCcc(cp: number): number {\n\tif (cp === 0x0f71) return 129;\n\tif (cp === 0x0f72) return 130;\n\tif (cp === 0x0f73) return 0; // Composed\n\tif (cp === 0x0f74) return 132;\n\tif (cp === 0x0f75) return 0; // Composed\n\tif (cp === 0x0f76) return 0; // Composed\n\tif (cp === 0x0f77) return 0; // Composed\n\tif (cp === 0x0f78) return 0; // Composed\n\tif (cp === 0x0f79) return 0; // Composed\n\tif (cp === 0x0f7a) return 130;\n\tif (cp === 0x0f7b) return 130;\n\tif (cp === 0x0f7c) return 130;\n\tif (cp === 0x0f7d) return 130;\n\tif (cp === 0x0f7e) return 0;\n\tif (cp === 0x0f80) return 130;\n\tif (cp === 0x0f81) return 0; // Composed\n\tif (cp === 0x0f82) return 230;\n\tif (cp === 0x0f83) return 230;\n\tif (cp === 0x0f84) return 9;\n\treturn 0;\n}\n\nfunction getHangulCcc(cp: number): number {\n\tif (cp === 0x302a) return 218;\n\tif (cp === 0x302b) return 228;\n\tif (cp === 0x302c) return 232;\n\tif (cp === 0x302d) return 222;\n\tif (cp === 0x302e) return 224;\n\tif (cp === 0x302f) return 224;\n\treturn 0;\n}\n\nfunction getCdmeClass(cp: number): number {\n\t// Combining Diacritical Marks Extended\n\tif (cp >= 0x1ab0 && cp <= 0x1abe) return 230;\n\tif (cp === 0x1abf) return 220;\n\tif (cp === 0x1ac0) return 220;\n\treturn 230;\n}\n\nfunction getCdmsClass(cp: number): number {\n\t// Combining Diacritical Marks Supplement\n\tif (cp >= 0x1dc0 && cp <= 0x1dc1) return 230;\n\tif (cp === 0x1dc2) return 220;\n\tif (cp >= 0x1dc3 && cp <= 0x1dca) return 230;\n\tif (cp === 0x1dcb) return 230;\n\tif (cp === 0x1dcc) return 230;\n\tif (cp === 0x1dcd) return 234;\n\tif (cp === 0x1dce) return 214;\n\tif (cp === 0x1dcf) return 220;\n\tif (cp === 0x1dd0) return 202;\n\tif (cp >= 0x1dd1 && cp <= 0x1df5) return 230;\n\tif (cp >= 0x1df6 && cp <= 0x1df8) return 232;\n\tif (cp === 0x1df9) return 220;\n\tif (cp === 0x1dfa) return 218;\n\tif (cp >= 0x1dfb && cp <= 0x1dff) return 230;\n\treturn 230;\n}\n\nfunction getHebrewCcc(cp: number): number {\n\t// Hebrew accents and marks have specific combining classes\n\tif (cp >= 0x0591 && cp <= 0x05a1) return 220; // Below marks\n\tif (cp >= 0x05a2 && cp <= 0x05af) return 230; // Above marks\n\tif (cp >= 0x05b0 && cp <= 0x05b9) {\n\t\t// Vowel points\n\t\tif (cp === 0x05b0) return 10; // Sheva\n\t\tif (cp === 0x05b1) return 11; // Hataf Segol\n\t\tif (cp === 0x05b2) return 12; // Hataf Patah\n\t\tif (cp === 0x05b3) return 13; // Hataf Qamats\n\t\tif (cp === 0x05b4) return 14; // Hiriq\n\t\tif (cp === 0x05b5) return 15; // Tsere\n\t\tif (cp === 0x05b6) return 16; // Segol\n\t\tif (cp === 0x05b7) return 17; // Patah\n\t\tif (cp === 0x05b8) return 18; // Qamats\n\t\tif (cp === 0x05b9) return 19; // Holam\n\t}\n\tif (cp === 0x05ba) return 19; // Holam Haser\n\tif (cp === 0x05bb) return 20; // Qubuts\n\tif (cp === 0x05bc) return 21; // Dagesh\n\tif (cp === 0x05bd) return 22; // Meteg\n\treturn 0;\n}\n\nfunction getArabicCcc(cp: number): number {\n\tif (cp === 0x064b) return 27; // Fathatan\n\tif (cp === 0x064c) return 28; // Dammatan\n\tif (cp === 0x064d) return 29; // Kasratan\n\tif (cp === 0x064e) return 30; // Fatha\n\tif (cp === 0x064f) return 31; // Damma\n\tif (cp === 0x0650) return 32; // Kasra\n\tif (cp === 0x0651) return 33; // Shadda\n\tif (cp === 0x0652) return 34; // Sukun\n\tif (cp >= 0x0653 && cp <= 0x0655) return 230; // Maddah, Hamza above\n\tif (cp === 0x0656) return 220; // Subscript Alef\n\tif (cp === 0x0657) return 230; // Inverted Damma\n\tif (cp === 0x0658) return 230; // Mark Noon Ghunna\n\tif (cp >= 0x0659 && cp <= 0x065f) return 230;\n\treturn 0;\n}\n\nfunction getLatinCcc(cp: number): number {\n\t// Combining diacritical marks\n\tif (cp >= 0x0300 && cp <= 0x0314) return 230; // Above marks\n\tif (cp >= 0x0315 && cp <= 0x0315) return 232; // Above right\n\tif (cp >= 0x0316 && cp <= 0x0319) return 220; // Below marks\n\tif (cp >= 0x031a && cp <= 0x031a) return 232; // Above right\n\tif (cp >= 0x031b && cp <= 0x031b) return 216; // Attached above right\n\tif (cp >= 0x031c && cp <= 0x0320) return 220; // Below\n\tif (cp >= 0x0321 && cp <= 0x0322) return 202; // Attached below\n\tif (cp >= 0x0323 && cp <= 0x0326) return 220; // Below\n\tif (cp >= 0x0327 && cp <= 0x0328) return 202; // Attached below\n\tif (cp >= 0x0329 && cp <= 0x0333) return 220; // Below\n\tif (cp >= 0x0334 && cp <= 0x0338) return 1; // Overlay\n\tif (cp >= 0x0339 && cp <= 0x033c) return 220; // Below\n\tif (cp >= 0x033d && cp <= 0x0344) return 230; // Above\n\tif (cp === 0x0345) return 240; // Iota subscript\n\tif (cp >= 0x0346 && cp <= 0x034e) return 230; // Above\n\tif (cp === 0x034f) return 0; // CGJ\n\tif (cp >= 0x0350 && cp <= 0x0352) return 230; // Above\n\tif (cp >= 0x0353 && cp <= 0x0356) return 220; // Below\n\tif (cp >= 0x0357 && cp <= 0x0358) return 230; // Above\n\tif (cp >= 0x0359 && cp <= 0x035a) return 220; // Below\n\tif (cp >= 0x035b && cp <= 0x035b) return 230; // Above\n\tif (cp >= 0x035c && cp <= 0x035c) return 233; // Double below\n\tif (cp >= 0x035d && cp <= 0x035e) return 234; // Double above\n\tif (cp >= 0x035f && cp <= 0x035f) return 233; // Double below\n\tif (cp >= 0x0360 && cp <= 0x0361) return 234; // Double above\n\tif (cp >= 0x0362 && cp <= 0x0362) return 233; // Double below\n\tif (cp >= 0x0363 && cp <= 0x036f) return 230; // Above\n\treturn 0;\n}\n\n/**\n * Reorder combining marks according to canonical combining class\n */\nexport function reorderMarks(infos: GlyphInfo[]): void {\n\t// Simple bubble sort for stability (marks with same ccc keep order)\n\tconst n = infos.length;\n\tlet i = 1;\n\n\twhile (i < n) {\n\t\tconst info = infos[i];\n\t\tif (!info) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst ccc = getCombiningClass(info.codepoint);\n\t\tif (ccc === 0) {\n\t\t\t// Non-combining, advance\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Look backward for marks to reorder with\n\t\tlet j = i;\n\t\twhile (j > 0) {\n\t\t\tconst prevInfo = infos[j - 1];\n\t\t\tif (!prevInfo) break;\n\n\t\t\tconst prevCcc = getCombiningClass(prevInfo.codepoint);\n\t\t\tif (prevCcc === 0) break; // Hit a base character\n\t\t\tif (prevCcc <= ccc) break; // Already in order\n\n\t\t\t// Swap\n\t\t\tinfos[j] = prevInfo;\n\t\t\tinfos[j - 1] = info;\n\t\t\tj--;\n\t\t}\n\n\t\ti++;\n\t}\n}\n\n/**\n * Common decomposition mappings (subset of Unicode decomposition)\n */\nconst DECOMPOSITIONS: Map<number, number[]> = new Map([\n\t// Latin precomposed characters (Latin-1 Supplement)\n\t[0x00c0, [0x0041, 0x0300]], //  = A + grave\n\t[0x00c1, [0x0041, 0x0301]], //  = A + acute\n\t[0x00c2, [0x0041, 0x0302]], //  = A + circumflex\n\t[0x00c3, [0x0041, 0x0303]], //  = A + tilde\n\t[0x00c4, [0x0041, 0x0308]], //  = A + diaeresis\n\t[0x00c5, [0x0041, 0x030a]], //  = A + ring\n\t[0x00c7, [0x0043, 0x0327]], //  = C + cedilla\n\t[0x00c8, [0x0045, 0x0300]], //  = E + grave\n\t[0x00c9, [0x0045, 0x0301]], //  = E + acute\n\t[0x00ca, [0x0045, 0x0302]], //  = E + circumflex\n\t[0x00cb, [0x0045, 0x0308]], //  = E + diaeresis\n\t[0x00cc, [0x0049, 0x0300]], //  = I + grave\n\t[0x00cd, [0x0049, 0x0301]], //  = I + acute\n\t[0x00ce, [0x0049, 0x0302]], //  = I + circumflex\n\t[0x00cf, [0x0049, 0x0308]], //  = I + diaeresis\n\t[0x00d1, [0x004e, 0x0303]], //  = N + tilde\n\t[0x00d2, [0x004f, 0x0300]], //  = O + grave\n\t[0x00d3, [0x004f, 0x0301]], //  = O + acute\n\t[0x00d4, [0x004f, 0x0302]], //  = O + circumflex\n\t[0x00d5, [0x004f, 0x0303]], //  = O + tilde\n\t[0x00d6, [0x004f, 0x0308]], //  = O + diaeresis\n\t[0x00d9, [0x0055, 0x0300]], //  = U + grave\n\t[0x00da, [0x0055, 0x0301]], //  = U + acute\n\t[0x00db, [0x0055, 0x0302]], //  = U + circumflex\n\t[0x00dc, [0x0055, 0x0308]], //  = U + diaeresis\n\t[0x00dd, [0x0059, 0x0301]], //  = Y + acute\n\t// Lowercase Latin-1\n\t[0x00e0, [0x0061, 0x0300]], //  = a + grave\n\t[0x00e1, [0x0061, 0x0301]], //  = a + acute\n\t[0x00e2, [0x0061, 0x0302]], //  = a + circumflex\n\t[0x00e3, [0x0061, 0x0303]], //  = a + tilde\n\t[0x00e4, [0x0061, 0x0308]], //  = a + diaeresis\n\t[0x00e5, [0x0061, 0x030a]], //  = a + ring\n\t[0x00e7, [0x0063, 0x0327]], //  = c + cedilla\n\t[0x00e8, [0x0065, 0x0300]], //  = e + grave\n\t[0x00e9, [0x0065, 0x0301]], //  = e + acute\n\t[0x00ea, [0x0065, 0x0302]], //  = e + circumflex\n\t[0x00eb, [0x0065, 0x0308]], //  = e + diaeresis\n\t[0x00ec, [0x0069, 0x0300]], //  = i + grave\n\t[0x00ed, [0x0069, 0x0301]], //  = i + acute\n\t[0x00ee, [0x0069, 0x0302]], //  = i + circumflex\n\t[0x00ef, [0x0069, 0x0308]], //  = i + diaeresis\n\t[0x00f1, [0x006e, 0x0303]], //  = n + tilde\n\t[0x00f2, [0x006f, 0x0300]], //  = o + grave\n\t[0x00f3, [0x006f, 0x0301]], //  = o + acute\n\t[0x00f4, [0x006f, 0x0302]], //  = o + circumflex\n\t[0x00f5, [0x006f, 0x0303]], //  = o + tilde\n\t[0x00f6, [0x006f, 0x0308]], //  = o + diaeresis\n\t[0x00f9, [0x0075, 0x0300]], //  = u + grave\n\t[0x00fa, [0x0075, 0x0301]], //  = u + acute\n\t[0x00fb, [0x0075, 0x0302]], //  = u + circumflex\n\t[0x00fc, [0x0075, 0x0308]], //  = u + diaeresis\n\t[0x00fd, [0x0079, 0x0301]], //  = y + acute\n\t[0x00ff, [0x0079, 0x0308]], //  = y + diaeresis\n\t// Latin Extended-A\n\t[0x0100, [0x0041, 0x0304]], //  = A + macron\n\t[0x0101, [0x0061, 0x0304]], //  = a + macron\n\t[0x0102, [0x0041, 0x0306]], //  = A + breve\n\t[0x0103, [0x0061, 0x0306]], //  = a + breve\n\t[0x0104, [0x0041, 0x0328]], //  = A + ogonek\n\t[0x0105, [0x0061, 0x0328]], //  = a + ogonek\n\t[0x0106, [0x0043, 0x0301]], //  = C + acute\n\t[0x0107, [0x0063, 0x0301]], //  = c + acute\n\t[0x0108, [0x0043, 0x0302]], //  = C + circumflex\n\t[0x0109, [0x0063, 0x0302]], //  = c + circumflex\n\t[0x010a, [0x0043, 0x0307]], //  = C + dot above\n\t[0x010b, [0x0063, 0x0307]], //  = c + dot above\n\t[0x010c, [0x0043, 0x030c]], //  = C + caron\n\t[0x010d, [0x0063, 0x030c]], //  = c + caron\n\t[0x010e, [0x0044, 0x030c]], //  = D + caron\n\t[0x010f, [0x0064, 0x030c]], //  = d + caron\n\t[0x0112, [0x0045, 0x0304]], //  = E + macron\n\t[0x0113, [0x0065, 0x0304]], //  = e + macron\n\t[0x0114, [0x0045, 0x0306]], //  = E + breve\n\t[0x0115, [0x0065, 0x0306]], //  = e + breve\n\t[0x0116, [0x0045, 0x0307]], //  = E + dot above\n\t[0x0117, [0x0065, 0x0307]], //  = e + dot above\n\t[0x0118, [0x0045, 0x0328]], //  = E + ogonek\n\t[0x0119, [0x0065, 0x0328]], //  = e + ogonek\n\t[0x011a, [0x0045, 0x030c]], //  = E + caron\n\t[0x011b, [0x0065, 0x030c]], //  = e + caron\n\t[0x011c, [0x0047, 0x0302]], //  = G + circumflex\n\t[0x011d, [0x0067, 0x0302]], //  = g + circumflex\n\t[0x011e, [0x0047, 0x0306]], //  = G + breve\n\t[0x011f, [0x0067, 0x0306]], //  = g + breve\n\t[0x0120, [0x0047, 0x0307]], //  = G + dot above\n\t[0x0121, [0x0067, 0x0307]], //  = g + dot above\n\t[0x0122, [0x0047, 0x0327]], //  = G + cedilla\n\t[0x0123, [0x0067, 0x0327]], //  = g + cedilla\n\t[0x0124, [0x0048, 0x0302]], //  = H + circumflex\n\t[0x0125, [0x0068, 0x0302]], //  = h + circumflex\n\t[0x0128, [0x0049, 0x0303]], //  = I + tilde\n\t[0x0129, [0x0069, 0x0303]], //  = i + tilde\n\t[0x012a, [0x0049, 0x0304]], //  = I + macron\n\t[0x012b, [0x0069, 0x0304]], //  = i + macron\n\t[0x012c, [0x0049, 0x0306]], //  = I + breve\n\t[0x012d, [0x0069, 0x0306]], //  = i + breve\n\t[0x012e, [0x0049, 0x0328]], //  = I + ogonek\n\t[0x012f, [0x0069, 0x0328]], //  = i + ogonek\n\t[0x0130, [0x0049, 0x0307]], //  = I + dot above\n\t[0x0134, [0x004a, 0x0302]], //  = J + circumflex\n\t[0x0135, [0x006a, 0x0302]], //  = j + circumflex\n\t[0x0136, [0x004b, 0x0327]], //  = K + cedilla\n\t[0x0137, [0x006b, 0x0327]], //  = k + cedilla\n\t[0x0139, [0x004c, 0x0301]], //  = L + acute\n\t[0x013a, [0x006c, 0x0301]], //  = l + acute\n\t[0x013b, [0x004c, 0x0327]], //  = L + cedilla\n\t[0x013c, [0x006c, 0x0327]], //  = l + cedilla\n\t[0x013d, [0x004c, 0x030c]], //  = L + caron\n\t[0x013e, [0x006c, 0x030c]], //  = l + caron\n\t[0x0143, [0x004e, 0x0301]], //  = N + acute\n\t[0x0144, [0x006e, 0x0301]], //  = n + acute\n\t[0x0145, [0x004e, 0x0327]], //  = N + cedilla\n\t[0x0146, [0x006e, 0x0327]], //  = n + cedilla\n\t[0x0147, [0x004e, 0x030c]], //  = N + caron\n\t[0x0148, [0x006e, 0x030c]], //  = n + caron\n\t[0x014c, [0x004f, 0x0304]], //  = O + macron\n\t[0x014d, [0x006f, 0x0304]], //  = o + macron\n\t[0x014e, [0x004f, 0x0306]], //  = O + breve\n\t[0x014f, [0x006f, 0x0306]], //  = o + breve\n\t[0x0150, [0x004f, 0x030b]], //  = O + double acute\n\t[0x0151, [0x006f, 0x030b]], //  = o + double acute\n\t[0x0154, [0x0052, 0x0301]], //  = R + acute\n\t[0x0155, [0x0072, 0x0301]], //  = r + acute\n\t[0x0156, [0x0052, 0x0327]], //  = R + cedilla\n\t[0x0157, [0x0072, 0x0327]], //  = r + cedilla\n\t[0x0158, [0x0052, 0x030c]], //  = R + caron\n\t[0x0159, [0x0072, 0x030c]], //  = r + caron\n\t[0x015a, [0x0053, 0x0301]], //  = S + acute\n\t[0x015b, [0x0073, 0x0301]], //  = s + acute\n\t[0x015c, [0x0053, 0x0302]], //  = S + circumflex\n\t[0x015d, [0x0073, 0x0302]], //  = s + circumflex\n\t[0x015e, [0x0053, 0x0327]], //  = S + cedilla\n\t[0x015f, [0x0073, 0x0327]], //  = s + cedilla\n\t[0x0160, [0x0053, 0x030c]], //  = S + caron\n\t[0x0161, [0x0073, 0x030c]], //  = s + caron\n\t[0x0162, [0x0054, 0x0327]], //  = T + cedilla\n\t[0x0163, [0x0074, 0x0327]], //  = t + cedilla\n\t[0x0164, [0x0054, 0x030c]], //  = T + caron\n\t[0x0165, [0x0074, 0x030c]], //  = t + caron\n\t[0x0168, [0x0055, 0x0303]], //  = U + tilde\n\t[0x0169, [0x0075, 0x0303]], //  = u + tilde\n\t[0x016a, [0x0055, 0x0304]], //  = U + macron\n\t[0x016b, [0x0075, 0x0304]], //  = u + macron\n\t[0x016c, [0x0055, 0x0306]], //  = U + breve\n\t[0x016d, [0x0075, 0x0306]], //  = u + breve\n\t[0x016e, [0x0055, 0x030a]], //  = U + ring\n\t[0x016f, [0x0075, 0x030a]], //  = u + ring\n\t[0x0170, [0x0055, 0x030b]], //  = U + double acute\n\t[0x0171, [0x0075, 0x030b]], //  = u + double acute\n\t[0x0172, [0x0055, 0x0328]], //  = U + ogonek\n\t[0x0173, [0x0075, 0x0328]], //  = u + ogonek\n\t[0x0174, [0x0057, 0x0302]], //  = W + circumflex\n\t[0x0175, [0x0077, 0x0302]], //  = w + circumflex\n\t[0x0176, [0x0059, 0x0302]], //  = Y + circumflex\n\t[0x0177, [0x0079, 0x0302]], //  = y + circumflex\n\t[0x0178, [0x0059, 0x0308]], //  = Y + diaeresis\n\t[0x0179, [0x005a, 0x0301]], //  = Z + acute\n\t[0x017a, [0x007a, 0x0301]], //  = z + acute\n\t[0x017b, [0x005a, 0x0307]], //  = Z + dot above\n\t[0x017c, [0x007a, 0x0307]], //  = z + dot above\n\t[0x017d, [0x005a, 0x030c]], //  = Z + caron\n\t[0x017e, [0x007a, 0x030c]], //  = z + caron\n\t// Vietnamese characters (Latin Extended Additional)\n\t[0x1ea0, [0x0041, 0x0323]], //  = A + dot below\n\t[0x1ea1, [0x0061, 0x0323]], //  = a + dot below\n\t[0x1ea2, [0x0041, 0x0309]], //  = A + hook above\n\t[0x1ea3, [0x0061, 0x0309]], //  = a + hook above\n\t[0x1eb8, [0x0045, 0x0323]], //  = E + dot below\n\t[0x1eb9, [0x0065, 0x0323]], //  = e + dot below\n\t[0x1eba, [0x0045, 0x0309]], //  = E + hook above\n\t[0x1ebb, [0x0065, 0x0309]], //  = e + hook above\n\t[0x1ebc, [0x0045, 0x0303]], //  = E + tilde\n\t[0x1ebd, [0x0065, 0x0303]], //  = e + tilde\n\t[0x1ec8, [0x0049, 0x0309]], //  = I + hook above\n\t[0x1ec9, [0x0069, 0x0309]], //  = i + hook above\n\t[0x1eca, [0x0049, 0x0323]], //  = I + dot below\n\t[0x1ecb, [0x0069, 0x0323]], //  = i + dot below\n\t[0x1ecc, [0x004f, 0x0323]], //  = O + dot below\n\t[0x1ecd, [0x006f, 0x0323]], //  = o + dot below\n\t[0x1ece, [0x004f, 0x0309]], //  = O + hook above\n\t[0x1ecf, [0x006f, 0x0309]], //  = o + hook above\n\t[0x1ee4, [0x0055, 0x0323]], //  = U + dot below\n\t[0x1ee5, [0x0075, 0x0323]], //  = u + dot below\n\t[0x1ee6, [0x0055, 0x0309]], //  = U + hook above\n\t[0x1ee7, [0x0075, 0x0309]], //  = u + hook above\n\t[0x1ef2, [0x0059, 0x0300]], //  = Y + grave\n\t[0x1ef3, [0x0079, 0x0300]], //  = y + grave\n\t[0x1ef4, [0x0059, 0x0323]], //  = Y + dot below\n\t[0x1ef5, [0x0079, 0x0323]], //  = y + dot below\n\t[0x1ef6, [0x0059, 0x0309]], //  = Y + hook above\n\t[0x1ef7, [0x0079, 0x0309]], //  = y + hook above\n\t[0x1ef8, [0x0059, 0x0303]], //  = Y + tilde\n\t[0x1ef9, [0x0079, 0x0303]], //  = y + tilde\n\t// Greek Extended\n\t[0x1f00, [0x03b1, 0x0313]], //  =  + psili\n\t[0x1f01, [0x03b1, 0x0314]], //  =  + dasia\n\t[0x1f08, [0x0391, 0x0313]], //  =  + psili\n\t[0x1f09, [0x0391, 0x0314]], //  =  + dasia\n\t// Cyrillic (common)\n\t[0x0439, [0x0438, 0x0306]], //  =  + breve\n\t[0x0419, [0x0418, 0x0306]], //  =  + breve\n\t[0x0451, [0x0435, 0x0308]], //  =  + diaeresis\n\t[0x0401, [0x0415, 0x0308]], //  =  + diaeresis\n]);\n\n/**\n * Decompose a codepoint if it has a canonical decomposition\n */\nexport function decompose(cp: number): number[] | null {\n\treturn DECOMPOSITIONS.get(cp) ?? null;\n}\n\n/**\n * Common composition mappings (subset of Unicode canonical composition)\n * Maps (base, combining) pairs to composed character\n */\nconst COMPOSITIONS: Map<number, Map<number, number>> = new Map([\n\t// Latin A compositions\n\t[\n\t\t0x0041,\n\t\tnew Map([\n\t\t\t[0x0300, 0x00c0], // A + grave = \n\t\t\t[0x0301, 0x00c1], // A + acute = \n\t\t\t[0x0302, 0x00c2], // A + circumflex = \n\t\t\t[0x0303, 0x00c3], // A + tilde = \n\t\t\t[0x0308, 0x00c4], // A + diaeresis = \n\t\t\t[0x030a, 0x00c5], // A + ring = \n\t\t\t[0x0328, 0x0104], // A + ogonek = \n\t\t\t[0x030c, 0x01cd], // A + caron = \n\t\t\t[0x0304, 0x0100], // A + macron = \n\t\t\t[0x0306, 0x0102], // A + breve = \n\t\t]),\n\t],\n\t// Latin C compositions\n\t[\n\t\t0x0043,\n\t\tnew Map([\n\t\t\t[0x0327, 0x00c7], // C + cedilla = \n\t\t\t[0x0301, 0x0106], // C + acute = \n\t\t\t[0x0302, 0x0108], // C + circumflex = \n\t\t\t[0x030c, 0x010c], // C + caron = \n\t\t\t[0x0307, 0x010a], // C + dot above = \n\t\t]),\n\t],\n\t// Latin E compositions\n\t[\n\t\t0x0045,\n\t\tnew Map([\n\t\t\t[0x0300, 0x00c8], // E + grave = \n\t\t\t[0x0301, 0x00c9], // E + acute = \n\t\t\t[0x0302, 0x00ca], // E + circumflex = \n\t\t\t[0x0308, 0x00cb], // E + diaeresis = \n\t\t\t[0x0328, 0x0118], // E + ogonek = \n\t\t\t[0x030c, 0x011a], // E + caron = \n\t\t\t[0x0304, 0x0112], // E + macron = \n\t\t\t[0x0306, 0x0114], // E + breve = \n\t\t\t[0x0307, 0x0116], // E + dot above = \n\t\t]),\n\t],\n\t// Latin I compositions\n\t[\n\t\t0x0049,\n\t\tnew Map([\n\t\t\t[0x0300, 0x00cc], // I + grave = \n\t\t\t[0x0301, 0x00cd], // I + acute = \n\t\t\t[0x0302, 0x00ce], // I + circumflex = \n\t\t\t[0x0308, 0x00cf], // I + diaeresis = \n\t\t\t[0x0303, 0x0128], // I + tilde = \n\t\t\t[0x0304, 0x012a], // I + macron = \n\t\t\t[0x0306, 0x012c], // I + breve = \n\t\t\t[0x0328, 0x012e], // I + ogonek = \n\t\t\t[0x0307, 0x0130], // I + dot above = \n\t\t]),\n\t],\n\t// Latin N compositions\n\t[\n\t\t0x004e,\n\t\tnew Map([\n\t\t\t[0x0303, 0x00d1], // N + tilde = \n\t\t\t[0x0301, 0x0143], // N + acute = \n\t\t\t[0x0327, 0x0145], // N + cedilla = \n\t\t\t[0x030c, 0x0147], // N + caron = \n\t\t]),\n\t],\n\t// Latin O compositions\n\t[\n\t\t0x004f,\n\t\tnew Map([\n\t\t\t[0x0300, 0x00d2], // O + grave = \n\t\t\t[0x0301, 0x00d3], // O + acute = \n\t\t\t[0x0302, 0x00d4], // O + circumflex = \n\t\t\t[0x0303, 0x00d5], // O + tilde = \n\t\t\t[0x0308, 0x00d6], // O + diaeresis = \n\t\t\t[0x0304, 0x014c], // O + macron = \n\t\t\t[0x0306, 0x014e], // O + breve = \n\t\t\t[0x030b, 0x0150], // O + double acute = \n\t\t\t[0x0328, 0x01ea], // O + ogonek = \n\t\t]),\n\t],\n\t// Latin U compositions\n\t[\n\t\t0x0055,\n\t\tnew Map([\n\t\t\t[0x0300, 0x00d9], // U + grave = \n\t\t\t[0x0301, 0x00da], // U + acute = \n\t\t\t[0x0302, 0x00db], // U + circumflex = \n\t\t\t[0x0308, 0x00dc], // U + diaeresis = \n\t\t\t[0x0303, 0x0168], // U + tilde = \n\t\t\t[0x0304, 0x016a], // U + macron = \n\t\t\t[0x0306, 0x016c], // U + breve = \n\t\t\t[0x030a, 0x016e], // U + ring = \n\t\t\t[0x030b, 0x0170], // U + double acute = \n\t\t\t[0x0328, 0x0172], // U + ogonek = \n\t\t\t[0x030c, 0x01d3], // U + caron = \n\t\t]),\n\t],\n\t// Latin Y compositions\n\t[\n\t\t0x0059,\n\t\tnew Map([\n\t\t\t[0x0301, 0x00dd], // Y + acute = \n\t\t\t[0x0302, 0x0176], // Y + circumflex = \n\t\t\t[0x0308, 0x0178], // Y + diaeresis = \n\t\t]),\n\t],\n\t// Lowercase a compositions\n\t[\n\t\t0x0061,\n\t\tnew Map([\n\t\t\t[0x0300, 0x00e0], // a + grave = \n\t\t\t[0x0301, 0x00e1], // a + acute = \n\t\t\t[0x0302, 0x00e2], // a + circumflex = \n\t\t\t[0x0303, 0x00e3], // a + tilde = \n\t\t\t[0x0308, 0x00e4], // a + diaeresis = \n\t\t\t[0x030a, 0x00e5], // a + ring = \n\t\t\t[0x0328, 0x0105], // a + ogonek = \n\t\t\t[0x030c, 0x01ce], // a + caron = \n\t\t\t[0x0304, 0x0101], // a + macron = \n\t\t\t[0x0306, 0x0103], // a + breve = \n\t\t]),\n\t],\n\t// Lowercase c compositions\n\t[\n\t\t0x0063,\n\t\tnew Map([\n\t\t\t[0x0327, 0x00e7], // c + cedilla = \n\t\t\t[0x0301, 0x0107], // c + acute = \n\t\t\t[0x0302, 0x0109], // c + circumflex = \n\t\t\t[0x030c, 0x010d], // c + caron = \n\t\t\t[0x0307, 0x010b], // c + dot above = \n\t\t]),\n\t],\n\t// Lowercase e compositions\n\t[\n\t\t0x0065,\n\t\tnew Map([\n\t\t\t[0x0300, 0x00e8], // e + grave = \n\t\t\t[0x0301, 0x00e9], // e + acute = \n\t\t\t[0x0302, 0x00ea], // e + circumflex = \n\t\t\t[0x0308, 0x00eb], // e + diaeresis = \n\t\t\t[0x0328, 0x0119], // e + ogonek = \n\t\t\t[0x030c, 0x011b], // e + caron = \n\t\t\t[0x0304, 0x0113], // e + macron = \n\t\t\t[0x0306, 0x0115], // e + breve = \n\t\t\t[0x0307, 0x0117], // e + dot above = \n\t\t]),\n\t],\n\t// Lowercase i compositions\n\t[\n\t\t0x0069,\n\t\tnew Map([\n\t\t\t[0x0300, 0x00ec], // i + grave = \n\t\t\t[0x0301, 0x00ed], // i + acute = \n\t\t\t[0x0302, 0x00ee], // i + circumflex = \n\t\t\t[0x0308, 0x00ef], // i + diaeresis = \n\t\t\t[0x0303, 0x0129], // i + tilde = \n\t\t\t[0x0304, 0x012b], // i + macron = \n\t\t\t[0x0306, 0x012d], // i + breve = \n\t\t\t[0x0328, 0x012f], // i + ogonek = \n\t\t]),\n\t],\n\t// Lowercase n compositions\n\t[\n\t\t0x006e,\n\t\tnew Map([\n\t\t\t[0x0303, 0x00f1], // n + tilde = \n\t\t\t[0x0301, 0x0144], // n + acute = \n\t\t\t[0x0327, 0x0146], // n + cedilla = \n\t\t\t[0x030c, 0x0148], // n + caron = \n\t\t]),\n\t],\n\t// Lowercase o compositions\n\t[\n\t\t0x006f,\n\t\tnew Map([\n\t\t\t[0x0300, 0x00f2], // o + grave = \n\t\t\t[0x0301, 0x00f3], // o + acute = \n\t\t\t[0x0302, 0x00f4], // o + circumflex = \n\t\t\t[0x0303, 0x00f5], // o + tilde = \n\t\t\t[0x0308, 0x00f6], // o + diaeresis = \n\t\t\t[0x0304, 0x014d], // o + macron = \n\t\t\t[0x0306, 0x014f], // o + breve = \n\t\t\t[0x030b, 0x0151], // o + double acute = \n\t\t\t[0x0328, 0x01eb], // o + ogonek = \n\t\t]),\n\t],\n\t// Lowercase u compositions\n\t[\n\t\t0x0075,\n\t\tnew Map([\n\t\t\t[0x0300, 0x00f9], // u + grave = \n\t\t\t[0x0301, 0x00fa], // u + acute = \n\t\t\t[0x0302, 0x00fb], // u + circumflex = \n\t\t\t[0x0308, 0x00fc], // u + diaeresis = \n\t\t\t[0x0303, 0x0169], // u + tilde = \n\t\t\t[0x0304, 0x016b], // u + macron = \n\t\t\t[0x0306, 0x016d], // u + breve = \n\t\t\t[0x030a, 0x016f], // u + ring = \n\t\t\t[0x030b, 0x0171], // u + double acute = \n\t\t\t[0x0328, 0x0173], // u + ogonek = \n\t\t\t[0x030c, 0x01d4], // u + caron = \n\t\t]),\n\t],\n\t// Lowercase y compositions\n\t[\n\t\t0x0079,\n\t\tnew Map([\n\t\t\t[0x0301, 0x00fd], // y + acute = \n\t\t\t[0x0308, 0x00ff], // y + diaeresis = \n\t\t\t[0x0302, 0x0177], // y + circumflex = \n\t\t]),\n\t],\n\t// Other common compositions\n\t[\n\t\t0x0053,\n\t\tnew Map([\n\t\t\t// S\n\t\t\t[0x0301, 0x015a], // S + acute = \n\t\t\t[0x0302, 0x015c], // S + circumflex = \n\t\t\t[0x0327, 0x015e], // S + cedilla = \n\t\t\t[0x030c, 0x0160], // S + caron = \n\t\t]),\n\t],\n\t[\n\t\t0x0073,\n\t\tnew Map([\n\t\t\t// s\n\t\t\t[0x0301, 0x015b], // s + acute = \n\t\t\t[0x0302, 0x015d], // s + circumflex = \n\t\t\t[0x0327, 0x015f], // s + cedilla = \n\t\t\t[0x030c, 0x0161], // s + caron = \n\t\t]),\n\t],\n\t[\n\t\t0x005a,\n\t\tnew Map([\n\t\t\t// Z\n\t\t\t[0x0301, 0x0179], // Z + acute = \n\t\t\t[0x0307, 0x017b], // Z + dot above = \n\t\t\t[0x030c, 0x017d], // Z + caron = \n\t\t]),\n\t],\n\t[\n\t\t0x007a,\n\t\tnew Map([\n\t\t\t// z\n\t\t\t[0x0301, 0x017a], // z + acute = \n\t\t\t[0x0307, 0x017c], // z + dot above = \n\t\t\t[0x030c, 0x017e], // z + caron = \n\t\t]),\n\t],\n]);\n\n/**\n * Try to compose a base character with a combining mark\n * Returns the composed character or null if no composition exists\n */\nexport function tryCompose(base: number, combining: number): number | null {\n\tconst baseCompositions = COMPOSITIONS.get(base);\n\tif (!baseCompositions) return null;\n\treturn baseCompositions.get(combining) ?? null;\n}\n\n/**\n * Compose combining marks with their bases where possible (NFC-like)\n */\nfunction composeMarks(infos: GlyphInfo[]): GlyphInfo[] {\n\tif (infos.length === 0) return infos;\n\n\tconst result: GlyphInfo[] = [];\n\tlet i = 0;\n\n\twhile (i < infos.length) {\n\t\tconst current = infos[i];\n\t\tif (!current) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst currentCcc = getCombiningClass(current.codepoint);\n\n\t\t// If this is a base character (ccc = 0), try to compose with following marks\n\t\tif (currentCcc === 0) {\n\t\t\tlet composedCp = current.codepoint;\n\t\t\tlet lastCcc = 0;\n\t\t\tlet j = i + 1;\n\n\t\t\t// Look for combining marks that can be composed\n\t\t\twhile (j < infos.length) {\n\t\t\t\tconst mark = infos[j];\n\t\t\t\tif (!mark) break;\n\n\t\t\t\tconst markCcc = getCombiningClass(mark.codepoint);\n\n\t\t\t\t// Stop at next base character\n\t\t\t\tif (markCcc === 0) break;\n\n\t\t\t\t// Can only compose if:\n\t\t\t\t// 1. Mark has higher ccc than last composed mark (or last was base)\n\t\t\t\t// 2. Composition exists for the pair\n\t\t\t\tif (markCcc > lastCcc || lastCcc === 0) {\n\t\t\t\t\tconst composed = tryCompose(composedCp, mark.codepoint);\n\t\t\t\t\tif (composed !== null) {\n\t\t\t\t\t\tcomposedCp = composed;\n\t\t\t\t\t\t// Mark this position as consumed (will skip)\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Mark wasn't composed, stop looking for compositions\n\t\t\t\t// but continue with remaining marks\n\t\t\t\tlastCcc = markCcc;\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\t// Output the (possibly composed) base\n\t\t\tresult.push({\n\t\t\t\tglyphId: current.glyphId,\n\t\t\t\tcluster: current.cluster,\n\t\t\t\tmask: current.mask,\n\t\t\t\tcodepoint: composedCp,\n\t\t\t});\n\n\t\t\t// Output any marks that weren't composed\n\t\t\tfor (let k = i + 1; k < j; k++) {\n\t\t\t\tconst mark = infos[k];\n\t\t\t\tif (!mark) continue;\n\n\t\t\t\tconst markCcc = getCombiningClass(mark.codepoint);\n\t\t\t\t// Only output marks that weren't composed (check if they're still combining marks)\n\t\t\t\t// We need to re-check if a composition exists to determine what to output\n\t\t\t\tconst compositionExists =\n\t\t\t\t\ttryCompose(composedCp, mark.codepoint) !== null;\n\t\t\t\tif (!compositionExists && markCcc !== 0) {\n\t\t\t\t\tresult.push(mark);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = j;\n\t\t} else {\n\t\t\t// Standalone combining mark (no base), just copy it\n\t\t\tresult.push(current);\n\t\t\ti++;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Apply normalization to glyph infos\n */\nexport function normalize(\n\tinfos: GlyphInfo[],\n\tmode: NormalizationMode,\n): GlyphInfo[] {\n\tif (mode === NormalizationMode.None) {\n\t\treturn infos;\n\t}\n\n\tif (mode === NormalizationMode.Decompose) {\n\t\t// Decompose precomposed characters (NFD-like)\n\t\tconst result: GlyphInfo[] = [];\n\n\t\tfor (const info of infos) {\n\t\t\tconst decomposed = decompose(info.codepoint);\n\t\t\tif (decomposed) {\n\t\t\t\t// Replace with decomposed sequence\n\t\t\t\tfor (const cp of decomposed) {\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\tglyphId: info.glyphId, // Will be remapped later\n\t\t\t\t\t\tcluster: info.cluster,\n\t\t\t\t\t\tmask: info.mask,\n\t\t\t\t\t\tcodepoint: cp,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult.push(info);\n\t\t\t}\n\t\t}\n\n\t\t// Reorder combining marks\n\t\treorderMarks(result);\n\n\t\treturn result;\n\t}\n\n\tif (mode === NormalizationMode.Compose) {\n\t\t// First decompose, reorder, then compose (NFC-like)\n\t\t// Step 1: Decompose\n\t\tconst decomposed: GlyphInfo[] = [];\n\t\tfor (const info of infos) {\n\t\t\tconst dec = decompose(info.codepoint);\n\t\t\tif (dec) {\n\t\t\t\tfor (const cp of dec) {\n\t\t\t\t\tdecomposed.push({\n\t\t\t\t\t\tglyphId: info.glyphId,\n\t\t\t\t\t\tcluster: info.cluster,\n\t\t\t\t\t\tmask: info.mask,\n\t\t\t\t\t\tcodepoint: cp,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdecomposed.push(info);\n\t\t\t}\n\t\t}\n\n\t\t// Step 2: Reorder combining marks\n\t\treorderMarks(decomposed);\n\n\t\t// Step 3: Compose\n\t\treturn composeMarks(decomposed);\n\t}\n\n\tif (mode === NormalizationMode.Auto) {\n\t\t// Auto mode: use decomposition by default (better for shaping)\n\t\tconst result: GlyphInfo[] = [];\n\n\t\tfor (const info of infos) {\n\t\t\tconst decomposed = decompose(info.codepoint);\n\t\t\tif (decomposed) {\n\t\t\t\tfor (const cp of decomposed) {\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\tglyphId: info.glyphId,\n\t\t\t\t\t\tcluster: info.cluster,\n\t\t\t\t\t\tmask: info.mask,\n\t\t\t\t\t\tcodepoint: cp,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult.push(info);\n\t\t\t}\n\t\t}\n\n\t\treorderMarks(result);\n\t\treturn result;\n\t}\n\n\treturn infos;\n}\n", "import type { Font } from \"../font/font.ts\";\nimport { getGlyphClass } from \"../font/tables/gdef.ts\";\nimport { getKernValue } from \"../font/tables/kern.ts\";\nimport type { GlyphId, GlyphInfo, GlyphPosition } from \"../types.ts\";\nimport { GlyphClass } from \"../types.ts\";\nimport { getCombiningClass } from \"../unicode/normalize.ts\";\n\n/**\n * Fallback mark positioning when GPOS is not available\n * Uses combining class information to position marks\n */\nexport function applyFallbackMarkPositioning(\n\tfont: Font,\n\tinfos: GlyphInfo[],\n\tpositions: GlyphPosition[],\n): void {\n\tfor (let i = 0; i < infos.length; i++) {\n\t\tconst info = infos[i];\n\t\tconst pos = positions[i];\n\t\tif (!info || !pos) continue;\n\n\t\tconst glyphClass = font.gdef ? getGlyphClass(font.gdef, info.glyphId) : 0;\n\t\tconst ccc = getCombiningClass(info.codepoint);\n\n\t\t// Skip if not a mark\n\t\tif (glyphClass !== GlyphClass.Mark && ccc === 0) continue;\n\n\t\t// Find the base glyph\n\t\tlet baseIndex = -1;\n\t\tfor (let j = i - 1; j >= 0; j--) {\n\t\t\tconst prevInfo = infos[j];\n\t\t\tif (!prevInfo) continue;\n\n\t\t\tconst prevClass = font.gdef\n\t\t\t\t? getGlyphClass(font.gdef, prevInfo.glyphId)\n\t\t\t\t: 0;\n\t\t\tconst prevCcc = getCombiningClass(prevInfo.codepoint);\n\n\t\t\tif (prevClass === GlyphClass.Base || (prevClass === 0 && prevCcc === 0)) {\n\t\t\t\tbaseIndex = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (baseIndex < 0) continue;\n\n\t\tconst baseInfo = infos[baseIndex];\n\t\tconst basePos = positions[baseIndex];\n\t\tif (!baseInfo || !basePos) continue;\n\n\t\t// Get base glyph metrics\n\t\tconst baseAdvance = font.advanceWidth(baseInfo.glyphId);\n\n\t\t// Position mark relative to base based on combining class\n\t\t// This is a simplified heuristic - real mark positioning uses anchors\n\t\tpositionMarkFallback(font, info, pos, baseInfo, basePos, baseAdvance, ccc);\n\n\t\t// Mark has zero advance (already accounted for in base)\n\t\tpos.xAdvance = 0;\n\t\tpos.yAdvance = 0;\n\t}\n}\n\nfunction positionMarkFallback(\n\tfont: Font,\n\tmarkInfo: GlyphInfo,\n\tmarkPos: GlyphPosition,\n\t_baseInfo: GlyphInfo,\n\tbasePos: GlyphPosition,\n\tbaseAdvance: number,\n\tccc: number,\n): void {\n\tconst markAdvance = font.advanceWidth(markInfo.glyphId);\n\tconst unitsPerEm = font.unitsPerEm;\n\n\t// Default: center mark over base\n\tlet xOffset = (baseAdvance - markAdvance) / 2;\n\tlet yOffset = 0;\n\n\t// Position based on combining class\n\tif (ccc >= 200 && ccc <= 240) {\n\t\t// Above marks (ccc 230 is common for above)\n\t\tyOffset = unitsPerEm * 0.7; // 70% of em height\n\t\txOffset = (baseAdvance - markAdvance) / 2;\n\t} else if (ccc >= 202 && ccc <= 220) {\n\t\t// Below marks (ccc 220 is common for below)\n\t\tyOffset = -unitsPerEm * 0.15;\n\t\txOffset = (baseAdvance - markAdvance) / 2;\n\t} else if (ccc === 1) {\n\t\t// Overlay marks\n\t\txOffset = (baseAdvance - markAdvance) / 2;\n\t\tyOffset = unitsPerEm * 0.3;\n\t} else if (ccc >= 7 && ccc <= 9) {\n\t\t// Nukta, virama (below consonant)\n\t\tyOffset = -unitsPerEm * 0.1;\n\t\txOffset = (baseAdvance - markAdvance) / 2;\n\t} else if (ccc >= 10 && ccc <= 35) {\n\t\t// Hebrew/Arabic vowels - specific positioning\n\t\tif (ccc <= 22) {\n\t\t\t// Hebrew below vowels\n\t\t\tyOffset = -unitsPerEm * 0.2;\n\t\t} else {\n\t\t\t// Arabic marks\n\t\t\tyOffset = ccc < 30 ? -unitsPerEm * 0.15 : unitsPerEm * 0.6;\n\t\t}\n\t\txOffset = (baseAdvance - markAdvance) / 2;\n\t}\n\n\t// Apply offset relative to base position\n\tmarkPos.xOffset = basePos.xOffset + xOffset - baseAdvance;\n\tmarkPos.yOffset = basePos.yOffset + yOffset;\n}\n\n/**\n * Apply fallback kerning using kern table\n */\nexport function applyFallbackKerning(\n\tfont: Font,\n\tinfos: GlyphInfo[],\n\tpositions: GlyphPosition[],\n): void {\n\tconst kern = font.kern;\n\tif (!kern) return;\n\n\tfor (let i = 0; i < infos.length - 1; i++) {\n\t\tconst info1 = infos[i];\n\t\tconst info2 = infos[i + 1];\n\t\tif (!info1 || !info2) continue;\n\n\t\tconst pos1 = positions[i];\n\t\tif (!pos1) continue;\n\n\t\t// Skip marks\n\t\tconst class1 = font.gdef ? getGlyphClass(font.gdef, info1.glyphId) : 0;\n\t\tconst class2 = font.gdef ? getGlyphClass(font.gdef, info2.glyphId) : 0;\n\t\tif (class1 === GlyphClass.Mark || class2 === GlyphClass.Mark) continue;\n\n\t\t// Get kerning from kern table\n\t\tconst kernValue = getKernValueFromTable(font, info1.glyphId, info2.glyphId);\n\t\tif (kernValue !== 0) {\n\t\t\tpos1.xAdvance += kernValue;\n\t\t}\n\t}\n}\n\nfunction getKernValueFromTable(\n\tfont: Font,\n\tleft: GlyphId,\n\tright: GlyphId,\n): number {\n\tconst kern = font.kern;\n\tif (!kern) return 0;\n\n\treturn getKernValue(kern, left, right);\n}\n\n/**\n * Recategorize combining marks for proper processing\n * Some scripts need marks to be processed in specific order\n */\nexport function recategorizeCombiningMarks(\n\t_font: Font,\n\tinfos: GlyphInfo[],\n): void {\n\t// For Hebrew, Arabic, and other scripts, ensure marks are in canonical order\n\t// This is typically handled by normalization, but we do a final check here\n\n\tlet i = 0;\n\twhile (i < infos.length) {\n\t\tconst info = infos[i];\n\t\tif (!info) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst ccc = getCombiningClass(info.codepoint);\n\t\tif (ccc === 0) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Find extent of combining sequence\n\t\tlet j = i + 1;\n\t\twhile (j < infos.length) {\n\t\t\tconst nextInfo = infos[j];\n\t\t\tif (!nextInfo) break;\n\t\t\tconst nextCcc = getCombiningClass(nextInfo.codepoint);\n\t\t\tif (nextCcc === 0) break;\n\t\t\tj++;\n\t\t}\n\n\t\t// Sort combining marks by CCC (stable sort)\n\t\tif (j - i > 1) {\n\t\t\tconst marks = infos.slice(i, j);\n\t\t\tmarks.sort((a, b) => {\n\t\t\t\tconst cccA = getCombiningClass(a.codepoint);\n\t\t\t\tconst cccB = getCombiningClass(b.codepoint);\n\t\t\t\treturn cccA - cccB;\n\t\t\t});\n\t\t\tfor (const [k, mark] of marks.entries()) {\n\t\t\t\tinfos[i + k] = mark;\n\t\t\t}\n\t\t}\n\n\t\ti = j;\n\t}\n}\n", "import { tag } from \"../types.ts\";\nimport type { ShapeFeature } from \"./shape-plan.ts\";\n\n/**\n * Feature helper utilities\n * Provides convenient APIs for enabling OpenType features\n */\n\n/**\n * Create a ShapeFeature for a stylistic set (ss01-ss20)\n */\nexport function stylisticSet(\n\tsetNumber: number,\n\tenabled: boolean = true,\n): ShapeFeature {\n\tif (setNumber < 1 || setNumber > 20) {\n\t\tthrow new Error(`Stylistic set number must be 1-20, got ${setNumber}`);\n\t}\n\tconst tagStr = `ss${setNumber.toString().padStart(2, \"0\")}`;\n\treturn { tag: tag(tagStr), enabled };\n}\n\n/**\n * Create ShapeFeatures for multiple stylistic sets\n */\nexport function stylisticSets(\n\tsetNumbers: number[],\n\tenabled: boolean = true,\n): ShapeFeature[] {\n\treturn setNumbers.map((n) => stylisticSet(n, enabled));\n}\n\n/**\n * Create a ShapeFeature for a character variant (cv01-cv99)\n */\nexport function characterVariant(\n\tvariantNumber: number,\n\tenabled: boolean = true,\n): ShapeFeature {\n\tif (variantNumber < 1 || variantNumber > 99) {\n\t\tthrow new Error(\n\t\t\t`Character variant number must be 1-99, got ${variantNumber}`,\n\t\t);\n\t}\n\tconst tagStr = `cv${variantNumber.toString().padStart(2, \"0\")}`;\n\treturn { tag: tag(tagStr), enabled };\n}\n\n/**\n * Create ShapeFeatures for multiple character variants\n */\nexport function characterVariants(\n\tvariantNumbers: number[],\n\tenabled: boolean = true,\n): ShapeFeature[] {\n\treturn variantNumbers.map((n) => characterVariant(n, enabled));\n}\n\n/**\n * Standard ligatures (liga)\n */\nexport function standardLigatures(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"liga\"), enabled };\n}\n\n/**\n * Discretionary ligatures (dlig)\n */\nexport function discretionaryLigatures(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"dlig\"), enabled };\n}\n\n/**\n * Historical ligatures (hlig)\n */\nexport function historicalLigatures(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"hlig\"), enabled };\n}\n\n/**\n * Contextual alternates (calt)\n */\nexport function contextualAlternates(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"calt\"), enabled };\n}\n\n/**\n * Stylistic alternates (salt)\n */\nexport function stylisticAlternates(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"salt\"), enabled };\n}\n\n/**\n * Swash (swsh)\n */\nexport function swash(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"swsh\"), enabled };\n}\n\n/**\n * Small capitals (smcp)\n */\nexport function smallCaps(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"smcp\"), enabled };\n}\n\n/**\n * Capitals to small capitals (c2sc)\n */\nexport function capsToSmallCaps(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"c2sc\"), enabled };\n}\n\n/**\n * Petite capitals (pcap)\n */\nexport function petiteCaps(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"pcap\"), enabled };\n}\n\n/**\n * All small capitals (both smcp and c2sc)\n */\nexport function allSmallCaps(enabled: boolean = true): ShapeFeature[] {\n\treturn [smallCaps(enabled), capsToSmallCaps(enabled)];\n}\n\n/**\n * Oldstyle figures (onum)\n */\nexport function oldstyleFigures(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"onum\"), enabled };\n}\n\n/**\n * Lining figures (lnum)\n */\nexport function liningFigures(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"lnum\"), enabled };\n}\n\n/**\n * Proportional figures (pnum)\n */\nexport function proportionalFigures(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"pnum\"), enabled };\n}\n\n/**\n * Tabular figures (tnum)\n */\nexport function tabularFigures(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"tnum\"), enabled };\n}\n\n/**\n * Fractions (frac)\n */\nexport function fractions(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"frac\"), enabled };\n}\n\n/**\n * Ordinals (ordn)\n */\nexport function ordinals(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"ordn\"), enabled };\n}\n\n/**\n * Slashed zero (zero)\n */\nexport function slashedZero(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"zero\"), enabled };\n}\n\n/**\n * Superscript (sups)\n */\nexport function superscript(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"sups\"), enabled };\n}\n\n/**\n * Subscript (subs)\n */\nexport function subscript(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"subs\"), enabled };\n}\n\n/**\n * Scientific inferiors (sinf)\n */\nexport function scientificInferiors(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"sinf\"), enabled };\n}\n\n/**\n * Case-sensitive forms (case)\n */\nexport function caseSensitiveForms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"case\"), enabled };\n}\n\n/**\n * Capital spacing (cpsp)\n */\nexport function capitalSpacing(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"cpsp\"), enabled };\n}\n\n/**\n * Kerning (kern)\n */\nexport function kerning(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"kern\"), enabled };\n}\n\n/**\n * Vertical forms (vert) - for vertical text layout\n */\nexport function verticalForms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"vert\"), enabled };\n}\n\n/**\n * Vertical alternates and rotation (vrt2) - for vertical text layout\n */\nexport function verticalAlternatesRotation(\n\tenabled: boolean = true,\n): ShapeFeature {\n\treturn { tag: tag(\"vrt2\"), enabled };\n}\n\n/**\n * Vertical Kana alternates (vkna) - for Japanese vertical text\n */\nexport function verticalKanaAlternates(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"vkna\"), enabled };\n}\n\n/**\n * All vertical layout features\n */\nexport function verticalLayoutFeatures(\n\tenabled: boolean = true,\n): ShapeFeature[] {\n\treturn [\n\t\tverticalForms(enabled),\n\t\tverticalAlternatesRotation(enabled),\n\t\tverticalKanaAlternates(enabled),\n\t];\n}\n\n/**\n * Ruby notation forms (ruby)\n */\nexport function ruby(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"ruby\"), enabled };\n}\n\n/**\n * Half-width forms (hwid)\n */\nexport function halfWidthForms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"hwid\"), enabled };\n}\n\n/**\n * Full-width forms (fwid)\n */\nexport function fullWidthForms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"fwid\"), enabled };\n}\n\n/**\n * Proportional-width forms (pwid)\n */\nexport function proportionalWidthForms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"pwid\"), enabled };\n}\n\n/**\n * Quarter-width forms (qwid)\n */\nexport function quarterWidthForms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"qwid\"), enabled };\n}\n\n/**\n * Third-width forms (twid)\n */\nexport function thirdWidthForms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"twid\"), enabled };\n}\n\n/**\n * JIS78 forms (jp78) - Japanese\n */\nexport function jis78Forms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"jp78\"), enabled };\n}\n\n/**\n * JIS83 forms (jp83) - Japanese\n */\nexport function jis83Forms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"jp83\"), enabled };\n}\n\n/**\n * JIS90 forms (jp90) - Japanese\n */\nexport function jis90Forms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"jp90\"), enabled };\n}\n\n/**\n * JIS2004 forms (jp04) - Japanese\n */\nexport function jis2004Forms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"jp04\"), enabled };\n}\n\n/**\n * Simplified forms (smpl) - Chinese\n */\nexport function simplifiedForms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"smpl\"), enabled };\n}\n\n/**\n * Traditional forms (trad) - Chinese\n */\nexport function traditionalForms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"trad\"), enabled };\n}\n\n/**\n * Create a feature from a 4-character tag string\n */\nexport function feature(tagStr: string, enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(tagStr), enabled };\n}\n\n/**\n * Create multiple features from tag strings\n */\nexport function features(\n\ttagStrs: string[],\n\tenabled: boolean = true,\n): ShapeFeature[] {\n\treturn tagStrs.map((t) => feature(t, enabled));\n}\n\n/**\n * Combine multiple feature sets\n */\nexport function combineFeatures(\n\t...featureSets: (ShapeFeature | ShapeFeature[])[]\n): ShapeFeature[] {\n\tconst result: ShapeFeature[] = [];\n\tfor (const set of featureSets) {\n\t\tif (Array.isArray(set)) {\n\t\t\tresult.push(...set);\n\t\t} else {\n\t\t\tresult.push(set);\n\t\t}\n\t}\n\treturn result;\n}\n", "import type { Font } from \"../font/font.ts\";\nimport type { AnyGposLookup, GposTable } from \"../font/tables/gpos.ts\";\nimport type { AnyGsubLookup, GsubTable } from \"../font/tables/gsub.ts\";\nimport {\n\tfindLangSys,\n\tfindScript,\n\tgetFeature,\n} from \"../layout/structures/layout-common.ts\";\nimport {\n\ttype FeatureVariations,\n\tfindMatchingFeatureVariation,\n} from \"../layout/structures/feature-variations.ts\";\nimport type { Tag, uint16 } from \"../types.ts\";\nimport { tag, tagToString } from \"../types.ts\";\n\n/** Shape plan cache for reusing computed plans */\nconst shapePlanCache = new WeakMap<Font, Map<string, ShapePlan>>();\n\n/** Maximum cache size per font */\nconst MAX_CACHE_SIZE = 64;\n\n/** Feature with optional value */\nexport interface ShapeFeature {\n\ttag: Tag;\n\tenabled: boolean;\n}\n\n/** Collected lookups for shaping */\nexport interface ShapePlan {\n\tscript: Tag;\n\tlanguage: Tag | null;\n\tdirection: \"ltr\" | \"rtl\";\n\n\t/** GSUB lookups to apply, in order */\n\tgsubLookups: Array<{ index: number; lookup: AnyGsubLookup }>;\n\n\t/** GPOS lookups to apply, in order */\n\tgposLookups: Array<{ index: number; lookup: AnyGposLookup }>;\n}\n\n/** Default GSUB features (always enabled) */\nconst DEFAULT_GSUB_FEATURES = [\n\t\"ccmp\", // Glyph composition/decomposition\n\t\"locl\", // Localized forms\n\t\"rlig\", // Required ligatures\n\t\"rclt\", // Required contextual alternates\n\t\"calt\", // Contextual alternates\n\t\"liga\", // Standard ligatures\n];\n\n/** Default GPOS features (always enabled) */\nconst DEFAULT_GPOS_FEATURES = [\n\t\"kern\", // Kerning\n\t\"mark\", // Mark positioning\n\t\"mkmk\", // Mark-to-mark positioning\n];\n\n/** Generate cache key for shape plan */\nfunction getCacheKey(\n\tscript: string,\n\tlanguage: string | null,\n\tdirection: \"ltr\" | \"rtl\",\n\tuserFeatures: ShapeFeature[],\n\taxisCoords: number[] | null,\n): string {\n\tconst featuresKey = userFeatures\n\t\t.map((f) => `${tagToString(f.tag)}:${f.enabled ? \"1\" : \"0\"}`)\n\t\t.sort()\n\t\t.join(\",\");\n\tconst coordsKey = axisCoords ? axisCoords.map(c => c.toFixed(4)).join(\",\") : \"\";\n\treturn `${script}|${language || \"\"}|${direction}|${featuresKey}|${coordsKey}`;\n}\n\n/** Get or create a cached shape plan */\nexport function getOrCreateShapePlan(\n\tfont: Font,\n\tscript: string,\n\tlanguage: string | null,\n\tdirection: \"ltr\" | \"rtl\",\n\tuserFeatures: ShapeFeature[] = [],\n\taxisCoords: number[] | null = null,\n): ShapePlan {\n\tconst cacheKey = getCacheKey(script, language, direction, userFeatures, axisCoords);\n\n\t// Get or create font's cache map\n\tlet fontCache = shapePlanCache.get(font);\n\tif (!fontCache) {\n\t\tfontCache = new Map();\n\t\tshapePlanCache.set(font, fontCache);\n\t}\n\n\t// Check cache\n\tconst cached = fontCache.get(cacheKey);\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\t// Create new plan\n\tconst plan = createShapePlanInternal(\n\t\tfont,\n\t\tscript,\n\t\tlanguage,\n\t\tdirection,\n\t\tuserFeatures,\n\t\taxisCoords,\n\t);\n\n\t// Evict if cache is too large\n\tif (fontCache.size >= MAX_CACHE_SIZE) {\n\t\tconst firstKey = fontCache.keys().next().value;\n\t\tif (firstKey !== undefined) {\n\t\t\tfontCache.delete(firstKey);\n\t\t}\n\t}\n\n\tfontCache.set(cacheKey, plan);\n\treturn plan;\n}\n\n/** Create a shape plan for the given font and settings */\nexport function createShapePlan(\n\tfont: Font,\n\tscript: string,\n\tlanguage: string | null,\n\tdirection: \"ltr\" | \"rtl\",\n\tuserFeatures: ShapeFeature[] = [],\n\taxisCoords: number[] | null = null,\n): ShapePlan {\n\t// Use caching by default\n\treturn getOrCreateShapePlan(font, script, language, direction, userFeatures, axisCoords);\n}\n\n/** Create a shape plan without caching */\nfunction createShapePlanInternal(\n\tfont: Font,\n\tscript: string,\n\tlanguage: string | null,\n\tdirection: \"ltr\" | \"rtl\",\n\tuserFeatures: ShapeFeature[] = [],\n\taxisCoords: number[] | null = null,\n): ShapePlan {\n\tconst scriptTag = tag(script.padEnd(4, \" \"));\n\tconst languageTag = language ? tag(language.padEnd(4, \" \")) : null;\n\n\t// Collect enabled features\n\tconst enabledFeatures = new Set<Tag>();\n\n\t// Add default features\n\tfor (const feat of DEFAULT_GSUB_FEATURES) {\n\t\tenabledFeatures.add(tag(feat));\n\t}\n\tfor (const feat of DEFAULT_GPOS_FEATURES) {\n\t\tenabledFeatures.add(tag(feat));\n\t}\n\n\t// Apply user features\n\tfor (const feat of userFeatures) {\n\t\tif (feat.enabled) {\n\t\t\tenabledFeatures.add(feat.tag);\n\t\t} else {\n\t\t\tenabledFeatures.delete(feat.tag);\n\t\t}\n\t}\n\n\t// Collect GSUB lookups (with feature variations support)\n\tconst gsubLookups = collectLookups(\n\t\tfont.gsub,\n\t\tscriptTag,\n\t\tlanguageTag,\n\t\tenabledFeatures,\n\t\taxisCoords,\n\t);\n\n\t// Collect GPOS lookups (with feature variations support)\n\tconst gposLookups = collectLookups(\n\t\tfont.gpos,\n\t\tscriptTag,\n\t\tlanguageTag,\n\t\tenabledFeatures,\n\t\taxisCoords,\n\t);\n\n\treturn {\n\t\tscript: scriptTag,\n\t\tlanguage: languageTag,\n\t\tdirection,\n\t\tgsubLookups: gsubLookups as Array<{ index: number; lookup: AnyGsubLookup }>,\n\t\tgposLookups: gposLookups as Array<{ index: number; lookup: AnyGposLookup }>,\n\t};\n}\n\nfunction collectLookups<T extends { lookups: unknown[] }>(\n\ttable: T | null,\n\tscriptTag: Tag,\n\tlanguageTag: Tag | null,\n\tenabledFeatures: Set<Tag>,\n\taxisCoords: number[] | null,\n): Array<{ index: number; lookup: unknown }> {\n\tif (!table) return [];\n\n\tconst gsub = table as unknown as GsubTable | GposTable;\n\tconst lookupIndices = new Set<number>();\n\n\t// Find script\n\tlet script = findScript(gsub.scriptList, scriptTag);\n\tif (!script) {\n\t\t// Try DFLT script\n\t\tscript = findScript(gsub.scriptList, tag(\"DFLT\"));\n\t}\n\tif (!script) {\n\t\t// Try latn as fallback\n\t\tscript = findScript(gsub.scriptList, tag(\"latn\"));\n\t}\n\tif (!script) return [];\n\n\t// Find language system\n\tconst langSys = findLangSys(script, languageTag);\n\tif (!langSys) return [];\n\n\t// Get feature variations substitutions if applicable\n\tconst featureVariations = (gsub as { featureVariations?: FeatureVariations }).featureVariations;\n\tconst matchingVariation = featureVariations && axisCoords\n\t\t? findMatchingFeatureVariation(featureVariations, axisCoords)\n\t\t: null;\n\n\t// Build a map of feature indices to their substituted lookup lists\n\tconst featureSubstitutions = new Map<uint16, uint16[]>();\n\tif (matchingVariation) {\n\t\tfor (const subst of matchingVariation.featureTableSubstitution.substitutions) {\n\t\t\tfeatureSubstitutions.set(subst.featureIndex, subst.alternateFeature.lookupListIndices);\n\t\t}\n\t}\n\n\t// Add required feature\n\tif (langSys.requiredFeatureIndex !== 0xffff) {\n\t\tconst feature = getFeature(gsub.featureList, langSys.requiredFeatureIndex);\n\t\tif (feature) {\n\t\t\t// Check if this feature has a substitution\n\t\t\tconst substitutedLookups = featureSubstitutions.get(langSys.requiredFeatureIndex);\n\t\t\tconst lookups = substitutedLookups ?? feature.feature.lookupListIndices;\n\t\t\tfor (const lookupIndex of lookups) {\n\t\t\t\tlookupIndices.add(lookupIndex);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Add enabled features\n\tfor (const featureIndex of langSys.featureIndices) {\n\t\tconst featureRecord = getFeature(gsub.featureList, featureIndex);\n\t\tif (!featureRecord) continue;\n\n\t\tif (enabledFeatures.has(featureRecord.featureTag)) {\n\t\t\t// Check if this feature has a substitution\n\t\t\tconst substitutedLookups = featureSubstitutions.get(featureIndex);\n\t\t\tconst lookups = substitutedLookups ?? featureRecord.feature.lookupListIndices;\n\t\t\tfor (const lookupIndex of lookups) {\n\t\t\t\tlookupIndices.add(lookupIndex);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Convert to sorted array with lookup objects\n\tconst result: Array<{ index: number; lookup: unknown }> = [];\n\tconst sortedIndices = Array.from(lookupIndices).sort((a, b) => a - b);\n\n\tfor (const index of sortedIndices) {\n\t\tconst lookup = gsub.lookups[index];\n\t\tif (lookup) {\n\t\t\tresult.push({ index, lookup });\n\t\t}\n\t}\n\n\treturn result;\n}\n", "import type { GlyphInfo } from \"../../types.ts\";\n\n/**\n * Arabic joining types from Unicode\n */\nexport enum ArabicJoiningType {\n\tNonJoining = \"U\", // Non_Joining\n\tRightJoining = \"R\", // Right_Joining (joins on the right)\n\tDualJoining = \"D\", // Dual_Joining (joins on both sides)\n\tJoinCausing = \"C\", // Join_Causing (like TATWEEL)\n\tLeftJoining = \"L\", // Left_Joining (rare)\n\tTransparent = \"T\", // Transparent (marks, etc.)\n}\n\n/**\n * Action to take for each glyph based on context\n */\nexport enum JoiningAction {\n\tNone = 0,\n\tIsol = 1, // Isolated form\n\tFina = 2, // Final form\n\tMedi = 3, // Medial form\n\tInit = 4, // Initial form\n}\n\n/**\n * Arabic joining group for specific shaping behavior\n */\nexport enum ArabicJoiningGroup {\n\tNone = 0,\n\tAlaph = 1,\n\tDalathRish = 2,\n\t// Add more as needed for Syriac, etc.\n}\n\n/**\n * Per-glyph info for Arabic shaping\n */\nexport interface ArabicGlyphData {\n\tjoiningType: ArabicJoiningType;\n\tjoiningGroup: ArabicJoiningGroup;\n\taction: JoiningAction;\n}\n\n// Unicode ranges for Arabic characters\nconst ARABIC_START = 0x0600;\nconst ARABIC_END = 0x06ff;\nconst ARABIC_SUPPLEMENT_START = 0x0750;\nconst ARABIC_SUPPLEMENT_END = 0x077f;\nconst ARABIC_EXTENDED_A_START = 0x08a0;\nconst ARABIC_EXTENDED_A_END = 0x08ff;\nconst ARABIC_PRESENTATION_A_START = 0xfb50;\nconst ARABIC_PRESENTATION_A_END = 0xfdff;\nconst ARABIC_PRESENTATION_B_START = 0xfe70;\nconst ARABIC_PRESENTATION_B_END = 0xfeff;\n\n/**\n * Check if a codepoint is in Arabic script range\n */\nexport function isArabic(cp: number): boolean {\n\treturn (\n\t\t(cp >= ARABIC_START && cp <= ARABIC_END) ||\n\t\t(cp >= ARABIC_SUPPLEMENT_START && cp <= ARABIC_SUPPLEMENT_END) ||\n\t\t(cp >= ARABIC_EXTENDED_A_START && cp <= ARABIC_EXTENDED_A_END) ||\n\t\t(cp >= ARABIC_PRESENTATION_A_START && cp <= ARABIC_PRESENTATION_A_END) ||\n\t\t(cp >= ARABIC_PRESENTATION_B_START && cp <= ARABIC_PRESENTATION_B_END)\n\t);\n}\n\n/**\n * Get the joining type for a codepoint\n * Based on Unicode Arabic Shaping data\n */\nexport function getJoiningType(cp: number): ArabicJoiningType {\n\t// Non-joining: space, numbers, punctuation\n\tif (cp < ARABIC_START) return ArabicJoiningType.NonJoining;\n\n\t// Arabic block (0600-06FF)\n\tif (cp >= 0x0600 && cp <= 0x0605) return ArabicJoiningType.NonJoining; // Number signs\n\tif (cp === 0x0608) return ArabicJoiningType.NonJoining; // Arabic Ray\n\tif (cp === 0x060b) return ArabicJoiningType.NonJoining; // Afghani Sign\n\tif (cp === 0x060d) return ArabicJoiningType.NonJoining; // Date Separator\n\n\t// Dual-joining letters (most common Arabic letters)\n\t// These can connect on both sides\n\tif (cp === 0x0626) return ArabicJoiningType.DualJoining; // YEH WITH HAMZA ABOVE\n\tif (cp === 0x0628) return ArabicJoiningType.DualJoining; // BEH\n\tif (cp === 0x062a) return ArabicJoiningType.DualJoining; // TEH\n\tif (cp === 0x062b) return ArabicJoiningType.DualJoining; // THEH\n\tif (cp === 0x062c) return ArabicJoiningType.DualJoining; // JEEM\n\tif (cp === 0x062d) return ArabicJoiningType.DualJoining; // HAH\n\tif (cp === 0x062e) return ArabicJoiningType.DualJoining; // KHAH\n\tif (cp === 0x0633) return ArabicJoiningType.DualJoining; // SEEN\n\tif (cp === 0x0634) return ArabicJoiningType.DualJoining; // SHEEN\n\tif (cp === 0x0635) return ArabicJoiningType.DualJoining; // SAD\n\tif (cp === 0x0636) return ArabicJoiningType.DualJoining; // DAD\n\tif (cp === 0x0637) return ArabicJoiningType.DualJoining; // TAH\n\tif (cp === 0x0638) return ArabicJoiningType.DualJoining; // ZAH\n\tif (cp === 0x0639) return ArabicJoiningType.DualJoining; // AIN\n\tif (cp === 0x063a) return ArabicJoiningType.DualJoining; // GHAIN\n\tif (cp >= 0x063b && cp <= 0x063f) return ArabicJoiningType.DualJoining; // Extended\n\tif (cp === 0x0641) return ArabicJoiningType.DualJoining; // FEH\n\tif (cp === 0x0642) return ArabicJoiningType.DualJoining; // QAF\n\tif (cp === 0x0643) return ArabicJoiningType.DualJoining; // KAF\n\tif (cp === 0x0644) return ArabicJoiningType.DualJoining; // LAM\n\tif (cp === 0x0645) return ArabicJoiningType.DualJoining; // MEEM\n\tif (cp === 0x0646) return ArabicJoiningType.DualJoining; // NOON\n\tif (cp === 0x0647) return ArabicJoiningType.DualJoining; // HEH\n\tif (cp === 0x0649) return ArabicJoiningType.DualJoining; // ALEF MAKSURA\n\tif (cp === 0x064a) return ArabicJoiningType.DualJoining; // YEH\n\tif (cp >= 0x066e && cp <= 0x066f) return ArabicJoiningType.DualJoining; // DOTLESS BEH/QAF\n\tif (cp >= 0x0678 && cp <= 0x0687) return ArabicJoiningType.DualJoining; // Extended Arabic\n\tif (cp >= 0x069a && cp <= 0x06bf) return ArabicJoiningType.DualJoining; // More extended\n\tif (cp >= 0x06c1 && cp <= 0x06c2) return ArabicJoiningType.DualJoining; // HEH variants\n\tif (cp === 0x06cc) return ArabicJoiningType.DualJoining; // FARSI YEH\n\tif (cp >= 0x06ce && cp <= 0x06d1) return ArabicJoiningType.DualJoining; // YEH variants\n\tif (cp === 0x06d5) return ArabicJoiningType.DualJoining; // AE\n\tif (cp >= 0x06fa && cp <= 0x06fc) return ArabicJoiningType.DualJoining; // More letters\n\tif (cp === 0x06ff) return ArabicJoiningType.DualJoining; // HEH WITH INVERTED V\n\n\t// Right-joining letters (only connect on the right)\n\t// ALEF and its variants, DAL/DHAL, REH/ZAY, WAW\n\tif (cp === 0x0622) return ArabicJoiningType.RightJoining; // ALEF WITH MADDA ABOVE\n\tif (cp === 0x0623) return ArabicJoiningType.RightJoining; // ALEF WITH HAMZA ABOVE\n\tif (cp === 0x0624) return ArabicJoiningType.RightJoining; // WAW WITH HAMZA ABOVE\n\tif (cp === 0x0625) return ArabicJoiningType.RightJoining; // ALEF WITH HAMZA BELOW\n\tif (cp === 0x0627) return ArabicJoiningType.RightJoining; // ALEF\n\tif (cp === 0x0629) return ArabicJoiningType.RightJoining; // TEH MARBUTA\n\tif (cp === 0x062f) return ArabicJoiningType.RightJoining; // DAL\n\tif (cp === 0x0630) return ArabicJoiningType.RightJoining; // THAL\n\tif (cp === 0x0631) return ArabicJoiningType.RightJoining; // REH\n\tif (cp === 0x0632) return ArabicJoiningType.RightJoining; // ZAIN\n\tif (cp === 0x0648) return ArabicJoiningType.RightJoining; // WAW\n\tif (cp === 0x0671) return ArabicJoiningType.RightJoining; // ALEF WASLA\n\tif (cp >= 0x0672 && cp <= 0x0677) return ArabicJoiningType.RightJoining; // ALEF variants\n\tif (cp >= 0x0688 && cp <= 0x0699) return ArabicJoiningType.RightJoining; // DAL/REH extended\n\tif (cp >= 0x06c0 && cp <= 0x06c0) return ArabicJoiningType.RightJoining; // HEH WITH YEH\n\tif (cp === 0x06c3) return ArabicJoiningType.RightJoining; // TEH MARBUTA GOAL\n\tif (cp >= 0x06c4 && cp <= 0x06cb) return ArabicJoiningType.RightJoining; // WAW variants\n\tif (cp === 0x06cd) return ArabicJoiningType.RightJoining; // YEH WITH TAIL\n\tif (cp >= 0x06d2 && cp <= 0x06d3) return ArabicJoiningType.RightJoining; // YEH BARREE\n\n\t// TATWEEL - Join causing\n\tif (cp === 0x0640) return ArabicJoiningType.JoinCausing;\n\n\t// Transparent - combining marks, diacritics\n\tif (cp >= 0x064b && cp <= 0x065f) return ArabicJoiningType.Transparent; // Arabic marks\n\tif (cp === 0x0670) return ArabicJoiningType.Transparent; // SUPERSCRIPT ALEF\n\tif (cp >= 0x06d6 && cp <= 0x06ed) return ArabicJoiningType.Transparent; // Quranic marks\n\tif (cp >= 0x08d3 && cp <= 0x08ff) return ArabicJoiningType.Transparent; // Extended marks\n\n\t// Default for Arabic range: NonJoining\n\tif (isArabic(cp)) return ArabicJoiningType.NonJoining;\n\n\treturn ArabicJoiningType.NonJoining;\n}\n\n/**\n * Analyze joining for a sequence of glyphs.\n * Returns the action to take for each glyph.\n */\nexport function analyzeJoining(infos: GlyphInfo[]): JoiningAction[] {\n\tconst n = infos.length;\n\tconst actions: JoiningAction[] = new Array(n).fill(JoiningAction.None);\n\tconst types: ArabicJoiningType[] = [];\n\n\t// Get joining types for all glyphs\n\tfor (const info of infos) {\n\t\tconst cp = info.codepoint ?? 0;\n\t\ttypes.push(getJoiningType(cp));\n\t}\n\n\t// Analyze each glyph based on neighbors (skipping transparent)\n\tfor (let i = 0; i < n; i++) {\n\t\tconst type = types[i];\n\t\tif (!type) continue;\n\n\t\t// Skip non-Arabic characters\n\t\tif (\n\t\t\ttype === ArabicJoiningType.NonJoining ||\n\t\t\ttype === ArabicJoiningType.Transparent\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Find previous non-transparent glyph\n\t\tlet prevType: ArabicJoiningType | null = null;\n\t\tfor (let j = i - 1; j >= 0; j--) {\n\t\t\tconst jType = types[j];\n\t\t\tif (jType && jType !== ArabicJoiningType.Transparent) {\n\t\t\t\tprevType = jType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Find next non-transparent glyph\n\t\tlet nextType: ArabicJoiningType | null = null;\n\t\tfor (let j = i + 1; j < n; j++) {\n\t\t\tconst jType = types[j];\n\t\t\tif (jType && jType !== ArabicJoiningType.Transparent) {\n\t\t\t\tnextType = jType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Determine if we join left/right\n\t\tconst joinsLeft =\n\t\t\tprevType === ArabicJoiningType.DualJoining ||\n\t\t\tprevType === ArabicJoiningType.LeftJoining ||\n\t\t\tprevType === ArabicJoiningType.JoinCausing;\n\n\t\tconst joinsRight =\n\t\t\tnextType === ArabicJoiningType.DualJoining ||\n\t\t\tnextType === ArabicJoiningType.RightJoining ||\n\t\t\tnextType === ArabicJoiningType.JoinCausing;\n\n\t\t// Determine action based on joining type and context\n\t\tif (type === ArabicJoiningType.DualJoining) {\n\t\t\tif (joinsLeft && joinsRight) {\n\t\t\t\tactions[i] = JoiningAction.Medi;\n\t\t\t} else if (joinsLeft) {\n\t\t\t\tactions[i] = JoiningAction.Fina;\n\t\t\t} else if (joinsRight) {\n\t\t\t\tactions[i] = JoiningAction.Init;\n\t\t\t} else {\n\t\t\t\tactions[i] = JoiningAction.Isol;\n\t\t\t}\n\t\t} else if (type === ArabicJoiningType.RightJoining) {\n\t\t\t// Right-joining can only join on the right (to previous glyph in RTL)\n\t\t\tif (joinsLeft) {\n\t\t\t\tactions[i] = JoiningAction.Fina;\n\t\t\t} else {\n\t\t\t\tactions[i] = JoiningAction.Isol;\n\t\t\t}\n\t\t} else if (type === ArabicJoiningType.LeftJoining) {\n\t\t\t// Left-joining (rare)\n\t\t\tif (joinsRight) {\n\t\t\t\tactions[i] = JoiningAction.Init;\n\t\t\t} else {\n\t\t\t\tactions[i] = JoiningAction.Isol;\n\t\t\t}\n\t\t} else if (type === ArabicJoiningType.JoinCausing) {\n\t\t\t// TATWEEL - just connects, no form change\n\t\t\tactions[i] = JoiningAction.None;\n\t\t}\n\t}\n\n\treturn actions;\n}\n\n/**\n * Get the feature tag for a joining action\n */\nexport function getFeatureForAction(action: JoiningAction): string | null {\n\tswitch (action) {\n\t\tcase JoiningAction.Isol:\n\t\t\treturn \"isol\";\n\t\tcase JoiningAction.Fina:\n\t\t\treturn \"fina\";\n\t\tcase JoiningAction.Medi:\n\t\t\treturn \"medi\";\n\t\tcase JoiningAction.Init:\n\t\t\treturn \"init\";\n\t\tdefault:\n\t\t\treturn null;\n\t}\n}\n\n/**\n * Set the feature mask for each glyph based on joining analysis\n */\nexport function setupArabicMasks(infos: GlyphInfo[]): void {\n\tconst actions = analyzeJoining(infos);\n\n\t// Feature tag bits (these should match how ShapePlan assigns masks)\n\t// For now we use a simple scheme where:\n\t// - bit 0: isol\n\t// - bit 1: fina\n\t// - bit 2: medi\n\t// - bit 3: init\n\tfor (const [i, action] of actions.entries()) {\n\t\tconst info = infos[i];\n\t\tif (!info) continue;\n\n\t\t// Set mask based on action\n\t\t// The shaper will need to check these masks when applying features\n\t\tswitch (action) {\n\t\t\tcase JoiningAction.Isol:\n\t\t\t\tinfo.mask = (info.mask & 0xfffffff0) | 0x1;\n\t\t\t\tbreak;\n\t\t\tcase JoiningAction.Fina:\n\t\t\t\tinfo.mask = (info.mask & 0xfffffff0) | 0x2;\n\t\t\t\tbreak;\n\t\t\tcase JoiningAction.Medi:\n\t\t\t\tinfo.mask = (info.mask & 0xfffffff0) | 0x4;\n\t\t\t\tbreak;\n\t\t\tcase JoiningAction.Init:\n\t\t\t\tinfo.mask = (info.mask & 0xfffffff0) | 0x8;\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n", "import type { GlyphInfo } from \"../../types.ts\";\n\n/**\n * Hangul shaper for Korean text\n * Handles Jamo composition and syllable block formation\n */\n\n// Hangul Unicode ranges\nconst HANGUL_BASE = 0xac00; // First precomposed syllable ()\nconst HANGUL_END = 0xd7a3; // Last precomposed syllable ()\n\nconst JAMO_L_BASE = 0x1100; // Leading consonant (choseong) base\nconst JAMO_V_BASE = 0x1161; // Vowel (jungseong) base\nconst JAMO_T_BASE = 0x11a7; // Trailing consonant (jongseong) base - 0x11a8 is first real one\n\nconst JAMO_L_COUNT = 19; // Number of leading consonants\nconst JAMO_V_COUNT = 21; // Number of vowels\nconst JAMO_T_COUNT = 28; // Number of trailing consonants (including none)\n\nconst JAMO_VT_COUNT = JAMO_V_COUNT * JAMO_T_COUNT; // 588\nconst _JAMO_LVT_COUNT = JAMO_L_COUNT * JAMO_VT_COUNT; // 11172\n\n// Compatibility Jamo (for conversion)\nconst COMPAT_JAMO_START = 0x3131;\nconst COMPAT_JAMO_END = 0x318e;\n\n// Hangul Jamo Extended-A (old Korean)\nconst JAMO_EXT_A_START = 0xa960;\nconst JAMO_EXT_A_END = 0xa97c;\n\n// Hangul Jamo Extended-B (old Korean)\nconst JAMO_EXT_B_START = 0xd7b0;\nconst JAMO_EXT_B_END = 0xd7fb;\n\n/**\n * Check if codepoint is a Hangul syllable\n */\nexport function isHangulSyllable(cp: number): boolean {\n\treturn cp >= HANGUL_BASE && cp <= HANGUL_END;\n}\n\n/**\n * Check if codepoint is a Hangul Jamo (conjoining)\n */\nexport function isHangulJamo(cp: number): boolean {\n\treturn (\n\t\t(cp >= JAMO_L_BASE && cp <= 0x11ff) ||\n\t\t(cp >= JAMO_EXT_A_START && cp <= JAMO_EXT_A_END) ||\n\t\t(cp >= JAMO_EXT_B_START && cp <= JAMO_EXT_B_END)\n\t);\n}\n\n/**\n * Check if codepoint is a leading consonant (L)\n */\nexport function isJamoL(cp: number): boolean {\n\treturn (\n\t\t(cp >= JAMO_L_BASE && cp < JAMO_L_BASE + JAMO_L_COUNT) ||\n\t\t(cp >= JAMO_EXT_A_START && cp <= JAMO_EXT_A_END)\n\t);\n}\n\n/**\n * Check if codepoint is a vowel (V)\n */\nexport function isJamoV(cp: number): boolean {\n\treturn (\n\t\t(cp >= JAMO_V_BASE && cp < JAMO_V_BASE + JAMO_V_COUNT) ||\n\t\t(cp >= 0xd7b0 && cp <= 0xd7c6)\n\t);\n}\n\n/**\n * Check if codepoint is a trailing consonant (T)\n */\nexport function isJamoT(cp: number): boolean {\n\treturn (\n\t\t(cp > JAMO_T_BASE && cp <= JAMO_T_BASE + JAMO_T_COUNT - 1) ||\n\t\t(cp >= 0xd7cb && cp <= 0xd7fb)\n\t);\n}\n\n/**\n * Decompose a precomposed Hangul syllable into Jamo\n */\nexport function decomposeHangul(cp: number): number[] {\n\tif (!isHangulSyllable(cp)) return [cp];\n\n\tconst syllableIndex = cp - HANGUL_BASE;\n\tconst l = Math.floor(syllableIndex / JAMO_VT_COUNT);\n\tconst v = Math.floor((syllableIndex % JAMO_VT_COUNT) / JAMO_T_COUNT);\n\tconst t = syllableIndex % JAMO_T_COUNT;\n\n\tconst result = [JAMO_L_BASE + l, JAMO_V_BASE + v];\n\tif (t > 0) {\n\t\tresult.push(JAMO_T_BASE + t);\n\t}\n\treturn result;\n}\n\n/**\n * Compose Jamo into a precomposed Hangul syllable\n */\nexport function composeHangul(\n\tl: number,\n\tv: number,\n\tt: number = 0,\n): number | null {\n\t// Normalize indices\n\tconst lIndex = l - JAMO_L_BASE;\n\tconst vIndex = v - JAMO_V_BASE;\n\tconst tIndex = t === 0 ? 0 : t - JAMO_T_BASE;\n\n\tif (lIndex < 0 || lIndex >= JAMO_L_COUNT) return null;\n\tif (vIndex < 0 || vIndex >= JAMO_V_COUNT) return null;\n\tif (tIndex < 0 || tIndex >= JAMO_T_COUNT) return null;\n\n\treturn HANGUL_BASE + lIndex * JAMO_VT_COUNT + vIndex * JAMO_T_COUNT + tIndex;\n}\n\n/**\n * Hangul syllable types\n */\nexport enum HangulSyllableType {\n\tNotApplicable = 0,\n\tLeadingJamo = 1, // L\n\tVowelJamo = 2, // V\n\tTrailingJamo = 3, // T\n\tLVSyllable = 4, // LV (no trailing)\n\tLVTSyllable = 5, // LVT (with trailing)\n}\n\n/**\n * Get the syllable type of a codepoint\n */\nexport function getHangulSyllableType(cp: number): HangulSyllableType {\n\tif (isJamoL(cp)) return HangulSyllableType.LeadingJamo;\n\tif (isJamoV(cp)) return HangulSyllableType.VowelJamo;\n\tif (isJamoT(cp)) return HangulSyllableType.TrailingJamo;\n\n\tif (isHangulSyllable(cp)) {\n\t\tconst syllableIndex = cp - HANGUL_BASE;\n\t\tconst t = syllableIndex % JAMO_T_COUNT;\n\t\treturn t === 0\n\t\t\t? HangulSyllableType.LVSyllable\n\t\t\t: HangulSyllableType.LVTSyllable;\n\t}\n\n\treturn HangulSyllableType.NotApplicable;\n}\n\n/**\n * Feature masks for Hangul\n */\nexport const HangulFeatureMask = {\n\tljmo: 0x0001, // Leading jamo forms\n\tvjmo: 0x0002, // Vowel jamo forms\n\ttjmo: 0x0004, // Trailing jamo forms\n} as const;\n\n/**\n * Setup Hangul masks for feature application\n */\nexport function setupHangulMasks(infos: GlyphInfo[]): void {\n\tfor (const info of infos) {\n\t\tconst type = getHangulSyllableType(info.codepoint);\n\n\t\tswitch (type) {\n\t\t\tcase HangulSyllableType.LeadingJamo:\n\t\t\t\tinfo.mask |= HangulFeatureMask.ljmo;\n\t\t\t\tbreak;\n\t\t\tcase HangulSyllableType.VowelJamo:\n\t\t\t\tinfo.mask |= HangulFeatureMask.vjmo;\n\t\t\t\tbreak;\n\t\t\tcase HangulSyllableType.TrailingJamo:\n\t\t\t\tinfo.mask |= HangulFeatureMask.tjmo;\n\t\t\t\tbreak;\n\t\t\tcase HangulSyllableType.LVSyllable:\n\t\t\tcase HangulSyllableType.LVTSyllable:\n\t\t\t\t// Precomposed syllables don't need special features\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * Normalize Hangul - compose Jamo sequences into syllables where possible\n */\nexport function normalizeHangul(infos: GlyphInfo[]): GlyphInfo[] {\n\tconst result: GlyphInfo[] = [];\n\tlet i = 0;\n\n\twhile (i < infos.length) {\n\t\tconst info = infos[i];\n\t\tif (!info) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tconst type = getHangulSyllableType(info.codepoint);\n\n\t\t// Try to compose L + V [+ T]\n\t\tif (type === HangulSyllableType.LeadingJamo && i + 1 < infos.length) {\n\t\t\tconst nextInfo = infos[i + 1];\n\t\t\tif (!nextInfo) {\n\t\t\t\tresult.push(info);\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst nextType = getHangulSyllableType(nextInfo.codepoint);\n\n\t\t\tif (nextType === HangulSyllableType.VowelJamo) {\n\t\t\t\t// Check for trailing jamo\n\t\t\t\tlet t = 0;\n\t\t\t\tlet consumed = 2;\n\n\t\t\t\tif (i + 2 < infos.length) {\n\t\t\t\t\tconst thirdInfo = infos[i + 2];\n\t\t\t\t\tif (thirdInfo) {\n\t\t\t\t\t\tconst thirdType = getHangulSyllableType(thirdInfo.codepoint);\n\n\t\t\t\t\t\tif (thirdType === HangulSyllableType.TrailingJamo) {\n\t\t\t\t\t\t\tt = thirdInfo.codepoint;\n\t\t\t\t\t\t\tconsumed = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst composed = composeHangul(info.codepoint, nextInfo.codepoint, t);\n\t\t\t\tif (composed !== null) {\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\tglyphId: info.glyphId, // Will be remapped\n\t\t\t\t\t\tcluster: info.cluster,\n\t\t\t\t\t\tmask: info.mask,\n\t\t\t\t\t\tcodepoint: composed,\n\t\t\t\t\t});\n\t\t\t\t\ti += consumed;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Try to compose LV + T\n\t\tif (type === HangulSyllableType.LVSyllable && i + 1 < infos.length) {\n\t\t\tconst nextInfo = infos[i + 1];\n\t\t\tif (!nextInfo) {\n\t\t\t\tresult.push(info);\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst nextType = getHangulSyllableType(nextInfo.codepoint);\n\n\t\t\tif (nextType === HangulSyllableType.TrailingJamo) {\n\t\t\t\t// Decompose LV, add T, recompose\n\t\t\t\tconst decomposed = decomposeHangul(info.codepoint);\n\t\t\t\tconst [firstJamo, secondJamo] = decomposed;\n\t\t\t\tif (\n\t\t\t\t\tdecomposed.length === 2 &&\n\t\t\t\t\tfirstJamo !== undefined &&\n\t\t\t\t\tsecondJamo !== undefined\n\t\t\t\t) {\n\t\t\t\t\tconst composed = composeHangul(\n\t\t\t\t\t\tfirstJamo,\n\t\t\t\t\t\tsecondJamo,\n\t\t\t\t\t\tnextInfo.codepoint,\n\t\t\t\t\t);\n\t\t\t\t\tif (composed !== null) {\n\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\tglyphId: info.glyphId,\n\t\t\t\t\t\t\tcluster: info.cluster,\n\t\t\t\t\t\t\tmask: info.mask,\n\t\t\t\t\t\t\tcodepoint: composed,\n\t\t\t\t\t\t});\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// No composition, keep as-is\n\t\tresult.push(info);\n\t\ti++;\n\t}\n\n\treturn result;\n}\n\n/**\n * Check if codepoint is Korean (Hangul or Jamo)\n */\nexport function isKorean(cp: number): boolean {\n\treturn (\n\t\tisHangulSyllable(cp) ||\n\t\tisHangulJamo(cp) ||\n\t\t(cp >= COMPAT_JAMO_START && cp <= COMPAT_JAMO_END)\n\t);\n}\n", "import type { GlyphInfo } from \"../../types.ts\";\n\n/**\n * Hebrew character categories\n */\nexport enum HebrewCategory {\n\tOther = 0,\n\tLetter = 1, // Regular letter\n\tPoint = 2, // Niqqud (vowel point)\n\tDagesh = 3, // Dagesh/Mapiq\n\tShin = 4, // Shin/Sin dot\n\tRafe = 5, // Rafe mark\n\tAccent = 6, // Cantillation marks\n\tMaqaf = 7, // Hebrew hyphen\n\tPunctuation = 8, // Punctuation\n}\n\n/**\n * Hebrew Unicode range\n */\nconst HEBREW_START = 0x0590;\nconst HEBREW_END = 0x05ff;\nconst HEBREW_EXTENDED_START = 0xfb1d;\nconst HEBREW_EXTENDED_END = 0xfb4f;\n\n/**\n * Check if codepoint is Hebrew\n */\nexport function isHebrew(cp: number): boolean {\n\treturn (\n\t\t(cp >= HEBREW_START && cp <= HEBREW_END) ||\n\t\t(cp >= HEBREW_EXTENDED_START && cp <= HEBREW_EXTENDED_END)\n\t);\n}\n\n/**\n * Get Hebrew category for a codepoint\n */\nexport function getHebrewCategory(cp: number): HebrewCategory {\n\t// Cantillation marks (0591-05AF)\n\tif (cp >= 0x0591 && cp <= 0x05af) return HebrewCategory.Accent;\n\n\t// Points (05B0-05BD)\n\tif (cp >= 0x05b0 && cp <= 0x05bd) return HebrewCategory.Point;\n\n\t// Maqaf\n\tif (cp === 0x05be) return HebrewCategory.Maqaf;\n\n\t// Rafe\n\tif (cp === 0x05bf) return HebrewCategory.Rafe;\n\n\t// Paseq, Sof Pasuq\n\tif (cp === 0x05c0 || cp === 0x05c3) return HebrewCategory.Punctuation;\n\n\t// Shin/Sin dot\n\tif (cp === 0x05c1 || cp === 0x05c2) return HebrewCategory.Shin;\n\n\t// Dagesh/Mapiq\n\tif (cp === 0x05bc) return HebrewCategory.Dagesh;\n\n\t// Meteg\n\tif (cp === 0x05bd) return HebrewCategory.Point;\n\n\t// Letters (05D0-05EA)\n\tif (cp >= 0x05d0 && cp <= 0x05ea) return HebrewCategory.Letter;\n\n\t// Final letters are handled the same\n\tif (cp >= 0x05f0 && cp <= 0x05f4) return HebrewCategory.Letter;\n\n\t// Extended forms (FB1D-FB4F)\n\tif (cp >= 0xfb1d && cp <= 0xfb4f) return HebrewCategory.Letter;\n\n\tif (isHebrew(cp)) return HebrewCategory.Other;\n\treturn HebrewCategory.Other;\n}\n\n/**\n * Set up masks for Hebrew shaping\n * Hebrew is relatively simple - mainly RTL with marks\n */\nexport function setupHebrewMasks(infos: GlyphInfo[]): void {\n\t// Hebrew shaping primarily relies on:\n\t// 1. Mark positioning (handled by GPOS)\n\t// 2. RTL reordering (handled by main shaper)\n\n\t// Group characters with their base letters\n\tlet baseIndex = 0;\n\n\tfor (let i = 0; i < infos.length; i++) {\n\t\tconst info = infos[i];\n\t\tif (!info) continue;\n\n\t\tconst cat = getHebrewCategory(info.codepoint);\n\n\t\t// Letters start new clusters\n\t\tif (cat === HebrewCategory.Letter) {\n\t\t\tbaseIndex = i;\n\t\t}\n\n\t\t// Store base index for mark attachment\n\t\tinfo.mask = (info.mask & 0xffff0000) | (baseIndex & 0xffff);\n\t}\n}\n", "import type { GlyphInfo } from \"../../types.ts\";\n\n/**\n * Indic syllable categories based on Unicode and OpenType spec\n */\nexport enum IndicCategory {\n\tX = 0, // Other/Unknown\n\tC = 1, // Consonant\n\tV = 2, // Independent vowel\n\tN = 3, // Nukta\n\tH = 4, // Halant/Virama\n\tZWNJ = 5, // Zero Width Non-Joiner\n\tZWJ = 6, // Zero Width Joiner\n\tM = 7, // Matra (dependent vowel)\n\tSM = 8, // Syllable modifier (anusvara, visarga)\n\tA = 9, // Accent mark\n\tVD = 10, // Vedic mark\n\tPlaceholder = 11, // Placeholder (dotted circle)\n\tDotted_Circle = 12, // Explicit dotted circle\n\tRS = 13, // Repha form\n\tCoeng = 14, // Coeng (Khmer virama)\n\tRa = 15, // Ra consonant (for repha)\n\tCM = 16, // Consonant modifier\n\tSymbol = 17, // Symbol\n\tCS = 18, // Consonant with stacker\n}\n\n/**\n * Indic syllabic position\n */\nexport enum IndicPosition {\n\tStart = 0,\n\tRaToBecomeReph = 1,\n\tPreM = 2,\n\tPreC = 3,\n\tBaseC = 4,\n\tAfterMain = 5,\n\tAboveC = 6,\n\tBeforeSub = 7,\n\tBelowC = 8,\n\tAfterSub = 9,\n\tBeforePost = 10,\n\tPostC = 11,\n\tAfterPost = 12,\n\tFinalC = 13,\n\tSMVD = 14,\n\tEnd = 15,\n}\n\n/**\n * Per-glyph Indic shaping data\n */\nexport interface IndicGlyphData {\n\tcategory: IndicCategory;\n\tposition: IndicPosition;\n\tsyllableIndex: number;\n}\n\n/**\n * Determine if codepoint is in Devanagari range\n */\nfunction isDevanagari(cp: number): boolean {\n\treturn cp >= 0x0900 && cp <= 0x097f;\n}\n\n/**\n * Determine if codepoint is in Bengali range\n */\nfunction isBengali(cp: number): boolean {\n\treturn cp >= 0x0980 && cp <= 0x09ff;\n}\n\n/**\n * Determine if codepoint is in Gurmukhi range\n */\nfunction isGurmukhi(cp: number): boolean {\n\treturn cp >= 0x0a00 && cp <= 0x0a7f;\n}\n\n/**\n * Determine if codepoint is in Gujarati range\n */\nfunction isGujarati(cp: number): boolean {\n\treturn cp >= 0x0a80 && cp <= 0x0aff;\n}\n\n/**\n * Determine if codepoint is in Oriya range\n */\nfunction isOriya(cp: number): boolean {\n\treturn cp >= 0x0b00 && cp <= 0x0b7f;\n}\n\n/**\n * Determine if codepoint is in Tamil range\n */\nfunction isTamil(cp: number): boolean {\n\treturn cp >= 0x0b80 && cp <= 0x0bff;\n}\n\n/**\n * Determine if codepoint is in Telugu range\n */\nfunction isTelugu(cp: number): boolean {\n\treturn cp >= 0x0c00 && cp <= 0x0c7f;\n}\n\n/**\n * Determine if codepoint is in Kannada range\n */\nfunction isKannada(cp: number): boolean {\n\treturn cp >= 0x0c80 && cp <= 0x0cff;\n}\n\n/**\n * Determine if codepoint is in Malayalam range\n */\nfunction isMalayalam(cp: number): boolean {\n\treturn cp >= 0x0d00 && cp <= 0x0d7f;\n}\n\n/**\n * Check if a codepoint is an Indic script\n */\nexport function isIndic(cp: number): boolean {\n\treturn (\n\t\tisDevanagari(cp) ||\n\t\tisBengali(cp) ||\n\t\tisGurmukhi(cp) ||\n\t\tisGujarati(cp) ||\n\t\tisOriya(cp) ||\n\t\tisTamil(cp) ||\n\t\tisTelugu(cp) ||\n\t\tisKannada(cp) ||\n\t\tisMalayalam(cp)\n\t);\n}\n\n/**\n * Get the Indic category for a codepoint\n */\nexport function getIndicCategory(cp: number): IndicCategory {\n\t// Zero-width characters\n\tif (cp === 0x200c) return IndicCategory.ZWNJ;\n\tif (cp === 0x200d) return IndicCategory.ZWJ;\n\tif (cp === 0x25cc) return IndicCategory.Dotted_Circle;\n\n\t// Devanagari (0900-097F)\n\tif (isDevanagari(cp)) {\n\t\t// Vowel signs (matras)\n\t\tif (\n\t\t\t(cp >= 0x093a && cp <= 0x093b) ||\n\t\t\t(cp >= 0x093e && cp <= 0x094c) ||\n\t\t\t(cp >= 0x094e && cp <= 0x094f) ||\n\t\t\t(cp >= 0x0955 && cp <= 0x0957)\n\t\t) {\n\t\t\treturn IndicCategory.M;\n\t\t}\n\t\t// Virama\n\t\tif (cp === 0x094d) return IndicCategory.H;\n\t\t// Nukta\n\t\tif (cp === 0x093c) return IndicCategory.N;\n\t\t// Anusvara, Visarga, Chandrabindu\n\t\tif (cp >= 0x0901 && cp <= 0x0903) return IndicCategory.SM;\n\t\t// Vedic marks\n\t\tif (cp >= 0x0951 && cp <= 0x0954) return IndicCategory.A;\n\t\t// Independent vowels\n\t\tif (\n\t\t\t(cp >= 0x0904 && cp <= 0x0914) ||\n\t\t\tcp === 0x0960 ||\n\t\t\tcp === 0x0961 ||\n\t\t\tcp === 0x0972 ||\n\t\t\t(cp >= 0x0976 && cp <= 0x0977)\n\t\t) {\n\t\t\treturn IndicCategory.V;\n\t\t}\n\t\t// Consonants\n\t\tif (\n\t\t\t(cp >= 0x0915 && cp <= 0x0939) ||\n\t\t\t(cp >= 0x0958 && cp <= 0x095f) ||\n\t\t\tcp === 0x0978 ||\n\t\t\tcp === 0x0979 ||\n\t\t\tcp === 0x097a ||\n\t\t\t(cp >= 0x097b && cp <= 0x097c) ||\n\t\t\t(cp >= 0x097e && cp <= 0x097f)\n\t\t) {\n\t\t\t// Ra for repha\n\t\t\tif (cp === 0x0930) return IndicCategory.Ra;\n\t\t\treturn IndicCategory.C;\n\t\t}\n\t\t// Digits and symbols\n\t\tif (cp >= 0x0966 && cp <= 0x096f) return IndicCategory.Symbol;\n\t\treturn IndicCategory.X;\n\t}\n\n\t// Bengali (0980-09FF)\n\tif (isBengali(cp)) {\n\t\tif (\n\t\t\t(cp >= 0x09be && cp <= 0x09c4) ||\n\t\t\t(cp >= 0x09c7 && cp <= 0x09c8) ||\n\t\t\t(cp >= 0x09cb && cp <= 0x09cc) ||\n\t\t\tcp === 0x09d7\n\t\t) {\n\t\t\treturn IndicCategory.M;\n\t\t}\n\t\tif (cp === 0x09cd) return IndicCategory.H;\n\t\tif (cp === 0x09bc) return IndicCategory.N;\n\t\tif (cp >= 0x0981 && cp <= 0x0983) return IndicCategory.SM;\n\t\tif (\n\t\t\t(cp >= 0x0985 && cp <= 0x098c) ||\n\t\t\t(cp >= 0x098f && cp <= 0x0990) ||\n\t\t\t(cp >= 0x0993 && cp <= 0x0994) ||\n\t\t\tcp === 0x09e0 ||\n\t\t\tcp === 0x09e1\n\t\t) {\n\t\t\treturn IndicCategory.V;\n\t\t}\n\t\tif (\n\t\t\t(cp >= 0x0995 && cp <= 0x09a8) ||\n\t\t\t(cp >= 0x09aa && cp <= 0x09b0) ||\n\t\t\tcp === 0x09b2 ||\n\t\t\t(cp >= 0x09b6 && cp <= 0x09b9) ||\n\t\t\t(cp >= 0x09dc && cp <= 0x09dd) ||\n\t\t\t(cp >= 0x09df && cp <= 0x09e1)\n\t\t) {\n\t\t\tif (cp === 0x09b0) return IndicCategory.Ra;\n\t\t\treturn IndicCategory.C;\n\t\t}\n\t\treturn IndicCategory.X;\n\t}\n\n\t// Other Indic scripts - simplified handling\n\t// Tamil, Telugu, Kannada, Malayalam, Gurmukhi, Gujarati, Oriya\n\tif (\n\t\tisGurmukhi(cp) ||\n\t\tisGujarati(cp) ||\n\t\tisOriya(cp) ||\n\t\tisTamil(cp) ||\n\t\tisTelugu(cp) ||\n\t\tisKannada(cp) ||\n\t\tisMalayalam(cp)\n\t) {\n\t\tconst offset = cp & 0x7f; // Position within the block\n\t\t// Common patterns for Indic scripts\n\t\tif (offset >= 0x01 && offset <= 0x03) return IndicCategory.SM; // Anusvara etc\n\t\tif (offset >= 0x05 && offset <= 0x14) return IndicCategory.V; // Vowels\n\t\tif (offset >= 0x15 && offset <= 0x39) return IndicCategory.C; // Consonants\n\t\tif (offset === 0x3c) return IndicCategory.N; // Nukta\n\t\tif (offset >= 0x3e && offset <= 0x4c) return IndicCategory.M; // Matras\n\t\tif (offset === 0x4d) return IndicCategory.H; // Virama\n\t\treturn IndicCategory.X;\n\t}\n\n\treturn IndicCategory.X;\n}\n\n/**\n * Syllable structure for Indic scripts\n */\ninterface Syllable {\n\tstart: number;\n\tend: number;\n\thasReph: boolean;\n\tbaseConsonant: number;\n}\n\n/**\n * Find syllable boundaries in the glyph buffer\n */\nexport function findSyllables(infos: GlyphInfo[]): Syllable[] {\n\tconst syllables: Syllable[] = [];\n\tconst n = infos.length;\n\tif (n === 0) return syllables;\n\n\tlet start = 0;\n\n\twhile (start < n) {\n\t\tconst syllable = parseSyllable(infos, start);\n\t\tsyllables.push(syllable);\n\t\tstart = syllable.end;\n\t}\n\n\treturn syllables;\n}\n\n/**\n * Parse a single syllable starting at the given position\n */\nfunction parseSyllable(infos: GlyphInfo[], start: number): Syllable {\n\tconst n = infos.length;\n\tlet pos = start;\n\n\t// Check for initial consonant cluster with halant\n\tlet baseConsonant = -1;\n\tlet hasReph = false;\n\n\t// Look for Ra + H at the start (potential Reph)\n\tif (pos + 1 < n) {\n\t\tconst info1 = infos[pos];\n\t\tconst info2 = infos[pos + 1];\n\t\tif (info1 && info2) {\n\t\t\tconst cat1 = getIndicCategory(info1.codepoint ?? 0);\n\t\t\tconst cat2 = getIndicCategory(info2.codepoint ?? 0);\n\t\t\tif (cat1 === IndicCategory.Ra && cat2 === IndicCategory.H) {\n\t\t\t\thasReph = true;\n\t\t\t\tpos += 2;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Find base consonant (last consonant before matras/end)\n\tlet lastConsonant = -1;\n\twhile (pos < n) {\n\t\tconst info = infos[pos];\n\t\tif (!info) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\t\tconst cp = info.codepoint ?? 0;\n\t\tconst cat = getIndicCategory(cp);\n\n\t\tif (cat === IndicCategory.C || cat === IndicCategory.Ra) {\n\t\t\tlastConsonant = pos;\n\t\t\tpos++;\n\t\t\t// Check for nukta\n\t\t\tif (pos < n) {\n\t\t\t\tconst nextInfo = infos[pos];\n\t\t\t\tif (\n\t\t\t\t\tnextInfo &&\n\t\t\t\t\tgetIndicCategory(nextInfo.codepoint ?? 0) === IndicCategory.N\n\t\t\t\t) {\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check for halant (may continue consonant cluster)\n\t\t\tif (pos < n) {\n\t\t\t\tconst hInfo = infos[pos];\n\t\t\t\tif (\n\t\t\t\t\thInfo &&\n\t\t\t\t\tgetIndicCategory(hInfo.codepoint ?? 0) === IndicCategory.H\n\t\t\t\t) {\n\t\t\t\t\tpos++;\n\t\t\t\t\t// After halant, might have ZWJ/ZWNJ or another consonant\n\t\t\t\t\tif (pos < n) {\n\t\t\t\t\t\tconst afterH = infos[pos];\n\t\t\t\t\t\tif (afterH) {\n\t\t\t\t\t\t\tconst nextCat = getIndicCategory(afterH.codepoint ?? 0);\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tnextCat === IndicCategory.ZWJ ||\n\t\t\t\t\t\t\t\tnextCat === IndicCategory.ZWNJ\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue; // Look for more consonants\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (cat === IndicCategory.V) {\n\t\t\t// Independent vowel as syllable base\n\t\t\tpos++;\n\t\t\tbreak;\n\t\t} else if (cat === IndicCategory.N) {\n\t\t\t// Standalone nukta - skip\n\t\t\tpos++;\n\t\t} else {\n\t\t\t// Non-syllable character, end here\n\t\t\tif (lastConsonant === -1) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tbaseConsonant = lastConsonant >= 0 ? lastConsonant : start;\n\n\t// Consume matras, anusvara, visarga\n\twhile (pos < n) {\n\t\tconst info = infos[pos];\n\t\tif (!info) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\t\tconst cp = info.codepoint ?? 0;\n\t\tconst cat = getIndicCategory(cp);\n\n\t\tif (\n\t\t\tcat === IndicCategory.M ||\n\t\t\tcat === IndicCategory.SM ||\n\t\t\tcat === IndicCategory.A ||\n\t\t\tcat === IndicCategory.N\n\t\t) {\n\t\t\tpos++;\n\t\t} else if (cat === IndicCategory.H) {\n\t\t\t// Halant at end (final form)\n\t\t\tpos++;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Ensure we advance at least one position\n\tif (pos === start) {\n\t\tpos = start + 1;\n\t}\n\n\treturn {\n\t\tstart,\n\t\tend: pos,\n\t\thasReph,\n\t\tbaseConsonant,\n\t};\n}\n\n/**\n * Indic feature masks for OpenType features\n */\nexport const IndicFeatureMask = {\n\tnukt: 0x0001, // Nukta forms\n\takhn: 0x0002, // Akhand forms\n\trphf: 0x0004, // Reph forms\n\trkrf: 0x0008, // Rakaar forms\n\tpref: 0x0010, // Pre-base forms\n\tblwf: 0x0020, // Below-base forms\n\tabvf: 0x0040, // Above-base forms\n\thalf: 0x0080, // Half forms\n\tpstf: 0x0100, // Post-base forms\n\tvatu: 0x0200, // Vattu variants\n\tcjct: 0x0400, // Conjunct forms\n\tinit: 0x0800, // Initial forms\n\tpres: 0x1000, // Pre-base substitutions\n\tabvs: 0x2000, // Above-base substitutions\n\tblws: 0x4000, // Below-base substitutions\n\tpsts: 0x8000, // Post-base substitutions\n} as const;\n\n/**\n * Matra position in syllable\n */\nexport enum MatraPosition {\n\tPreBase = 0,\n\tAboveBase = 1,\n\tBelowBase = 2,\n\tPostBase = 3,\n}\n\n/**\n * Get matra position based on codepoint\n */\nexport function getMatraPosition(cp: number): MatraPosition {\n\t// Devanagari\n\tif (cp >= 0x0900 && cp <= 0x097f) {\n\t\t// Pre-base:  (093F)\n\t\tif (cp === 0x093f) return MatraPosition.PreBase;\n\t\t// Above-base:     (0945-0948)\n\t\tif (cp >= 0x0945 && cp <= 0x0948) return MatraPosition.AboveBase;\n\t\t// Below-base:     (0941-0944)\n\t\tif (cp >= 0x0941 && cp <= 0x0944) return MatraPosition.BelowBase;\n\t\t// Post-base: everything else\n\t\treturn MatraPosition.PostBase;\n\t}\n\n\t// Bengali\n\tif (cp >= 0x0980 && cp <= 0x09ff) {\n\t\t// Pre-base:  (09BF)\n\t\tif (cp === 0x09bf) return MatraPosition.PreBase;\n\t\t// Pre-base split vowels:   (09C7-09C8) - left part\n\t\tif (cp === 0x09c7 || cp === 0x09c8) return MatraPosition.PreBase;\n\t\t// Below-base:     (09C1-09C4)\n\t\tif (cp >= 0x09c1 && cp <= 0x09c4) return MatraPosition.BelowBase;\n\t\treturn MatraPosition.PostBase;\n\t}\n\n\t// Tamil\n\tif (cp >= 0x0b80 && cp <= 0x0bff) {\n\t\t// Pre-base:    (0BC6-0BC8)\n\t\tif (cp >= 0x0bc6 && cp <= 0x0bc8) return MatraPosition.PreBase;\n\t\t// Above-base: none\n\t\t// Below-base:   (0BC1-0BC2)\n\t\tif (cp === 0x0bc1 || cp === 0x0bc2) return MatraPosition.BelowBase;\n\t\treturn MatraPosition.PostBase;\n\t}\n\n\t// Telugu\n\tif (cp >= 0x0c00 && cp <= 0x0c7f) {\n\t\t// Above-base:      (0C3E-0C40, 0C46-0C48)\n\t\tif ((cp >= 0x0c3e && cp <= 0x0c40) || (cp >= 0x0c46 && cp <= 0x0c48)) {\n\t\t\treturn MatraPosition.AboveBase;\n\t\t}\n\t\t// Below-base:     (0C41-0C44)\n\t\tif (cp >= 0x0c41 && cp <= 0x0c44) return MatraPosition.BelowBase;\n\t\treturn MatraPosition.PostBase;\n\t}\n\n\t// Kannada\n\tif (cp >= 0x0c80 && cp <= 0x0cff) {\n\t\t// Above-base: similar to Telugu\n\t\tif ((cp >= 0x0cbe && cp <= 0x0cc0) || (cp >= 0x0cc6 && cp <= 0x0cc8)) {\n\t\t\treturn MatraPosition.AboveBase;\n\t\t}\n\t\tif (cp >= 0x0cc1 && cp <= 0x0cc4) return MatraPosition.BelowBase;\n\t\treturn MatraPosition.PostBase;\n\t}\n\n\t// Malayalam\n\tif (cp >= 0x0d00 && cp <= 0x0d7f) {\n\t\t// Pre-base:    (0D46-0D48)\n\t\tif (cp >= 0x0d46 && cp <= 0x0d48) return MatraPosition.PreBase;\n\t\t// Below-base:    (0D41-0D43)\n\t\tif (cp >= 0x0d41 && cp <= 0x0d43) return MatraPosition.BelowBase;\n\t\treturn MatraPosition.PostBase;\n\t}\n\n\t// Gurmukhi\n\tif (cp >= 0x0a00 && cp <= 0x0a7f) {\n\t\t// Pre-base:  (0A3F)\n\t\tif (cp === 0x0a3f) return MatraPosition.PreBase;\n\t\t// Below-base:   (0A41-0A42)\n\t\tif (cp === 0x0a41 || cp === 0x0a42) return MatraPosition.BelowBase;\n\t\treturn MatraPosition.PostBase;\n\t}\n\n\t// Gujarati\n\tif (cp >= 0x0a80 && cp <= 0x0aff) {\n\t\t// Pre-base:  (0ABF)\n\t\tif (cp === 0x0abf) return MatraPosition.PreBase;\n\t\t// Below-base:     (0AC1-0AC4)\n\t\tif (cp >= 0x0ac1 && cp <= 0x0ac4) return MatraPosition.BelowBase;\n\t\treturn MatraPosition.PostBase;\n\t}\n\n\t// Oriya\n\tif (cp >= 0x0b00 && cp <= 0x0b7f) {\n\t\t// Pre-base:  (0B3F)\n\t\tif (cp === 0x0b3f) return MatraPosition.PreBase;\n\t\t// Below-base:    (0B41-0B43)\n\t\tif (cp >= 0x0b41 && cp <= 0x0b43) return MatraPosition.BelowBase;\n\t\treturn MatraPosition.PostBase;\n\t}\n\n\treturn MatraPosition.PostBase;\n}\n\n/**\n * Set up masks and syllable indices for Indic shaping\n */\nexport function setupIndicMasks(infos: GlyphInfo[]): void {\n\tconst syllables = findSyllables(infos);\n\n\tfor (const [i, syllable] of syllables.entries()) {\n\t\t// Mark syllable boundaries in mask\n\t\tfor (let j = syllable.start; j < syllable.end; j++) {\n\t\t\tconst info = infos[j];\n\t\t\tif (info) {\n\t\t\t\t// Store syllable index in upper bits\n\t\t\t\tinfo.mask = (info.mask & 0x0000ffff) | ((i & 0xffff) << 16);\n\n\t\t\t\tconst cat = getIndicCategory(info.codepoint);\n\n\t\t\t\t// Nukta - always apply nukt feature\n\t\t\t\tif (cat === IndicCategory.N) {\n\t\t\t\t\tinfo.mask |= IndicFeatureMask.nukt;\n\t\t\t\t}\n\n\t\t\t\t// Halant handling\n\t\t\t\tif (cat === IndicCategory.H) {\n\t\t\t\t\t// Check position relative to base\n\t\t\t\t\tif (j < syllable.baseConsonant) {\n\t\t\t\t\t\t// Pre-base halant - half forms\n\t\t\t\t\t\tinfo.mask |= IndicFeatureMask.half;\n\t\t\t\t\t} else if (j > syllable.baseConsonant) {\n\t\t\t\t\t\t// Post-base halant - below/post forms\n\t\t\t\t\t\tinfo.mask |= IndicFeatureMask.blwf | IndicFeatureMask.pstf;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Consonant handling\n\t\t\t\tif (cat === IndicCategory.C || cat === IndicCategory.Ra) {\n\t\t\t\t\tif (j < syllable.baseConsonant) {\n\t\t\t\t\t\t// Pre-base consonant\n\t\t\t\t\t\tinfo.mask |= IndicFeatureMask.half | IndicFeatureMask.cjct;\n\t\t\t\t\t} else if (j > syllable.baseConsonant) {\n\t\t\t\t\t\t// Post-base consonant\n\t\t\t\t\t\tinfo.mask |=\n\t\t\t\t\t\t\tIndicFeatureMask.blwf |\n\t\t\t\t\t\t\tIndicFeatureMask.pstf |\n\t\t\t\t\t\t\tIndicFeatureMask.vatu;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Reph handling\n\t\t\t\tif (syllable.hasReph && j < syllable.start + 2) {\n\t\t\t\t\tinfo.mask |= IndicFeatureMask.rphf;\n\t\t\t\t}\n\n\t\t\t\t// Matra handling\n\t\t\t\tif (cat === IndicCategory.M) {\n\t\t\t\t\tconst matraPos = getMatraPosition(info.codepoint);\n\t\t\t\t\tswitch (matraPos) {\n\t\t\t\t\t\tcase MatraPosition.PreBase:\n\t\t\t\t\t\t\tinfo.mask |= IndicFeatureMask.pref | IndicFeatureMask.pres;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase MatraPosition.AboveBase:\n\t\t\t\t\t\t\tinfo.mask |= IndicFeatureMask.abvf | IndicFeatureMask.abvs;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase MatraPosition.BelowBase:\n\t\t\t\t\t\t\tinfo.mask |= IndicFeatureMask.blwf | IndicFeatureMask.blws;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase MatraPosition.PostBase:\n\t\t\t\t\t\t\tinfo.mask |= IndicFeatureMask.pstf | IndicFeatureMask.psts;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Syllable modifiers (anusvara, visarga)\n\t\t\t\tif (cat === IndicCategory.SM) {\n\t\t\t\t\tinfo.mask |= IndicFeatureMask.abvs | IndicFeatureMask.psts;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Reorder glyphs within a syllable for correct visual display\n * This handles:\n * - Moving pre-base matras before the base consonant\n * - Moving reph to its final position\n */\nexport function reorderIndic(infos: GlyphInfo[]): void {\n\tconst syllables = findSyllables(infos);\n\n\tfor (const syllable of syllables) {\n\t\treorderSyllable(infos, syllable);\n\t}\n}\n\n/**\n * Reorder a single syllable\n */\nfunction reorderSyllable(infos: GlyphInfo[], syllable: Syllable): void {\n\tconst { start, end, baseConsonant, hasReph } = syllable;\n\n\t// Collect pre-base matras that need to move\n\tconst preBaseMatras: { index: number; info: GlyphInfo }[] = [];\n\n\tfor (let i = baseConsonant + 1; i < end; i++) {\n\t\tconst info = infos[i];\n\t\tif (!info) continue;\n\n\t\tconst cat = getIndicCategory(info.codepoint);\n\t\tif (cat === IndicCategory.M) {\n\t\t\tconst matraPos = getMatraPosition(info.codepoint);\n\t\t\tif (matraPos === MatraPosition.PreBase) {\n\t\t\t\tpreBaseMatras.push({ index: i, info });\n\t\t\t}\n\t\t}\n\t}\n\n\t// Move pre-base matras before the base (or before reph if present)\n\tif (preBaseMatras.length > 0) {\n\t\t// Sort by original index descending to process from right to left\n\t\tpreBaseMatras.sort((a, b) => b.index - a.index);\n\n\t\tfor (const { index, info } of preBaseMatras) {\n\t\t\t// Remove from current position\n\t\t\tinfos.splice(index, 1);\n\n\t\t\t// Insert before base (accounting for reph)\n\t\t\tconst insertPos = hasReph ? start + 2 : start;\n\t\t\tinfos.splice(insertPos, 0, info);\n\t\t}\n\t}\n\n\t// Handle reph movement (Ra + Halant at start moves to end of syllable)\n\t// Note: In many scripts, reph moves to after the matra\n\t// This is a simplified implementation - full implementation would check\n\t// script-specific rules\n\tif (hasReph && end > start + 2) {\n\t\t// Reph is at positions start and start+1 (Ra + Halant)\n\t\t// Move to end of syllable, before final consonant markers\n\t\tconst rephRa = infos[start];\n\t\tconst rephH = infos[start + 1];\n\n\t\tif (rephRa && rephH) {\n\t\t\t// Find insertion point: after matras, before syllable modifiers\n\t\t\tlet rephTarget = end - 1;\n\n\t\t\t// Adjust for any syllable modifiers at the end\n\t\t\twhile (rephTarget > baseConsonant) {\n\t\t\t\tconst targetInfo = infos[rephTarget];\n\t\t\t\tif (!targetInfo) break;\n\n\t\t\t\tconst cat = getIndicCategory(targetInfo.codepoint);\n\t\t\t\tif (cat === IndicCategory.SM || cat === IndicCategory.A) {\n\t\t\t\t\trephTarget--;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Only move if target is different from current position\n\t\t\tif (rephTarget > start + 1) {\n\t\t\t\t// Remove Ra + Halant from start\n\t\t\t\tinfos.splice(start, 2);\n\n\t\t\t\t// Insert at new position (adjusted for removal)\n\t\t\t\tconst adjustedTarget = rephTarget - 2;\n\t\t\t\tinfos.splice(adjustedTarget + 1, 0, rephRa, rephH);\n\t\t\t}\n\t\t}\n\t}\n}\n", "import type { GlyphInfo } from \"../../types.ts\";\n\n/**\n * Khmer shaper\n * Handles Khmer script syllable structure and reordering\n */\n\n// Khmer Unicode range\nconst KHMER_START = 0x1780;\nconst KHMER_END = 0x17ff;\nconst KHMER_SYMBOLS_START = 0x19e0;\nconst KHMER_SYMBOLS_END = 0x19ff;\n\n/**\n * Khmer character categories\n */\nexport enum KhmerCategory {\n\tOther = 0,\n\tConsonant = 1,\n\tIndependentVowel = 2,\n\tDependentVowel = 3,\n\tCoeng = 4, // Subscript sign ()\n\tRegister = 5, // Register shifters\n\tRobat = 6, // Consonant shifter ()\n\tSign = 7,\n\tAnusvara = 8, // Nikahit ()\n\tVisarga = 9, // Reahmuk ()\n}\n\n/**\n * Get Khmer character category\n */\nexport function getKhmerCategory(cp: number): KhmerCategory {\n\tif (cp < KHMER_START || cp > KHMER_END) return KhmerCategory.Other;\n\n\t// Consonants (-)\n\tif (cp >= 0x1780 && cp <= 0x17a2) return KhmerCategory.Consonant;\n\tif (cp === 0x17a3 || cp === 0x17a4) return KhmerCategory.IndependentVowel;\n\n\t// Independent vowels (-)\n\tif (cp >= 0x17a5 && cp <= 0x17b3) return KhmerCategory.IndependentVowel;\n\n\t// Dependent vowels (-)\n\tif (cp >= 0x17b6 && cp <= 0x17c5) return KhmerCategory.DependentVowel;\n\n\t// Signs\n\tif (cp === 0x17c6) return KhmerCategory.Anusvara; // Nikahit\n\tif (cp === 0x17c7) return KhmerCategory.Visarga; // Reahmuk\n\tif (cp === 0x17c8) return KhmerCategory.Sign; // Yuukaleapintu\n\n\t// Register shifters\n\tif (cp === 0x17c9 || cp === 0x17ca) return KhmerCategory.Register;\n\n\t// Coeng (subscript marker)\n\tif (cp === 0x17d2) return KhmerCategory.Coeng;\n\n\t// Robat\n\tif (cp === 0x17cc) return KhmerCategory.Robat;\n\n\t// Other signs\n\tif (cp >= 0x17cb && cp <= 0x17d1) return KhmerCategory.Sign;\n\tif (cp >= 0x17d3 && cp <= 0x17dd) return KhmerCategory.Sign;\n\n\treturn KhmerCategory.Other;\n}\n\n/**\n * Khmer feature masks\n */\nexport const KhmerFeatureMask = {\n\tpref: 0x0001, // Pre-base forms\n\tblwf: 0x0002, // Below-base forms\n\tabvf: 0x0004, // Above-base forms\n\tpstf: 0x0008, // Post-base forms\n\tcfar: 0x0010, // Conjunct form after Ra\n\tpres: 0x0020, // Pre-base substitutions\n\tabvs: 0x0040, // Above-base substitutions\n\tblws: 0x0080, // Below-base substitutions\n\tpsts: 0x0100, // Post-base substitutions\n\tclig: 0x0200, // Contextual ligatures\n} as const;\n\n/**\n * Check if codepoint is Khmer\n */\nexport function isKhmer(cp: number): boolean {\n\treturn (\n\t\t(cp >= KHMER_START && cp <= KHMER_END) ||\n\t\t(cp >= KHMER_SYMBOLS_START && cp <= KHMER_SYMBOLS_END)\n\t);\n}\n\n/**\n * Setup Khmer masks for feature application\n */\nexport function setupKhmerMasks(infos: GlyphInfo[]): void {\n\tlet i = 0;\n\n\twhile (i < infos.length) {\n\t\tconst info = infos[i];\n\t\tif (!info) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tconst cat = getKhmerCategory(info.codepoint);\n\n\t\tif (cat === KhmerCategory.Other) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Find syllable extent\n\t\tconst _syllableStart = i;\n\t\tlet _base = -1;\n\n\t\t// Find base consonant\n\t\tif (cat === KhmerCategory.Consonant) {\n\t\t\t_base = i;\n\t\t}\n\n\t\t// Process syllable\n\t\tlet j = i + 1;\n\t\twhile (j < infos.length) {\n\t\t\tconst nextInfo = infos[j];\n\t\t\tif (!nextInfo) {\n\t\t\t\tj++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst nextCat = getKhmerCategory(nextInfo.codepoint);\n\n\t\t\tif (nextCat === KhmerCategory.Other) break;\n\t\t\tif (nextCat === KhmerCategory.Consonant) {\n\t\t\t\t// Check if followed by coeng\n\t\t\t\tconst prevInfo = infos[j - 1];\n\t\t\t\tif (\n\t\t\t\t\tprevInfo &&\n\t\t\t\t\tgetKhmerCategory(prevInfo.codepoint) !== KhmerCategory.Coeng\n\t\t\t\t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Coeng + consonant = subscript consonant\n\t\t\tif (nextCat === KhmerCategory.Coeng && j + 1 < infos.length) {\n\t\t\t\tconst afterCoeng = infos[j + 1];\n\t\t\t\tif (\n\t\t\t\t\tafterCoeng &&\n\t\t\t\t\tgetKhmerCategory(afterCoeng.codepoint) === KhmerCategory.Consonant\n\t\t\t\t) {\n\t\t\t\t\t// Mark for below-base forms\n\t\t\t\t\tnextInfo.mask |= KhmerFeatureMask.blwf;\n\t\t\t\t\tafterCoeng.mask |= KhmerFeatureMask.blwf;\n\t\t\t\t\tj += 2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Dependent vowels\n\t\t\tif (nextCat === KhmerCategory.DependentVowel) {\n\t\t\t\t// Pre-base vowels:   \n\t\t\t\tif (nextInfo.codepoint >= 0x17c1 && nextInfo.codepoint <= 0x17c3) {\n\t\t\t\t\tnextInfo.mask |= KhmerFeatureMask.pref;\n\t\t\t\t}\n\t\t\t\t// Above-base vowels\n\t\t\t\telse if (nextInfo.codepoint >= 0x17b7 && nextInfo.codepoint <= 0x17ba) {\n\t\t\t\t\tnextInfo.mask |= KhmerFeatureMask.abvf;\n\t\t\t\t}\n\t\t\t\t// Below-base vowels\n\t\t\t\telse if (\n\t\t\t\t\tnextInfo.codepoint === 0x17bb ||\n\t\t\t\t\tnextInfo.codepoint === 0x17bc ||\n\t\t\t\t\tnextInfo.codepoint === 0x17bd\n\t\t\t\t) {\n\t\t\t\t\tnextInfo.mask |= KhmerFeatureMask.blwf;\n\t\t\t\t}\n\t\t\t\t// Post-base vowels\n\t\t\t\telse {\n\t\t\t\t\tnextInfo.mask |= KhmerFeatureMask.pstf;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Register shifters (above)\n\t\t\tif (nextCat === KhmerCategory.Register) {\n\t\t\t\tnextInfo.mask |= KhmerFeatureMask.abvs;\n\t\t\t}\n\n\t\t\t// Robat (above)\n\t\t\tif (nextCat === KhmerCategory.Robat) {\n\t\t\t\tnextInfo.mask |= KhmerFeatureMask.abvs;\n\t\t\t}\n\n\t\t\tj++;\n\t\t}\n\n\t\ti = j;\n\t}\n}\n\n/**\n * Reorder Khmer pre-base vowels\n * Pre-base vowels (  ) should visually appear before the base\n */\nexport function reorderKhmer(infos: GlyphInfo[]): void {\n\tlet i = 0;\n\n\twhile (i < infos.length) {\n\t\tconst info = infos[i];\n\t\tif (!info) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tconst cat = getKhmerCategory(info.codepoint);\n\n\t\tif (cat !== KhmerCategory.Consonant) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Found base consonant, look for pre-base vowels after it\n\t\tconst base = i;\n\t\tlet j = i + 1;\n\n\t\t// Skip coeng sequences\n\t\twhile (j < infos.length) {\n\t\t\tconst jInfo = infos[j];\n\t\t\tif (!jInfo) break;\n\t\t\tconst jCat = getKhmerCategory(jInfo.codepoint);\n\t\t\tif (jCat === KhmerCategory.Coeng && j + 1 < infos.length) {\n\t\t\t\tj += 2; // Skip coeng + consonant\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Check for pre-base vowel\n\t\tif (j < infos.length) {\n\t\t\tconst jInfo = infos[j];\n\t\t\tif (jInfo) {\n\t\t\t\tconst cp = jInfo.codepoint;\n\t\t\t\tif (cp >= 0x17c1 && cp <= 0x17c3) {\n\t\t\t\t\t// Move pre-base vowel before base\n\t\t\t\t\tconst vowel = jInfo;\n\t\t\t\t\tfor (let k = j; k > base; k--) {\n\t\t\t\t\t\tconst prevInfo = infos[k - 1];\n\t\t\t\t\t\tif (prevInfo) {\n\t\t\t\t\t\t\tinfos[k] = prevInfo;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tinfos[base] = vowel;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ti = j + 1;\n\t}\n}\n", "import type { GlyphInfo } from \"../../types.ts\";\n\n/**\n * Myanmar shaper\n * Handles Myanmar script syllable structure and reordering\n */\n\n// Myanmar Unicode ranges\nconst MYANMAR_START = 0x1000;\nconst MYANMAR_END = 0x109f;\nconst MYANMAR_EXT_A_START = 0xaa60;\nconst MYANMAR_EXT_A_END = 0xaa7f;\nconst MYANMAR_EXT_B_START = 0xa9e0;\nconst MYANMAR_EXT_B_END = 0xa9ff;\n\n/**\n * Myanmar character categories\n */\nexport enum MyanmarCategory {\n\tOther = 0,\n\tConsonant = 1,\n\tIndependentVowel = 2,\n\tDependentVowel = 3,\n\tMedial = 4,\n\tAsat = 5, // Killer ()\n\tAnusvara = 6, // Dot below\n\tVisarga = 7, // Visarga\n\tSign = 8,\n\tNumber = 9,\n\tPlaceholder = 10, // Placeholder for visible virama\n}\n\n/**\n * Get Myanmar character category\n */\nexport function getMyanmarCategory(cp: number): MyanmarCategory {\n\t// Main Myanmar block\n\tif (cp >= MYANMAR_START && cp <= MYANMAR_END) {\n\t\t// Consonants (-)\n\t\tif (cp >= 0x1000 && cp <= 0x1021) return MyanmarCategory.Consonant;\n\t\tif (cp >= 0x1023 && cp <= 0x1027) return MyanmarCategory.IndependentVowel;\n\t\tif (cp >= 0x1029 && cp <= 0x102a) return MyanmarCategory.IndependentVowel;\n\n\t\t// Dependent vowels\n\t\tif (cp >= 0x102b && cp <= 0x1035) return MyanmarCategory.DependentVowel;\n\n\t\t// Anusvara\n\t\tif (cp === 0x1036) return MyanmarCategory.Anusvara;\n\n\t\t// Dot below (asat indicator)\n\t\tif (cp === 0x1037) return MyanmarCategory.Sign;\n\n\t\t// Visarga\n\t\tif (cp === 0x1038) return MyanmarCategory.Visarga;\n\n\t\t// Asat (killer/virama)\n\t\tif (cp === 0x1039) return MyanmarCategory.Asat;\n\t\tif (cp === 0x103a) return MyanmarCategory.Asat;\n\n\t\t// Medials (   )\n\t\tif (cp >= 0x103b && cp <= 0x103e) return MyanmarCategory.Medial;\n\n\t\t// More consonants (, etc.)\n\t\tif (cp >= 0x103f && cp <= 0x1049) {\n\t\t\tif (cp === 0x103f) return MyanmarCategory.Consonant;\n\t\t\treturn MyanmarCategory.Number;\n\t\t}\n\n\t\t// Signs and digits\n\t\tif (cp >= 0x104a && cp <= 0x104f) return MyanmarCategory.Sign;\n\t\tif (cp >= 0x1050 && cp <= 0x1059) return MyanmarCategory.Consonant;\n\n\t\t// Extended consonants\n\t\tif (cp >= 0x105a && cp <= 0x105d) return MyanmarCategory.Consonant;\n\t\tif (cp >= 0x1060 && cp <= 0x1061) return MyanmarCategory.Consonant;\n\t\tif (cp >= 0x1062 && cp <= 0x1064) return MyanmarCategory.DependentVowel;\n\t\tif (cp >= 0x1065 && cp <= 0x1066) return MyanmarCategory.Consonant;\n\t\tif (cp >= 0x1067 && cp <= 0x106d) return MyanmarCategory.DependentVowel;\n\t\tif (cp >= 0x106e && cp <= 0x1070) return MyanmarCategory.Consonant;\n\t\tif (cp >= 0x1071 && cp <= 0x1074) return MyanmarCategory.DependentVowel;\n\t\tif (cp >= 0x1075 && cp <= 0x1081) return MyanmarCategory.Consonant;\n\t\tif (cp >= 0x1082 && cp <= 0x1082) return MyanmarCategory.Medial;\n\t\tif (cp >= 0x1083 && cp <= 0x108c) return MyanmarCategory.DependentVowel;\n\t\tif (cp === 0x108d) return MyanmarCategory.Sign;\n\t\tif (cp === 0x108e) return MyanmarCategory.Consonant;\n\t\tif (cp === 0x108f) return MyanmarCategory.Sign;\n\t\tif (cp >= 0x1090 && cp <= 0x1099) return MyanmarCategory.Number;\n\t}\n\n\t// Myanmar Extended-A\n\tif (cp >= MYANMAR_EXT_A_START && cp <= MYANMAR_EXT_A_END) {\n\t\tif (cp >= 0xaa60 && cp <= 0xaa76) return MyanmarCategory.Consonant;\n\t\tif (cp >= 0xaa77 && cp <= 0xaa79) return MyanmarCategory.Sign;\n\t\tif (cp === 0xaa7a) return MyanmarCategory.Consonant;\n\t\tif (cp === 0xaa7b) return MyanmarCategory.Sign;\n\t\tif (cp === 0xaa7c) return MyanmarCategory.Sign;\n\t\tif (cp === 0xaa7d) return MyanmarCategory.Sign;\n\t\tif (cp >= 0xaa7e && cp <= 0xaa7f) return MyanmarCategory.Consonant;\n\t}\n\n\t// Myanmar Extended-B\n\tif (cp >= MYANMAR_EXT_B_START && cp <= MYANMAR_EXT_B_END) {\n\t\tif (cp >= 0xa9e0 && cp <= 0xa9e4) return MyanmarCategory.Consonant;\n\t\tif (cp === 0xa9e5) return MyanmarCategory.DependentVowel;\n\t\tif (cp >= 0xa9e6 && cp <= 0xa9ef) return MyanmarCategory.Consonant;\n\t\tif (cp >= 0xa9f0 && cp <= 0xa9f9) return MyanmarCategory.Number;\n\t\tif (cp >= 0xa9fa && cp <= 0xa9fe) return MyanmarCategory.Consonant;\n\t}\n\n\treturn MyanmarCategory.Other;\n}\n\n/**\n * Myanmar feature masks\n */\nexport const MyanmarFeatureMask = {\n\trphf: 0x0001, // Reph forms\n\tpref: 0x0002, // Pre-base forms\n\tblwf: 0x0004, // Below-base forms\n\tpstf: 0x0008, // Post-base forms\n\tpres: 0x0010, // Pre-base substitutions\n\tabvs: 0x0020, // Above-base substitutions\n\tblws: 0x0040, // Below-base substitutions\n\tpsts: 0x0080, // Post-base substitutions\n} as const;\n\n/**\n * Check if codepoint is Myanmar\n */\nexport function isMyanmar(cp: number): boolean {\n\treturn (\n\t\t(cp >= MYANMAR_START && cp <= MYANMAR_END) ||\n\t\t(cp >= MYANMAR_EXT_A_START && cp <= MYANMAR_EXT_A_END) ||\n\t\t(cp >= MYANMAR_EXT_B_START && cp <= MYANMAR_EXT_B_END)\n\t);\n}\n\n/**\n * Setup Myanmar masks for feature application\n */\nexport function setupMyanmarMasks(infos: GlyphInfo[]): void {\n\tlet i = 0;\n\n\twhile (i < infos.length) {\n\t\tconst info = infos[i];\n\t\tif (!info) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tconst cat = getMyanmarCategory(info.codepoint);\n\n\t\tif (cat === MyanmarCategory.Other) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Find syllable extent\n\t\tlet _base = -1;\n\t\tlet hasAsat = false;\n\n\t\tif (cat === MyanmarCategory.Consonant) {\n\t\t\t_base = i;\n\t\t}\n\n\t\tlet j = i + 1;\n\t\twhile (j < infos.length) {\n\t\t\tconst nextInfo = infos[j];\n\t\t\tif (!nextInfo) {\n\t\t\t\tj++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst nextCat = getMyanmarCategory(nextInfo.codepoint);\n\n\t\t\tif (nextCat === MyanmarCategory.Other) break;\n\n\t\t\t// Asat (killer) marks a stacked consonant\n\t\t\tif (nextCat === MyanmarCategory.Asat) {\n\t\t\t\thasAsat = true;\n\t\t\t\tnextInfo.mask |= MyanmarFeatureMask.blwf;\n\n\t\t\t\t// Check for following consonant (stacking)\n\t\t\t\tif (j + 1 < infos.length) {\n\t\t\t\t\tconst afterAsat = infos[j + 1];\n\t\t\t\t\tif (\n\t\t\t\t\t\tafterAsat &&\n\t\t\t\t\t\tgetMyanmarCategory(afterAsat.codepoint) ===\n\t\t\t\t\t\t\tMyanmarCategory.Consonant\n\t\t\t\t\t) {\n\t\t\t\t\t\tafterAsat.mask |= MyanmarFeatureMask.blwf;\n\t\t\t\t\t\tj += 2;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Medials\n\t\t\tif (nextCat === MyanmarCategory.Medial) {\n\t\t\t\tconst cp = nextInfo.codepoint;\n\t\t\t\t//  (ya) - pre-base\n\t\t\t\tif (cp === 0x103b) {\n\t\t\t\t\tnextInfo.mask |= MyanmarFeatureMask.pref;\n\t\t\t\t}\n\t\t\t\t//  (ra) - pre-base\n\t\t\t\telse if (cp === 0x103c) {\n\t\t\t\t\tnextInfo.mask |= MyanmarFeatureMask.pref;\n\t\t\t\t}\n\t\t\t\t//  (wa) - below-base\n\t\t\t\telse if (cp === 0x103d) {\n\t\t\t\t\tnextInfo.mask |= MyanmarFeatureMask.blwf;\n\t\t\t\t}\n\t\t\t\t//  (ha) - below-base\n\t\t\t\telse if (cp === 0x103e) {\n\t\t\t\t\tnextInfo.mask |= MyanmarFeatureMask.blwf;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Dependent vowels\n\t\t\tif (nextCat === MyanmarCategory.DependentVowel) {\n\t\t\t\tconst cp = nextInfo.codepoint;\n\t\t\t\t// Pre-base vowels: \n\t\t\t\tif (cp === 0x1031) {\n\t\t\t\t\tnextInfo.mask |= MyanmarFeatureMask.pref;\n\t\t\t\t}\n\t\t\t\t// Above-base vowels\n\t\t\t\telse if (cp === 0x102d || cp === 0x102e || cp === 0x1032) {\n\t\t\t\t\tnextInfo.mask |= MyanmarFeatureMask.abvs;\n\t\t\t\t}\n\t\t\t\t// Below-base vowels\n\t\t\t\telse if (cp === 0x102f || cp === 0x1030) {\n\t\t\t\t\tnextInfo.mask |= MyanmarFeatureMask.blws;\n\t\t\t\t}\n\t\t\t\t// Post-base vowels\n\t\t\t\telse {\n\t\t\t\t\tnextInfo.mask |= MyanmarFeatureMask.psts;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Signs above\n\t\t\tif (\n\t\t\t\tnextCat === MyanmarCategory.Anusvara ||\n\t\t\t\tnextCat === MyanmarCategory.Sign\n\t\t\t) {\n\t\t\t\tnextInfo.mask |= MyanmarFeatureMask.abvs;\n\t\t\t}\n\n\t\t\t// New syllable on consonant without asat\n\t\t\tif (nextCat === MyanmarCategory.Consonant && !hasAsat) {\n\t\t\t\t// Check if previous was asat\n\t\t\t\tif (j > 0) {\n\t\t\t\t\tconst prevInfo = infos[j - 1];\n\t\t\t\t\tif (prevInfo) {\n\t\t\t\t\t\tconst prevCat = getMyanmarCategory(prevInfo.codepoint);\n\t\t\t\t\t\tif (prevCat !== MyanmarCategory.Asat) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thasAsat = false;\n\t\t\tj++;\n\t\t}\n\n\t\ti = j;\n\t}\n}\n\n/**\n * Reorder Myanmar pre-base vowels and medials\n *  and  should visually appear before the base consonant\n */\nexport function reorderMyanmar(infos: GlyphInfo[]): void {\n\tlet i = 0;\n\n\twhile (i < infos.length) {\n\t\tconst info = infos[i];\n\t\tif (!info) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tconst cat = getMyanmarCategory(info.codepoint);\n\n\t\tif (cat !== MyanmarCategory.Consonant) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Found base consonant\n\t\tconst base = i;\n\t\tconst preBase: GlyphInfo[] = [];\n\n\t\t// Collect pre-base elements that follow base\n\t\tlet j = i + 1;\n\t\twhile (j < infos.length) {\n\t\t\tconst jInfo = infos[j];\n\t\t\tif (!jInfo) {\n\t\t\t\tj++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst jCat = getMyanmarCategory(jInfo.codepoint);\n\n\t\t\t// Pre-base vowel ()\n\t\t\tif (jInfo.codepoint === 0x1031) {\n\t\t\t\tpreBase.push(jInfo);\n\t\t\t\tinfos.splice(j, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Pre-base medial ( ra)\n\t\t\tif (jInfo.codepoint === 0x103c) {\n\t\t\t\tpreBase.push(jInfo);\n\t\t\t\tinfos.splice(j, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Stop at next syllable\n\t\t\tif (\n\t\t\t\tjCat === MyanmarCategory.Consonant ||\n\t\t\t\tjCat === MyanmarCategory.Other\n\t\t\t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tj++;\n\t\t}\n\n\t\t// Insert pre-base elements before base\n\t\tif (preBase.length > 0) {\n\t\t\tinfos.splice(base, 0, ...preBase);\n\t\t\ti += preBase.length;\n\t\t}\n\n\t\ti++;\n\t}\n}\n", "import type { GlyphInfo } from \"../../types.ts\";\n\n/**\n * Thai/Lao character categories\n */\nexport enum ThaiLaoCategory {\n\tOther = 0,\n\tConsonant = 1,\n\tLeadingVowel = 2, // Vowels that appear before consonant\n\tAboveVowel = 3, // Vowels above consonant\n\tBelowVowel = 4, // Vowels below consonant\n\tFollowingVowel = 5, // Vowels after consonant\n\tTone = 6, // Tone marks\n\tNikhahitMaiEk = 7, // Special combining marks\n\tSaraAm = 8, // Thai Sara Am (combines anusvara + aa)\n\tSymbol = 9,\n}\n\n/**\n * Check if codepoint is Thai\n */\nexport function isThai(cp: number): boolean {\n\treturn cp >= 0x0e00 && cp <= 0x0e7f;\n}\n\n/**\n * Check if codepoint is Lao\n */\nexport function isLao(cp: number): boolean {\n\treturn cp >= 0x0e80 && cp <= 0x0eff;\n}\n\n/**\n * Get Thai/Lao category for a codepoint\n */\nexport function getThaiLaoCategory(cp: number): ThaiLaoCategory {\n\t// Thai (0E00-0E7F)\n\tif (isThai(cp)) {\n\t\t// Consonants\n\t\tif (cp >= 0x0e01 && cp <= 0x0e2e) return ThaiLaoCategory.Consonant;\n\t\t// Additional consonants\n\t\tif (cp === 0x0e2f) return ThaiLaoCategory.Consonant; // Paiyannoi\n\n\t\t// Leading vowels (displayed before consonant)\n\t\tif (cp >= 0x0e40 && cp <= 0x0e44) return ThaiLaoCategory.LeadingVowel;\n\n\t\t// Above vowels\n\t\tif (cp === 0x0e31) return ThaiLaoCategory.AboveVowel; // Mai Han-Akat\n\t\tif (cp >= 0x0e34 && cp <= 0x0e37) return ThaiLaoCategory.AboveVowel;\n\t\tif (cp === 0x0e47) return ThaiLaoCategory.AboveVowel; // Maitaikhu\n\n\t\t// Below vowels\n\t\tif (cp >= 0x0e38 && cp <= 0x0e3a) return ThaiLaoCategory.BelowVowel;\n\n\t\t// Following vowels\n\t\tif (cp === 0x0e30) return ThaiLaoCategory.FollowingVowel; // Sara A\n\t\tif (cp === 0x0e32 || cp === 0x0e33) return ThaiLaoCategory.FollowingVowel; // Sara Aa, Sara Am\n\t\tif (cp === 0x0e45) return ThaiLaoCategory.FollowingVowel; // Lakkhangyao\n\n\t\t// Sara Am (special - decomposes to nikhahit + sara aa)\n\t\tif (cp === 0x0e33) return ThaiLaoCategory.SaraAm;\n\n\t\t// Tone marks\n\t\tif (cp >= 0x0e48 && cp <= 0x0e4b) return ThaiLaoCategory.Tone;\n\n\t\t// Thanthakhat (cancellation mark)\n\t\tif (cp === 0x0e4c) return ThaiLaoCategory.Tone;\n\n\t\t// Nikhahit (anusvara)\n\t\tif (cp === 0x0e4d) return ThaiLaoCategory.NikhahitMaiEk;\n\n\t\t// Yamakkan\n\t\tif (cp === 0x0e4e) return ThaiLaoCategory.NikhahitMaiEk;\n\n\t\t// Digits and symbols\n\t\tif (cp >= 0x0e50 && cp <= 0x0e5b) return ThaiLaoCategory.Symbol;\n\n\t\treturn ThaiLaoCategory.Other;\n\t}\n\n\t// Lao (0E80-0EFF)\n\tif (isLao(cp)) {\n\t\t// Consonants\n\t\tif (cp >= 0x0e81 && cp <= 0x0eae) return ThaiLaoCategory.Consonant;\n\n\t\t// Leading vowels\n\t\tif (cp >= 0x0ec0 && cp <= 0x0ec4) return ThaiLaoCategory.LeadingVowel;\n\n\t\t// Above vowels\n\t\tif (cp === 0x0eb1) return ThaiLaoCategory.AboveVowel;\n\t\tif (cp >= 0x0eb4 && cp <= 0x0eb7) return ThaiLaoCategory.AboveVowel;\n\t\tif (cp === 0x0ebb) return ThaiLaoCategory.AboveVowel;\n\n\t\t// Below vowels\n\t\tif (cp >= 0x0eb8 && cp <= 0x0eb9) return ThaiLaoCategory.BelowVowel;\n\t\tif (cp === 0x0ebc) return ThaiLaoCategory.BelowVowel;\n\n\t\t// Following vowels\n\t\tif (cp === 0x0eb0) return ThaiLaoCategory.FollowingVowel;\n\t\tif (cp === 0x0eb2 || cp === 0x0eb3) return ThaiLaoCategory.FollowingVowel;\n\n\t\t// Tone marks\n\t\tif (cp >= 0x0ec8 && cp <= 0x0ecd) return ThaiLaoCategory.Tone;\n\n\t\t// Digits\n\t\tif (cp >= 0x0ed0 && cp <= 0x0ed9) return ThaiLaoCategory.Symbol;\n\n\t\treturn ThaiLaoCategory.Other;\n\t}\n\n\treturn ThaiLaoCategory.Other;\n}\n\n/**\n * Set up masks for Thai/Lao shaping\n *\n * Thai/Lao require:\n * 1. Reordering of pre-base vowels (they appear before consonant visually but after in Unicode)\n * 2. Proper stacking of above/below vowels and tone marks\n */\nexport function setupThaiLaoMasks(infos: GlyphInfo[]): void {\n\t// Group characters into syllable-like clusters\n\t// Each cluster starts with a consonant\n\n\tlet clusterIndex = 0;\n\tlet _consonantIndex = -1;\n\n\tfor (let i = 0; i < infos.length; i++) {\n\t\tconst info = infos[i];\n\t\tif (!info) continue;\n\n\t\tconst cat = getThaiLaoCategory(info.codepoint);\n\n\t\t// Consonants start new clusters\n\t\tif (cat === ThaiLaoCategory.Consonant) {\n\t\t\tclusterIndex++;\n\t\t\t_consonantIndex = i;\n\t\t}\n\n\t\t// Store cluster info in mask\n\t\t// Upper bits: cluster index\n\t\t// Lower bits: category for reordering\n\t\tinfo.mask = (info.mask & 0xffffff00) | (cat & 0xff);\n\t\tinfo.mask = (info.mask & 0x0000ffff) | ((clusterIndex & 0xffff) << 16);\n\n\t\t// Mark leading vowels for reordering\n\t\tif (cat === ThaiLaoCategory.LeadingVowel) {\n\t\t\t// These need to be moved before the consonant during shaping\n\t\t\t// The GSUB pref feature handles this\n\t\t\tinfo.mask |= 0x100; // Mark for pre-base processing\n\t\t}\n\t}\n}\n\n/**\n * Reorder Thai/Lao clusters\n * Leading vowels (Sara E, Sara Ae, Sara O, Sara Ai Mai Muan, Sara Ai Mai Malai)\n * are stored after consonant in Unicode but displayed before\n */\nexport function reorderThaiLao(infos: GlyphInfo[]): void {\n\tlet i = 0;\n\twhile (i < infos.length) {\n\t\tconst info = infos[i];\n\t\tif (!info) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst cat = getThaiLaoCategory(info.codepoint);\n\n\t\t// If we find a leading vowel, move it before its consonant\n\t\tif (cat === ThaiLaoCategory.LeadingVowel) {\n\t\t\t// Find the following consonant\n\t\t\tlet j = i + 1;\n\t\t\twhile (j < infos.length) {\n\t\t\t\tconst nextInfo = infos[j];\n\t\t\t\tif (!nextInfo) {\n\t\t\t\t\tj++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst nextCat = getThaiLaoCategory(nextInfo.codepoint ?? 0);\n\t\t\t\tif (nextCat === ThaiLaoCategory.Consonant) {\n\t\t\t\t\t// Swap vowel and consonant\n\t\t\t\t\tconst temp = info;\n\t\t\t\t\tinfos[i] = nextInfo;\n\t\t\t\t\tinfos[j] = temp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (nextCat !== ThaiLaoCategory.LeadingVowel) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n}\n", "import type { GlyphInfo } from \"../../types.ts\";\n\n/**\n * Universal Shaping Engine (USE) categories\n * Based on Unicode USE specification\n */\nexport enum UseCategory {\n\tO = 0, // Other\n\tB = 1, // Base\n\tCGJ = 2, // Combining Grapheme Joiner\n\tCM = 3, // Consonant modifier\n\tCS = 4, // Consonant with stacker\n\tF = 5, // Final\n\tFM = 6, // Final modifier\n\tGB = 7, // Generic base\n\tH = 8, // Halant/Virama\n\tHN = 9, // Halant or Nukta\n\tIND = 10, // Independent\n\tJ = 11, // Joiner\n\tN = 12, // Nukta\n\tR = 13, // Repha\n\tS = 14, // Symbol\n\tSB = 15, // Symbol modifier\n\tSE = 16, // Syllable ending\n\tSUB = 17, // Subjoined\n\tVS = 18, // Variation selector\n\tWJ = 19, // Word joiner\n\tZWJ = 20, // Zero Width Joiner\n\tZWNJ = 21, // Zero Width Non-Joiner\n\tV = 22, // Vowel (independent)\n\tVD = 23, // Vowel dependent\n\tVMAbv = 24, // Vowel modifier above\n\tVMBlw = 25, // Vowel modifier below\n\tVMPre = 26, // Vowel modifier pre\n\tVMPst = 27, // Vowel modifier post\n\tVAbv = 28, // Vowel above\n\tVBlw = 29, // Vowel below\n\tVPre = 30, // Vowel pre\n\tVPst = 31, // Vowel post\n\tSMAbv = 32, // Syllable modifier above\n\tSMBlw = 33, // Syllable modifier below\n\tFAbv = 34, // Final above\n\tFBlw = 35, // Final below\n\tFPst = 36, // Final post\n\tMAbv = 37, // Medial above\n\tMBlw = 38, // Medial below\n\tMPre = 39, // Medial pre\n\tMPst = 40, // Medial post\n}\n\n/**\n * Check if a script uses USE\n */\nexport function usesUSE(script: string): boolean {\n\t// Scripts that use Universal Shaping Engine\n\tconst useScripts = [\n\t\t\"bali\", // Balinese\n\t\t\"batk\", // Batak\n\t\t\"brah\", // Brahmi\n\t\t\"bugi\", // Buginese\n\t\t\"buhd\", // Buhid\n\t\t\"cakm\", // Chakma\n\t\t\"cham\", // Cham\n\t\t\"dupl\", // Duployan\n\t\t\"egyp\", // Egyptian Hieroglyphs\n\t\t\"gran\", // Grantha\n\t\t\"hano\", // Hanunoo\n\t\t\"java\", // Javanese\n\t\t\"kthi\", // Kaithi\n\t\t\"khar\", // Kharoshthi\n\t\t\"khmr\", // Khmer\n\t\t\"khoj\", // Khojki\n\t\t\"lana\", // Tai Tham\n\t\t\"lepc\", // Lepcha\n\t\t\"limb\", // Limbu\n\t\t\"mahj\", // Mahajani\n\t\t\"modi\", // Modi\n\t\t\"mtei\", // Meetei Mayek\n\t\t\"mymr\", // Myanmar\n\t\t\"newa\", // Newa\n\t\t\"phlp\", // Psalter Pahlavi\n\t\t\"rjng\", // Rejang\n\t\t\"saur\", // Saurashtra\n\t\t\"shrd\", // Sharada\n\t\t\"sidd\", // Siddham\n\t\t\"sind\", // Sindhi (Khudawadi)\n\t\t\"sinh\", // Sinhala\n\t\t\"sund\", // Sundanese\n\t\t\"sylo\", // Syloti Nagri\n\t\t\"tagb\", // Tagbanwa\n\t\t\"takr\", // Takri\n\t\t\"tale\", // Tai Le\n\t\t\"talu\", // New Tai Lue\n\t\t\"tavt\", // Tai Viet\n\t\t\"tibt\", // Tibetan\n\t\t\"tirh\", // Tirhuta\n\t];\n\treturn useScripts.includes(script);\n}\n\n/**\n * Get USE category for a codepoint\n */\nexport function getUseCategory(cp: number): UseCategory {\n\t// Zero-width characters\n\tif (cp === 0x200c) return UseCategory.ZWNJ;\n\tif (cp === 0x200d) return UseCategory.ZWJ;\n\tif (cp === 0x034f) return UseCategory.CGJ; // Combining Grapheme Joiner\n\tif (cp === 0x2060) return UseCategory.WJ; // Word Joiner\n\tif (cp >= 0xfe00 && cp <= 0xfe0f) return UseCategory.VS; // Variation Selectors\n\tif (cp >= 0xe0100 && cp <= 0xe01ef) return UseCategory.VS; // VS 17-256\n\n\t// Myanmar (1000-109F)\n\tif (cp >= 0x1000 && cp <= 0x109f) {\n\t\t// Consonants\n\t\tif (cp >= 0x1000 && cp <= 0x1020) return UseCategory.B;\n\t\t// Independent vowels\n\t\tif (cp >= 0x1021 && cp <= 0x102a) return UseCategory.IND;\n\t\t// Dependent vowels\n\t\tif (cp >= 0x102b && cp <= 0x1032) return UseCategory.VPst;\n\t\t// Anusvara etc\n\t\tif (cp >= 0x1036 && cp <= 0x1037) return UseCategory.SMAbv;\n\t\t// Virama\n\t\tif (cp === 0x1039) return UseCategory.H;\n\t\t// Asat (visible virama)\n\t\tif (cp === 0x103a) return UseCategory.H;\n\t\t// Medial consonants\n\t\tif (cp >= 0x103b && cp <= 0x103e) return UseCategory.MBlw;\n\t\t// Digits\n\t\tif (cp >= 0x1040 && cp <= 0x1049) return UseCategory.GB;\n\t\treturn UseCategory.O;\n\t}\n\n\t// Khmer (1780-17FF)\n\tif (cp >= 0x1780 && cp <= 0x17ff) {\n\t\t// Consonants\n\t\tif (cp >= 0x1780 && cp <= 0x17a2) return UseCategory.B;\n\t\t// Independent vowels\n\t\tif (cp >= 0x17a3 && cp <= 0x17b3) return UseCategory.IND;\n\t\t// Dependent vowels\n\t\tif (cp >= 0x17b6 && cp <= 0x17c5) return UseCategory.VPst;\n\t\t// Coeng (stacking virama)\n\t\tif (cp === 0x17d2) return UseCategory.H;\n\t\t// Anusvara, Visarga\n\t\tif (cp >= 0x17c6 && cp <= 0x17c8) return UseCategory.SMAbv;\n\t\treturn UseCategory.O;\n\t}\n\n\t// Tibetan (0F00-0FFF)\n\tif (cp >= 0x0f00 && cp <= 0x0fff) {\n\t\t// Syllable markers\n\t\tif (cp >= 0x0f00 && cp <= 0x0f17) return UseCategory.S;\n\t\t// Vowel signs\n\t\tif (cp >= 0x0f71 && cp <= 0x0f7d) return UseCategory.VAbv;\n\t\t// Subjoined consonants\n\t\tif (cp >= 0x0f90 && cp <= 0x0fbc) return UseCategory.SUB;\n\t\t// Base consonants\n\t\tif (cp >= 0x0f40 && cp <= 0x0f6c) return UseCategory.B;\n\t\treturn UseCategory.O;\n\t}\n\n\t// Thai (0E00-0E7F)\n\tif (cp >= 0x0e00 && cp <= 0x0e7f) {\n\t\t// Consonants\n\t\tif (cp >= 0x0e01 && cp <= 0x0e2e) return UseCategory.B;\n\t\t// Vowels\n\t\tif (cp >= 0x0e30 && cp <= 0x0e3a) return UseCategory.VPst;\n\t\tif (cp >= 0x0e40 && cp <= 0x0e44) return UseCategory.VPre;\n\t\t// Tone marks\n\t\tif (cp >= 0x0e48 && cp <= 0x0e4b) return UseCategory.SMAbv;\n\t\treturn UseCategory.O;\n\t}\n\n\t// Lao (0E80-0EFF)\n\tif (cp >= 0x0e80 && cp <= 0x0eff) {\n\t\t// Consonants\n\t\tif (cp >= 0x0e81 && cp <= 0x0ea3) return UseCategory.B;\n\t\t// Vowels\n\t\tif (cp >= 0x0eb0 && cp <= 0x0ebc) return UseCategory.VPst;\n\t\tif (cp >= 0x0ec0 && cp <= 0x0ec4) return UseCategory.VPre;\n\t\t// Tone marks\n\t\tif (cp >= 0x0ec8 && cp <= 0x0ecd) return UseCategory.SMAbv;\n\t\treturn UseCategory.O;\n\t}\n\n\t// Test mappings for categories not yet in real scripts\n\t// Using private use area for testing\n\tif (cp >= 0xe000 && cp <= 0xe0ff) {\n\t\tif (cp === 0xe000) return UseCategory.R; // Repha test\n\t\tif (cp === 0xe001) return UseCategory.VMAbv;\n\t\tif (cp === 0xe002) return UseCategory.VMBlw;\n\t\tif (cp === 0xe003) return UseCategory.VMPre;\n\t\tif (cp === 0xe004) return UseCategory.VMPst;\n\t\tif (cp === 0xe005) return UseCategory.CS;\n\t\tif (cp === 0xe006) return UseCategory.N;\n\t\tif (cp === 0xe007) return UseCategory.HN;\n\t\tif (cp === 0xe008) return UseCategory.VD;\n\t\tif (cp === 0xe009) return UseCategory.VBlw;\n\t\tif (cp === 0xe00a) return UseCategory.MAbv;\n\t\tif (cp === 0xe00b) return UseCategory.MPre;\n\t\tif (cp === 0xe00c) return UseCategory.MPst;\n\t\tif (cp === 0xe00d) return UseCategory.SMBlw;\n\t\tif (cp === 0xe00e) return UseCategory.FAbv;\n\t\tif (cp === 0xe00f) return UseCategory.FBlw;\n\t\tif (cp === 0xe010) return UseCategory.FPst;\n\t\tif (cp === 0xe011) return UseCategory.F;\n\t\tif (cp === 0xe012) return UseCategory.FM;\n\t}\n\n\treturn UseCategory.O;\n}\n\n/** USE feature masks */\nexport const UseFeatureMask = {\n\trphf: 0x0001, // Reph forms\n\tpref: 0x0002, // Pre-base forms\n\tblwf: 0x0004, // Below-base forms\n\tabvf: 0x0008, // Above-base forms\n\tpstf: 0x0010, // Post-base forms\n\thalf: 0x0020, // Half forms\n\tcjct: 0x0040, // Conjunct forms\n\tvatu: 0x0080, // Vattu variants\n\tpres: 0x0100, // Pre-base substitutions\n\tabvs: 0x0200, // Above-base substitutions\n\tblws: 0x0400, // Below-base substitutions\n\tpsts: 0x0800, // Post-base substitutions\n\thaln: 0x1000, // Halant forms\n} as const;\n\n/**\n * USE syllable structure\n */\ninterface UseSyllable {\n\tstart: number;\n\tend: number;\n\tbase: number;\n\thasReph: boolean;\n}\n\n/**\n * Find syllable boundaries in USE text\n */\nfunction findUseSyllables(infos: GlyphInfo[]): UseSyllable[] {\n\tconst syllables: UseSyllable[] = [];\n\tconst n = infos.length;\n\tif (n === 0) return syllables;\n\n\tlet start = 0;\n\n\twhile (start < n) {\n\t\tconst syllable = parseUseSyllable(infos, start);\n\t\tsyllables.push(syllable);\n\t\tstart = syllable.end;\n\t}\n\n\treturn syllables;\n}\n\n/**\n * Parse a single USE syllable\n */\nfunction parseUseSyllable(infos: GlyphInfo[], start: number): UseSyllable {\n\tconst n = infos.length;\n\tlet pos = start;\n\tlet base = -1;\n\tlet hasReph = false;\n\n\t// Check for Repha (R + H at start)\n\tif (pos + 1 < n) {\n\t\tconst info1 = infos[pos];\n\t\tconst info2 = infos[pos + 1];\n\t\tif (info1 && info2) {\n\t\t\tconst cat1 = getUseCategory(info1.codepoint ?? 0);\n\t\t\tconst cat2 = getUseCategory(info2.codepoint ?? 0);\n\t\t\tif (cat1 === UseCategory.R && cat2 === UseCategory.H) {\n\t\t\t\thasReph = true;\n\t\t\t\tpos += 2;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Find base character\n\twhile (pos < n) {\n\t\tconst info = infos[pos];\n\t\tif (!info) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\t\tconst cat = getUseCategory(info.codepoint ?? 0);\n\n\t\t// Base characters\n\t\tif (\n\t\t\tcat === UseCategory.B ||\n\t\t\tcat === UseCategory.IND ||\n\t\t\tcat === UseCategory.GB ||\n\t\t\tcat === UseCategory.V\n\t\t) {\n\t\t\tbase = pos;\n\t\t\tpos++;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Non-base starters - continue looking\n\t\tif (\n\t\t\tcat === UseCategory.VMPre ||\n\t\t\tcat === UseCategory.VPre ||\n\t\t\tcat === UseCategory.MPre\n\t\t) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// End of valid cluster start\n\t\tif (base === -1) {\n\t\t\tpos++;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (base === -1) base = start;\n\n\t// Consume consonant cluster\n\twhile (pos < n) {\n\t\tconst posInfo = infos[pos];\n\t\tif (!posInfo) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\t\tconst cat = getUseCategory(posInfo.codepoint ?? 0);\n\n\t\t// Halant + Consonant continues cluster\n\t\tif (cat === UseCategory.H) {\n\t\t\tpos++;\n\t\t\tif (pos < n) {\n\t\t\t\tconst nextInfo = infos[pos];\n\t\t\t\tif (nextInfo) {\n\t\t\t\t\tconst nextCat = getUseCategory(nextInfo.codepoint ?? 0);\n\t\t\t\t\tif (\n\t\t\t\t\t\tnextCat === UseCategory.B ||\n\t\t\t\t\t\tnextCat === UseCategory.CS ||\n\t\t\t\t\t\tnextCat === UseCategory.SUB\n\t\t\t\t\t) {\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// ZWJ/ZWNJ after halant\n\t\t\t\t\tif (nextCat === UseCategory.ZWJ || nextCat === UseCategory.ZWNJ) {\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Subjoined consonants\n\t\tif (cat === UseCategory.SUB || cat === UseCategory.CS) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Nukta\n\t\tif (cat === UseCategory.N || cat === UseCategory.HN) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t// Consume matras and modifiers\n\twhile (pos < n) {\n\t\tconst posInfo = infos[pos];\n\t\tif (!posInfo) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\t\tconst cat = getUseCategory(posInfo.codepoint ?? 0);\n\n\t\t// Vowel signs\n\t\tif (\n\t\t\tcat === UseCategory.VAbv ||\n\t\t\tcat === UseCategory.VBlw ||\n\t\t\tcat === UseCategory.VPre ||\n\t\t\tcat === UseCategory.VPst ||\n\t\t\tcat === UseCategory.VD\n\t\t) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Medials\n\t\tif (\n\t\t\tcat === UseCategory.MAbv ||\n\t\t\tcat === UseCategory.MBlw ||\n\t\t\tcat === UseCategory.MPre ||\n\t\t\tcat === UseCategory.MPst\n\t\t) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Vowel modifiers\n\t\tif (\n\t\t\tcat === UseCategory.VMAbv ||\n\t\t\tcat === UseCategory.VMBlw ||\n\t\t\tcat === UseCategory.VMPre ||\n\t\t\tcat === UseCategory.VMPst\n\t\t) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Syllable modifiers\n\t\tif (cat === UseCategory.SMAbv || cat === UseCategory.SMBlw) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Finals\n\t\tif (\n\t\t\tcat === UseCategory.FAbv ||\n\t\t\tcat === UseCategory.FBlw ||\n\t\t\tcat === UseCategory.FPst ||\n\t\t\tcat === UseCategory.F ||\n\t\t\tcat === UseCategory.FM\n\t\t) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// CGJ, VS\n\t\tif (cat === UseCategory.CGJ || cat === UseCategory.VS) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t// Ensure we advance at least one position\n\tif (pos === start) {\n\t\tpos = start + 1;\n\t}\n\n\treturn { start, end: pos, base, hasReph };\n}\n\n/**\n * Set up masks for USE shaping\n */\nexport function setupUseMasks(infos: GlyphInfo[]): void {\n\tconst syllables = findUseSyllables(infos);\n\n\tfor (const [i, syllable] of syllables.entries()) {\n\t\tfor (let j = syllable.start; j < syllable.end; j++) {\n\t\t\tconst info = infos[j];\n\t\t\tif (!info) continue;\n\n\t\t\t// Store syllable index in upper mask bits\n\t\t\tinfo.mask = (info.mask & 0x0000ffff) | ((i & 0xffff) << 16);\n\n\t\t\tconst cat = getUseCategory(info.codepoint);\n\n\t\t\t// Reph handling\n\t\t\tif (syllable.hasReph && j < syllable.start + 2) {\n\t\t\t\tinfo.mask |= UseFeatureMask.rphf;\n\t\t\t}\n\n\t\t\t// Pre-base handling\n\t\t\tif (j < syllable.base) {\n\t\t\t\tif (\n\t\t\t\t\tcat === UseCategory.B ||\n\t\t\t\t\tcat === UseCategory.CS ||\n\t\t\t\t\tcat === UseCategory.SUB\n\t\t\t\t) {\n\t\t\t\t\tinfo.mask |= UseFeatureMask.half | UseFeatureMask.cjct;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Post-base handling\n\t\t\tif (j > syllable.base) {\n\t\t\t\tif (\n\t\t\t\t\tcat === UseCategory.B ||\n\t\t\t\t\tcat === UseCategory.CS ||\n\t\t\t\t\tcat === UseCategory.SUB\n\t\t\t\t) {\n\t\t\t\t\tinfo.mask |=\n\t\t\t\t\t\tUseFeatureMask.blwf | UseFeatureMask.pstf | UseFeatureMask.vatu;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Halant\n\t\t\tif (cat === UseCategory.H || cat === UseCategory.HN) {\n\t\t\t\tif (j < syllable.base) {\n\t\t\t\t\tinfo.mask |= UseFeatureMask.half;\n\t\t\t\t} else {\n\t\t\t\t\tinfo.mask |= UseFeatureMask.haln;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Vowel signs\n\t\t\tif (cat === UseCategory.VPre) {\n\t\t\t\tinfo.mask |= UseFeatureMask.pref | UseFeatureMask.pres;\n\t\t\t} else if (cat === UseCategory.VAbv) {\n\t\t\t\tinfo.mask |= UseFeatureMask.abvf | UseFeatureMask.abvs;\n\t\t\t} else if (cat === UseCategory.VBlw) {\n\t\t\t\tinfo.mask |= UseFeatureMask.blwf | UseFeatureMask.blws;\n\t\t\t} else if (cat === UseCategory.VPst || cat === UseCategory.VD) {\n\t\t\t\tinfo.mask |= UseFeatureMask.pstf | UseFeatureMask.psts;\n\t\t\t}\n\n\t\t\t// Medials\n\t\t\tif (cat === UseCategory.MAbv) {\n\t\t\t\tinfo.mask |= UseFeatureMask.abvs;\n\t\t\t} else if (cat === UseCategory.MBlw) {\n\t\t\t\tinfo.mask |= UseFeatureMask.blws;\n\t\t\t} else if (cat === UseCategory.MPre) {\n\t\t\t\tinfo.mask |= UseFeatureMask.pres;\n\t\t\t} else if (cat === UseCategory.MPst) {\n\t\t\t\tinfo.mask |= UseFeatureMask.psts;\n\t\t\t}\n\n\t\t\t// Syllable modifiers\n\t\t\tif (cat === UseCategory.SMAbv) {\n\t\t\t\tinfo.mask |= UseFeatureMask.abvs;\n\t\t\t} else if (cat === UseCategory.SMBlw) {\n\t\t\t\tinfo.mask |= UseFeatureMask.blws;\n\t\t\t}\n\n\t\t\t// Finals\n\t\t\tif (cat === UseCategory.FAbv) {\n\t\t\t\tinfo.mask |= UseFeatureMask.abvs;\n\t\t\t} else if (cat === UseCategory.FBlw) {\n\t\t\t\tinfo.mask |= UseFeatureMask.blws;\n\t\t\t} else if (\n\t\t\t\tcat === UseCategory.FPst ||\n\t\t\t\tcat === UseCategory.F ||\n\t\t\t\tcat === UseCategory.FM\n\t\t\t) {\n\t\t\t\tinfo.mask |= UseFeatureMask.psts;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Reorder USE syllables (pre-base vowels, reph)\n */\nexport function reorderUSE(infos: GlyphInfo[]): void {\n\tconst syllables = findUseSyllables(infos);\n\n\tfor (const syllable of syllables) {\n\t\treorderUseSyllable(infos, syllable);\n\t}\n}\n\n/**\n * Reorder a single USE syllable\n */\nfunction reorderUseSyllable(infos: GlyphInfo[], syllable: UseSyllable): void {\n\tconst { start, end, base, hasReph } = syllable;\n\n\t// Collect pre-base vowels that need to move\n\tconst preBaseVowels: { index: number; info: GlyphInfo }[] = [];\n\n\tfor (let i = base + 1; i < end; i++) {\n\t\tconst info = infos[i];\n\t\tif (!info) continue;\n\n\t\tconst cat = getUseCategory(info.codepoint);\n\t\tif (cat === UseCategory.VPre || cat === UseCategory.MPre) {\n\t\t\tpreBaseVowels.push({ index: i, info });\n\t\t}\n\t}\n\n\t// Move pre-base vowels before the base\n\tif (preBaseVowels.length > 0) {\n\t\tpreBaseVowels.sort((a, b) => b.index - a.index);\n\n\t\tfor (const { index, info } of preBaseVowels) {\n\t\t\tinfos.splice(index, 1);\n\t\t\tconst insertPos = hasReph ? start + 2 : start;\n\t\t\tinfos.splice(insertPos, 0, info);\n\t\t}\n\t}\n\n\t// Move reph to end (if present)\n\tif (hasReph && end > start + 2) {\n\t\tconst rephStart = infos[start];\n\t\tconst rephH = infos[start + 1];\n\n\t\tif (rephStart && rephH) {\n\t\t\t// Find target position: after matras, before finals\n\t\t\tlet rephTarget = end - 1;\n\n\t\t\twhile (rephTarget > base) {\n\t\t\t\tconst targetInfo = infos[rephTarget];\n\t\t\t\tif (!targetInfo) break;\n\n\t\t\t\tconst cat = getUseCategory(targetInfo.codepoint);\n\t\t\t\tif (\n\t\t\t\t\tcat === UseCategory.SMAbv ||\n\t\t\t\t\tcat === UseCategory.SMBlw ||\n\t\t\t\t\tcat === UseCategory.FAbv ||\n\t\t\t\t\tcat === UseCategory.FBlw ||\n\t\t\t\t\tcat === UseCategory.FPst ||\n\t\t\t\t\tcat === UseCategory.F ||\n\t\t\t\t\tcat === UseCategory.FM\n\t\t\t\t) {\n\t\t\t\t\trephTarget--;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rephTarget > start + 1) {\n\t\t\t\tinfos.splice(start, 2);\n\t\t\t\tconst adjustedTarget = rephTarget - 2;\n\t\t\t\tinfos.splice(adjustedTarget + 1, 0, rephStart, rephH);\n\t\t\t}\n\t\t}\n\t}\n}\n", "import {\n\tprocessContextual,\n\tprocessInsertion,\n\tprocessLigature,\n\tprocessRearrangement,\n} from \"../aat/state-machine.ts\";\nimport { GlyphBuffer } from \"../buffer/glyph-buffer.ts\";\nimport type { UnicodeBuffer } from \"../buffer/unicode-buffer.ts\";\nimport { Face } from \"../font/face.ts\";\nimport type { Font } from \"../font/font.ts\";\nimport { getGlyphClass } from \"../font/tables/gdef.ts\";\nimport {\n\ttype AnyGposLookup,\n\ttype CursivePosLookup,\n\tGposLookupType,\n\tgetKerning,\n\ttype MarkBasePosLookup,\n\ttype MarkLigaturePosLookup,\n\ttype MarkMarkPosLookup,\n\ttype PairPosLookup,\n\ttype SinglePosLookup,\n} from \"../font/tables/gpos.ts\";\nimport type {\n\tChainingContextPosFormat1,\n\tChainingContextPosFormat2,\n\tChainingContextPosFormat3,\n\tChainingContextPosLookup,\n\tContextPosFormat1,\n\tContextPosFormat2,\n\tContextPosFormat3,\n\tContextPosLookup,\n\tPosLookupRecord,\n} from \"../font/tables/gpos-contextual.ts\";\nimport {\n\ttype AlternateSubstLookup,\n\ttype AnyGsubLookup,\n\tapplyLigatureSubst,\n\tapplySingleSubst,\n\ttype ChainingContextSubstLookup,\n\ttype ContextSubstLookup,\n\tGsubLookupType,\n\ttype LigatureSubstLookup,\n\ttype MultipleSubstLookup,\n\ttype ReverseChainingSingleSubstLookup,\n\ttype SingleSubstLookup,\n} from \"../font/tables/gsub.ts\";\nimport type {\n\tChainingContextFormat1,\n\tChainingContextFormat2,\n\tChainingContextFormat3,\n\tContextSubstFormat1,\n\tContextSubstFormat2,\n\tContextSubstFormat3,\n\tSequenceLookupRecord,\n} from \"../font/tables/gsub-contextual.ts\";\nimport {\n\tapplyNonContextual,\n\ttype MorxContextualSubtable,\n\ttype MorxInsertionSubtable,\n\ttype MorxLigatureSubtable,\n\ttype MorxNonContextualSubtable,\n\ttype MorxRearrangementSubtable,\n\tMorxSubtableType,\n} from \"../font/tables/morx.ts\";\nimport type { ClassDef } from \"../layout/structures/class-def.ts\";\nimport {\n\tgetMarkAttachmentType,\n\tLookupFlag,\n} from \"../layout/structures/layout-common.ts\";\nimport type { GlyphId, GlyphInfo, GlyphPosition } from \"../types.ts\";\nimport { GlyphClass } from \"../types.ts\";\nimport { setupArabicMasks } from \"./complex/arabic.ts\";\nimport {\n\tisKorean,\n\tnormalizeHangul,\n\tsetupHangulMasks,\n} from \"./complex/hangul.ts\";\nimport { setupHebrewMasks } from \"./complex/hebrew.ts\";\nimport { isIndic, reorderIndic, setupIndicMasks } from \"./complex/indic.ts\";\nimport { isKhmer, reorderKhmer, setupKhmerMasks } from \"./complex/khmer.ts\";\nimport {\n\tisMyanmar,\n\treorderMyanmar,\n\tsetupMyanmarMasks,\n} from \"./complex/myanmar.ts\";\nimport {\n\tisLao,\n\tisThai,\n\treorderThaiLao,\n\tsetupThaiLaoMasks,\n} from \"./complex/thai-lao.ts\";\nimport { reorderUSE, setupUseMasks, usesUSE } from \"./complex/use.ts\";\nimport {\n\tapplyFallbackKerning,\n\tapplyFallbackMarkPositioning,\n} from \"./fallback.ts\";\nimport {\n\tcreateShapePlan,\n\ttype ShapeFeature,\n\ttype ShapePlan,\n} from \"./shape-plan.ts\";\n\nexport interface ShapeOptions {\n\tscript?: string;\n\tlanguage?: string | null;\n\tdirection?: \"ltr\" | \"rtl\";\n\tfeatures?: ShapeFeature[];\n}\n\n/** Font or Face - accepted by shape function */\nexport type FontLike = Font | Face;\n\n/** Get the underlying Font from a FontLike */\nfunction getFont(fontLike: FontLike): Font {\n\treturn fontLike instanceof Face ? fontLike.font : fontLike;\n}\n\n/** Get Face (create if needed) */\nfunction getFace(fontLike: FontLike): Face {\n\treturn fontLike instanceof Face ? fontLike : new Face(fontLike);\n}\n\n/**\n * Shape text using OpenType features.\n * Accepts Font or Face (for variable fonts).\n */\nexport function shape(\n\tfontLike: FontLike,\n\tbuffer: UnicodeBuffer,\n\toptions: ShapeOptions = {},\n): GlyphBuffer {\n\tconst font = getFont(fontLike);\n\tconst face = getFace(fontLike);\n\n\tconst script = options.script ?? buffer.script ?? \"latn\";\n\tconst language = options.language ?? buffer.language ?? null;\n\tconst direction = options.direction ?? \"ltr\";\n\tconst features = options.features ?? [];\n\n\t// Get axis coordinates from face for feature variations\n\tconst axisCoords = face.normalizedCoords.length > 0 ? face.normalizedCoords : null;\n\tconst plan = createShapePlan(font, script, language, direction, features, axisCoords);\n\n\tconst glyphBuffer = new GlyphBuffer();\n\tglyphBuffer.direction = buffer.direction;\n\tglyphBuffer.script = script;\n\tglyphBuffer.language = language;\n\n\t// Convert codepoints to initial glyph infos\n\tconst infos: GlyphInfo[] = [];\n\tfor (const [i, codepoint] of buffer.codepoints.entries()) {\n\t\tconst cluster = buffer.clusters[i];\n\t\tif (cluster === undefined) continue;\n\t\tconst glyphId = font.glyphId(codepoint);\n\n\t\tinfos.push({\n\t\t\tglyphId,\n\t\t\tcluster,\n\t\t\tmask: 0xffffffff,\n\t\t\tcodepoint,\n\t\t});\n\t}\n\n\tglyphBuffer.initFromInfos(infos);\n\n\t// Pre-shaping: Apply complex script analysis\n\tpreShape(glyphBuffer, script);\n\n\t// Apply GSUB\n\tapplyGsub(font, glyphBuffer, plan);\n\n\t// Initialize positions (using Face for variable font metrics)\n\tinitializePositions(face, glyphBuffer);\n\n\t// Apply GPOS or fallback positioning\n\tconst hasGpos = font.gpos !== null && plan.gposLookups.length > 0;\n\tif (hasGpos) {\n\t\tapplyGpos(font, glyphBuffer, plan);\n\t} else {\n\t\t// Fallback kerning using kern table\n\t\tapplyFallbackKerning(font, glyphBuffer.infos, glyphBuffer.positions);\n\t\t// Fallback mark positioning using combining classes\n\t\tapplyFallbackMarkPositioning(\n\t\t\tfont,\n\t\t\tglyphBuffer.infos,\n\t\t\tglyphBuffer.positions,\n\t\t);\n\t}\n\n\t// Apply AAT morx substitutions if no GSUB\n\tif (!font.gsub && font.morx) {\n\t\tapplyMorx(font, glyphBuffer);\n\t}\n\n\t// Reverse for RTL\n\tif (direction === \"rtl\") {\n\t\tglyphBuffer.reverse();\n\t}\n\n\treturn glyphBuffer;\n}\n\n// Pre-shaping for complex scripts\n\nfunction preShape(buffer: GlyphBuffer, script: string): void {\n\t// Arabic joining analysis\n\tif (\n\t\tscript === \"arab\" ||\n\t\tscript === \"syrc\" ||\n\t\tscript === \"mand\" ||\n\t\tscript === \"nko \"\n\t) {\n\t\tsetupArabicMasks(buffer.infos);\n\t\treturn;\n\t}\n\n\t// Hebrew (RTL with marks)\n\tif (script === \"hebr\") {\n\t\tsetupHebrewMasks(buffer.infos);\n\t\treturn;\n\t}\n\n\t// Hangul (Korean)\n\tif (script === \"hang\" || script === \"kore\") {\n\t\t// Normalize Jamo sequences into precomposed syllables\n\t\tconst normalized = normalizeHangul(buffer.infos);\n\t\tif (normalized.length !== buffer.infos.length) {\n\t\t\tbuffer.initFromInfos(normalized);\n\t\t}\n\t\tsetupHangulMasks(buffer.infos);\n\t\treturn;\n\t}\n\n\t// Indic scripts (syllable-based)\n\tif (\n\t\tscript === \"deva\" ||\n\t\tscript === \"beng\" ||\n\t\tscript === \"guru\" ||\n\t\tscript === \"gujr\" ||\n\t\tscript === \"orya\" ||\n\t\tscript === \"taml\" ||\n\t\tscript === \"telu\" ||\n\t\tscript === \"knda\" ||\n\t\tscript === \"mlym\"\n\t) {\n\t\tsetupIndicMasks(buffer.infos);\n\t\treorderIndic(buffer.infos);\n\t\treturn;\n\t}\n\n\t// Thai and Lao (leading vowel reordering)\n\tif (script === \"thai\" || script === \"lao \") {\n\t\tsetupThaiLaoMasks(buffer.infos);\n\t\treorderThaiLao(buffer.infos);\n\t\treturn;\n\t}\n\n\t// Khmer (subscript consonants, pre-base vowels)\n\tif (script === \"khmr\") {\n\t\tsetupKhmerMasks(buffer.infos);\n\t\treorderKhmer(buffer.infos);\n\t\treturn;\n\t}\n\n\t// Myanmar (medials, pre-base vowels, stacking)\n\tif (script === \"mymr\") {\n\t\tsetupMyanmarMasks(buffer.infos);\n\t\treorderMyanmar(buffer.infos);\n\t\treturn;\n\t}\n\n\t// Universal Shaping Engine (many other complex scripts)\n\tif (usesUSE(script)) {\n\t\tsetupUseMasks(buffer.infos);\n\t\treorderUSE(buffer.infos);\n\t\treturn;\n\t}\n\n\t// Auto-detect based on content if script is unknown\n\tif (script === \"Zyyy\" || script === \"Zinh\" || script === \"Zzzz\") {\n\t\tdetectAndApplyComplexShaping(buffer.infos);\n\t}\n}\n\n// Auto-detect complex script from content\nfunction detectAndApplyComplexShaping(infos: GlyphInfo[]): void {\n\tif (infos.length === 0) return;\n\n\t// Sample first few codepoints to detect script\n\tconst sample = infos.slice(0, Math.min(10, infos.length));\n\n\tfor (const info of sample) {\n\t\tconst cp = info.codepoint;\n\n\t\t// Arabic range\n\t\tif (\n\t\t\t(cp >= 0x0600 && cp <= 0x06ff) ||\n\t\t\t(cp >= 0x0750 && cp <= 0x077f) ||\n\t\t\t(cp >= 0x08a0 && cp <= 0x08ff)\n\t\t) {\n\t\t\tsetupArabicMasks(infos);\n\t\t\treturn;\n\t\t}\n\n\t\t// Hebrew range\n\t\tif (cp >= 0x0590 && cp <= 0x05ff) {\n\t\t\tsetupHebrewMasks(infos);\n\t\t\treturn;\n\t\t}\n\n\t\t// Korean/Hangul\n\t\tif (isKorean(cp)) {\n\t\t\tconst normalized = normalizeHangul(infos);\n\t\t\tif (normalized.length !== infos.length) {\n\t\t\t\t// Replace infos in place\n\t\t\t\tinfos.length = 0;\n\t\t\t\tinfos.push(...normalized);\n\t\t\t}\n\t\t\tsetupHangulMasks(infos);\n\t\t\treturn;\n\t\t}\n\n\t\t// Devanagari and other Indic\n\t\tif (isIndic(cp)) {\n\t\t\tsetupIndicMasks(infos);\n\t\t\treorderIndic(infos);\n\t\t\treturn;\n\t\t}\n\n\t\t// Thai\n\t\tif (isThai(cp)) {\n\t\t\tsetupThaiLaoMasks(infos);\n\t\t\treorderThaiLao(infos);\n\t\t\treturn;\n\t\t}\n\n\t\t// Lao\n\t\tif (isLao(cp)) {\n\t\t\tsetupThaiLaoMasks(infos);\n\t\t\treorderThaiLao(infos);\n\t\t\treturn;\n\t\t}\n\n\t\t// Khmer\n\t\tif (isKhmer(cp)) {\n\t\t\tsetupKhmerMasks(infos);\n\t\t\treorderKhmer(infos);\n\t\t\treturn;\n\t\t}\n\n\t\t// Myanmar\n\t\tif (isMyanmar(cp)) {\n\t\t\tsetupMyanmarMasks(infos);\n\t\t\treorderMyanmar(infos);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n// GSUB application\n\nfunction applyGsub(font: Font, buffer: GlyphBuffer, plan: ShapePlan): void {\n\tfor (const { lookup } of plan.gsubLookups) {\n\t\tapplyGsubLookup(font, buffer, lookup, plan);\n\t}\n}\n\nfunction applyGsubLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: AnyGsubLookup,\n\tplan: ShapePlan,\n): void {\n\tswitch (lookup.type) {\n\t\tcase GsubLookupType.Single:\n\t\t\tapplySingleSubstLookup(font, buffer, lookup);\n\t\t\tbreak;\n\t\tcase GsubLookupType.Multiple:\n\t\t\tapplyMultipleSubstLookup(font, buffer, lookup);\n\t\t\tbreak;\n\t\tcase GsubLookupType.Alternate:\n\t\t\t// Alternate requires user selection - use first alternate as default\n\t\t\tapplyAlternateSubstLookup(font, buffer, lookup);\n\t\t\tbreak;\n\t\tcase GsubLookupType.Ligature:\n\t\t\tapplyLigatureSubstLookup(font, buffer, lookup);\n\t\t\tbreak;\n\t\tcase GsubLookupType.Context:\n\t\t\tapplyContextSubstLookup(font, buffer, lookup, plan);\n\t\t\tbreak;\n\t\tcase GsubLookupType.ChainingContext:\n\t\t\tapplyChainingContextSubstLookup(font, buffer, lookup, plan);\n\t\t\tbreak;\n\t\t// Note: Extension lookups (Type 7) are unwrapped during parsing\n\t\t// and converted to their actual lookup types, so no case needed here\n\t\tcase GsubLookupType.ReverseChainingSingle:\n\t\t\tapplyReverseChainingSingleSubstLookup(font, buffer, lookup);\n\t\t\tbreak;\n\t}\n}\n\nfunction applySingleSubstLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: SingleSubstLookup,\n): void {\n\tfor (const info of buffer.infos) {\n\t\tif (shouldSkipGlyph(font, info.glyphId, lookup.flag)) continue;\n\n\t\tconst replacement = applySingleSubst(lookup, info.glyphId);\n\t\tif (replacement !== null) {\n\t\t\tinfo.glyphId = replacement;\n\t\t}\n\t}\n}\n\nfunction applyMultipleSubstLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: MultipleSubstLookup,\n): void {\n\tlet i = 0;\n\twhile (i < buffer.infos.length) {\n\t\tconst info = buffer.infos[i];\n\t\tif (!info) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (shouldSkipGlyph(font, info.glyphId, lookup.flag)) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet applied = false;\n\t\tfor (const subtable of lookup.subtables) {\n\t\t\tconst coverageIndex = subtable.coverage.get(info.glyphId);\n\t\t\tif (coverageIndex === null) continue;\n\n\t\t\tconst sequence = subtable.sequences[coverageIndex];\n\t\t\tif (!sequence || sequence.length === 0) continue;\n\n\t\t\tconst [firstGlyph, ...restGlyphs] = sequence;\n\t\t\tif (firstGlyph === undefined) continue;\n\n\t\t\t// Replace with sequence\n\t\t\tinfo.glyphId = firstGlyph;\n\n\t\t\t// Insert remaining glyphs\n\t\t\tfor (const [j, glyphId] of restGlyphs.entries()) {\n\t\t\t\tconst newInfo: GlyphInfo = {\n\t\t\t\t\tglyphId,\n\t\t\t\t\tcluster: info.cluster,\n\t\t\t\t\tmask: info.mask,\n\t\t\t\t\tcodepoint: info.codepoint,\n\t\t\t\t};\n\t\t\t\tconst newPos: GlyphPosition = {\n\t\t\t\t\txAdvance: 0,\n\t\t\t\t\tyAdvance: 0,\n\t\t\t\t\txOffset: 0,\n\t\t\t\t\tyOffset: 0,\n\t\t\t\t};\n\t\t\t\tbuffer.insertGlyph(i + j + 1, newInfo, newPos);\n\t\t\t}\n\n\t\t\ti += sequence.length;\n\t\t\tapplied = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!applied) i++;\n\t}\n}\n\nfunction applyAlternateSubstLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: AlternateSubstLookup,\n): void {\n\t// Alternate substitution allows selecting from multiple alternates\n\t// By default, use the first alternate (index 0)\n\tfor (const info of buffer.infos) {\n\t\tif (shouldSkipGlyph(font, info.glyphId, lookup.flag)) continue;\n\n\t\tfor (const subtable of lookup.subtables) {\n\t\t\tconst coverageIndex = subtable.coverage.get(info.glyphId);\n\t\t\tif (coverageIndex === null) continue;\n\n\t\t\tconst alternateSet = subtable.alternateSets[coverageIndex];\n\t\t\tif (!alternateSet || alternateSet.length === 0) continue;\n\n\t\t\tconst [firstAlternate] = alternateSet;\n\t\t\tif (firstAlternate === undefined) continue;\n\n\t\t\t// Use first alternate by default\n\t\t\tinfo.glyphId = firstAlternate;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction applyLigatureSubstLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: LigatureSubstLookup,\n): void {\n\tlet i = 0;\n\twhile (i < buffer.infos.length) {\n\t\tconst info = buffer.infos[i];\n\t\tif (!info) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (shouldSkipGlyph(font, info.glyphId, lookup.flag)) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Collect matchable glyphs (skipping ignored ones)\n\t\tconst matchIndices: number[] = [i];\n\t\tconst matchGlyphs: GlyphId[] = [info.glyphId];\n\n\t\tfor (\n\t\t\tlet j = i + 1;\n\t\t\tj < buffer.infos.length && matchGlyphs.length < 16;\n\t\t\tj++\n\t\t) {\n\t\t\tconst nextInfo = buffer.infos[j];\n\t\t\tif (!nextInfo) continue;\n\t\t\tif (shouldSkipGlyph(font, nextInfo.glyphId, lookup.flag)) continue;\n\t\t\tmatchIndices.push(j);\n\t\t\tmatchGlyphs.push(nextInfo.glyphId);\n\t\t}\n\n\t\tconst result = applyLigatureSubst(lookup, matchGlyphs, 0);\n\t\tif (result) {\n\t\t\t// Replace first glyph with ligature\n\t\t\tinfo.glyphId = result.ligatureGlyph;\n\n\t\t\t// Merge clusters and remove consumed glyphs\n\t\t\tconst indicesToRemove: number[] = [];\n\t\t\tfor (let k = 1; k < result.consumed; k++) {\n\t\t\t\tconst idx = matchIndices[k];\n\t\t\t\tif (idx !== undefined) {\n\t\t\t\t\tconst targetInfo = buffer.infos[idx];\n\t\t\t\t\tif (targetInfo) {\n\t\t\t\t\t\tinfo.cluster = Math.min(info.cluster, targetInfo.cluster);\n\t\t\t\t\t}\n\t\t\t\t\tindicesToRemove.push(idx);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove in reverse order to maintain indices\n\t\t\tfor (const idx of indicesToRemove.reverse()) {\n\t\t\t\tbuffer.removeRange(idx, idx + 1);\n\t\t\t}\n\t\t}\n\n\t\ti++;\n\t}\n}\n\nfunction applyContextSubstLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: ContextSubstLookup,\n\tplan: ShapePlan,\n): void {\n\t// Context substitution - matches input sequence and applies nested lookups\n\tfor (let i = 0; i < buffer.infos.length; i++) {\n\t\tconst info = buffer.infos[i];\n\t\tif (!info) continue;\n\t\tif (shouldSkipGlyph(font, info.glyphId, lookup.flag)) continue;\n\n\t\tfor (const subtable of lookup.subtables) {\n\t\t\tlet matched = false;\n\t\t\tlet lookupRecords: SequenceLookupRecord[] = [];\n\n\t\t\tif (subtable.format === 1) {\n\t\t\t\tconst result = matchContextFormat1(\n\t\t\t\t\tfont,\n\t\t\t\t\tbuffer,\n\t\t\t\t\ti,\n\t\t\t\t\tsubtable,\n\t\t\t\t\tlookup.flag,\n\t\t\t\t);\n\t\t\t\tif (result) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tlookupRecords = result;\n\t\t\t\t}\n\t\t\t} else if (subtable.format === 2) {\n\t\t\t\tconst result = matchContextFormat2(\n\t\t\t\t\tfont,\n\t\t\t\t\tbuffer,\n\t\t\t\t\ti,\n\t\t\t\t\tsubtable,\n\t\t\t\t\tlookup.flag,\n\t\t\t\t);\n\t\t\t\tif (result) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tlookupRecords = result;\n\t\t\t\t}\n\t\t\t} else if (subtable.format === 3) {\n\t\t\t\tif (matchContextFormat3(font, buffer, i, subtable, lookup.flag)) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tlookupRecords = subtable.lookupRecords;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (matched) {\n\t\t\t\tapplyNestedLookups(font, buffer, i, lookupRecords, plan);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction applyChainingContextSubstLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: ChainingContextSubstLookup,\n\tplan: ShapePlan,\n): void {\n\tfor (let i = 0; i < buffer.infos.length; i++) {\n\t\tconst info = buffer.infos[i];\n\t\tif (!info) continue;\n\t\tif (shouldSkipGlyph(font, info.glyphId, lookup.flag)) continue;\n\n\t\tfor (const subtable of lookup.subtables) {\n\t\t\tlet matched = false;\n\t\t\tlet lookupRecords: SequenceLookupRecord[] = [];\n\n\t\t\tif (subtable.format === 1) {\n\t\t\t\tconst result = matchChainingFormat1(\n\t\t\t\t\tfont,\n\t\t\t\t\tbuffer,\n\t\t\t\t\ti,\n\t\t\t\t\tsubtable,\n\t\t\t\t\tlookup.flag,\n\t\t\t\t);\n\t\t\t\tif (result) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tlookupRecords = result;\n\t\t\t\t}\n\t\t\t} else if (subtable.format === 2) {\n\t\t\t\tconst result = matchChainingFormat2(\n\t\t\t\t\tfont,\n\t\t\t\t\tbuffer,\n\t\t\t\t\ti,\n\t\t\t\t\tsubtable,\n\t\t\t\t\tlookup.flag,\n\t\t\t\t);\n\t\t\t\tif (result) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tlookupRecords = result;\n\t\t\t\t}\n\t\t\t} else if (subtable.format === 3) {\n\t\t\t\tif (matchChainingFormat3(font, buffer, i, subtable, lookup.flag)) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tlookupRecords = subtable.lookupRecords;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (matched) {\n\t\t\t\tapplyNestedLookups(font, buffer, i, lookupRecords, plan);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction applyReverseChainingSingleSubstLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: ReverseChainingSingleSubstLookup,\n): void {\n\t// Process in reverse order\n\tfor (let i = buffer.infos.length - 1; i >= 0; i--) {\n\t\tconst info = buffer.infos[i];\n\t\tif (!info) continue;\n\t\tif (shouldSkipGlyph(font, info.glyphId, lookup.flag)) continue;\n\n\t\tfor (const subtable of lookup.subtables) {\n\t\t\tconst coverageIndex = subtable.coverage.get(info.glyphId);\n\t\t\tif (coverageIndex === null) continue;\n\n\t\t\t// Check backtrack (glyphs after current in reverse order)\n\t\t\tlet backtrackMatch = true;\n\t\t\tlet backtrackPos = i + 1;\n\t\t\tfor (const backCov of subtable.backtrackCoverages) {\n\t\t\t\twhile (\n\t\t\t\t\tbacktrackPos < buffer.infos.length &&\n\t\t\t\t\tshouldSkipGlyph(\n\t\t\t\t\t\tfont,\n\t\t\t\t\t\tbuffer.infos[backtrackPos]?.glyphId,\n\t\t\t\t\t\tlookup.flag,\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tbacktrackPos++;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tbacktrackPos >= buffer.infos.length ||\n\t\t\t\t\tbackCov.get(buffer.infos[backtrackPos]?.glyphId) === null\n\t\t\t\t) {\n\t\t\t\t\tbacktrackMatch = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbacktrackPos++;\n\t\t\t}\n\t\t\tif (!backtrackMatch) continue;\n\n\t\t\t// Check lookahead (glyphs before current)\n\t\t\tlet lookaheadMatch = true;\n\t\t\tlet lookaheadPos = i - 1;\n\t\t\tfor (const lookCov of subtable.lookaheadCoverages) {\n\t\t\t\twhile (\n\t\t\t\t\tlookaheadPos >= 0 &&\n\t\t\t\t\tshouldSkipGlyph(\n\t\t\t\t\t\tfont,\n\t\t\t\t\t\tbuffer.infos[lookaheadPos]?.glyphId,\n\t\t\t\t\t\tlookup.flag,\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tlookaheadPos--;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tlookaheadPos < 0 ||\n\t\t\t\t\tlookCov.get(buffer.infos[lookaheadPos]?.glyphId) === null\n\t\t\t\t) {\n\t\t\t\t\tlookaheadMatch = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlookaheadPos--;\n\t\t\t}\n\t\t\tif (!lookaheadMatch) continue;\n\n\t\t\t// Apply substitution\n\t\t\tconst substitute = subtable.substituteGlyphIds[coverageIndex];\n\t\t\tif (substitute !== undefined) {\n\t\t\t\tinfo.glyphId = substitute;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n// Note: Extension lookups (Type 7) are unwrapped during parsing,\n// so no applyExtensionGsubLookup function is needed at runtime.\n\n/** Match Context Format 1 - glyph-based rules */\nfunction matchContextFormat1(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tsubtable: ContextSubstFormat1,\n\tlookupFlag: number,\n): SequenceLookupRecord[] | null {\n\tconst firstGlyph = buffer.infos[startIndex]?.glyphId;\n\tconst coverageIndex = subtable.coverage.get(firstGlyph);\n\tif (coverageIndex === null) return null;\n\n\tconst ruleSet = subtable.ruleSets[coverageIndex];\n\tif (!ruleSet) return null;\n\n\tfor (const rule of ruleSet) {\n\t\tif (\n\t\t\tmatchGlyphSequence(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tstartIndex + 1,\n\t\t\t\trule.inputSequence,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\treturn rule.lookupRecords;\n\t\t}\n\t}\n\treturn null;\n}\n\n/** Match Context Format 2 - class-based rules */\nfunction matchContextFormat2(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tsubtable: ContextSubstFormat2,\n\tlookupFlag: number,\n): SequenceLookupRecord[] | null {\n\tconst firstGlyph = buffer.infos[startIndex]?.glyphId;\n\tconst coverageIndex = subtable.coverage.get(firstGlyph);\n\tif (coverageIndex === null) return null;\n\n\tconst firstClass = subtable.classDef.get(firstGlyph);\n\tconst classRuleSet = subtable.classRuleSets[firstClass];\n\tif (!classRuleSet) return null;\n\n\tfor (const rule of classRuleSet) {\n\t\tif (\n\t\t\tmatchClassSequence(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tstartIndex + 1,\n\t\t\t\trule.inputClasses,\n\t\t\t\tsubtable.classDef,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\treturn rule.lookupRecords;\n\t\t}\n\t}\n\treturn null;\n}\n\n/** Match Context Format 3 - coverage-based */\nfunction matchContextFormat3(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tsubtable: ContextSubstFormat3,\n\tlookupFlag: number,\n): boolean {\n\tlet pos = startIndex;\n\tfor (const coverage of subtable.coverages) {\n\t\twhile (\n\t\t\tpos < buffer.infos.length &&\n\t\t\tshouldSkipGlyph(font, buffer.infos[pos]?.glyphId, lookupFlag)\n\t\t) {\n\t\t\tpos++;\n\t\t}\n\t\tif (pos >= buffer.infos.length) return false;\n\t\tif (coverage.get(buffer.infos[pos]?.glyphId) === null) return false;\n\t\tpos++;\n\t}\n\treturn true;\n}\n\n/** Match Chaining Context Format 1 - glyph-based rules */\nfunction matchChainingFormat1(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tsubtable: ChainingContextFormat1,\n\tlookupFlag: number,\n): SequenceLookupRecord[] | null {\n\tconst firstGlyph = buffer.infos[startIndex]?.glyphId;\n\tconst coverageIndex = subtable.coverage.get(firstGlyph);\n\tif (coverageIndex === null) return null;\n\n\tconst chainRuleSet = subtable.chainRuleSets[coverageIndex];\n\tif (!chainRuleSet) return null;\n\n\tfor (const rule of chainRuleSet) {\n\t\t// Check backtrack (reversed order, before startIndex)\n\t\tif (\n\t\t\t!matchGlyphSequenceBackward(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tstartIndex - 1,\n\t\t\t\trule.backtrackSequence,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Check input (excluding first glyph which is in coverage)\n\t\tif (\n\t\t\t!matchGlyphSequence(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tstartIndex + 1,\n\t\t\t\trule.inputSequence,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Find where input sequence ends\n\t\tlet inputEnd = startIndex + 1;\n\t\tfor (let i = 0; i < rule.inputSequence.length; i++) {\n\t\t\twhile (\n\t\t\t\tinputEnd < buffer.infos.length &&\n\t\t\t\tshouldSkipGlyph(font, buffer.infos[inputEnd]?.glyphId, lookupFlag)\n\t\t\t) {\n\t\t\t\tinputEnd++;\n\t\t\t}\n\t\t\tinputEnd++;\n\t\t}\n\n\t\t// Check lookahead\n\t\tif (\n\t\t\t!matchGlyphSequence(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tinputEnd,\n\t\t\t\trule.lookaheadSequence,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn rule.lookupRecords;\n\t}\n\treturn null;\n}\n\n/** Match Chaining Context Format 2 - class-based rules */\nfunction matchChainingFormat2(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tsubtable: ChainingContextFormat2,\n\tlookupFlag: number,\n): SequenceLookupRecord[] | null {\n\tconst firstGlyph = buffer.infos[startIndex]?.glyphId;\n\tconst coverageIndex = subtable.coverage.get(firstGlyph);\n\tif (coverageIndex === null) return null;\n\n\tconst firstClass = subtable.inputClassDef.get(firstGlyph);\n\tconst chainClassRuleSet = subtable.chainClassRuleSets[firstClass];\n\tif (!chainClassRuleSet) return null;\n\n\tfor (const rule of chainClassRuleSet) {\n\t\t// Check backtrack classes (reversed order)\n\t\tif (\n\t\t\t!matchClassSequenceBackward(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tstartIndex - 1,\n\t\t\t\trule.backtrackClasses,\n\t\t\t\tsubtable.backtrackClassDef,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Check input classes (excluding first)\n\t\tif (\n\t\t\t!matchClassSequence(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tstartIndex + 1,\n\t\t\t\trule.inputClasses,\n\t\t\t\tsubtable.inputClassDef,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Find where input ends\n\t\tlet inputEnd = startIndex + 1;\n\t\tfor (let i = 0; i < rule.inputClasses.length; i++) {\n\t\t\twhile (\n\t\t\t\tinputEnd < buffer.infos.length &&\n\t\t\t\tshouldSkipGlyph(font, buffer.infos[inputEnd]?.glyphId, lookupFlag)\n\t\t\t) {\n\t\t\t\tinputEnd++;\n\t\t\t}\n\t\t\tinputEnd++;\n\t\t}\n\n\t\t// Check lookahead classes\n\t\tif (\n\t\t\t!matchClassSequence(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tinputEnd,\n\t\t\t\trule.lookaheadClasses,\n\t\t\t\tsubtable.lookaheadClassDef,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn rule.lookupRecords;\n\t}\n\treturn null;\n}\n\n/** Match Chaining Context Format 3 - coverage-based */\nfunction matchChainingFormat3(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tsubtable: ChainingContextFormat3,\n\tlookupFlag: number,\n): boolean {\n\t// Check backtrack (in reverse order, before startIndex)\n\tlet backtrackPos = startIndex - 1;\n\tfor (const coverage of subtable.backtrackCoverages) {\n\t\twhile (\n\t\t\tbacktrackPos >= 0 &&\n\t\t\tshouldSkipGlyph(font, buffer.infos[backtrackPos]?.glyphId, lookupFlag)\n\t\t) {\n\t\t\tbacktrackPos--;\n\t\t}\n\t\tif (backtrackPos < 0) return false;\n\t\tif (coverage.get(buffer.infos[backtrackPos]?.glyphId) === null)\n\t\t\treturn false;\n\t\tbacktrackPos--;\n\t}\n\n\t// Check input sequence\n\tlet inputPos = startIndex;\n\tfor (const coverage of subtable.inputCoverages) {\n\t\twhile (\n\t\t\tinputPos < buffer.infos.length &&\n\t\t\tshouldSkipGlyph(font, buffer.infos[inputPos]?.glyphId, lookupFlag)\n\t\t) {\n\t\t\tinputPos++;\n\t\t}\n\t\tif (inputPos >= buffer.infos.length) return false;\n\t\tif (coverage.get(buffer.infos[inputPos]?.glyphId) === null) return false;\n\t\tinputPos++;\n\t}\n\n\t// Check lookahead\n\tlet lookaheadPos = inputPos;\n\tfor (const coverage of subtable.lookaheadCoverages) {\n\t\twhile (\n\t\t\tlookaheadPos < buffer.infos.length &&\n\t\t\tshouldSkipGlyph(font, buffer.infos[lookaheadPos]?.glyphId, lookupFlag)\n\t\t) {\n\t\t\tlookaheadPos++;\n\t\t}\n\t\tif (lookaheadPos >= buffer.infos.length) return false;\n\t\tif (coverage.get(buffer.infos[lookaheadPos]?.glyphId) === null)\n\t\t\treturn false;\n\t\tlookaheadPos++;\n\t}\n\n\treturn true;\n}\n\nfunction applyNestedLookups(\n\t_font: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tlookupRecords: Array<{ sequenceIndex: number; lookupListIndex: number }>,\n\tplan: ShapePlan,\n): void {\n\t// Sort by sequence index descending to apply from end to start\n\tconst sorted = [...lookupRecords].sort(\n\t\t(a, b) => b.sequenceIndex - a.sequenceIndex,\n\t);\n\n\tfor (const record of sorted) {\n\t\tconst lookupEntry = plan.gsubLookups.find(\n\t\t\t(l) => l.index === record.lookupListIndex,\n\t\t);\n\t\tif (!lookupEntry) continue;\n\n\t\t// Apply at the specific position\n\t\tconst pos = startIndex + record.sequenceIndex;\n\t\tif (pos >= buffer.infos.length) continue;\n\n\t\tconst targetInfo = buffer.infos[pos];\n\t\tif (!targetInfo) continue;\n\n\t\t// For single subst, apply directly\n\t\tif (lookupEntry.lookup.type === GsubLookupType.Single) {\n\t\t\tconst replacement = applySingleSubst(\n\t\t\t\tlookupEntry.lookup as SingleSubstLookup,\n\t\t\t\ttargetInfo.glyphId,\n\t\t\t);\n\t\t\tif (replacement !== null) {\n\t\t\t\ttargetInfo.glyphId = replacement;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// GPOS application\n\nfunction initializePositions(face: Face, buffer: GlyphBuffer): void {\n\tfor (const [i, info] of buffer.infos.entries()) {\n\t\t// Use Face.advanceWidth to include variable font deltas\n\t\tconst advance = face.advanceWidth(info.glyphId);\n\t\tbuffer.setAdvance(i, advance, 0);\n\t}\n}\n\nfunction applyGpos(font: Font, buffer: GlyphBuffer, plan: ShapePlan): void {\n\tfor (const { lookup } of plan.gposLookups) {\n\t\tapplyGposLookup(font, buffer, lookup, plan);\n\t}\n}\n\nfunction applyGposLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: AnyGposLookup,\n\tplan: ShapePlan,\n): void {\n\tswitch (lookup.type) {\n\t\tcase GposLookupType.Single:\n\t\t\tapplySinglePosLookup(font, buffer, lookup);\n\t\t\tbreak;\n\t\tcase GposLookupType.Pair:\n\t\t\tapplyPairPosLookup(font, buffer, lookup);\n\t\t\tbreak;\n\t\tcase GposLookupType.Cursive:\n\t\t\tapplyCursivePosLookup(font, buffer, lookup);\n\t\t\tbreak;\n\t\tcase GposLookupType.MarkToBase:\n\t\t\tapplyMarkBasePosLookup(font, buffer, lookup);\n\t\t\tbreak;\n\t\tcase GposLookupType.MarkToLigature:\n\t\t\tapplyMarkLigaturePosLookup(font, buffer, lookup);\n\t\t\tbreak;\n\t\tcase GposLookupType.MarkToMark:\n\t\t\tapplyMarkMarkPosLookup(font, buffer, lookup);\n\t\t\tbreak;\n\t\tcase GposLookupType.Context:\n\t\t\tapplyContextPosLookup(font, buffer, lookup as ContextPosLookup, plan);\n\t\t\tbreak;\n\t\tcase GposLookupType.ChainingContext:\n\t\t\tapplyChainingContextPosLookup(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tlookup as ChainingContextPosLookup,\n\t\t\t\tplan,\n\t\t\t);\n\t\t\tbreak;\n\t\t// Extension (type 9) is unwrapped during parsing - no runtime case needed\n\t}\n}\n\nfunction applySinglePosLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: SinglePosLookup,\n): void {\n\tfor (const [i, info] of buffer.infos.entries()) {\n\t\tconst pos = buffer.positions[i];\n\t\tif (!pos) continue;\n\t\tif (shouldSkipGlyph(font, info.glyphId, lookup.flag)) continue;\n\n\t\tfor (const subtable of lookup.subtables) {\n\t\t\tconst coverageIndex = subtable.coverage.get(info.glyphId);\n\t\t\tif (coverageIndex === null) continue;\n\n\t\t\tconst value =\n\t\t\t\tsubtable.format === 1\n\t\t\t\t\t? subtable.value\n\t\t\t\t\t: subtable.values?.[coverageIndex];\n\t\t\tif (value) {\n\t\t\t\tif (value.xPlacement) pos.xOffset += value.xPlacement;\n\t\t\t\tif (value.yPlacement) pos.yOffset += value.yPlacement;\n\t\t\t\tif (value.xAdvance) pos.xAdvance += value.xAdvance;\n\t\t\t\tif (value.yAdvance) pos.yAdvance += value.yAdvance;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction applyPairPosLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: PairPosLookup,\n): void {\n\tfor (let i = 0; i < buffer.infos.length - 1; i++) {\n\t\tconst info1 = buffer.infos[i];\n\t\tif (!info1) continue;\n\t\tif (shouldSkipGlyph(font, info1.glyphId, lookup.flag)) continue;\n\n\t\t// Find next non-skipped glyph\n\t\tlet j = i + 1;\n\t\twhile (j < buffer.infos.length) {\n\t\t\tconst nextInfo = buffer.infos[j];\n\t\t\tif (nextInfo && !shouldSkipGlyph(font, nextInfo.glyphId, lookup.flag)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tif (j >= buffer.infos.length) break;\n\n\t\tconst info2 = buffer.infos[j];\n\t\tif (!info2) continue;\n\n\t\tconst kern = getKerning(lookup, info1.glyphId, info2.glyphId);\n\t\tif (kern) {\n\t\t\tconst pos1 = buffer.positions[i];\n\t\t\tconst pos2 = buffer.positions[j];\n\t\t\tif (pos1) pos1.xAdvance += kern.xAdvance1;\n\t\t\tif (pos2) pos2.xAdvance += kern.xAdvance2;\n\t\t}\n\t}\n}\n\nfunction applyCursivePosLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: CursivePosLookup,\n): void {\n\t// Cursive attachment - connect exit anchor of one glyph to entry anchor of next\n\tfor (let i = 0; i < buffer.infos.length - 1; i++) {\n\t\tconst info1 = buffer.infos[i];\n\t\tif (!info1) continue;\n\t\tif (shouldSkipGlyph(font, info1.glyphId, lookup.flag)) continue;\n\n\t\t// Find next non-skipped glyph\n\t\tlet j = i + 1;\n\t\twhile (j < buffer.infos.length) {\n\t\t\tconst nextInfo = buffer.infos[j];\n\t\t\tif (nextInfo && !shouldSkipGlyph(font, nextInfo.glyphId, lookup.flag)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tif (j >= buffer.infos.length) break;\n\n\t\tconst info2 = buffer.infos[j];\n\t\tif (!info2) continue;\n\n\t\tfor (const subtable of lookup.subtables) {\n\t\t\tconst exitIndex = subtable.coverage.get(info1.glyphId);\n\t\t\tconst entryIndex = subtable.coverage.get(info2.glyphId);\n\n\t\t\tif (exitIndex === null || entryIndex === null) continue;\n\n\t\t\tconst exitRecord = subtable.entryExitRecords[exitIndex];\n\t\t\tconst entryRecord = subtable.entryExitRecords[entryIndex];\n\n\t\t\tif (!exitRecord?.exitAnchor || !entryRecord?.entryAnchor) continue;\n\n\t\t\t// Calculate offset to align anchors\n\t\t\tconst exitAnchor = exitRecord.exitAnchor;\n\t\t\tconst entryAnchor = entryRecord.entryAnchor;\n\n\t\t\t// Adjust position of second glyph\n\t\t\tconst pos2 = buffer.positions[j];\n\t\t\tif (pos2) {\n\t\t\t\tpos2.yOffset = exitAnchor.yCoordinate - entryAnchor.yCoordinate;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction applyMarkBasePosLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: MarkBasePosLookup,\n): void {\n\tfor (let i = 0; i < buffer.infos.length; i++) {\n\t\tconst markInfo = buffer.infos[i];\n\t\tif (!markInfo) continue;\n\n\t\t// Must be a mark glyph\n\t\tif (getGlyphClass(font.gdef, markInfo.glyphId) !== GlyphClass.Mark)\n\t\t\tcontinue;\n\n\t\t// Find preceding base glyph\n\t\tlet baseIndex = -1;\n\t\tfor (let j = i - 1; j >= 0; j--) {\n\t\t\tconst prevInfo = buffer.infos[j];\n\t\t\tif (!prevInfo) continue;\n\t\t\tconst prevClass = getGlyphClass(font.gdef, prevInfo.glyphId);\n\t\t\tif (prevClass === GlyphClass.Base || prevClass === 0) {\n\t\t\t\tbaseIndex = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// Skip marks\n\t\t\tif (prevClass === GlyphClass.Mark) continue;\n\t\t\t// Stop at ligature\n\t\t\tif (prevClass === GlyphClass.Ligature) {\n\t\t\t\tbaseIndex = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (baseIndex < 0) continue;\n\t\tconst baseInfo = buffer.infos[baseIndex];\n\t\tif (!baseInfo) continue;\n\n\t\tfor (const subtable of lookup.subtables) {\n\t\t\tconst markCoverageIndex = subtable.markCoverage.get(markInfo.glyphId);\n\t\t\tconst baseCoverageIndex = subtable.baseCoverage.get(baseInfo.glyphId);\n\n\t\t\tif (markCoverageIndex === null || baseCoverageIndex === null) continue;\n\n\t\t\tconst markRecord = subtable.markArray.markRecords[markCoverageIndex];\n\t\t\tconst baseRecord = subtable.baseArray[baseCoverageIndex];\n\n\t\t\tif (!markRecord || !baseRecord) continue;\n\n\t\t\tconst baseAnchor = baseRecord.baseAnchors[markRecord.markClass];\n\t\t\tif (!baseAnchor) continue;\n\n\t\t\tconst markAnchor = markRecord.markAnchor;\n\n\t\t\t// Position mark relative to base\n\t\t\tconst markPos = buffer.positions[i];\n\t\t\tconst basePos = buffer.positions[baseIndex];\n\t\t\tif (!markPos || !basePos) continue;\n\n\t\t\tmarkPos.xOffset =\n\t\t\t\tbaseAnchor.xCoordinate - markAnchor.xCoordinate + basePos.xOffset;\n\t\t\tmarkPos.yOffset =\n\t\t\t\tbaseAnchor.yCoordinate - markAnchor.yCoordinate + basePos.yOffset;\n\n\t\t\t// Mark doesn't advance cursor\n\t\t\tmarkPos.xAdvance = 0;\n\t\t\tmarkPos.yAdvance = 0;\n\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction applyMarkLigaturePosLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: MarkLigaturePosLookup,\n): void {\n\tfor (let i = 0; i < buffer.infos.length; i++) {\n\t\tconst markInfo = buffer.infos[i];\n\t\tif (!markInfo) continue;\n\n\t\tif (getGlyphClass(font.gdef, markInfo.glyphId) !== GlyphClass.Mark)\n\t\t\tcontinue;\n\n\t\t// Find preceding ligature\n\t\tlet ligIndex = -1;\n\t\tlet componentIndex = 0; // Which component of the ligature\n\n\t\tfor (let j = i - 1; j >= 0; j--) {\n\t\t\tconst prevInfo = buffer.infos[j];\n\t\t\tif (!prevInfo) continue;\n\t\t\tconst prevClass = getGlyphClass(font.gdef, prevInfo.glyphId);\n\t\t\tif (prevClass === GlyphClass.Ligature) {\n\t\t\t\tligIndex = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (prevClass === GlyphClass.Mark) {\n\t\t\t\tcomponentIndex++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ligIndex < 0) continue;\n\t\tconst ligInfo = buffer.infos[ligIndex];\n\t\tif (!ligInfo) continue;\n\n\t\tfor (const subtable of lookup.subtables) {\n\t\t\tconst markCoverageIndex = subtable.markCoverage.get(markInfo.glyphId);\n\t\t\tconst ligCoverageIndex = subtable.ligatureCoverage.get(ligInfo.glyphId);\n\n\t\t\tif (markCoverageIndex === null || ligCoverageIndex === null) continue;\n\n\t\t\tconst markRecord = subtable.markArray.markRecords[markCoverageIndex];\n\t\t\tconst ligAttach = subtable.ligatureArray[ligCoverageIndex];\n\n\t\t\tif (!markRecord || !ligAttach) continue;\n\n\t\t\t// Clamp component index\n\t\t\tconst compIdx = Math.min(\n\t\t\t\tcomponentIndex,\n\t\t\t\tligAttach.componentRecords.length - 1,\n\t\t\t);\n\t\t\tconst component = ligAttach.componentRecords[compIdx];\n\t\t\tif (!component) continue;\n\n\t\t\tconst ligAnchor = component.ligatureAnchors[markRecord.markClass];\n\t\t\tif (!ligAnchor) continue;\n\n\t\t\tconst markAnchor = markRecord.markAnchor;\n\t\t\tconst markPos = buffer.positions[i];\n\t\t\tconst ligPos = buffer.positions[ligIndex];\n\t\t\tif (!markPos || !ligPos) continue;\n\n\t\t\tmarkPos.xOffset =\n\t\t\t\tligAnchor.xCoordinate - markAnchor.xCoordinate + ligPos.xOffset;\n\t\t\tmarkPos.yOffset =\n\t\t\t\tligAnchor.yCoordinate - markAnchor.yCoordinate + ligPos.yOffset;\n\t\t\tmarkPos.xAdvance = 0;\n\t\t\tmarkPos.yAdvance = 0;\n\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction applyMarkMarkPosLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: MarkMarkPosLookup,\n): void {\n\tfor (let i = 0; i < buffer.infos.length; i++) {\n\t\tconst mark1Info = buffer.infos[i];\n\t\tif (!mark1Info) continue;\n\n\t\tif (getGlyphClass(font.gdef, mark1Info.glyphId) !== GlyphClass.Mark)\n\t\t\tcontinue;\n\n\t\t// Find preceding mark (mark2) - must be immediately preceding\n\t\tlet mark2Index = -1;\n\t\tif (i > 0) {\n\t\t\tconst prevInfo = buffer.infos[i - 1];\n\t\t\tif (prevInfo) {\n\t\t\t\tconst prevClass = getGlyphClass(font.gdef, prevInfo.glyphId);\n\t\t\t\tif (prevClass === GlyphClass.Mark) {\n\t\t\t\t\tmark2Index = i - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mark2Index < 0) continue;\n\t\tconst mark2Info = buffer.infos[mark2Index];\n\t\tif (!mark2Info) continue;\n\n\t\tfor (const subtable of lookup.subtables) {\n\t\t\tconst mark1CoverageIndex = subtable.mark1Coverage.get(mark1Info.glyphId);\n\t\t\tconst mark2CoverageIndex = subtable.mark2Coverage.get(mark2Info.glyphId);\n\n\t\t\tif (mark1CoverageIndex === null || mark2CoverageIndex === null) continue;\n\n\t\t\tconst mark1Record = subtable.mark1Array.markRecords[mark1CoverageIndex];\n\t\t\tconst mark2Record = subtable.mark2Array[mark2CoverageIndex];\n\n\t\t\tif (!mark1Record || !mark2Record) continue;\n\n\t\t\tconst mark2Anchor = mark2Record.mark2Anchors[mark1Record.markClass];\n\t\t\tif (!mark2Anchor) continue;\n\n\t\t\tconst mark1Anchor = mark1Record.markAnchor;\n\t\t\tconst mark1Pos = buffer.positions[i];\n\t\t\tconst mark2Pos = buffer.positions[mark2Index];\n\t\t\tif (!mark1Pos || !mark2Pos) continue;\n\n\t\t\tmark1Pos.xOffset =\n\t\t\t\tmark2Anchor.xCoordinate - mark1Anchor.xCoordinate + mark2Pos.xOffset;\n\t\t\tmark1Pos.yOffset =\n\t\t\t\tmark2Anchor.yCoordinate - mark1Anchor.yCoordinate + mark2Pos.yOffset;\n\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n// GPOS Context positioning\n\nfunction applyContextPosLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: ContextPosLookup,\n\tplan: ShapePlan,\n): void {\n\tfor (let i = 0; i < buffer.infos.length; i++) {\n\t\tconst info = buffer.infos[i];\n\t\tif (!info) continue;\n\t\tif (shouldSkipGlyph(font, info.glyphId, lookup.flag)) continue;\n\n\t\tfor (const subtable of lookup.subtables) {\n\t\t\tlet matched = false;\n\t\t\tlet lookupRecords: PosLookupRecord[] = [];\n\n\t\t\tif (subtable.format === 1) {\n\t\t\t\tconst result = matchContextPosFormat1(\n\t\t\t\t\tfont,\n\t\t\t\t\tbuffer,\n\t\t\t\t\ti,\n\t\t\t\t\tsubtable,\n\t\t\t\t\tlookup.flag,\n\t\t\t\t);\n\t\t\t\tif (result) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tlookupRecords = result;\n\t\t\t\t}\n\t\t\t} else if (subtable.format === 2) {\n\t\t\t\tconst result = matchContextPosFormat2(\n\t\t\t\t\tfont,\n\t\t\t\t\tbuffer,\n\t\t\t\t\ti,\n\t\t\t\t\tsubtable,\n\t\t\t\t\tlookup.flag,\n\t\t\t\t);\n\t\t\t\tif (result) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tlookupRecords = result;\n\t\t\t\t}\n\t\t\t} else if (subtable.format === 3) {\n\t\t\t\tif (matchContextPosFormat3(font, buffer, i, subtable, lookup.flag)) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tlookupRecords = subtable.lookupRecords;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (matched) {\n\t\t\t\tapplyNestedPosLookups(font, buffer, i, lookupRecords, plan);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction applyChainingContextPosLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: ChainingContextPosLookup,\n\tplan: ShapePlan,\n): void {\n\tfor (let i = 0; i < buffer.infos.length; i++) {\n\t\tconst info = buffer.infos[i];\n\t\tif (!info) continue;\n\t\tif (shouldSkipGlyph(font, info.glyphId, lookup.flag)) continue;\n\n\t\tfor (const subtable of lookup.subtables) {\n\t\t\tlet matched = false;\n\t\t\tlet lookupRecords: PosLookupRecord[] = [];\n\n\t\t\tif (subtable.format === 1) {\n\t\t\t\tconst result = matchChainingContextPosFormat1(\n\t\t\t\t\tfont,\n\t\t\t\t\tbuffer,\n\t\t\t\t\ti,\n\t\t\t\t\tsubtable,\n\t\t\t\t\tlookup.flag,\n\t\t\t\t);\n\t\t\t\tif (result) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tlookupRecords = result;\n\t\t\t\t}\n\t\t\t} else if (subtable.format === 2) {\n\t\t\t\tconst result = matchChainingContextPosFormat2(\n\t\t\t\t\tfont,\n\t\t\t\t\tbuffer,\n\t\t\t\t\ti,\n\t\t\t\t\tsubtable,\n\t\t\t\t\tlookup.flag,\n\t\t\t\t);\n\t\t\t\tif (result) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tlookupRecords = result;\n\t\t\t\t}\n\t\t\t} else if (subtable.format === 3) {\n\t\t\t\tif (\n\t\t\t\t\tmatchChainingContextPosFormat3(font, buffer, i, subtable, lookup.flag)\n\t\t\t\t) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tlookupRecords = subtable.lookupRecords;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (matched) {\n\t\t\t\tapplyNestedPosLookups(font, buffer, i, lookupRecords, plan);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/** Match Context Pos Format 1 - glyph-based rules */\nfunction matchContextPosFormat1(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tsubtable: ContextPosFormat1,\n\tlookupFlag: number,\n): PosLookupRecord[] | null {\n\tconst firstGlyph = buffer.infos[startIndex]?.glyphId;\n\tconst coverageIndex = subtable.coverage.get(firstGlyph);\n\tif (coverageIndex === null) return null;\n\n\tconst ruleSet = subtable.ruleSets[coverageIndex];\n\tif (!ruleSet) return null;\n\n\tfor (const rule of ruleSet) {\n\t\tif (\n\t\t\tmatchGlyphSequence(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tstartIndex + 1,\n\t\t\t\trule.inputSequence,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\treturn rule.lookupRecords;\n\t\t}\n\t}\n\treturn null;\n}\n\n/** Match Context Pos Format 2 - class-based rules */\nfunction matchContextPosFormat2(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tsubtable: ContextPosFormat2,\n\tlookupFlag: number,\n): PosLookupRecord[] | null {\n\tconst firstGlyph = buffer.infos[startIndex]?.glyphId;\n\tconst coverageIndex = subtable.coverage.get(firstGlyph);\n\tif (coverageIndex === null) return null;\n\n\tconst firstClass = subtable.classDef.get(firstGlyph);\n\tconst classRuleSet = subtable.classRuleSets[firstClass];\n\tif (!classRuleSet) return null;\n\n\tfor (const rule of classRuleSet) {\n\t\tif (\n\t\t\tmatchClassSequence(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tstartIndex + 1,\n\t\t\t\trule.inputClasses,\n\t\t\t\tsubtable.classDef,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\treturn rule.lookupRecords;\n\t\t}\n\t}\n\treturn null;\n}\n\n/** Match Context Pos Format 3 - coverage-based */\nfunction matchContextPosFormat3(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tsubtable: ContextPosFormat3,\n\tlookupFlag: number,\n): boolean {\n\tlet pos = startIndex;\n\tfor (const coverage of subtable.coverages) {\n\t\twhile (\n\t\t\tpos < buffer.infos.length &&\n\t\t\tshouldSkipGlyph(font, buffer.infos[pos]?.glyphId, lookupFlag)\n\t\t) {\n\t\t\tpos++;\n\t\t}\n\t\tif (pos >= buffer.infos.length) return false;\n\t\tif (coverage.get(buffer.infos[pos]?.glyphId) === null) return false;\n\t\tpos++;\n\t}\n\treturn true;\n}\n\n/** Match Chaining Context Pos Format 1 - glyph-based rules */\nfunction matchChainingContextPosFormat1(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tsubtable: ChainingContextPosFormat1,\n\tlookupFlag: number,\n): PosLookupRecord[] | null {\n\tconst firstGlyph = buffer.infos[startIndex]?.glyphId;\n\tconst coverageIndex = subtable.coverage.get(firstGlyph);\n\tif (coverageIndex === null) return null;\n\n\tconst chainRuleSet = subtable.chainRuleSets[coverageIndex];\n\tif (!chainRuleSet) return null;\n\n\tfor (const rule of chainRuleSet) {\n\t\t// Check backtrack (reversed order, before startIndex)\n\t\tif (\n\t\t\t!matchGlyphSequenceBackward(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tstartIndex - 1,\n\t\t\t\trule.backtrackSequence,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Check input (excluding first glyph which is in coverage)\n\t\tif (\n\t\t\t!matchGlyphSequence(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tstartIndex + 1,\n\t\t\t\trule.inputSequence,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Find where input sequence ends\n\t\tlet inputEnd = startIndex + 1;\n\t\tfor (let i = 0; i < rule.inputSequence.length; i++) {\n\t\t\twhile (\n\t\t\t\tinputEnd < buffer.infos.length &&\n\t\t\t\tshouldSkipGlyph(font, buffer.infos[inputEnd]?.glyphId, lookupFlag)\n\t\t\t) {\n\t\t\t\tinputEnd++;\n\t\t\t}\n\t\t\tinputEnd++;\n\t\t}\n\n\t\t// Check lookahead\n\t\tif (\n\t\t\t!matchGlyphSequence(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tinputEnd,\n\t\t\t\trule.lookaheadSequence,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn rule.lookupRecords;\n\t}\n\treturn null;\n}\n\n/** Match Chaining Context Pos Format 2 - class-based rules */\nfunction matchChainingContextPosFormat2(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tsubtable: ChainingContextPosFormat2,\n\tlookupFlag: number,\n): PosLookupRecord[] | null {\n\tconst firstGlyph = buffer.infos[startIndex]?.glyphId;\n\tconst coverageIndex = subtable.coverage.get(firstGlyph);\n\tif (coverageIndex === null) return null;\n\n\tconst firstClass = subtable.inputClassDef.get(firstGlyph);\n\tconst chainClassRuleSet = subtable.chainClassRuleSets[firstClass];\n\tif (!chainClassRuleSet) return null;\n\n\tfor (const rule of chainClassRuleSet) {\n\t\t// Check backtrack classes (reversed order)\n\t\tif (\n\t\t\t!matchClassSequenceBackward(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tstartIndex - 1,\n\t\t\t\trule.backtrackClasses,\n\t\t\t\tsubtable.backtrackClassDef,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Check input classes (excluding first)\n\t\tif (\n\t\t\t!matchClassSequence(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tstartIndex + 1,\n\t\t\t\trule.inputClasses,\n\t\t\t\tsubtable.inputClassDef,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Find where input ends\n\t\tlet inputEnd = startIndex + 1;\n\t\tfor (let i = 0; i < rule.inputClasses.length; i++) {\n\t\t\twhile (\n\t\t\t\tinputEnd < buffer.infos.length &&\n\t\t\t\tshouldSkipGlyph(font, buffer.infos[inputEnd]?.glyphId, lookupFlag)\n\t\t\t) {\n\t\t\t\tinputEnd++;\n\t\t\t}\n\t\t\tinputEnd++;\n\t\t}\n\n\t\t// Check lookahead classes\n\t\tif (\n\t\t\t!matchClassSequence(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tinputEnd,\n\t\t\t\trule.lookaheadClasses,\n\t\t\t\tsubtable.lookaheadClassDef,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn rule.lookupRecords;\n\t}\n\treturn null;\n}\n\n/** Match Chaining Context Pos Format 3 - coverage-based */\nfunction matchChainingContextPosFormat3(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tsubtable: ChainingContextPosFormat3,\n\tlookupFlag: number,\n): boolean {\n\t// Check backtrack (in reverse order, before startIndex)\n\tlet backtrackPos = startIndex - 1;\n\tfor (const coverage of subtable.backtrackCoverages) {\n\t\twhile (\n\t\t\tbacktrackPos >= 0 &&\n\t\t\tshouldSkipGlyph(font, buffer.infos[backtrackPos]?.glyphId, lookupFlag)\n\t\t) {\n\t\t\tbacktrackPos--;\n\t\t}\n\t\tif (backtrackPos < 0) return false;\n\t\tif (coverage.get(buffer.infos[backtrackPos]?.glyphId) === null)\n\t\t\treturn false;\n\t\tbacktrackPos--;\n\t}\n\n\t// Check input sequence\n\tlet inputPos = startIndex;\n\tfor (const coverage of subtable.inputCoverages) {\n\t\twhile (\n\t\t\tinputPos < buffer.infos.length &&\n\t\t\tshouldSkipGlyph(font, buffer.infos[inputPos]?.glyphId, lookupFlag)\n\t\t) {\n\t\t\tinputPos++;\n\t\t}\n\t\tif (inputPos >= buffer.infos.length) return false;\n\t\tif (coverage.get(buffer.infos[inputPos]?.glyphId) === null) return false;\n\t\tinputPos++;\n\t}\n\n\t// Check lookahead\n\tlet lookaheadPos = inputPos;\n\tfor (const coverage of subtable.lookaheadCoverages) {\n\t\twhile (\n\t\t\tlookaheadPos < buffer.infos.length &&\n\t\t\tshouldSkipGlyph(font, buffer.infos[lookaheadPos]?.glyphId, lookupFlag)\n\t\t) {\n\t\t\tlookaheadPos++;\n\t\t}\n\t\tif (lookaheadPos >= buffer.infos.length) return false;\n\t\tif (coverage.get(buffer.infos[lookaheadPos]?.glyphId) === null)\n\t\t\treturn false;\n\t\tlookaheadPos++;\n\t}\n\n\treturn true;\n}\n\n/** Apply nested positioning lookups at specific positions */\nfunction applyNestedPosLookups(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tlookupRecords: PosLookupRecord[],\n\tplan: ShapePlan,\n): void {\n\t// Sort by sequence index descending to apply from end to start\n\tconst sorted = [...lookupRecords].sort(\n\t\t(a, b) => b.sequenceIndex - a.sequenceIndex,\n\t);\n\n\tfor (const record of sorted) {\n\t\tconst lookupEntry = plan.gposLookups.find(\n\t\t\t(l) => l.index === record.lookupListIndex,\n\t\t);\n\t\tif (!lookupEntry) continue;\n\n\t\t// Apply at the specific position\n\t\tconst pos = startIndex + record.sequenceIndex;\n\t\tif (pos >= buffer.infos.length) continue;\n\n\t\t// Apply the lookup directly\n\t\tapplyGposLookup(font, buffer, lookupEntry.lookup, plan);\n\t}\n}\n\n// Sequence matching helpers\n\n/** Match a sequence of specific glyphs forward */\nfunction matchGlyphSequence(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartPos: number,\n\tglyphs: GlyphId[],\n\tlookupFlag: number,\n): boolean {\n\tlet pos = startPos;\n\tfor (const glyph of glyphs) {\n\t\twhile (\n\t\t\tpos < buffer.infos.length &&\n\t\t\tshouldSkipGlyph(font, buffer.infos[pos]?.glyphId, lookupFlag)\n\t\t) {\n\t\t\tpos++;\n\t\t}\n\t\tif (pos >= buffer.infos.length) return false;\n\t\tif (buffer.infos[pos]?.glyphId !== glyph) return false;\n\t\tpos++;\n\t}\n\treturn true;\n}\n\n/** Match a sequence of specific glyphs backward */\nfunction matchGlyphSequenceBackward(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartPos: number,\n\tglyphs: GlyphId[],\n\tlookupFlag: number,\n): boolean {\n\tlet pos = startPos;\n\tfor (const glyph of glyphs) {\n\t\twhile (\n\t\t\tpos >= 0 &&\n\t\t\tshouldSkipGlyph(font, buffer.infos[pos]?.glyphId, lookupFlag)\n\t\t) {\n\t\t\tpos--;\n\t\t}\n\t\tif (pos < 0) return false;\n\t\tif (buffer.infos[pos]?.glyphId !== glyph) return false;\n\t\tpos--;\n\t}\n\treturn true;\n}\n\n/** Match a sequence of classes forward */\nfunction matchClassSequence(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartPos: number,\n\tclasses: number[],\n\tclassDef: ClassDef,\n\tlookupFlag: number,\n): boolean {\n\tlet pos = startPos;\n\tfor (const cls of classes) {\n\t\twhile (\n\t\t\tpos < buffer.infos.length &&\n\t\t\tshouldSkipGlyph(font, buffer.infos[pos]?.glyphId, lookupFlag)\n\t\t) {\n\t\t\tpos++;\n\t\t}\n\t\tif (pos >= buffer.infos.length) return false;\n\t\tif (classDef.get(buffer.infos[pos]?.glyphId) !== cls) return false;\n\t\tpos++;\n\t}\n\treturn true;\n}\n\n/** Match a sequence of classes backward */\nfunction matchClassSequenceBackward(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartPos: number,\n\tclasses: number[],\n\tclassDef: ClassDef,\n\tlookupFlag: number,\n): boolean {\n\tlet pos = startPos;\n\tfor (const cls of classes) {\n\t\twhile (\n\t\t\tpos >= 0 &&\n\t\t\tshouldSkipGlyph(font, buffer.infos[pos]?.glyphId, lookupFlag)\n\t\t) {\n\t\t\tpos--;\n\t\t}\n\t\tif (pos < 0) return false;\n\t\tif (classDef.get(buffer.infos[pos]?.glyphId) !== cls) return false;\n\t\tpos--;\n\t}\n\treturn true;\n}\n\n// Utility\n\nfunction shouldSkipGlyph(\n\tfont: Font,\n\tglyphId: GlyphId,\n\tlookupFlag: number,\n): boolean {\n\tconst gdef = font.gdef;\n\tif (!gdef) return false;\n\n\tconst glyphClass = getGlyphClass(gdef, glyphId);\n\n\tif (\n\t\tlookupFlag & LookupFlag.IgnoreBaseGlyphs &&\n\t\tglyphClass === GlyphClass.Base\n\t)\n\t\treturn true;\n\tif (\n\t\tlookupFlag & LookupFlag.IgnoreLigatures &&\n\t\tglyphClass === GlyphClass.Ligature\n\t)\n\t\treturn true;\n\tif (lookupFlag & LookupFlag.IgnoreMarks && glyphClass === GlyphClass.Mark)\n\t\treturn true;\n\n\tconst markAttachmentType = getMarkAttachmentType(lookupFlag);\n\tif (markAttachmentType !== 0 && glyphClass === GlyphClass.Mark) {\n\t\tconst glyphMarkClass = gdef.markAttachClassDef.get(glyphId);\n\t\tif (glyphMarkClass !== markAttachmentType) return true;\n\t}\n\n\treturn false;\n}\n\n// AAT morx substitution\n\nfunction applyMorx(font: Font, buffer: GlyphBuffer): void {\n\tconst morx = font.morx;\n\tif (!morx) return;\n\n\tfor (const chain of morx.chains) {\n\t\tfor (const subtable of chain.subtables) {\n\t\t\t// Apply if subFeatureFlags match (default: all enabled)\n\t\t\tif ((chain.defaultFlags & subtable.subFeatureFlags) === 0) continue;\n\n\t\t\tswitch (subtable.type) {\n\t\t\t\tcase MorxSubtableType.NonContextual:\n\t\t\t\t\t// Simple substitution (Type 4)\n\t\t\t\t\tfor (const info of buffer.infos) {\n\t\t\t\t\t\tconst replacement = applyNonContextual(\n\t\t\t\t\t\t\tsubtable as MorxNonContextualSubtable,\n\t\t\t\t\t\t\tinfo.glyphId,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (replacement !== null) {\n\t\t\t\t\t\t\tinfo.glyphId = replacement;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MorxSubtableType.Rearrangement:\n\t\t\t\t\t// Rearrangement (Type 0) - reorder glyphs\n\t\t\t\t\tprocessRearrangement(\n\t\t\t\t\t\tsubtable as MorxRearrangementSubtable,\n\t\t\t\t\t\tbuffer.infos,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MorxSubtableType.Contextual:\n\t\t\t\t\t// Contextual substitution (Type 1)\n\t\t\t\t\tprocessContextual(subtable as MorxContextualSubtable, buffer.infos);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MorxSubtableType.Ligature: {\n\t\t\t\t\t// Ligature (Type 2)\n\t\t\t\t\tconst newInfos = processLigature(\n\t\t\t\t\t\tsubtable as MorxLigatureSubtable,\n\t\t\t\t\t\tbuffer.infos,\n\t\t\t\t\t);\n\t\t\t\t\t// Update buffer with new infos (may be shorter due to ligatures)\n\t\t\t\t\tif (newInfos.length !== buffer.infos.length) {\n\t\t\t\t\t\tbuffer.initFromInfos(newInfos);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase MorxSubtableType.Insertion: {\n\t\t\t\t\t// Insertion (Type 5)\n\t\t\t\t\tconst newInfos = processInsertion(\n\t\t\t\t\t\tsubtable as MorxInsertionSubtable,\n\t\t\t\t\t\tbuffer.infos,\n\t\t\t\t\t);\n\t\t\t\t\t// Update buffer with new infos (may be longer due to insertions)\n\t\t\t\t\tif (newInfos.length !== buffer.infos.length) {\n\t\t\t\t\t\tbuffer.initFromInfos(newInfos);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "// Bidi bracket pairs data, auto generated\nexport default {\n\tpairs:\n\t\t\"14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1\",\n\tcanonical:\n\t\t\"6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye\",\n};\n", "/**\n * Parses an string that holds encoded codepoint mappings, e.g. for bracket pairs or\n * mirroring characters. Returns an object holding the `map`, and optionally a `reverseMap`.\n */\nexport function parseCharacterMap(\n\tencodedString: string,\n\tincludeReverse: boolean,\n): { map: Map<string, string>; reverseMap: Map<string, string> | null } {\n\tconst radix = 36;\n\tlet lastCode = 0;\n\tconst map = new Map<string, string>();\n\tconst reverseMap = includeReverse ? new Map<string, string>() : null;\n\tlet prevPair = \"\";\n\n\tfunction visit(entry: string): void {\n\t\tif (entry.indexOf(\"+\") !== -1) {\n\t\t\tfor (let i = +entry; i--; ) {\n\t\t\t\tvisit(prevPair);\n\t\t\t}\n\t\t} else {\n\t\t\tprevPair = entry;\n\t\t\tconst parts = entry.split(\">\");\n\t\t\tconst aStr = parts[0] ?? \"\";\n\t\t\tconst bStr = parts[1] ?? \"\";\n\t\t\tlastCode += parseInt(aStr, radix);\n\t\t\tconst a = String.fromCodePoint(lastCode);\n\t\t\tlastCode += parseInt(bStr, radix);\n\t\t\tconst b = String.fromCodePoint(lastCode);\n\t\t\tmap.set(a, b);\n\t\t\tif (reverseMap) {\n\t\t\t\treverseMap.set(b, a);\n\t\t\t}\n\t\t}\n\t}\n\n\tencodedString.split(\",\").forEach(visit);\n\treturn { map, reverseMap };\n}\n", "/**\n * Bidi bracket pair functions\n * Port of bidi-js brackets.js\n */\n\nimport data from \"./brackets.data.ts\";\nimport { parseCharacterMap } from \"./parse-character-map.ts\";\n\nlet openToClose: Map<string, string> | null = null;\nlet closeToOpen: Map<string, string> | null = null;\nlet canonical: Map<string, string> | null = null;\n\nfunction parse(): void {\n\tif (!openToClose) {\n\t\tconst { map, reverseMap } = parseCharacterMap(data.pairs, true);\n\t\topenToClose = map;\n\t\tcloseToOpen = reverseMap;\n\t\tcanonical = parseCharacterMap(data.canonical, false).map;\n\t}\n}\n\nexport function openingToClosingBracket(char: string): string | null {\n\tparse();\n\treturn openToClose?.get(char) || null;\n}\n\nexport function closingToOpeningBracket(char: string): string | null {\n\tparse();\n\treturn closeToOpen?.get(char) || null;\n}\n\nexport function getCanonicalBracket(char: string): string | null {\n\tparse();\n\treturn canonical?.get(char) || null;\n}\n", "// Bidi character types data, auto generated\nexport default {\n\tR: \"13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73\",\n\tEN: \"1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9\",\n\tES: \"17,2,6dp+1,f+1,av,16vr,mx+1,4o,2\",\n\tET: \"z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj\",\n\tAN: \"16o+5,2j+9,2+1,35,ed,1ff2+9,87+u\",\n\tCS: \"18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b\",\n\tB: \"a,3,f+2,2v,690\",\n\tS: \"9,2,k\",\n\tWS: \"c,k,4f4,1vk+a,u,1j,335\",\n\tON: \"x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i\",\n\tBN: \"0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1\",\n\tNSM: \"lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n\",\n\tAL: \"16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d\",\n\tLRO: \"6ct\",\n\tRLO: \"6cu\",\n\tLRE: \"6cq\",\n\tRLE: \"6cr\",\n\tPDF: \"6cs\",\n\tLRI: \"6ee\",\n\tRLI: \"6ef\",\n\tFSI: \"6eg\",\n\tPDI: \"6eh\",\n};\n", "/**\n * Bidi character type detection\n * Port of bidi-js charTypes.js\n */\n\nimport DATA from \"./char-types.data.ts\";\n\nexport const TYPES: Record<string, number> = {};\nexport const TYPES_TO_NAMES: Record<number, string> = {};\nTYPES.L = 1; // L is the default\nTYPES_TO_NAMES[1] = \"L\";\n\nObject.keys(DATA).forEach((type, i) => {\n\tTYPES[type] = 1 << (i + 1);\n\tconst typeVal = TYPES[type];\n\tif (typeVal !== undefined) {\n\t\tTYPES_TO_NAMES[typeVal] = type;\n\t}\n});\n\nObject.freeze(TYPES);\n\n// Helper to get type value with fallback\nfunction getType(name: string): number {\n\treturn TYPES[name] ?? 0;\n}\n\nexport const ISOLATE_INIT_TYPES =\n\tgetType(\"LRI\") | getType(\"RLI\") | getType(\"FSI\");\nexport const STRONG_TYPES = getType(\"L\") | getType(\"R\") | getType(\"AL\");\nexport const NEUTRAL_ISOLATE_TYPES =\n\tgetType(\"B\") |\n\tgetType(\"S\") |\n\tgetType(\"WS\") |\n\tgetType(\"ON\") |\n\tgetType(\"FSI\") |\n\tgetType(\"LRI\") |\n\tgetType(\"RLI\") |\n\tgetType(\"PDI\");\nexport const BN_LIKE_TYPES =\n\tgetType(\"BN\") |\n\tgetType(\"RLE\") |\n\tgetType(\"LRE\") |\n\tgetType(\"RLO\") |\n\tgetType(\"LRO\") |\n\tgetType(\"PDF\");\nexport const TRAILING_TYPES =\n\tgetType(\"S\") |\n\tgetType(\"WS\") |\n\tgetType(\"B\") |\n\tISOLATE_INIT_TYPES |\n\tgetType(\"PDI\") |\n\tBN_LIKE_TYPES;\n\nlet map: Map<number, number> | null = null;\n\nfunction parseData(): void {\n\tif (!map) {\n\t\tmap = new Map();\n\t\tlet start = 0;\n\t\tfor (const type in DATA) {\n\t\t\tif (Object.hasOwn(DATA, type)) {\n\t\t\t\tconst segments = DATA[type as keyof typeof DATA];\n\t\t\t\tlet temp = \"\";\n\t\t\t\tlet end = 0;\n\t\t\t\tlet state = false;\n\t\t\t\tlet lastCode = 0; // Reset for each type - data is encoded relative to 0\n\t\t\t\tfor (let i = 0; i <= segments.length + 1; i += 1) {\n\t\t\t\t\tconst char = segments[i];\n\t\t\t\t\tif (char !== \",\" && i !== segments.length) {\n\t\t\t\t\t\tif (char === \"+\") {\n\t\t\t\t\t\t\tstate = true;\n\t\t\t\t\t\t\tlastCode = start = lastCode + parseInt(temp, 36);\n\t\t\t\t\t\t\ttemp = \"\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttemp += char;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!state) {\n\t\t\t\t\t\t\tlastCode = start = lastCode + parseInt(temp, 36);\n\t\t\t\t\t\t\tend = start;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tend = start + parseInt(temp, 36);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstate = false;\n\t\t\t\t\t\ttemp = \"\";\n\t\t\t\t\t\tlastCode = end;\n\t\t\t\t\t\tconst typeVal = getType(type);\n\t\t\t\t\t\tfor (let j = start; j < end + 1; j += 1) {\n\t\t\t\t\t\t\tmap.set(j, typeVal);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Get the bidi character type for a character\n */\nexport function getBidiCharType(char: string): number {\n\tparseData();\n\tconst codepoint = char.codePointAt(0);\n\tif (codepoint === undefined) return getType(\"L\");\n\treturn map?.get(codepoint) ?? getType(\"L\");\n}\n\n/**\n * Get the name of a bidi character type\n */\nexport function getBidiCharTypeName(char: string): string {\n\treturn TYPES_TO_NAMES[getBidiCharType(char)] ?? \"L\";\n}\n", "/**\n * Bidi embedding levels calculation (UAX #9)\n * Port of bidi-js embeddingLevels.js\n */\n\nimport {\n\tclosingToOpeningBracket,\n\tgetCanonicalBracket,\n\topeningToClosingBracket,\n} from \"./brackets.ts\";\nimport {\n\tBN_LIKE_TYPES,\n\tgetBidiCharType,\n\tISOLATE_INIT_TYPES,\n\tNEUTRAL_ISOLATE_TYPES,\n\tSTRONG_TYPES,\n\tTRAILING_TYPES,\n\tTYPES,\n} from \"./char-types.ts\";\n\n// Local type aliases\nconst TYPE_L = TYPES.L ?? 1;\nconst TYPE_R = TYPES.R ?? 2;\nconst TYPE_EN = TYPES.EN ?? 4;\nconst TYPE_ES = TYPES.ES ?? 8;\nconst TYPE_ET = TYPES.ET ?? 16;\nconst TYPE_AN = TYPES.AN ?? 32;\nconst TYPE_CS = TYPES.CS ?? 64;\nconst TYPE_B = TYPES.B ?? 128;\nconst TYPE_S = TYPES.S ?? 256;\nconst TYPE_ON = TYPES.ON ?? 512;\nconst TYPE_BN = TYPES.BN ?? 1024;\nconst TYPE_NSM = TYPES.NSM ?? 2048;\nconst TYPE_AL = TYPES.AL ?? 4096;\nconst TYPE_LRO = TYPES.LRO ?? 8192;\nconst TYPE_RLO = TYPES.RLO ?? 16384;\nconst TYPE_LRE = TYPES.LRE ?? 32768;\nconst TYPE_RLE = TYPES.RLE ?? 65536;\nconst TYPE_PDF = TYPES.PDF ?? 131072;\nconst TYPE_LRI = TYPES.LRI ?? 262144;\nconst TYPE_RLI = TYPES.RLI ?? 524288;\nconst TYPE_FSI = TYPES.FSI ?? 1048576;\nconst TYPE_PDI = TYPES.PDI ?? 2097152;\n\nexport interface EmbeddingLevelsResult {\n\tparagraphs: Array<{ start: number; end: number; level: number }>;\n\tlevels: Uint8Array;\n}\n\ninterface StatusStackEntry {\n\t_level: number;\n\t_override: number;\n\t_isolate: number;\n\t_isolInitIndex?: number;\n}\n\ninterface LevelRun {\n\t_start: number;\n\t_end: number;\n\t_level: number;\n\t_startsWithPDI: boolean;\n\t_endsWithIsolInit: boolean;\n}\n\ninterface IsolatingRunSeq {\n\t_seqIndices: number[];\n\t_sosType: number;\n\t_eosType: number;\n}\n\nfunction getCharType(charTypes: Uint32Array, i: number): number {\n\treturn charTypes[i] ?? 0;\n}\n\nfunction getSeqIndex(seqIndices: number[], i: number): number {\n\treturn seqIndices[i] ?? 0;\n}\n\nfunction getCharAt(s: string, i: number): string {\n\treturn s[i] ?? \"\";\n}\n\n/**\n * This function applies the Bidirectional Algorithm to a string, returning the resolved embedding levels\n * in a single Uint8Array plus a list of objects holding each paragraph's start and end indices and resolved\n * base embedding level.\n */\nexport function getEmbeddingLevels(\n\tstring: string,\n\tbaseDirection?: \"ltr\" | \"rtl\" | \"auto\",\n): EmbeddingLevelsResult {\n\tconst MAX_DEPTH = 125;\n\n\t// Start by mapping all characters to their unicode type, as a bitmask integer\n\tconst charTypes = new Uint32Array(string.length);\n\tfor (let i = 0; i < string.length; i++) {\n\t\tcharTypes[i] = getBidiCharType(getCharAt(string, i));\n\t}\n\n\tconst charTypeCounts = new Map<number, number>();\n\n\tfunction changeCharType(i: number, type: number): void {\n\t\tconst oldType = getCharType(charTypes, i);\n\t\tcharTypes[i] = type;\n\t\tcharTypeCounts.set(oldType, (charTypeCounts.get(oldType) ?? 0) - 1);\n\t\tif (oldType & NEUTRAL_ISOLATE_TYPES) {\n\t\t\tcharTypeCounts.set(\n\t\t\t\tNEUTRAL_ISOLATE_TYPES,\n\t\t\t\t(charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) ?? 0) - 1,\n\t\t\t);\n\t\t}\n\t\tcharTypeCounts.set(type, (charTypeCounts.get(type) ?? 0) + 1);\n\t\tif (type & NEUTRAL_ISOLATE_TYPES) {\n\t\t\tcharTypeCounts.set(\n\t\t\t\tNEUTRAL_ISOLATE_TYPES,\n\t\t\t\t(charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) ?? 0) + 1,\n\t\t\t);\n\t\t}\n\t}\n\n\tconst embedLevels = new Uint8Array(string.length);\n\tconst isolationPairs = new Map<number, number>();\n\n\tconst paragraphs: Array<{ start: number; end: number; level: number }> = [];\n\tlet paragraph: { start: number; end: number; level: number } | null = null;\n\n\tfunction determineAutoEmbedLevel(start: number, isFSI: boolean): number {\n\t\tfor (let i = start; i < string.length; i++) {\n\t\t\tconst charType = getCharType(charTypes, i);\n\t\t\tif (charType & (TYPE_R | TYPE_AL)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (charType & (TYPE_B | TYPE_L) || (isFSI && charType === TYPE_PDI)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (charType & ISOLATE_INIT_TYPES) {\n\t\t\t\tconst pdi = indexOfMatchingPDI(i);\n\t\t\t\ti = pdi === -1 ? string.length : pdi;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tfunction indexOfMatchingPDI(isolateStart: number): number {\n\t\tlet isolationLevel = 1;\n\t\tfor (let i = isolateStart + 1; i < string.length; i++) {\n\t\t\tconst charType = getCharType(charTypes, i);\n\t\t\tif (charType & TYPE_B) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (charType & TYPE_PDI) {\n\t\t\t\tif (--isolationLevel === 0) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t} else if (charType & ISOLATE_INIT_TYPES) {\n\t\t\t\tisolationLevel++;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tfor (let i = 0; i < string.length; i++) {\n\t\tif (!paragraph) {\n\t\t\tparagraph = {\n\t\t\t\tstart: i,\n\t\t\t\tend: string.length - 1,\n\t\t\t\tlevel:\n\t\t\t\t\tbaseDirection === \"rtl\"\n\t\t\t\t\t\t? 1\n\t\t\t\t\t\t: baseDirection === \"ltr\"\n\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t: determineAutoEmbedLevel(i, false),\n\t\t\t};\n\t\t\tparagraphs.push(paragraph);\n\t\t}\n\t\tif (getCharType(charTypes, i) & TYPE_B) {\n\t\t\tparagraph.end = i;\n\t\t\tparagraph = null;\n\t\t}\n\t}\n\n\tconst FORMATTING_TYPES =\n\t\tTYPE_RLE |\n\t\tTYPE_LRE |\n\t\tTYPE_RLO |\n\t\tTYPE_LRO |\n\t\tISOLATE_INIT_TYPES |\n\t\tTYPE_PDI |\n\t\tTYPE_PDF |\n\t\tTYPE_B;\n\tconst nextEven = (n: number): number => n + (n & 1 ? 1 : 2);\n\tconst nextOdd = (n: number): number => n + (n & 1 ? 2 : 1);\n\n\tfor (let paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {\n\t\tconst para = paragraphs[paraIdx];\n\t\tif (!para) continue;\n\t\tparagraph = para;\n\n\t\tconst statusStack: StatusStackEntry[] = [\n\t\t\t{\n\t\t\t\t_level: paragraph.level,\n\t\t\t\t_override: 0,\n\t\t\t\t_isolate: 0,\n\t\t\t},\n\t\t];\n\n\t\tlet overflowIsolateCount = 0;\n\t\tlet overflowEmbeddingCount = 0;\n\t\tlet validIsolateCount = 0;\n\t\tcharTypeCounts.clear();\n\n\t\tfor (let i = paragraph.start; i <= paragraph.end; i++) {\n\t\t\tlet charType = getCharType(charTypes, i);\n\t\t\tlet stackTop = statusStack[statusStack.length - 1];\n\t\t\tif (!stackTop) continue;\n\n\t\t\tcharTypeCounts.set(charType, (charTypeCounts.get(charType) ?? 0) + 1);\n\t\t\tif (charType & NEUTRAL_ISOLATE_TYPES) {\n\t\t\t\tcharTypeCounts.set(\n\t\t\t\t\tNEUTRAL_ISOLATE_TYPES,\n\t\t\t\t\t(charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) ?? 0) + 1,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (charType & FORMATTING_TYPES) {\n\t\t\t\tif (charType & (TYPE_RLE | TYPE_LRE)) {\n\t\t\t\t\tembedLevels[i] = stackTop._level;\n\t\t\t\t\tconst level = (charType === TYPE_RLE ? nextOdd : nextEven)(\n\t\t\t\t\t\tstackTop._level,\n\t\t\t\t\t);\n\t\t\t\t\tif (\n\t\t\t\t\t\tlevel <= MAX_DEPTH &&\n\t\t\t\t\t\t!overflowIsolateCount &&\n\t\t\t\t\t\t!overflowEmbeddingCount\n\t\t\t\t\t) {\n\t\t\t\t\t\tstatusStack.push({\n\t\t\t\t\t\t\t_level: level,\n\t\t\t\t\t\t\t_override: 0,\n\t\t\t\t\t\t\t_isolate: 0,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (!overflowIsolateCount) {\n\t\t\t\t\t\toverflowEmbeddingCount++;\n\t\t\t\t\t}\n\t\t\t\t} else if (charType & (TYPE_RLO | TYPE_LRO)) {\n\t\t\t\t\tembedLevels[i] = stackTop._level;\n\t\t\t\t\tconst level = (charType === TYPE_RLO ? nextOdd : nextEven)(\n\t\t\t\t\t\tstackTop._level,\n\t\t\t\t\t);\n\t\t\t\t\tif (\n\t\t\t\t\t\tlevel <= MAX_DEPTH &&\n\t\t\t\t\t\t!overflowIsolateCount &&\n\t\t\t\t\t\t!overflowEmbeddingCount\n\t\t\t\t\t) {\n\t\t\t\t\t\tstatusStack.push({\n\t\t\t\t\t\t\t_level: level,\n\t\t\t\t\t\t\t_override: charType & TYPE_RLO ? TYPE_R : TYPE_L,\n\t\t\t\t\t\t\t_isolate: 0,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (!overflowIsolateCount) {\n\t\t\t\t\t\toverflowEmbeddingCount++;\n\t\t\t\t\t}\n\t\t\t\t} else if (charType & ISOLATE_INIT_TYPES) {\n\t\t\t\t\tif (charType & TYPE_FSI) {\n\t\t\t\t\t\tcharType =\n\t\t\t\t\t\t\tdetermineAutoEmbedLevel(i + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;\n\t\t\t\t\t}\n\n\t\t\t\t\tembedLevels[i] = stackTop._level;\n\t\t\t\t\tif (stackTop._override) {\n\t\t\t\t\t\tchangeCharType(i, stackTop._override);\n\t\t\t\t\t}\n\t\t\t\t\tconst level = (charType === TYPE_RLI ? nextOdd : nextEven)(\n\t\t\t\t\t\tstackTop._level,\n\t\t\t\t\t);\n\t\t\t\t\tif (\n\t\t\t\t\t\tlevel <= MAX_DEPTH &&\n\t\t\t\t\t\toverflowIsolateCount === 0 &&\n\t\t\t\t\t\toverflowEmbeddingCount === 0\n\t\t\t\t\t) {\n\t\t\t\t\t\tvalidIsolateCount++;\n\t\t\t\t\t\tstatusStack.push({\n\t\t\t\t\t\t\t_level: level,\n\t\t\t\t\t\t\t_override: 0,\n\t\t\t\t\t\t\t_isolate: 1,\n\t\t\t\t\t\t\t_isolInitIndex: i,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\toverflowIsolateCount++;\n\t\t\t\t\t}\n\t\t\t\t} else if (charType & TYPE_PDI) {\n\t\t\t\t\tif (overflowIsolateCount > 0) {\n\t\t\t\t\t\toverflowIsolateCount--;\n\t\t\t\t\t} else if (validIsolateCount > 0) {\n\t\t\t\t\t\toverflowEmbeddingCount = 0;\n\t\t\t\t\t\twhile (statusStack.length > 0) {\n\t\t\t\t\t\t\tconst top = statusStack[statusStack.length - 1];\n\t\t\t\t\t\t\tif (top?._isolate) break;\n\t\t\t\t\t\t\tstatusStack.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst top = statusStack[statusStack.length - 1];\n\t\t\t\t\t\tconst isolInitIndex = top?._isolInitIndex;\n\t\t\t\t\t\tif (isolInitIndex != null) {\n\t\t\t\t\t\t\tisolationPairs.set(isolInitIndex, i);\n\t\t\t\t\t\t\tisolationPairs.set(i, isolInitIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstatusStack.pop();\n\t\t\t\t\t\tvalidIsolateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tstackTop = statusStack[statusStack.length - 1];\n\t\t\t\t\tif (!stackTop) continue;\n\t\t\t\t\tembedLevels[i] = stackTop._level;\n\t\t\t\t\tif (stackTop._override) {\n\t\t\t\t\t\tchangeCharType(i, stackTop._override);\n\t\t\t\t\t}\n\t\t\t\t} else if (charType & TYPE_PDF) {\n\t\t\t\t\tif (overflowIsolateCount === 0) {\n\t\t\t\t\t\tif (overflowEmbeddingCount > 0) {\n\t\t\t\t\t\t\toverflowEmbeddingCount--;\n\t\t\t\t\t\t} else if (!stackTop._isolate && statusStack.length > 1) {\n\t\t\t\t\t\t\tstatusStack.pop();\n\t\t\t\t\t\t\tstackTop = statusStack[statusStack.length - 1];\n\t\t\t\t\t\t\tif (!stackTop) continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tembedLevels[i] = stackTop._level;\n\t\t\t\t} else if (charType & TYPE_B) {\n\t\t\t\t\tembedLevels[i] = paragraph.level;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tembedLevels[i] = stackTop._level;\n\t\t\t\tif (stackTop._override && charType !== TYPE_BN) {\n\t\t\t\t\tchangeCharType(i, stackTop._override);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst levelRuns: LevelRun[] = [];\n\t\tlet currentRun: LevelRun | null = null;\n\t\tfor (let i = paragraph.start; i <= paragraph.end; i++) {\n\t\t\tconst charType = getCharType(charTypes, i);\n\t\t\tif (!(charType & BN_LIKE_TYPES)) {\n\t\t\t\tconst lvl = embedLevels[i] ?? 0;\n\t\t\t\tconst isIsolInit = !!(charType & ISOLATE_INIT_TYPES);\n\t\t\t\tconst isPDI = charType === TYPE_PDI;\n\t\t\t\tif (currentRun && lvl === currentRun._level) {\n\t\t\t\t\tcurrentRun._end = i;\n\t\t\t\t\tcurrentRun._endsWithIsolInit = isIsolInit;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentRun = {\n\t\t\t\t\t\t_start: i,\n\t\t\t\t\t\t_end: i,\n\t\t\t\t\t\t_level: lvl,\n\t\t\t\t\t\t_startsWithPDI: isPDI,\n\t\t\t\t\t\t_endsWithIsolInit: isIsolInit,\n\t\t\t\t\t};\n\t\t\t\t\tlevelRuns.push(currentRun);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst isolatingRunSeqs: IsolatingRunSeq[] = [];\n\n\t\tfor (let runIdx = 0; runIdx < levelRuns.length; runIdx++) {\n\t\t\tconst run = levelRuns[runIdx];\n\t\t\tif (!run) continue;\n\t\t\tif (\n\t\t\t\t!run._startsWithPDI ||\n\t\t\t\t(run._startsWithPDI && !isolationPairs.has(run._start))\n\t\t\t) {\n\t\t\t\tcurrentRun = run;\n\t\t\t\tconst seqRuns: LevelRun[] = [run];\n\n\t\t\t\twhile (currentRun?._endsWithIsolInit) {\n\t\t\t\t\tconst pdiIndex = isolationPairs.get(currentRun._end);\n\t\t\t\t\tif (pdiIndex == null) break;\n\t\t\t\t\tlet found = false;\n\t\t\t\t\tfor (let i = runIdx + 1; i < levelRuns.length; i++) {\n\t\t\t\t\t\tconst nextRun = levelRuns[i];\n\t\t\t\t\t\tif (nextRun?._start === pdiIndex) {\n\t\t\t\t\t\t\tcurrentRun = nextRun;\n\t\t\t\t\t\t\tseqRuns.push(nextRun);\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!found) break;\n\t\t\t\t}\n\n\t\t\t\tconst seqIndices: number[] = [];\n\t\t\t\tfor (const seqRun of seqRuns) {\n\t\t\t\t\tfor (let j = seqRun._start; j <= seqRun._end; j++) {\n\t\t\t\t\t\tseqIndices.push(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst firstIdx = seqIndices[0] ?? 0;\n\t\t\t\tconst firstLevel = embedLevels[firstIdx] ?? 0;\n\t\t\t\tlet prevLevel = paragraph.level;\n\t\t\t\tfor (let i = firstIdx - 1; i >= 0; i--) {\n\t\t\t\t\tif (!(getCharType(charTypes, i) & BN_LIKE_TYPES)) {\n\t\t\t\t\t\tprevLevel = embedLevels[i] ?? 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst lastIndex = seqIndices[seqIndices.length - 1] ?? 0;\n\t\t\t\tconst lastLevel = embedLevels[lastIndex] ?? 0;\n\t\t\t\tlet nextLevel = paragraph.level;\n\t\t\t\tif (!(getCharType(charTypes, lastIndex) & ISOLATE_INIT_TYPES)) {\n\t\t\t\t\tfor (let i = lastIndex + 1; i <= paragraph.end; i++) {\n\t\t\t\t\t\tif (!(getCharType(charTypes, i) & BN_LIKE_TYPES)) {\n\t\t\t\t\t\t\tnextLevel = embedLevels[i] ?? 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tisolatingRunSeqs.push({\n\t\t\t\t\t_seqIndices: seqIndices,\n\t\t\t\t\t_sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,\n\t\t\t\t\t_eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfor (const seq of isolatingRunSeqs) {\n\t\t\tconst {\n\t\t\t\t_seqIndices: seqIndices,\n\t\t\t\t_sosType: sosType,\n\t\t\t\t_eosType: eosType,\n\t\t\t} = seq;\n\t\t\tconst firstSeqIdx = seqIndices[0] ?? 0;\n\t\t\tconst embedDirection =\n\t\t\t\t(embedLevels[firstSeqIdx] ?? 0) & 1 ? TYPE_R : TYPE_L;\n\n\t\t\t// W1\n\t\t\tif (charTypeCounts.get(TYPE_NSM)) {\n\t\t\t\tfor (let si = 0; si < seqIndices.length; si++) {\n\t\t\t\t\tconst i = getSeqIndex(seqIndices, si);\n\t\t\t\t\tif (getCharType(charTypes, i) & TYPE_NSM) {\n\t\t\t\t\t\tlet prevType = sosType;\n\t\t\t\t\t\tfor (let sj = si - 1; sj >= 0; sj--) {\n\t\t\t\t\t\t\tconst sjIdx = getSeqIndex(seqIndices, sj);\n\t\t\t\t\t\t\tif (!(getCharType(charTypes, sjIdx) & BN_LIKE_TYPES)) {\n\t\t\t\t\t\t\t\tprevType = getCharType(charTypes, sjIdx);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchangeCharType(\n\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\tprevType & (ISOLATE_INIT_TYPES | TYPE_PDI) ? TYPE_ON : prevType,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// W2\n\t\t\tif (charTypeCounts.get(TYPE_EN)) {\n\t\t\t\tfor (let si = 0; si < seqIndices.length; si++) {\n\t\t\t\t\tconst i = getSeqIndex(seqIndices, si);\n\t\t\t\t\tif (getCharType(charTypes, i) & TYPE_EN) {\n\t\t\t\t\t\tfor (let sj = si - 1; sj >= -1; sj--) {\n\t\t\t\t\t\t\tconst prevCharType =\n\t\t\t\t\t\t\t\tsj === -1\n\t\t\t\t\t\t\t\t\t? sosType\n\t\t\t\t\t\t\t\t\t: getCharType(charTypes, getSeqIndex(seqIndices, sj));\n\t\t\t\t\t\t\tif (prevCharType & STRONG_TYPES) {\n\t\t\t\t\t\t\t\tif (prevCharType === TYPE_AL) {\n\t\t\t\t\t\t\t\t\tchangeCharType(i, TYPE_AN);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// W3\n\t\t\tif (charTypeCounts.get(TYPE_AL)) {\n\t\t\t\tfor (let si = 0; si < seqIndices.length; si++) {\n\t\t\t\t\tconst i = getSeqIndex(seqIndices, si);\n\t\t\t\t\tif (getCharType(charTypes, i) & TYPE_AL) {\n\t\t\t\t\t\tchangeCharType(i, TYPE_R);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// W4\n\t\t\tif (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n\t\t\t\tfor (let si = 1; si < seqIndices.length - 1; si++) {\n\t\t\t\t\tconst i = getSeqIndex(seqIndices, si);\n\t\t\t\t\tif (getCharType(charTypes, i) & (TYPE_ES | TYPE_CS)) {\n\t\t\t\t\t\tlet prevType = 0;\n\t\t\t\t\t\tlet nextType = 0;\n\t\t\t\t\t\tfor (let sj = si - 1; sj >= 0; sj--) {\n\t\t\t\t\t\t\tprevType = getCharType(charTypes, getSeqIndex(seqIndices, sj));\n\t\t\t\t\t\t\tif (!(prevType & BN_LIKE_TYPES)) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let sj = si + 1; sj < seqIndices.length; sj++) {\n\t\t\t\t\t\t\tnextType = getCharType(charTypes, getSeqIndex(seqIndices, sj));\n\t\t\t\t\t\t\tif (!(nextType & BN_LIKE_TYPES)) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tprevType === nextType &&\n\t\t\t\t\t\t\t(getCharType(charTypes, i) === TYPE_ES\n\t\t\t\t\t\t\t\t? prevType === TYPE_EN\n\t\t\t\t\t\t\t\t: prevType & (TYPE_EN | TYPE_AN))\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tchangeCharType(i, prevType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// W5\n\t\t\tif (charTypeCounts.get(TYPE_EN)) {\n\t\t\t\tfor (let si = 0; si < seqIndices.length; si++) {\n\t\t\t\t\tconst i = getSeqIndex(seqIndices, si);\n\t\t\t\t\tif (getCharType(charTypes, i) & TYPE_EN) {\n\t\t\t\t\t\tfor (let sj = si - 1; sj >= 0; sj--) {\n\t\t\t\t\t\t\tconst sjIdx = getSeqIndex(seqIndices, sj);\n\t\t\t\t\t\t\tif (!(getCharType(charTypes, sjIdx) & (TYPE_ET | BN_LIKE_TYPES)))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tchangeCharType(sjIdx, TYPE_EN);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (si++; si < seqIndices.length; si++) {\n\t\t\t\t\t\t\tconst siIdx = getSeqIndex(seqIndices, si);\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!(\n\t\t\t\t\t\t\t\t\tgetCharType(charTypes, siIdx) &\n\t\t\t\t\t\t\t\t\t(TYPE_ET | BN_LIKE_TYPES | TYPE_EN)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tif (getCharType(charTypes, siIdx) !== TYPE_EN) {\n\t\t\t\t\t\t\t\tchangeCharType(siIdx, TYPE_EN);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// W6\n\t\t\tif (\n\t\t\t\tcharTypeCounts.get(TYPE_ET) ||\n\t\t\t\tcharTypeCounts.get(TYPE_ES) ||\n\t\t\t\tcharTypeCounts.get(TYPE_CS)\n\t\t\t) {\n\t\t\t\tfor (let si = 0; si < seqIndices.length; si++) {\n\t\t\t\t\tconst i = getSeqIndex(seqIndices, si);\n\t\t\t\t\tif (getCharType(charTypes, i) & (TYPE_ET | TYPE_ES | TYPE_CS)) {\n\t\t\t\t\t\tchangeCharType(i, TYPE_ON);\n\t\t\t\t\t\tfor (let sj = si - 1; sj >= 0; sj--) {\n\t\t\t\t\t\t\tconst sjIdx = getSeqIndex(seqIndices, sj);\n\t\t\t\t\t\t\tif (!(getCharType(charTypes, sjIdx) & BN_LIKE_TYPES)) break;\n\t\t\t\t\t\t\tchangeCharType(sjIdx, TYPE_ON);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let sj = si + 1; sj < seqIndices.length; sj++) {\n\t\t\t\t\t\t\tconst sjIdx = getSeqIndex(seqIndices, sj);\n\t\t\t\t\t\t\tif (!(getCharType(charTypes, sjIdx) & BN_LIKE_TYPES)) break;\n\t\t\t\t\t\t\tchangeCharType(sjIdx, TYPE_ON);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// W7\n\t\t\tif (charTypeCounts.get(TYPE_EN)) {\n\t\t\t\tlet prevStrongType = sosType;\n\t\t\t\tfor (let si = 0; si < seqIndices.length; si++) {\n\t\t\t\t\tconst i = getSeqIndex(seqIndices, si);\n\t\t\t\t\tconst type = getCharType(charTypes, i);\n\t\t\t\t\tif (type & TYPE_EN) {\n\t\t\t\t\t\tif (prevStrongType === TYPE_L) {\n\t\t\t\t\t\t\tchangeCharType(i, TYPE_L);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (type & STRONG_TYPES) {\n\t\t\t\t\t\tprevStrongType = type;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// N0-N2\n\t\t\tif (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {\n\t\t\t\tconst R_TYPES_FOR_N_STEPS = TYPE_R | TYPE_EN | TYPE_AN;\n\t\t\t\tconst STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;\n\n\t\t\t\tconst bracketPairs: Array<[number, number]> = [];\n\t\t\t\tconst openerStack: Array<{ char: string; seqIndex: number }> = [];\n\n\t\t\t\tfor (let si = 0; si < seqIndices.length; si++) {\n\t\t\t\t\tconst siIdx = getSeqIndex(seqIndices, si);\n\t\t\t\t\tif (getCharType(charTypes, siIdx) & NEUTRAL_ISOLATE_TYPES) {\n\t\t\t\t\t\tconst char = getCharAt(string, siIdx);\n\t\t\t\t\t\tconst closingBracket = openingToClosingBracket(char);\n\t\t\t\t\t\tif (closingBracket !== null) {\n\t\t\t\t\t\t\tif (openerStack.length < 63) {\n\t\t\t\t\t\t\t\topenerStack.push({ char, seqIndex: si });\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst oppositeBracket = closingToOpeningBracket(char);\n\t\t\t\t\t\t\tif (oppositeBracket !== null) {\n\t\t\t\t\t\t\t\tfor (\n\t\t\t\t\t\t\t\t\tlet stackIdx = openerStack.length - 1;\n\t\t\t\t\t\t\t\t\tstackIdx >= 0;\n\t\t\t\t\t\t\t\t\tstackIdx--\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tconst opener = openerStack[stackIdx];\n\t\t\t\t\t\t\t\t\tif (!opener) continue;\n\t\t\t\t\t\t\t\t\tconst stackChar = opener.char;\n\t\t\t\t\t\t\t\t\tconst canonicalChar = getCanonicalBracket(char);\n\t\t\t\t\t\t\t\t\tconst canonicalStack = getCanonicalBracket(stackChar);\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tstackChar === oppositeBracket ||\n\t\t\t\t\t\t\t\t\t\t(canonicalChar &&\n\t\t\t\t\t\t\t\t\t\t\tstackChar === closingToOpeningBracket(canonicalChar)) ||\n\t\t\t\t\t\t\t\t\t\t(canonicalStack &&\n\t\t\t\t\t\t\t\t\t\t\topeningToClosingBracket(canonicalStack) === char)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tbracketPairs.push([opener.seqIndex, si]);\n\t\t\t\t\t\t\t\t\t\topenerStack.length = stackIdx;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbracketPairs.sort((a, b) => a[0] - b[0]);\n\n\t\t\t\tfor (const pair of bracketPairs) {\n\t\t\t\t\tconst [openSeqIdx, closeSeqIdx] = pair;\n\t\t\t\t\tlet foundStrongType = false;\n\t\t\t\t\tlet useStrongType = 0;\n\n\t\t\t\t\tfor (let si = openSeqIdx + 1; si < closeSeqIdx; si++) {\n\t\t\t\t\t\tconst i = getSeqIndex(seqIndices, si);\n\t\t\t\t\t\tconst ct = getCharType(charTypes, i);\n\t\t\t\t\t\tif (ct & STRONG_TYPES_FOR_N_STEPS) {\n\t\t\t\t\t\t\tfoundStrongType = true;\n\t\t\t\t\t\t\tconst lr = ct & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;\n\t\t\t\t\t\t\tif (lr === embedDirection) {\n\t\t\t\t\t\t\t\tuseStrongType = lr;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (foundStrongType && !useStrongType) {\n\t\t\t\t\t\tuseStrongType = sosType;\n\t\t\t\t\t\tfor (let si = openSeqIdx - 1; si >= 0; si--) {\n\t\t\t\t\t\t\tconst i = getSeqIndex(seqIndices, si);\n\t\t\t\t\t\t\tconst ct = getCharType(charTypes, i);\n\t\t\t\t\t\t\tif (ct & STRONG_TYPES_FOR_N_STEPS) {\n\t\t\t\t\t\t\t\tconst lr = ct & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;\n\t\t\t\t\t\t\t\tuseStrongType = lr !== embedDirection ? lr : embedDirection;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (useStrongType) {\n\t\t\t\t\t\tcharTypes[getSeqIndex(seqIndices, openSeqIdx)] = useStrongType;\n\t\t\t\t\t\tcharTypes[getSeqIndex(seqIndices, closeSeqIdx)] = useStrongType;\n\n\t\t\t\t\t\tif (useStrongType !== embedDirection) {\n\t\t\t\t\t\t\tfor (let si = openSeqIdx + 1; si < seqIndices.length; si++) {\n\t\t\t\t\t\t\t\tconst siIdx = getSeqIndex(seqIndices, si);\n\t\t\t\t\t\t\t\tif (!(getCharType(charTypes, siIdx) & BN_LIKE_TYPES)) {\n\t\t\t\t\t\t\t\t\tif (getBidiCharType(getCharAt(string, siIdx)) & TYPE_NSM) {\n\t\t\t\t\t\t\t\t\t\tcharTypes[siIdx] = useStrongType;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (let si = closeSeqIdx + 1; si < seqIndices.length; si++) {\n\t\t\t\t\t\t\t\tconst siIdx = getSeqIndex(seqIndices, si);\n\t\t\t\t\t\t\t\tif (!(getCharType(charTypes, siIdx) & BN_LIKE_TYPES)) {\n\t\t\t\t\t\t\t\t\tif (getBidiCharType(getCharAt(string, siIdx)) & TYPE_NSM) {\n\t\t\t\t\t\t\t\t\t\tcharTypes[siIdx] = useStrongType;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// N1/N2\n\t\t\t\tfor (let si = 0; si < seqIndices.length; si++) {\n\t\t\t\t\tconst siIdx = getSeqIndex(seqIndices, si);\n\t\t\t\t\tif (getCharType(charTypes, siIdx) & NEUTRAL_ISOLATE_TYPES) {\n\t\t\t\t\t\tlet niRunStart = si;\n\t\t\t\t\t\tlet niRunEnd = si;\n\t\t\t\t\t\tlet prevType = sosType;\n\n\t\t\t\t\t\tfor (let si2 = si - 1; si2 >= 0; si2--) {\n\t\t\t\t\t\t\tconst si2Idx = getSeqIndex(seqIndices, si2);\n\t\t\t\t\t\t\tif (getCharType(charTypes, si2Idx) & BN_LIKE_TYPES) {\n\t\t\t\t\t\t\t\tniRunStart = si2;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprevType =\n\t\t\t\t\t\t\t\t\tgetCharType(charTypes, si2Idx) & R_TYPES_FOR_N_STEPS\n\t\t\t\t\t\t\t\t\t\t? TYPE_R\n\t\t\t\t\t\t\t\t\t\t: TYPE_L;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet nextType = eosType;\n\t\t\t\t\t\tfor (let si2 = si + 1; si2 < seqIndices.length; si2++) {\n\t\t\t\t\t\t\tconst si2Idx = getSeqIndex(seqIndices, si2);\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tgetCharType(charTypes, si2Idx) &\n\t\t\t\t\t\t\t\t(NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tniRunEnd = si2;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnextType =\n\t\t\t\t\t\t\t\t\tgetCharType(charTypes, si2Idx) & R_TYPES_FOR_N_STEPS\n\t\t\t\t\t\t\t\t\t\t? TYPE_R\n\t\t\t\t\t\t\t\t\t\t: TYPE_L;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (let sj = niRunStart; sj <= niRunEnd; sj++) {\n\t\t\t\t\t\t\tcharTypes[getSeqIndex(seqIndices, sj)] =\n\t\t\t\t\t\t\t\tprevType === nextType ? prevType : embedDirection;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsi = niRunEnd;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Resolving Implicit Levels\n\t\tfor (let i = paragraph.start; i <= paragraph.end; i++) {\n\t\t\tconst level = embedLevels[i] ?? 0;\n\t\t\tconst type = getCharType(charTypes, i);\n\n\t\t\tif (level & 1) {\n\t\t\t\tif (type & (TYPE_L | TYPE_EN | TYPE_AN)) {\n\t\t\t\t\tembedLevels[i]++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (type & TYPE_R) {\n\t\t\t\t\tembedLevels[i]++;\n\t\t\t\t} else if (type & (TYPE_AN | TYPE_EN)) {\n\t\t\t\t\tembedLevels[i] += 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (type & BN_LIKE_TYPES) {\n\t\t\t\tembedLevels[i] =\n\t\t\t\t\ti === 0 ? paragraph.level : (embedLevels[i - 1] ?? paragraph.level);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ti === paragraph.end ||\n\t\t\t\tgetBidiCharType(getCharAt(string, i)) & (TYPE_S | TYPE_B)\n\t\t\t) {\n\t\t\t\tfor (\n\t\t\t\t\tlet j = i;\n\t\t\t\t\tj >= 0 && getBidiCharType(getCharAt(string, j)) & TRAILING_TYPES;\n\t\t\t\t\tj--\n\t\t\t\t) {\n\t\t\t\t\tembedLevels[j] = paragraph.level;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tlevels: embedLevels,\n\t\tparagraphs,\n\t};\n}\n", "// Bidi mirrored chars data, auto generated\nexport default \"14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1\";\n", "/**\n * Bidi character mirroring\n * Port of bidi-js mirroring.js\n */\n\nimport data from \"./mirroring.data.ts\";\nimport { parseCharacterMap } from \"./parse-character-map.ts\";\n\nlet mirrorMap: Map<string, string> | null = null;\n\nfunction parse(): void {\n\tif (!mirrorMap) {\n\t\tconst { map, reverseMap } = parseCharacterMap(data, true);\n\t\t// Combine both maps into one\n\t\tif (reverseMap) {\n\t\t\treverseMap.forEach((value, key) => {\n\t\t\t\tmap.set(key, value);\n\t\t\t});\n\t\t}\n\t\tmirrorMap = map;\n\t}\n}\n\nexport function getMirroredCharacter(char: string): string | null {\n\tparse();\n\treturn mirrorMap?.get(char) || null;\n}\n\n/**\n * Given a string and its resolved embedding levels, build a map of indices to replacement chars\n * for any characters in right-to-left segments that have defined mirrored characters.\n */\nexport function getMirroredCharactersMap(\n\tstring: string,\n\tembeddingLevels: Uint8Array,\n\tstart?: number,\n\tend?: number,\n): Map<number, string> {\n\tconst strLen = string.length;\n\tstart = Math.max(0, start == null ? 0 : +start);\n\tend = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n\n\tconst map = new Map<number, string>();\n\tfor (let i = start; i <= end; i++) {\n\t\tif (embeddingLevels[i]! & 1) {\n\t\t\t// only odd (rtl) levels\n\t\t\tconst mirror = getMirroredCharacter(string[i]!);\n\t\t\tif (mirror !== null) {\n\t\t\t\tmap.set(i, mirror);\n\t\t\t}\n\t\t}\n\t}\n\treturn map;\n}\n", "/**\n * Bidi reordering\n * Port of bidi-js reordering.js\n */\n\nimport { getBidiCharType, TRAILING_TYPES } from \"./char-types.ts\";\nimport type { EmbeddingLevelsResult } from \"./embedding-levels.ts\";\nimport { getMirroredCharacter } from \"./mirroring.ts\";\n\n/**\n * Given a start and end denoting a single line within a string, and a set of precalculated\n * bidi embedding levels, produce a list of segments whose ordering should be flipped, in sequence.\n */\nexport function getReorderSegments(\n\tstring: string,\n\tembeddingLevelsResult: EmbeddingLevelsResult,\n\tstart?: number,\n\tend?: number,\n): Array<[number, number]> {\n\tconst strLen = string.length;\n\tconst startPos = Math.max(0, start == null ? 0 : +start);\n\tconst endPos = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n\n\tconst segments: Array<[number, number]> = [];\n\tfor (const paragraph of embeddingLevelsResult.paragraphs) {\n\t\tconst lineStart = Math.max(startPos, paragraph.start);\n\t\tconst lineEnd = Math.min(endPos, paragraph.end);\n\t\tif (lineStart < lineEnd) {\n\t\t\t// Local slice for mutation\n\t\t\tconst lineLevels = embeddingLevelsResult.levels.slice(\n\t\t\t\tlineStart,\n\t\t\t\tlineEnd + 1,\n\t\t\t);\n\n\t\t\t// 3.4 L1.4: Reset any sequence of whitespace characters and/or isolate formatting characters at the\n\t\t\t// end of the line to the paragraph level.\n\t\t\tfor (let i = lineEnd; i >= lineStart; i--) {\n\t\t\t\tconst char = string[i];\n\t\t\t\tif (char === undefined) break;\n\t\t\t\tif (!(getBidiCharType(char) & TRAILING_TYPES)) break;\n\t\t\t\tlineLevels[i - lineStart] = paragraph.level;\n\t\t\t}\n\n\t\t\t// L2. From the highest level found in the text to the lowest odd level on each line, including intermediate levels\n\t\t\t// not actually present in the text, reverse any contiguous sequence of characters that are at that level or higher.\n\t\t\tlet maxLevel = paragraph.level;\n\t\t\tlet minOddLevel = Infinity;\n\t\t\tfor (let i = 0; i < lineLevels.length; i++) {\n\t\t\t\tconst level = lineLevels[i] ?? 0;\n\t\t\t\tif (level > maxLevel) maxLevel = level;\n\t\t\t\tif (level < minOddLevel) minOddLevel = level | 1;\n\t\t\t}\n\t\t\tfor (let lvl = maxLevel; lvl >= minOddLevel; lvl--) {\n\t\t\t\tfor (let i = 0; i < lineLevels.length; i++) {\n\t\t\t\t\tconst level = lineLevels[i] ?? 0;\n\t\t\t\t\tif (level >= lvl) {\n\t\t\t\t\t\tconst segStart = i;\n\t\t\t\t\t\twhile (i + 1 < lineLevels.length) {\n\t\t\t\t\t\t\tconst nextLevel = lineLevels[i + 1] ?? 0;\n\t\t\t\t\t\t\tif (nextLevel < lvl) break;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i > segStart) {\n\t\t\t\t\t\t\tsegments.push([segStart + lineStart, i + lineStart]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn segments;\n}\n\n/**\n * Get the reordered string with bidi segments reversed\n */\nexport function getReorderedString(\n\tstring: string,\n\tembedLevelsResult: EmbeddingLevelsResult,\n\tstart?: number,\n\tend?: number,\n): string {\n\tconst indices = getReorderedIndices(string, embedLevelsResult, start, end);\n\tconst chars = [...string];\n\tfor (let i = 0; i < indices.length; i++) {\n\t\tconst charIndex = indices[i] ?? 0;\n\t\tconst level = embedLevelsResult.levels[charIndex] ?? 0;\n\t\tconst originalChar = string[charIndex] ?? \"\";\n\t\tif (level & 1) {\n\t\t\tconst mirrored = getMirroredCharacter(originalChar);\n\t\t\tchars[i] = mirrored ?? originalChar;\n\t\t} else {\n\t\t\tchars[i] = originalChar;\n\t\t}\n\t}\n\treturn chars.join(\"\");\n}\n\n/**\n * Get an array with character indices in their new bidi order\n */\nexport function getReorderedIndices(\n\tstring: string,\n\tembedLevelsResult: EmbeddingLevelsResult,\n\tstart?: number,\n\tend?: number,\n): number[] {\n\tconst segments = getReorderSegments(string, embedLevelsResult, start, end);\n\t// Fill an array with indices\n\tconst indices: number[] = [];\n\tfor (let i = 0; i < string.length; i++) {\n\t\tindices[i] = i;\n\t}\n\t// Reverse each segment in order\n\tfor (const [segStart, segEnd] of segments) {\n\t\tconst slice = indices.slice(segStart, segEnd + 1);\n\t\tfor (let i = slice.length; i--; ) {\n\t\t\tconst val = slice[i];\n\t\t\tif (val !== undefined) {\n\t\t\t\tindices[segEnd - i] = val;\n\t\t\t}\n\t\t}\n\t}\n\treturn indices;\n}\n", "/**\n * Bidirectional text processing (UAX #9)\n */\n\nimport type { GlyphInfo } from \"../types.ts\";\nimport { Direction } from \"../types.ts\";\nimport {\n\tgetBidiCharType,\n\tgetEmbeddingLevels,\n\tgetMirroredCharacter,\n\tgetReorderedIndices,\n} from \"./bidi/index.ts\";\n\n/**\n * Result of BiDi processing\n */\nexport interface BidiResult {\n\t/** Embedding levels per character */\n\tlevels: Uint8Array;\n\t/** Paragraph information */\n\tparagraphs: BidiParagraph[];\n}\n\n/**\n * Paragraph info from BiDi algorithm\n */\nexport interface BidiParagraph {\n\tstart: number;\n\tend: number;\n\tlevel: number;\n}\n\n/**\n * Get embedding levels for a string\n */\nexport function getEmbeddings(\n\ttext: string,\n\tbaseDirection: Direction = Direction.LTR,\n): BidiResult {\n\tconst dir =\n\t\tbaseDirection === Direction.RTL\n\t\t\t? \"rtl\"\n\t\t\t: baseDirection === Direction.LTR\n\t\t\t\t? \"ltr\"\n\t\t\t\t: \"auto\";\n\n\tconst result = getEmbeddingLevels(text, dir);\n\n\treturn {\n\t\tlevels: result.levels,\n\t\tparagraphs: result.paragraphs,\n\t};\n}\n\n/**\n * Get reordered indices for visual display\n */\nexport function getVisualOrder(\n\ttext: string,\n\tresult: BidiResult,\n\tstart: number = 0,\n\tend: number = text.length,\n): number[] {\n\treturn Array.from(getReorderedIndices(text, result, start, end));\n}\n\n/**\n * Apply BiDi reordering to glyph infos\n */\nexport function reorderGlyphs(\n\tinfos: GlyphInfo[],\n\tresult: BidiResult,\n): GlyphInfo[] {\n\tif (infos.length === 0) return infos;\n\n\t// Get reordered indices\n\tconst dummyString = \"x\".repeat(infos.length);\n\tconst indices = getReorderedIndices(dummyString, result, 0, infos.length);\n\n\t// Reorder glyphs according to visual order\n\tconst reordered: GlyphInfo[] = [];\n\tfor (const idx of indices) {\n\t\tif (idx < infos.length) {\n\t\t\tconst info = infos[idx];\n\t\t\tif (info) {\n\t\t\t\treordered.push(info);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn reordered;\n}\n\n/**\n * Get mirrored character for RTL contexts\n */\nexport function getMirror(codepoint: number): number {\n\tconst char = String.fromCodePoint(codepoint);\n\tconst mirrored = getMirroredCharacter(char);\n\treturn mirrored ? (mirrored.codePointAt(0) ?? codepoint) : codepoint;\n}\n\n/**\n * Apply character mirroring for RTL runs\n */\nexport function applyMirroring(infos: GlyphInfo[], levels: Uint8Array): void {\n\tfor (const [i, info] of infos.entries()) {\n\t\tconst level = levels[i];\n\t\tif (level === undefined) continue;\n\n\t\t// Odd levels are RTL\n\t\tif (level & 1) {\n\t\t\tconst mirrored = getMirror(info.codepoint);\n\t\t\tif (mirrored !== info.codepoint) {\n\t\t\t\t// Store mirrored codepoint - glyph ID will be remapped later\n\t\t\t\tinfo.codepoint = mirrored;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * BiDi character type constants\n */\nexport const BidiType = {\n\tL: 0x0001, // Left-to-Right\n\tR: 0x0002, // Right-to-Left\n\tEN: 0x0004, // European Number\n\tES: 0x0008, // European Separator\n\tET: 0x0010, // European Terminator\n\tAN: 0x0020, // Arabic Number\n\tCS: 0x0040, // Common Separator\n\tB: 0x0080, // Paragraph Separator\n\tS: 0x0100, // Segment Separator\n\tWS: 0x0200, // Whitespace\n\tON: 0x0400, // Other Neutral\n\tBN: 0x0800, // Boundary Neutral\n\tNSM: 0x1000, // Non-Spacing Mark\n\tAL: 0x2000, // Arabic Letter\n\tLRO: 0x4000, // Left-to-Right Override\n\tRLO: 0x8000, // Right-to-Left Override\n\tLRE: 0x10000, // Left-to-Right Embedding\n\tRLE: 0x20000, // Right-to-Left Embedding\n\tPDF: 0x40000, // Pop Directional Format\n\tLRI: 0x80000, // Left-to-Right Isolate\n\tRLI: 0x100000, // Right-to-Left Isolate\n\tFSI: 0x200000, // First Strong Isolate\n\tPDI: 0x400000, // Pop Directional Isolate\n} as const;\n\n/**\n * Get BiDi character type for a character\n */\nexport function getCharType(char: string): number {\n\treturn getBidiCharType(char);\n}\n\n/**\n * Check if a character is strongly RTL\n */\nexport function isRTL(codepoint: number): boolean {\n\tconst char = String.fromCodePoint(codepoint);\n\tconst type = getBidiCharType(char);\n\treturn (type & (BidiType.R | BidiType.AL)) !== 0;\n}\n\n/**\n * Check if a character is strongly LTR\n */\nexport function isLTR(codepoint: number): boolean {\n\tconst char = String.fromCodePoint(codepoint);\n\tconst type = getBidiCharType(char);\n\treturn (type & BidiType.L) !== 0;\n}\n\n/**\n * Detect base direction from text content\n */\nexport function detectDirection(text: string): Direction {\n\tfor (const char of text) {\n\t\tconst type = getBidiCharType(char);\n\t\tif (type & BidiType.L) return Direction.LTR;\n\t\tif (type & (BidiType.R | BidiType.AL)) return Direction.RTL;\n\t}\n\treturn Direction.LTR; // Default\n}\n\n/**\n * Full BiDi processing for shaping\n */\nexport function processBidi(\n\tinfos: GlyphInfo[],\n\tbaseDirection: Direction = Direction.LTR,\n): { infos: GlyphInfo[]; levels: Uint8Array } {\n\tif (infos.length === 0) {\n\t\treturn { infos, levels: new Uint8Array(0) };\n\t}\n\n\t// Build string from codepoints\n\tconst text = infos.map((i) => String.fromCodePoint(i.codepoint)).join(\"\");\n\n\t// Get embedding levels\n\tconst result = getEmbeddings(text, baseDirection);\n\n\t// Apply character mirroring\n\tapplyMirroring(infos, result.levels);\n\n\t// Reorder glyphs for visual order\n\tconst reordered = reorderGlyphs(infos, result);\n\n\treturn { infos: reordered, levels: result.levels };\n}\n", "/**\n * Unicode Line Breaking Algorithm (UAX #14)\n * Determines line break opportunities in text\n */\n\nimport type { GlyphInfo } from \"../types.ts\";\n\n/**\n * Line break class from UAX #14\n */\nexport enum LineBreakClass {\n\t// Non-tailorable Line Breaking Classes\n\tBK = 0, // Mandatory Break\n\tCR = 1, // Carriage Return\n\tLF = 2, // Line Feed\n\tCM = 3, // Combining Mark\n\tNL = 4, // Next Line\n\tSG = 5, // Surrogate (not used)\n\tWJ = 6, // Word Joiner\n\tZW = 7, // Zero Width Space\n\tGL = 8, // Non-breaking (\"Glue\")\n\tSP = 9, // Space\n\tZWJ = 10, // Zero Width Joiner\n\n\t// Break Opportunities\n\tB2 = 11, // Break Opportunity Before and After\n\tBA = 12, // Break After\n\tBB = 13, // Break Before\n\tHY = 14, // Hyphen\n\tCB = 15, // Contingent Break Opportunity\n\n\t// Characters Prohibiting Certain Breaks\n\tCL = 16, // Close Punctuation\n\tCP = 17, // Close Parenthesis\n\tEX = 18, // Exclamation/Interrogation\n\tIN = 19, // Inseparable\n\tNS = 20, // Nonstarter\n\tOP = 21, // Open Punctuation\n\tQU = 22, // Quotation\n\n\t// Numeric Context\n\tIS = 23, // Infix Numeric Separator\n\tNU = 24, // Numeric\n\tPO = 25, // Postfix Numeric\n\tPR = 26, // Prefix Numeric\n\tSY = 27, // Symbols Allowing Break After\n\n\t// Other Characters\n\tAI = 28, // Ambiguous (Alphabetic or Ideographic)\n\tAL = 29, // Alphabetic\n\tCJ = 30, // Conditional Japanese Starter\n\tEB = 31, // Emoji Base\n\tEM = 32, // Emoji Modifier\n\tH2 = 33, // Hangul LV Syllable\n\tH3 = 34, // Hangul LVT Syllable\n\tHL = 35, // Hebrew Letter\n\tID = 36, // Ideographic\n\tJL = 37, // Hangul L Jamo\n\tJV = 38, // Hangul V Jamo\n\tJT = 39, // Hangul T Jamo\n\tRI = 40, // Regional Indicator\n\tSA = 41, // Complex Context Dependent (South East Asian)\n\tXX = 42, // Unknown\n}\n\n/**\n * Break action\n */\nexport enum BreakAction {\n\tDirect = 0, // Direct break opportunity (after space)\n\tIndirect = 1, // Indirect break (only if spaces intervene)\n\tCombiningIndirect = 2, // Indirect break for combining marks\n\tCombiningProhibited = 3, // Prohibited break for combining marks\n\tProhibited = 4, // No break allowed\n\tExplicit = 5, // Explicit break (BK, CR, LF, NL)\n}\n\n/**\n * Line break opportunity\n */\nexport enum BreakOpportunity {\n\tNoBreak = 0,\n\tOptional = 1,\n\tMandatory = 2,\n}\n\n/**\n * Get line break class for a codepoint\n */\nexport function getLineBreakClass(cp: number): LineBreakClass {\n\t// Mandatory breaks\n\tif (cp === 0x000a) return LineBreakClass.LF;\n\tif (cp === 0x000d) return LineBreakClass.CR;\n\tif (cp === 0x0085) return LineBreakClass.NL;\n\tif (cp === 0x000b || cp === 0x000c) return LineBreakClass.BK;\n\tif (cp === 0x2028) return LineBreakClass.BK; // Line Separator\n\tif (cp === 0x2029) return LineBreakClass.BK; // Paragraph Separator\n\n\t// Zero-width characters\n\tif (cp === 0x200b) return LineBreakClass.ZW; // Zero Width Space\n\tif (cp === 0x200d) return LineBreakClass.ZWJ; // Zero Width Joiner\n\tif (cp === 0x2060) return LineBreakClass.WJ; // Word Joiner\n\tif (cp === 0xfeff) return LineBreakClass.WJ; // BOM / ZWNBSP\n\n\t// Spaces\n\tif (cp === 0x0020) return LineBreakClass.SP;\n\tif (cp === 0x00a0) return LineBreakClass.GL; // No-Break Space\n\tif (cp === 0x202f) return LineBreakClass.GL; // Narrow No-Break Space\n\tif (cp === 0x2007) return LineBreakClass.GL; // Figure Space\n\tif (cp === 0x2011) return LineBreakClass.GL; // Non-Breaking Hyphen\n\n\t// Tabs and other whitespace\n\tif (cp === 0x0009) return LineBreakClass.BA; // Tab\n\tif (cp >= 0x2000 && cp <= 0x200a) return LineBreakClass.BA; // Various spaces\n\n\t// Combining marks\n\tif (cp >= 0x0300 && cp <= 0x036f) return LineBreakClass.CM; // Combining Diacritical Marks\n\tif (cp >= 0x0483 && cp <= 0x0489) return LineBreakClass.CM; // Cyrillic combining\n\tif (cp >= 0x0591 && cp <= 0x05bd) return LineBreakClass.CM; // Hebrew points\n\tif (cp >= 0x05bf && cp <= 0x05c7) return LineBreakClass.CM;\n\tif (cp >= 0x0610 && cp <= 0x061a) return LineBreakClass.CM; // Arabic marks\n\tif (cp >= 0x064b && cp <= 0x065f) return LineBreakClass.CM;\n\tif (cp >= 0x0670 && cp <= 0x0670) return LineBreakClass.CM;\n\tif (cp >= 0x06d6 && cp <= 0x06ed) return LineBreakClass.CM;\n\tif (cp >= 0x0711 && cp <= 0x0711) return LineBreakClass.CM; // Syriac\n\tif (cp >= 0x0730 && cp <= 0x074a) return LineBreakClass.CM;\n\tif (cp >= 0x07a6 && cp <= 0x07b0) return LineBreakClass.CM; // Thaana\n\tif (cp >= 0x0816 && cp <= 0x0823) return LineBreakClass.CM; // Samaritan\n\tif (cp >= 0x0825 && cp <= 0x082d) return LineBreakClass.CM;\n\tif (cp >= 0x0859 && cp <= 0x085b) return LineBreakClass.CM; // Mandaic\n\tif (cp >= 0x08d3 && cp <= 0x08e1) return LineBreakClass.CM; // Arabic extended\n\tif (cp >= 0x08e3 && cp <= 0x0903) return LineBreakClass.CM;\n\tif (cp >= 0x093a && cp <= 0x093c) return LineBreakClass.CM; // Devanagari\n\tif (cp >= 0x093e && cp <= 0x094f) return LineBreakClass.CM;\n\tif (cp >= 0x0951 && cp <= 0x0957) return LineBreakClass.CM;\n\tif (cp >= 0x0962 && cp <= 0x0963) return LineBreakClass.CM;\n\tif (cp >= 0x0981 && cp <= 0x0983) return LineBreakClass.CM; // Bengali\n\tif (cp === 0x09bc) return LineBreakClass.CM;\n\tif (cp >= 0x09be && cp <= 0x09cd) return LineBreakClass.CM;\n\tif (cp >= 0x09d7 && cp <= 0x09d7) return LineBreakClass.CM;\n\tif (cp >= 0x09e2 && cp <= 0x09e3) return LineBreakClass.CM;\n\tif (cp >= 0x09fe && cp <= 0x09fe) return LineBreakClass.CM;\n\tif (cp >= 0x0a01 && cp <= 0x0a03) return LineBreakClass.CM; // Gurmukhi\n\tif (cp >= 0x0a3c && cp <= 0x0a51) return LineBreakClass.CM;\n\tif (cp >= 0x0a70 && cp <= 0x0a71) return LineBreakClass.CM;\n\tif (cp >= 0x0a75 && cp <= 0x0a75) return LineBreakClass.CM;\n\tif (cp >= 0x0a81 && cp <= 0x0a83) return LineBreakClass.CM; // Gujarati\n\tif (cp >= 0x0abc && cp <= 0x0acd) return LineBreakClass.CM;\n\tif (cp >= 0x0ae2 && cp <= 0x0ae3) return LineBreakClass.CM;\n\tif (cp >= 0x0afa && cp <= 0x0aff) return LineBreakClass.CM;\n\tif (cp >= 0x0b01 && cp <= 0x0b03) return LineBreakClass.CM; // Oriya\n\tif (cp >= 0x0b3c && cp <= 0x0b57) return LineBreakClass.CM;\n\tif (cp >= 0x0b62 && cp <= 0x0b63) return LineBreakClass.CM;\n\tif (cp >= 0x0b82 && cp <= 0x0b82) return LineBreakClass.CM; // Tamil\n\tif (cp >= 0x0bbe && cp <= 0x0bcd) return LineBreakClass.CM;\n\tif (cp >= 0x0bd7 && cp <= 0x0bd7) return LineBreakClass.CM;\n\tif (cp >= 0x0c00 && cp <= 0x0c04) return LineBreakClass.CM; // Telugu\n\tif (cp >= 0x0c3e && cp <= 0x0c56) return LineBreakClass.CM;\n\tif (cp >= 0x0c62 && cp <= 0x0c63) return LineBreakClass.CM;\n\tif (cp >= 0x0c81 && cp <= 0x0c83) return LineBreakClass.CM; // Kannada\n\tif (cp >= 0x0cbc && cp <= 0x0cd6) return LineBreakClass.CM;\n\tif (cp >= 0x0ce2 && cp <= 0x0ce3) return LineBreakClass.CM;\n\tif (cp >= 0x0d00 && cp <= 0x0d03) return LineBreakClass.CM; // Malayalam\n\tif (cp >= 0x0d3b && cp <= 0x0d4d) return LineBreakClass.CM;\n\tif (cp >= 0x0d57 && cp <= 0x0d57) return LineBreakClass.CM;\n\tif (cp >= 0x0d62 && cp <= 0x0d63) return LineBreakClass.CM;\n\tif (cp >= 0x0d81 && cp <= 0x0d83) return LineBreakClass.CM; // Sinhala\n\tif (cp >= 0x0dca && cp <= 0x0df3) return LineBreakClass.CM;\n\tif (cp >= 0x0f18 && cp <= 0x0f19) return LineBreakClass.CM; // Tibetan\n\tif (cp >= 0x0f35 && cp <= 0x0f39) return LineBreakClass.CM;\n\tif (cp >= 0x0f3e && cp <= 0x0f3f) return LineBreakClass.CM;\n\tif (cp >= 0x0f71 && cp <= 0x0f84) return LineBreakClass.CM;\n\tif (cp >= 0x0f86 && cp <= 0x0f87) return LineBreakClass.CM;\n\tif (cp >= 0x0f8d && cp <= 0x0fbc) return LineBreakClass.CM;\n\tif (cp === 0x0fc6) return LineBreakClass.CM;\n\tif (cp >= 0x1712 && cp <= 0x1714) return LineBreakClass.CM; // Tagalog\n\tif (cp >= 0x1732 && cp <= 0x1734) return LineBreakClass.CM; // Hanunoo\n\tif (cp >= 0x1752 && cp <= 0x1753) return LineBreakClass.CM; // Buhid\n\tif (cp >= 0x1772 && cp <= 0x1773) return LineBreakClass.CM; // Tagbanwa\n\tif (cp >= 0x17b4 && cp <= 0x17d3) return LineBreakClass.CM; // Khmer\n\tif (cp === 0x17dd) return LineBreakClass.CM;\n\tif (cp >= 0x180b && cp <= 0x180d) return LineBreakClass.CM; // Mongolian\n\tif (cp === 0x180f) return LineBreakClass.CM;\n\tif (cp >= 0x1885 && cp <= 0x1886) return LineBreakClass.CM;\n\tif (cp === 0x18a9) return LineBreakClass.CM;\n\tif (cp >= 0x1920 && cp <= 0x193b) return LineBreakClass.CM; // Limbu, Buginese\n\tif (cp >= 0x1a17 && cp <= 0x1a1b) return LineBreakClass.CM;\n\tif (cp >= 0x1a55 && cp <= 0x1a7f) return LineBreakClass.CM; // Tai Tham\n\tif (cp >= 0x1ab0 && cp <= 0x1ace) return LineBreakClass.CM; // Combining Diacritical Marks Extended\n\tif (cp >= 0x1b00 && cp <= 0x1b04) return LineBreakClass.CM; // Balinese\n\tif (cp >= 0x1b34 && cp <= 0x1b44) return LineBreakClass.CM;\n\tif (cp >= 0x1b6b && cp <= 0x1b73) return LineBreakClass.CM;\n\tif (cp >= 0x1b80 && cp <= 0x1b82) return LineBreakClass.CM; // Sundanese\n\tif (cp >= 0x1ba1 && cp <= 0x1bad) return LineBreakClass.CM;\n\tif (cp >= 0x1be6 && cp <= 0x1bf3) return LineBreakClass.CM; // Batak\n\tif (cp >= 0x1c24 && cp <= 0x1c37) return LineBreakClass.CM; // Lepcha\n\tif (cp >= 0x1cd0 && cp <= 0x1cf9) return LineBreakClass.CM; // Vedic Extensions\n\tif (cp >= 0x1dc0 && cp <= 0x1dff) return LineBreakClass.CM; // Combining Diacritical Marks Supplement\n\tif (cp >= 0x20d0 && cp <= 0x20f0) return LineBreakClass.CM; // Combining Diacritical Marks for Symbols\n\tif (cp >= 0x2cef && cp <= 0x2cf1) return LineBreakClass.CM; // Coptic\n\tif (cp === 0x2d7f) return LineBreakClass.CM; // Tifinagh\n\tif (cp >= 0x2de0 && cp <= 0x2dff) return LineBreakClass.CM; // Cyrillic Extended-A\n\tif (cp >= 0x302a && cp <= 0x302f) return LineBreakClass.CM; // Ideographic Description\n\tif (cp >= 0x3099 && cp <= 0x309a) return LineBreakClass.CM; // Hiragana/Katakana voicing\n\tif (cp >= 0xa66f && cp <= 0xa672) return LineBreakClass.CM; // Combining Cyrillic\n\tif (cp >= 0xa674 && cp <= 0xa67d) return LineBreakClass.CM;\n\tif (cp >= 0xa69e && cp <= 0xa69f) return LineBreakClass.CM;\n\tif (cp >= 0xa6f0 && cp <= 0xa6f1) return LineBreakClass.CM; // Bamum\n\tif (cp >= 0xa802 && cp <= 0xa827) return LineBreakClass.CM; // Syloti Nagri\n\tif (cp >= 0xa82c && cp <= 0xa82c) return LineBreakClass.CM;\n\tif (cp >= 0xa880 && cp <= 0xa881) return LineBreakClass.CM; // Saurashtra\n\tif (cp >= 0xa8b4 && cp <= 0xa8c5) return LineBreakClass.CM;\n\tif (cp >= 0xa8e0 && cp <= 0xa8f1) return LineBreakClass.CM; // Devanagari Extended\n\tif (cp === 0xa8ff) return LineBreakClass.CM;\n\tif (cp >= 0xa926 && cp <= 0xa92d) return LineBreakClass.CM; // Kayah Li\n\tif (cp >= 0xa947 && cp <= 0xa953) return LineBreakClass.CM; // Rejang\n\tif (cp >= 0xa980 && cp <= 0xa983) return LineBreakClass.CM; // Javanese\n\tif (cp >= 0xa9b3 && cp <= 0xa9cd) return LineBreakClass.CM;\n\tif (cp === 0xa9e5) return LineBreakClass.CM; // Myanmar Extended-B\n\tif (cp >= 0xaa29 && cp <= 0xaa36) return LineBreakClass.CM; // Cham\n\tif (cp >= 0xaa43 && cp <= 0xaa43) return LineBreakClass.CM;\n\tif (cp >= 0xaa4c && cp <= 0xaa4d) return LineBreakClass.CM;\n\tif (cp >= 0xaa7b && cp <= 0xaa7d) return LineBreakClass.CM; // Myanmar Extended-A\n\tif (cp >= 0xaab0 && cp <= 0xaac2) return LineBreakClass.CM; // Tai Viet\n\tif (cp >= 0xaaeb && cp <= 0xaaef) return LineBreakClass.CM; // Meetei Mayek Extensions\n\tif (cp >= 0xaaf5 && cp <= 0xaaf6) return LineBreakClass.CM;\n\tif (cp >= 0xabe3 && cp <= 0xabea) return LineBreakClass.CM; // Meetei Mayek\n\tif (cp >= 0xabec && cp <= 0xabed) return LineBreakClass.CM;\n\tif (cp === 0xfb1e) return LineBreakClass.CM; // Hebrew\n\tif (cp >= 0xfe00 && cp <= 0xfe0f) return LineBreakClass.CM; // Variation Selectors\n\tif (cp >= 0xfe20 && cp <= 0xfe2f) return LineBreakClass.CM; // Combining Half Marks\n\tif (cp >= 0x101fd && cp <= 0x101fd) return LineBreakClass.CM; // Phaistos\n\tif (cp >= 0x102e0 && cp <= 0x102e0) return LineBreakClass.CM; // Coptic Epact\n\tif (cp >= 0x10376 && cp <= 0x1037a) return LineBreakClass.CM; // Old Permic\n\tif (cp >= 0x10a01 && cp <= 0x10a0f) return LineBreakClass.CM; // Kharoshthi\n\tif (cp >= 0x10a38 && cp <= 0x10a3f) return LineBreakClass.CM;\n\tif (cp >= 0x10ae5 && cp <= 0x10ae6) return LineBreakClass.CM; // Manichaean\n\tif (cp >= 0x10d24 && cp <= 0x10d27) return LineBreakClass.CM; // Hanifi Rohingya\n\tif (cp >= 0x10eab && cp <= 0x10eac) return LineBreakClass.CM; // Yezidi\n\tif (cp >= 0x10f46 && cp <= 0x10f50) return LineBreakClass.CM; // Sogdian\n\tif (cp >= 0x10f82 && cp <= 0x10f85) return LineBreakClass.CM; // Old Uyghur\n\tif (cp >= 0x11000 && cp <= 0x11002) return LineBreakClass.CM; // Brahmi\n\tif (cp >= 0x11038 && cp <= 0x11046) return LineBreakClass.CM;\n\tif (cp >= 0x11070 && cp <= 0x11070) return LineBreakClass.CM;\n\tif (cp >= 0x11073 && cp <= 0x11074) return LineBreakClass.CM;\n\tif (cp >= 0x1107f && cp <= 0x11082) return LineBreakClass.CM;\n\tif (cp >= 0x110b0 && cp <= 0x110c2) return LineBreakClass.CM; // Kaithi\n\tif (cp >= 0x11100 && cp <= 0x11102) return LineBreakClass.CM; // Chakma\n\tif (cp >= 0x11127 && cp <= 0x11134) return LineBreakClass.CM;\n\tif (cp === 0x11145) return LineBreakClass.CM;\n\tif (cp === 0x11146) return LineBreakClass.CM;\n\tif (cp >= 0x11173 && cp <= 0x11173) return LineBreakClass.CM; // Mahajani\n\tif (cp >= 0x11180 && cp <= 0x11182) return LineBreakClass.CM; // Sharada\n\tif (cp >= 0x111b3 && cp <= 0x111c0) return LineBreakClass.CM;\n\tif (cp >= 0x111c9 && cp <= 0x111cc) return LineBreakClass.CM;\n\tif (cp === 0x111ce) return LineBreakClass.CM;\n\tif (cp === 0x111cf) return LineBreakClass.CM;\n\tif (cp >= 0x1122c && cp <= 0x11237) return LineBreakClass.CM; // Khojki\n\tif (cp === 0x1123e) return LineBreakClass.CM;\n\tif (cp >= 0x112df && cp <= 0x112ea) return LineBreakClass.CM; // Khudawadi\n\tif (cp >= 0x11300 && cp <= 0x11303) return LineBreakClass.CM; // Grantha\n\tif (cp >= 0x1133b && cp <= 0x1133c) return LineBreakClass.CM;\n\tif (cp >= 0x1133e && cp <= 0x1134d) return LineBreakClass.CM;\n\tif (cp >= 0x11357 && cp <= 0x11357) return LineBreakClass.CM;\n\tif (cp >= 0x11362 && cp <= 0x11374) return LineBreakClass.CM;\n\tif (cp >= 0x11435 && cp <= 0x11446) return LineBreakClass.CM; // Newa\n\tif (cp === 0x1145e) return LineBreakClass.CM;\n\tif (cp >= 0x114b0 && cp <= 0x114c3) return LineBreakClass.CM; // Tirhuta\n\tif (cp >= 0x115af && cp <= 0x115c0) return LineBreakClass.CM; // Siddham\n\tif (cp >= 0x115dc && cp <= 0x115dd) return LineBreakClass.CM;\n\tif (cp >= 0x11630 && cp <= 0x11640) return LineBreakClass.CM; // Modi\n\tif (cp >= 0x116ab && cp <= 0x116b7) return LineBreakClass.CM; // Takri\n\tif (cp >= 0x1171d && cp <= 0x1172b) return LineBreakClass.CM; // Ahom\n\tif (cp >= 0x1182c && cp <= 0x1183a) return LineBreakClass.CM; // Dogra\n\tif (cp >= 0x11930 && cp <= 0x11935) return LineBreakClass.CM; // Dives Akuru\n\tif (cp >= 0x11937 && cp <= 0x11938) return LineBreakClass.CM;\n\tif (cp >= 0x1193b && cp <= 0x1193e) return LineBreakClass.CM;\n\tif (cp === 0x11940) return LineBreakClass.CM;\n\tif (cp >= 0x11942 && cp <= 0x11943) return LineBreakClass.CM;\n\tif (cp >= 0x119d1 && cp <= 0x119d7) return LineBreakClass.CM; // Nandinagari\n\tif (cp >= 0x119da && cp <= 0x119e0) return LineBreakClass.CM;\n\tif (cp === 0x119e4) return LineBreakClass.CM;\n\tif (cp >= 0x11a01 && cp <= 0x11a0a) return LineBreakClass.CM; // Zanabazar Square\n\tif (cp >= 0x11a33 && cp <= 0x11a39) return LineBreakClass.CM;\n\tif (cp >= 0x11a3b && cp <= 0x11a3e) return LineBreakClass.CM;\n\tif (cp === 0x11a47) return LineBreakClass.CM;\n\tif (cp >= 0x11a51 && cp <= 0x11a5b) return LineBreakClass.CM; // Soyombo\n\tif (cp >= 0x11a8a && cp <= 0x11a99) return LineBreakClass.CM;\n\tif (cp >= 0x11c2f && cp <= 0x11c36) return LineBreakClass.CM; // Bhaiksuki\n\tif (cp >= 0x11c38 && cp <= 0x11c3f) return LineBreakClass.CM;\n\tif (cp >= 0x11c92 && cp <= 0x11ca7) return LineBreakClass.CM; // Marchen\n\tif (cp >= 0x11ca9 && cp <= 0x11cb6) return LineBreakClass.CM;\n\tif (cp >= 0x11d31 && cp <= 0x11d45) return LineBreakClass.CM; // Masaram Gondi\n\tif (cp === 0x11d47) return LineBreakClass.CM;\n\tif (cp >= 0x11d8a && cp <= 0x11d97) return LineBreakClass.CM; // Gunjala Gondi\n\tif (cp >= 0x11ef3 && cp <= 0x11ef6) return LineBreakClass.CM; // Makasar\n\tif (cp >= 0x16af0 && cp <= 0x16af4) return LineBreakClass.CM; // Bassa Vah\n\tif (cp >= 0x16b30 && cp <= 0x16b36) return LineBreakClass.CM; // Pahawh Hmong\n\tif (cp === 0x16f4f) return LineBreakClass.CM; // Miao\n\tif (cp >= 0x16f51 && cp <= 0x16f87) return LineBreakClass.CM;\n\tif (cp >= 0x16f8f && cp <= 0x16f92) return LineBreakClass.CM;\n\tif (cp >= 0x16fe4 && cp <= 0x16fe4) return LineBreakClass.CM; // Khitan Small Script\n\tif (cp >= 0x16ff0 && cp <= 0x16ff1) return LineBreakClass.CM;\n\tif (cp >= 0x1bc9d && cp <= 0x1bc9e) return LineBreakClass.CM; // Duployan\n\tif (cp >= 0x1cf00 && cp <= 0x1cf46) return LineBreakClass.CM; // Znamenny Musical Notation\n\tif (cp >= 0x1d165 && cp <= 0x1d169) return LineBreakClass.CM; // Musical Symbols\n\tif (cp >= 0x1d16d && cp <= 0x1d172) return LineBreakClass.CM;\n\tif (cp >= 0x1d17b && cp <= 0x1d182) return LineBreakClass.CM;\n\tif (cp >= 0x1d185 && cp <= 0x1d18b) return LineBreakClass.CM;\n\tif (cp >= 0x1d1aa && cp <= 0x1d1ad) return LineBreakClass.CM;\n\tif (cp >= 0x1d242 && cp <= 0x1d244) return LineBreakClass.CM;\n\tif (cp >= 0x1da00 && cp <= 0x1da36) return LineBreakClass.CM; // Sutton SignWriting\n\tif (cp >= 0x1da3b && cp <= 0x1da6c) return LineBreakClass.CM;\n\tif (cp === 0x1da75) return LineBreakClass.CM;\n\tif (cp === 0x1da84) return LineBreakClass.CM;\n\tif (cp >= 0x1da9b && cp <= 0x1daaf) return LineBreakClass.CM;\n\tif (cp >= 0x1e000 && cp <= 0x1e02a) return LineBreakClass.CM; // Glagolitic Supplement\n\tif (cp >= 0x1e130 && cp <= 0x1e136) return LineBreakClass.CM; // Nyiakeng Puachue Hmong\n\tif (cp >= 0x1e2ae && cp <= 0x1e2ae) return LineBreakClass.CM; // Toto\n\tif (cp >= 0x1e2ec && cp <= 0x1e2ef) return LineBreakClass.CM; // Wancho\n\tif (cp >= 0x1e8d0 && cp <= 0x1e8d6) return LineBreakClass.CM; // Mende Kikakui\n\tif (cp >= 0x1e944 && cp <= 0x1e94a) return LineBreakClass.CM; // Adlam\n\tif (cp >= 0xe0100 && cp <= 0xe01ef) return LineBreakClass.CM; // Variation Selectors Supplement\n\n\t// Punctuation\n\tif (cp === 0x0021) return LineBreakClass.EX; // !\n\tif (cp === 0x003f) return LineBreakClass.EX; // ?\n\tif (cp === 0x0022) return LineBreakClass.QU; // \"\n\tif (cp === 0x0027) return LineBreakClass.QU; // '\n\tif (cp === 0x0028) return LineBreakClass.OP; // (\n\tif (cp === 0x0029) return LineBreakClass.CP; // )\n\tif (cp === 0x005b) return LineBreakClass.OP; // [\n\tif (cp === 0x005d) return LineBreakClass.CP; // ]\n\tif (cp === 0x007b) return LineBreakClass.OP; // {\n\tif (cp === 0x007d) return LineBreakClass.CL; // }\n\tif (cp === 0x002c) return LineBreakClass.IS; // ,\n\tif (cp === 0x002e) return LineBreakClass.IS; // .\n\tif (cp === 0x003a) return LineBreakClass.IS; // :\n\tif (cp === 0x003b) return LineBreakClass.IS; // ;\n\tif (cp === 0x002d) return LineBreakClass.HY; // -\n\tif (cp === 0x2010) return LineBreakClass.BA; // Hyphen\n\tif (cp === 0x2013) return LineBreakClass.BA; // En Dash\n\tif (cp === 0x2014) return LineBreakClass.B2; // Em Dash\n\tif (cp === 0x2018 || cp === 0x2019) return LineBreakClass.QU; // Single quotes\n\tif (cp === 0x201c || cp === 0x201d) return LineBreakClass.QU; // Double quotes\n\tif (cp === 0x2026) return LineBreakClass.IN; // Ellipsis\n\n\t// CJK punctuation\n\tif (cp === 0x3001 || cp === 0x3002) return LineBreakClass.CL; // Ideographic comma, period\n\tif (cp === 0x3008) return LineBreakClass.OP;\n\tif (cp === 0x3009) return LineBreakClass.CL;\n\tif (cp === 0x300a) return LineBreakClass.OP;\n\tif (cp === 0x300b) return LineBreakClass.CL;\n\tif (cp === 0x300c) return LineBreakClass.OP;\n\tif (cp === 0x300d) return LineBreakClass.CL;\n\tif (cp === 0x300e) return LineBreakClass.OP;\n\tif (cp === 0x300f) return LineBreakClass.CL;\n\tif (cp === 0x3010) return LineBreakClass.OP;\n\tif (cp === 0x3011) return LineBreakClass.CL;\n\tif (cp === 0x3014) return LineBreakClass.OP;\n\tif (cp === 0x3015) return LineBreakClass.CL;\n\tif (cp === 0x3016) return LineBreakClass.OP;\n\tif (cp === 0x3017) return LineBreakClass.CL;\n\tif (cp >= 0x3018 && cp <= 0x301b)\n\t\treturn cp % 2 === 0 ? LineBreakClass.OP : LineBreakClass.CL;\n\tif (cp === 0xff08) return LineBreakClass.OP; // Fullwidth (\n\tif (cp === 0xff09) return LineBreakClass.CL; // Fullwidth )\n\tif (cp === 0xff0c) return LineBreakClass.CL; // Fullwidth ,\n\tif (cp === 0xff0e) return LineBreakClass.CL; // Fullwidth .\n\tif (cp === 0xff1a) return LineBreakClass.NS; // Fullwidth :\n\tif (cp === 0xff1b) return LineBreakClass.NS; // Fullwidth ;\n\tif (cp === 0xff1f) return LineBreakClass.EX; // Fullwidth ?\n\tif (cp === 0xff01) return LineBreakClass.EX; // Fullwidth !\n\n\t// Small Kana\n\tif (cp >= 0x3041 && cp <= 0x3096) {\n\t\t// Check for small kana\n\t\tif (\n\t\t\tcp === 0x3041 ||\n\t\t\tcp === 0x3043 ||\n\t\t\tcp === 0x3045 ||\n\t\t\tcp === 0x3047 ||\n\t\t\tcp === 0x3049 ||\n\t\t\tcp === 0x3063 ||\n\t\t\tcp === 0x3083 ||\n\t\t\tcp === 0x3085 ||\n\t\t\tcp === 0x3087 ||\n\t\t\tcp === 0x308e ||\n\t\t\tcp === 0x3095 ||\n\t\t\tcp === 0x3096\n\t\t)\n\t\t\treturn LineBreakClass.CJ;\n\t\treturn LineBreakClass.ID;\n\t}\n\tif (cp >= 0x30a1 && cp <= 0x30fa) {\n\t\t// Check for small katakana\n\t\tif (\n\t\t\tcp === 0x30a1 ||\n\t\t\tcp === 0x30a3 ||\n\t\t\tcp === 0x30a5 ||\n\t\t\tcp === 0x30a7 ||\n\t\t\tcp === 0x30a9 ||\n\t\t\tcp === 0x30c3 ||\n\t\t\tcp === 0x30e3 ||\n\t\t\tcp === 0x30e5 ||\n\t\t\tcp === 0x30e7 ||\n\t\t\tcp === 0x30ee ||\n\t\t\tcp === 0x30f5 ||\n\t\t\tcp === 0x30f6\n\t\t)\n\t\t\treturn LineBreakClass.CJ;\n\t\treturn LineBreakClass.ID;\n\t}\n\n\t// Hiragana/Katakana prolonged sound mark\n\tif (cp === 0x30fc) return LineBreakClass.CJ;\n\n\t// Hangul\n\tif (cp >= 0x1100 && cp <= 0x115f) return LineBreakClass.JL;\n\tif (cp >= 0xa960 && cp <= 0xa97c) return LineBreakClass.JL;\n\tif (cp >= 0x1160 && cp <= 0x11a7) return LineBreakClass.JV;\n\tif (cp >= 0xd7b0 && cp <= 0xd7c6) return LineBreakClass.JV;\n\tif (cp >= 0x11a8 && cp <= 0x11ff) return LineBreakClass.JT;\n\tif (cp >= 0xd7cb && cp <= 0xd7fb) return LineBreakClass.JT;\n\t// Hangul syllables\n\tif (cp >= 0xac00 && cp <= 0xd7a3) {\n\t\tconst sIndex = cp - 0xac00;\n\t\tif (sIndex % 28 === 0) return LineBreakClass.H2;\n\t\treturn LineBreakClass.H3;\n\t}\n\n\t// Numbers\n\tif (cp >= 0x0030 && cp <= 0x0039) return LineBreakClass.NU;\n\tif (cp >= 0x0660 && cp <= 0x0669) return LineBreakClass.NU; // Arabic-Indic\n\tif (cp >= 0x06f0 && cp <= 0x06f9) return LineBreakClass.NU; // Extended Arabic-Indic\n\tif (cp >= 0x0966 && cp <= 0x096f) return LineBreakClass.NU; // Devanagari\n\tif (cp >= 0xff10 && cp <= 0xff19) return LineBreakClass.NU; // Fullwidth\n\n\t// Currency symbols\n\tif (cp === 0x0024) return LineBreakClass.PR; // $\n\tif (cp === 0x00a3) return LineBreakClass.PR; // \n\tif (cp === 0x00a5) return LineBreakClass.PR; // \n\tif (cp === 0x20ac) return LineBreakClass.PR; // \n\tif (cp === 0x0025) return LineBreakClass.PO; // %\n\n\t// Hebrew\n\tif (cp >= 0x05d0 && cp <= 0x05ea) return LineBreakClass.HL;\n\tif (cp >= 0xfb1d && cp <= 0xfb4f) return LineBreakClass.HL;\n\n\t// CJK Ideographs\n\tif (cp >= 0x4e00 && cp <= 0x9fff) return LineBreakClass.ID;\n\tif (cp >= 0x3400 && cp <= 0x4dbf) return LineBreakClass.ID;\n\tif (cp >= 0x20000 && cp <= 0x2a6df) return LineBreakClass.ID;\n\tif (cp >= 0x2a700 && cp <= 0x2b73f) return LineBreakClass.ID;\n\tif (cp >= 0x2b740 && cp <= 0x2b81f) return LineBreakClass.ID;\n\tif (cp >= 0x2b820 && cp <= 0x2ceaf) return LineBreakClass.ID;\n\tif (cp >= 0x2ceb0 && cp <= 0x2ebef) return LineBreakClass.ID;\n\tif (cp >= 0x30000 && cp <= 0x3134f) return LineBreakClass.ID;\n\tif (cp >= 0xf900 && cp <= 0xfaff) return LineBreakClass.ID;\n\tif (cp >= 0x2f800 && cp <= 0x2fa1f) return LineBreakClass.ID;\n\n\t// Emoji\n\tif (cp >= 0x1f300 && cp <= 0x1f9ff) return LineBreakClass.ID;\n\tif (cp >= 0x1fa00 && cp <= 0x1faff) return LineBreakClass.ID;\n\tif (cp >= 0x2600 && cp <= 0x26ff) return LineBreakClass.ID;\n\tif (cp >= 0x2700 && cp <= 0x27bf) return LineBreakClass.ID;\n\n\t// Regional indicators\n\tif (cp >= 0x1f1e0 && cp <= 0x1f1ff) return LineBreakClass.RI;\n\n\t// Emoji modifiers\n\tif (cp >= 0x1f3fb && cp <= 0x1f3ff) return LineBreakClass.EM;\n\n\t// Thai\n\tif (cp >= 0x0e00 && cp <= 0x0e7f) return LineBreakClass.SA;\n\n\t// Lao\n\tif (cp >= 0x0e80 && cp <= 0x0eff) return LineBreakClass.SA;\n\n\t// Myanmar\n\tif (cp >= 0x1000 && cp <= 0x109f) return LineBreakClass.SA;\n\tif (cp >= 0xa9e0 && cp <= 0xa9ff) return LineBreakClass.SA;\n\tif (cp >= 0xaa60 && cp <= 0xaa7f) return LineBreakClass.SA;\n\n\t// Khmer\n\tif (cp >= 0x1780 && cp <= 0x17ff) return LineBreakClass.SA;\n\tif (cp >= 0x19e0 && cp <= 0x19ff) return LineBreakClass.SA;\n\n\t// Default: treat as alphabetic\n\tif (cp >= 0x0041 && cp <= 0x005a) return LineBreakClass.AL; // A-Z\n\tif (cp >= 0x0061 && cp <= 0x007a) return LineBreakClass.AL; // a-z\n\tif (cp >= 0x00c0 && cp <= 0x024f) return LineBreakClass.AL; // Latin Extended\n\n\t// Arabic\n\tif (cp >= 0x0600 && cp <= 0x06ff) return LineBreakClass.AL;\n\tif (cp >= 0x0750 && cp <= 0x077f) return LineBreakClass.AL;\n\tif (cp >= 0x08a0 && cp <= 0x08ff) return LineBreakClass.AL;\n\n\t// Devanagari and other Indic\n\tif (cp >= 0x0900 && cp <= 0x097f) return LineBreakClass.AL;\n\tif (cp >= 0x0980 && cp <= 0x09ff) return LineBreakClass.AL;\n\tif (cp >= 0x0a00 && cp <= 0x0a7f) return LineBreakClass.AL;\n\tif (cp >= 0x0a80 && cp <= 0x0aff) return LineBreakClass.AL;\n\tif (cp >= 0x0b00 && cp <= 0x0b7f) return LineBreakClass.AL;\n\tif (cp >= 0x0b80 && cp <= 0x0bff) return LineBreakClass.AL;\n\tif (cp >= 0x0c00 && cp <= 0x0c7f) return LineBreakClass.AL;\n\tif (cp >= 0x0c80 && cp <= 0x0cff) return LineBreakClass.AL;\n\tif (cp >= 0x0d00 && cp <= 0x0d7f) return LineBreakClass.AL;\n\n\t// Cyrillic\n\tif (cp >= 0x0400 && cp <= 0x04ff) return LineBreakClass.AL;\n\tif (cp >= 0x0500 && cp <= 0x052f) return LineBreakClass.AL;\n\n\t// Greek\n\tif (cp >= 0x0370 && cp <= 0x03ff) return LineBreakClass.AL;\n\n\treturn LineBreakClass.XX;\n}\n\n/**\n * Pair table for line break classes\n * Returns whether a break is allowed between two classes\n */\nfunction getPairAction(\n\tbefore: LineBreakClass,\n\tafter: LineBreakClass,\n): BreakAction {\n\t// LB1: Resolve AI, CB, CJ, SA, SG, XX -> AL (simplified)\n\tif (before === LineBreakClass.AI) before = LineBreakClass.AL;\n\tif (before === LineBreakClass.SA) before = LineBreakClass.AL;\n\tif (before === LineBreakClass.SG) before = LineBreakClass.AL;\n\tif (before === LineBreakClass.XX) before = LineBreakClass.AL;\n\tif (before === LineBreakClass.CJ) before = LineBreakClass.NS;\n\n\tif (after === LineBreakClass.AI) after = LineBreakClass.AL;\n\tif (after === LineBreakClass.SA) after = LineBreakClass.AL;\n\tif (after === LineBreakClass.SG) after = LineBreakClass.AL;\n\tif (after === LineBreakClass.XX) after = LineBreakClass.AL;\n\tif (after === LineBreakClass.CJ) after = LineBreakClass.NS;\n\n\t// LB4: Always break after hard line breaks\n\tif (before === LineBreakClass.BK) return BreakAction.Explicit;\n\n\t// LB5: Treat CR followed by LF, as well as CR, LF, and NL as hard line breaks\n\tif (before === LineBreakClass.CR && after === LineBreakClass.LF)\n\t\treturn BreakAction.Prohibited;\n\tif (\n\t\tbefore === LineBreakClass.CR ||\n\t\tbefore === LineBreakClass.LF ||\n\t\tbefore === LineBreakClass.NL\n\t)\n\t\treturn BreakAction.Explicit;\n\n\t// LB6: Do not break before hard line breaks\n\tif (\n\t\tafter === LineBreakClass.BK ||\n\t\tafter === LineBreakClass.CR ||\n\t\tafter === LineBreakClass.LF ||\n\t\tafter === LineBreakClass.NL\n\t)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB7: Do not break before spaces or zero width space\n\tif (after === LineBreakClass.SP || after === LineBreakClass.ZW)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB8: Break before any character following a zero-width space\n\tif (before === LineBreakClass.ZW) return BreakAction.Direct;\n\n\t// LB8a: Do not break after a zero width joiner\n\tif (before === LineBreakClass.ZWJ) return BreakAction.Prohibited;\n\n\t// LB9: Do not break a combining character sequence\n\t// Note: BK, CR, LF, NL, ZW are already handled by early returns above\n\tif (after === LineBreakClass.CM || after === LineBreakClass.ZWJ) {\n\t\tif (before !== LineBreakClass.SP) return BreakAction.Prohibited;\n\t}\n\n\t// LB10: Treat any remaining combining mark or ZWJ as AL\n\t// Use type assertion since we know these could be CM/ZWJ from above\n\tlet beforeResolved: LineBreakClass = before;\n\tlet afterResolved: LineBreakClass = after;\n\tif (before === LineBreakClass.CM || (before as number) === LineBreakClass.ZWJ)\n\t\tbeforeResolved = LineBreakClass.AL;\n\tif (after === LineBreakClass.CM || after === LineBreakClass.ZWJ)\n\t\tafterResolved = LineBreakClass.AL;\n\tbefore = beforeResolved;\n\tafter = afterResolved;\n\n\t// LB11: Do not break before or after Word Joiner\n\tif (before === LineBreakClass.WJ || after === LineBreakClass.WJ)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB12: Do not break after NBSP and related characters\n\tif (before === LineBreakClass.GL) return BreakAction.Prohibited;\n\n\t// LB12a: Do not break before NBSP and related characters, except after spaces and hyphens\n\tif (after === LineBreakClass.GL) {\n\t\tif (\n\t\t\tbefore !== LineBreakClass.SP &&\n\t\t\tbefore !== LineBreakClass.BA &&\n\t\t\tbefore !== LineBreakClass.HY\n\t\t)\n\t\t\treturn BreakAction.Prohibited;\n\t}\n\n\t// LB13: Do not break before ']' or '!' or ';' or '/', even after spaces\n\tif (\n\t\tafter === LineBreakClass.CL ||\n\t\tafter === LineBreakClass.CP ||\n\t\tafter === LineBreakClass.EX ||\n\t\tafter === LineBreakClass.IS ||\n\t\tafter === LineBreakClass.SY\n\t)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB14: Do not break after '[', even after spaces\n\tif (before === LineBreakClass.OP) return BreakAction.Prohibited;\n\n\t// LB15: Do not break within '\"[', even with intervening spaces\n\tif (before === LineBreakClass.QU && after === LineBreakClass.OP)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB16: Do not break between closing punctuation and nonstarter\n\tif (\n\t\t(before === LineBreakClass.CL || before === LineBreakClass.CP) &&\n\t\tafter === LineBreakClass.NS\n\t)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB17: Do not break within '', even with intervening spaces\n\tif (before === LineBreakClass.B2 && after === LineBreakClass.B2)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB18: Break after spaces\n\tif (before === LineBreakClass.SP) return BreakAction.Direct;\n\n\t// LB19: Do not break before or after quotation marks\n\tif (before === LineBreakClass.QU || after === LineBreakClass.QU)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB20: Break before and after unresolved CB\n\tif (before === LineBreakClass.CB || after === LineBreakClass.CB)\n\t\treturn BreakAction.Direct;\n\n\t// LB21: Do not break before hyphen-minus, etc.\n\t// Note: LB21a (Hebrew + Hyphen) is subsumed by this rule\n\tif (\n\t\tafter === LineBreakClass.BA ||\n\t\tafter === LineBreakClass.HY ||\n\t\tafter === LineBreakClass.NS\n\t)\n\t\treturn BreakAction.Prohibited;\n\tif (before === LineBreakClass.BB) return BreakAction.Prohibited;\n\n\t// LB21b: Don't break between Solidus and Hebrew letters\n\tif (before === LineBreakClass.SY && after === LineBreakClass.HL)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB22: Do not break before ellipses\n\tif (after === LineBreakClass.IN) return BreakAction.Prohibited;\n\n\t// LB23: Do not break between digits and letters\n\tif (\n\t\t(before === LineBreakClass.AL || before === LineBreakClass.HL) &&\n\t\tafter === LineBreakClass.NU\n\t)\n\t\treturn BreakAction.Prohibited;\n\tif (\n\t\tbefore === LineBreakClass.NU &&\n\t\t(after === LineBreakClass.AL || after === LineBreakClass.HL)\n\t)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB23a: Do not break between numeric prefixes/postfixes and ideographs\n\tif (before === LineBreakClass.PR && after === LineBreakClass.ID)\n\t\treturn BreakAction.Prohibited;\n\tif (before === LineBreakClass.ID && after === LineBreakClass.PO)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB24: Do not break between numeric prefix/postfix and letters\n\tif (\n\t\t(before === LineBreakClass.PR || before === LineBreakClass.PO) &&\n\t\t(after === LineBreakClass.AL || after === LineBreakClass.HL)\n\t)\n\t\treturn BreakAction.Prohibited;\n\tif (\n\t\t(before === LineBreakClass.AL || before === LineBreakClass.HL) &&\n\t\t(after === LineBreakClass.PR || after === LineBreakClass.PO)\n\t)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB25: Do not break between numbers\n\tif (\n\t\t(before === LineBreakClass.CL || before === LineBreakClass.CP) &&\n\t\tafter === LineBreakClass.NU\n\t)\n\t\treturn BreakAction.Prohibited;\n\tif (\n\t\tbefore === LineBreakClass.NU &&\n\t\t(after === LineBreakClass.PO || after === LineBreakClass.PR)\n\t)\n\t\treturn BreakAction.Prohibited;\n\tif (\n\t\t(before === LineBreakClass.PO ||\n\t\t\tbefore === LineBreakClass.PR ||\n\t\t\tbefore === LineBreakClass.HY ||\n\t\t\tbefore === LineBreakClass.IS ||\n\t\t\tbefore === LineBreakClass.NU ||\n\t\t\tbefore === LineBreakClass.SY) &&\n\t\tafter === LineBreakClass.NU\n\t)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB26: Do not break a Korean syllable\n\tif (before === LineBreakClass.JL) {\n\t\tif (\n\t\t\tafter === LineBreakClass.JL ||\n\t\t\tafter === LineBreakClass.JV ||\n\t\t\tafter === LineBreakClass.H2 ||\n\t\t\tafter === LineBreakClass.H3\n\t\t)\n\t\t\treturn BreakAction.Prohibited;\n\t}\n\tif (before === LineBreakClass.JV || before === LineBreakClass.H2) {\n\t\tif (after === LineBreakClass.JV || after === LineBreakClass.JT)\n\t\t\treturn BreakAction.Prohibited;\n\t}\n\tif (before === LineBreakClass.JT || before === LineBreakClass.H3) {\n\t\tif (after === LineBreakClass.JT) return BreakAction.Prohibited;\n\t}\n\n\t// LB27: Treat Korean syllables as ID\n\tif (\n\t\tbefore === LineBreakClass.JL ||\n\t\tbefore === LineBreakClass.JV ||\n\t\tbefore === LineBreakClass.JT ||\n\t\tbefore === LineBreakClass.H2 ||\n\t\tbefore === LineBreakClass.H3\n\t) {\n\t\tif (after === LineBreakClass.PO) return BreakAction.Prohibited;\n\t}\n\tif (\n\t\tafter === LineBreakClass.JL ||\n\t\tafter === LineBreakClass.JV ||\n\t\tafter === LineBreakClass.JT ||\n\t\tafter === LineBreakClass.H2 ||\n\t\tafter === LineBreakClass.H3\n\t) {\n\t\tif (before === LineBreakClass.PR) return BreakAction.Prohibited;\n\t}\n\n\t// LB28: Do not break between alphabetics\n\tif (\n\t\t(before === LineBreakClass.AL || before === LineBreakClass.HL) &&\n\t\t(after === LineBreakClass.AL || after === LineBreakClass.HL)\n\t)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB29: Do not break between numeric punctuation and alphabetics\n\tif (\n\t\tbefore === LineBreakClass.IS &&\n\t\t(after === LineBreakClass.AL || after === LineBreakClass.HL)\n\t)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB30: Do not break between letters/numbers and opening/closing\n\tif (\n\t\t(before === LineBreakClass.AL ||\n\t\t\tbefore === LineBreakClass.HL ||\n\t\t\tbefore === LineBreakClass.NU) &&\n\t\tafter === LineBreakClass.OP\n\t)\n\t\treturn BreakAction.Prohibited;\n\tif (\n\t\tbefore === LineBreakClass.CP &&\n\t\t(after === LineBreakClass.AL ||\n\t\t\tafter === LineBreakClass.HL ||\n\t\t\tafter === LineBreakClass.NU)\n\t)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB30a: Break between pairs of regional indicator symbols\n\tif (before === LineBreakClass.RI && after === LineBreakClass.RI)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB30b: Do not break between an emoji base and an emoji modifier\n\tif (before === LineBreakClass.EB && after === LineBreakClass.EM)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB31: Break everywhere else\n\treturn BreakAction.Direct;\n}\n\n/**\n * Result of line break analysis\n */\nexport interface LineBreakAnalysis {\n\t/** Break opportunities (one per character boundary) */\n\tbreaks: BreakOpportunity[];\n\t/** Line break classes for each character */\n\tclasses: LineBreakClass[];\n}\n\n/**\n * Analyze line break opportunities in text\n */\nexport function analyzeLineBreaks(text: string): LineBreakAnalysis {\n\tconst codepoints: number[] = [];\n\tfor (const char of text) {\n\t\tcodepoints.push(char.codePointAt(0) ?? 0);\n\t}\n\n\treturn analyzeLineBreaksFromCodepoints(codepoints);\n}\n\n/**\n * Analyze line break opportunities from codepoints\n */\nexport function analyzeLineBreaksFromCodepoints(\n\tcodepoints: number[],\n): LineBreakAnalysis {\n\tconst len = codepoints.length;\n\tconst classes: LineBreakClass[] = [];\n\tconst breaks: BreakOpportunity[] = [];\n\n\t// Get classes for all codepoints\n\tfor (const cp of codepoints) {\n\t\tclasses.push(getLineBreakClass(cp));\n\t}\n\n\t// LB1: Assign a line breaking class - done in getLineBreakClass\n\n\t// LB2: Never break at the start of text\n\tbreaks.push(BreakOpportunity.NoBreak);\n\n\t// Process each boundary\n\tfor (let i = 1; i < len; i++) {\n\t\tconst before = classes[i - 1]!;\n\t\tconst after = classes[i]!;\n\n\t\tconst action = getPairAction(before, after);\n\n\t\tswitch (action) {\n\t\t\tcase BreakAction.Explicit:\n\t\t\t\tbreaks.push(BreakOpportunity.Mandatory);\n\t\t\t\tbreak;\n\t\t\tcase BreakAction.Direct:\n\t\t\t\tbreaks.push(BreakOpportunity.Optional);\n\t\t\t\tbreak;\n\t\t\tcase BreakAction.Indirect:\n\t\t\t\t// Look for intervening space\n\t\t\t\tif (before === LineBreakClass.SP) {\n\t\t\t\t\tbreaks.push(BreakOpportunity.Optional);\n\t\t\t\t} else {\n\t\t\t\t\tbreaks.push(BreakOpportunity.NoBreak);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreaks.push(BreakOpportunity.NoBreak);\n\t\t}\n\t}\n\n\t// LB3: Always break at the end of text\n\tbreaks.push(BreakOpportunity.Mandatory);\n\n\treturn { breaks, classes };\n}\n\n/**\n * Analyze line breaks for glyph infos\n */\nexport function analyzeLineBreaksForGlyphs(\n\tinfos: GlyphInfo[],\n): LineBreakAnalysis {\n\tconst codepoints = infos.map((info) => info.codepoint);\n\treturn analyzeLineBreaksFromCodepoints(codepoints);\n}\n\n/**\n * Find next line break opportunity\n */\nexport function findNextBreak(\n\tanalysis: LineBreakAnalysis,\n\tstartIndex: number,\n): number {\n\tfor (let i = startIndex + 1; i < analysis.breaks.length; i++) {\n\t\tif (analysis.breaks[i] !== BreakOpportunity.NoBreak) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn analysis.breaks.length - 1;\n}\n\n/**\n * Check if break is allowed at position\n */\nexport function canBreakAt(\n\tanalysis: LineBreakAnalysis,\n\tindex: number,\n): boolean {\n\tif (index < 0 || index >= analysis.breaks.length) return false;\n\treturn analysis.breaks[index] !== BreakOpportunity.NoBreak;\n}\n\n/**\n * Check if break is mandatory at position\n */\nexport function mustBreakAt(\n\tanalysis: LineBreakAnalysis,\n\tindex: number,\n): boolean {\n\tif (index < 0 || index >= analysis.breaks.length) return false;\n\treturn analysis.breaks[index] === BreakOpportunity.Mandatory;\n}\n\n/**\n * Get all break opportunities\n */\nexport function getAllBreakOpportunities(\n\tanalysis: LineBreakAnalysis,\n): number[] {\n\tconst opportunities: number[] = [];\n\tfor (let i = 0; i < analysis.breaks.length; i++) {\n\t\tif (analysis.breaks[i] !== BreakOpportunity.NoBreak) {\n\t\t\topportunities.push(i);\n\t\t}\n\t}\n\treturn opportunities;\n}\n", "/**\n * Unicode Text Segmentation (UAX #29)\n * Grapheme cluster and word boundaries\n */\n\nimport type { GlyphInfo } from \"../types.ts\";\n\n/**\n * Grapheme cluster break property\n */\nexport enum GraphemeBreakProperty {\n\tOther = 0,\n\tCR = 1,\n\tLF = 2,\n\tControl = 3,\n\tExtend = 4,\n\tZWJ = 5,\n\tRegional_Indicator = 6,\n\tPrepend = 7,\n\tSpacingMark = 8,\n\tL = 9, // Hangul L\n\tV = 10, // Hangul V\n\tT = 11, // Hangul T\n\tLV = 12, // Hangul LV\n\tLVT = 13, // Hangul LVT\n\tExtended_Pictographic = 14,\n}\n\n/**\n * Word break property\n */\nexport enum WordBreakProperty {\n\tOther = 0,\n\tCR = 1,\n\tLF = 2,\n\tNewline = 3,\n\tExtend = 4,\n\tZWJ = 5,\n\tRegional_Indicator = 6,\n\tFormat = 7,\n\tKatakana = 8,\n\tHebrew_Letter = 9,\n\tALetter = 10,\n\tSingle_Quote = 11,\n\tDouble_Quote = 12,\n\tMidNumLet = 13,\n\tMidLetter = 14,\n\tMidNum = 15,\n\tNumeric = 16,\n\tExtendNumLet = 17,\n\tWSegSpace = 18,\n\tExtended_Pictographic = 19,\n}\n\n/**\n * Get grapheme break property for codepoint\n */\nexport function getGraphemeBreakProperty(cp: number): GraphemeBreakProperty {\n\t// CR, LF\n\tif (cp === 0x000d) return GraphemeBreakProperty.CR;\n\tif (cp === 0x000a) return GraphemeBreakProperty.LF;\n\n\t// Control characters\n\tif (cp >= 0x0000 && cp <= 0x001f && cp !== 0x000a && cp !== 0x000d)\n\t\treturn GraphemeBreakProperty.Control;\n\tif (cp >= 0x007f && cp <= 0x009f) return GraphemeBreakProperty.Control;\n\tif (cp === 0x00ad) return GraphemeBreakProperty.Control; // Soft hyphen\n\tif (cp === 0x061c) return GraphemeBreakProperty.Control; // ALM\n\tif (cp === 0x180e) return GraphemeBreakProperty.Control;\n\tif (cp === 0x200b) return GraphemeBreakProperty.Control; // ZWSP\n\tif (cp >= 0x200e && cp <= 0x200f) return GraphemeBreakProperty.Control; // LRM, RLM\n\tif (cp >= 0x2028 && cp <= 0x202e) return GraphemeBreakProperty.Control;\n\tif (cp >= 0x2060 && cp <= 0x206f) return GraphemeBreakProperty.Control;\n\tif (cp === 0xfeff) return GraphemeBreakProperty.Control; // BOM\n\tif (cp >= 0xfff0 && cp <= 0xfffb) return GraphemeBreakProperty.Control;\n\n\t// ZWJ\n\tif (cp === 0x200d) return GraphemeBreakProperty.ZWJ;\n\n\t// Regional Indicator\n\tif (cp >= 0x1f1e0 && cp <= 0x1f1ff) return GraphemeBreakProperty.Regional_Indicator;\n\n\t// Prepend\n\tif (cp === 0x0600 || cp === 0x0601 || cp === 0x0602 || cp === 0x0603 ||\n\t\tcp === 0x0604 || cp === 0x0605 || cp === 0x06dd || cp === 0x070f ||\n\t\tcp === 0x0890 || cp === 0x0891 || cp === 0x08e2 || cp === 0x110bd ||\n\t\tcp === 0x110cd)\n\t\treturn GraphemeBreakProperty.Prepend;\n\n\t// Hangul L (Leading consonants)\n\tif (cp >= 0x1100 && cp <= 0x115f) return GraphemeBreakProperty.L;\n\tif (cp >= 0xa960 && cp <= 0xa97c) return GraphemeBreakProperty.L;\n\n\t// Hangul V (Vowels)\n\tif (cp >= 0x1160 && cp <= 0x11a7) return GraphemeBreakProperty.V;\n\tif (cp >= 0xd7b0 && cp <= 0xd7c6) return GraphemeBreakProperty.V;\n\n\t// Hangul T (Trailing consonants)\n\tif (cp >= 0x11a8 && cp <= 0x11ff) return GraphemeBreakProperty.T;\n\tif (cp >= 0xd7cb && cp <= 0xd7fb) return GraphemeBreakProperty.T;\n\n\t// Hangul syllables\n\tif (cp >= 0xac00 && cp <= 0xd7a3) {\n\t\tconst sIndex = cp - 0xac00;\n\t\tif (sIndex % 28 === 0) return GraphemeBreakProperty.LV;\n\t\treturn GraphemeBreakProperty.LVT;\n\t}\n\n\t// Extended Pictographic (Emoji)\n\tif (cp >= 0x1f300 && cp <= 0x1f9ff) return GraphemeBreakProperty.Extended_Pictographic;\n\tif (cp >= 0x1fa00 && cp <= 0x1faff) return GraphemeBreakProperty.Extended_Pictographic;\n\tif (cp >= 0x2600 && cp <= 0x26ff) return GraphemeBreakProperty.Extended_Pictographic;\n\tif (cp >= 0x2700 && cp <= 0x27bf) return GraphemeBreakProperty.Extended_Pictographic;\n\tif (cp === 0x00a9 || cp === 0x00ae) return GraphemeBreakProperty.Extended_Pictographic;\n\tif (cp >= 0x2300 && cp <= 0x23ff) return GraphemeBreakProperty.Extended_Pictographic;\n\tif (cp >= 0x1f000 && cp <= 0x1f02f) return GraphemeBreakProperty.Extended_Pictographic;\n\tif (cp >= 0x1f0a0 && cp <= 0x1f0ff) return GraphemeBreakProperty.Extended_Pictographic;\n\tif (cp >= 0x1f100 && cp <= 0x1f1ff) return GraphemeBreakProperty.Extended_Pictographic;\n\tif (cp >= 0x1f200 && cp <= 0x1f2ff) return GraphemeBreakProperty.Extended_Pictographic;\n\n\t// Spacing Mark\n\tif (cp >= 0x0903 && cp <= 0x0903) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x093b && cp <= 0x093b) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x093e && cp <= 0x0940) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0949 && cp <= 0x094c) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x094e && cp <= 0x094f) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0982 && cp <= 0x0983) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x09be && cp <= 0x09c0) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x09c7 && cp <= 0x09cc) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x09d7) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0a03 && cp <= 0x0a03) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0a3e && cp <= 0x0a40) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0a83 && cp <= 0x0a83) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0abe && cp <= 0x0ac0) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x0ac9) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0acb && cp <= 0x0acc) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0b02 && cp <= 0x0b03) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x0b3e) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x0b40) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0b47 && cp <= 0x0b4c) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x0b57) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0bbe && cp <= 0x0bbf) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0bc1 && cp <= 0x0bcc) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x0bd7) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0c01 && cp <= 0x0c03) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0c41 && cp <= 0x0c44) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0c82 && cp <= 0x0c83) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x0cbe) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0cc0 && cp <= 0x0cc4) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0cc7 && cp <= 0x0ccb) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0cd5 && cp <= 0x0cd6) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0d02 && cp <= 0x0d03) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0d3e && cp <= 0x0d40) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0d46 && cp <= 0x0d4c) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x0d57) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0d82 && cp <= 0x0d83) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0dcf && cp <= 0x0dd1) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0dd8 && cp <= 0x0ddf) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0df2 && cp <= 0x0df3) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x0f3e || cp === 0x0f3f) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x0f7f) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x102b && cp <= 0x102c) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x1031) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x1038) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x103b && cp <= 0x103c) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x1056 && cp <= 0x1057) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x1062) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x1067 && cp <= 0x1068) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x1083 && cp <= 0x1084) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x1087 && cp <= 0x108c) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x108f) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x109a && cp <= 0x109c) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x17b6 && cp <= 0x17b6) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x17be && cp <= 0x17c5) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x17c7 && cp <= 0x17c8) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x1923 && cp <= 0x1926) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x1929 && cp <= 0x192b) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x1930 && cp <= 0x1931) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x1933 && cp <= 0x1938) return GraphemeBreakProperty.SpacingMark;\n\n\t// Extend (combining marks, etc.)\n\tif (cp >= 0x0300 && cp <= 0x036f) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0483 && cp <= 0x0489) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0591 && cp <= 0x05bd) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x05bf) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x05c1 && cp <= 0x05c2) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x05c4 && cp <= 0x05c5) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x05c7) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0610 && cp <= 0x061a) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x064b && cp <= 0x065f) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0670) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x06d6 && cp <= 0x06dc) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x06df && cp <= 0x06e4) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x06e7 && cp <= 0x06e8) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x06ea && cp <= 0x06ed) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0711) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0730 && cp <= 0x074a) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x07a6 && cp <= 0x07b0) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x07eb && cp <= 0x07f3) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x07fd) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0816 && cp <= 0x0819) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x081b && cp <= 0x0823) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0825 && cp <= 0x0827) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0829 && cp <= 0x082d) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0859 && cp <= 0x085b) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x08d3 && cp <= 0x08e1) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x08e3 && cp <= 0x0902) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x093a) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x093c) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0941 && cp <= 0x0948) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x094d) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0951 && cp <= 0x0957) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0962 && cp <= 0x0963) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0981) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x09bc) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x09c1 && cp <= 0x09c4) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x09cd) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x09e2 && cp <= 0x09e3) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x09fe) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0a01 && cp <= 0x0a02) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0a3c) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0a41 && cp <= 0x0a42) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0a47 && cp <= 0x0a48) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0a4b && cp <= 0x0a4d) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0a51) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0a70 && cp <= 0x0a71) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0a75) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0a81 && cp <= 0x0a82) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0abc) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0ac1 && cp <= 0x0ac5) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0ac7 && cp <= 0x0ac8) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0acd) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0ae2 && cp <= 0x0ae3) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0afa && cp <= 0x0aff) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0b01) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0b3c) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0b3f) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0b41 && cp <= 0x0b44) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0b4d) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0b55 && cp <= 0x0b56) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0b62 && cp <= 0x0b63) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0b82) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0bc0) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0bcd) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0c00) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0c04) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0c3e && cp <= 0x0c40) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0c46 && cp <= 0x0c48) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0c4a && cp <= 0x0c4d) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0c55 && cp <= 0x0c56) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0c62 && cp <= 0x0c63) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0c81) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0cbc) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0cbf) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0cc6) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0ccc && cp <= 0x0ccd) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0ce2 && cp <= 0x0ce3) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0d00 && cp <= 0x0d01) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0d3b && cp <= 0x0d3c) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0d41 && cp <= 0x0d44) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0d4d) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0d62 && cp <= 0x0d63) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0d81) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0dca) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0dd2 && cp <= 0x0dd4) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0dd6) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0e31) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0e34 && cp <= 0x0e3a) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0e47 && cp <= 0x0e4e) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0eb1) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0eb4 && cp <= 0x0ebc) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0ec8 && cp <= 0x0ecd) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0f18 && cp <= 0x0f19) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0f35) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0f37) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0f39) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0f71 && cp <= 0x0f7e) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0f80 && cp <= 0x0f84) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0f86 && cp <= 0x0f87) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0f8d && cp <= 0x0f97) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0f99 && cp <= 0x0fbc) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0fc6) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x102d && cp <= 0x1030) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1032 && cp <= 0x1037) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1039 && cp <= 0x103a) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x103d && cp <= 0x103e) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1058 && cp <= 0x1059) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x105e && cp <= 0x1060) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1071 && cp <= 0x1074) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1082) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1085 && cp <= 0x1086) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x108d) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x109d) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x135d && cp <= 0x135f) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1712 && cp <= 0x1714) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1732 && cp <= 0x1734) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1752 && cp <= 0x1753) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1772 && cp <= 0x1773) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x17b4 && cp <= 0x17b5) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x17b7 && cp <= 0x17bd) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x17c6) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x17c9 && cp <= 0x17d3) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x17dd) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x180b && cp <= 0x180d) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x180f) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1885 && cp <= 0x1886) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x18a9) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1920 && cp <= 0x1922) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1927 && cp <= 0x1928) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1932) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1939 && cp <= 0x193b) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1a17 && cp <= 0x1a18) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1a1b) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1a56) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1a58 && cp <= 0x1a5e) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1a60) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1a62) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1a65 && cp <= 0x1a6c) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1a73 && cp <= 0x1a7c) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1a7f) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1ab0 && cp <= 0x1ace) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1b00 && cp <= 0x1b03) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1b34) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1b36 && cp <= 0x1b3a) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1b3c) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1b42) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1b6b && cp <= 0x1b73) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1b80 && cp <= 0x1b81) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1ba2 && cp <= 0x1ba5) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1ba8 && cp <= 0x1ba9) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1bab && cp <= 0x1bad) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1be6) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1be8 && cp <= 0x1be9) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1bed) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1bef && cp <= 0x1bf1) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1c2c && cp <= 0x1c33) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1c36 && cp <= 0x1c37) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1cd0 && cp <= 0x1cd2) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1cd4 && cp <= 0x1ce0) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1ce2 && cp <= 0x1ce8) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1ced) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1cf4) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1cf8 && cp <= 0x1cf9) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1dc0 && cp <= 0x1dff) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x20d0 && cp <= 0x20f0) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x2cef && cp <= 0x2cf1) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x2d7f) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x2de0 && cp <= 0x2dff) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x302a && cp <= 0x302f) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x3099 && cp <= 0x309a) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xa66f && cp <= 0xa672) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xa674 && cp <= 0xa67d) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xa69e && cp <= 0xa69f) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xa6f0 && cp <= 0xa6f1) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xa802) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xa806) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xa80b) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xa825 && cp <= 0xa826) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xa82c) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xa8c4 && cp <= 0xa8c5) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xa8e0 && cp <= 0xa8f1) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xa8ff) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xa926 && cp <= 0xa92d) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xa947 && cp <= 0xa951) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xa980 && cp <= 0xa982) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xa9b3) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xa9b6 && cp <= 0xa9b9) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xa9bc && cp <= 0xa9bd) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xa9e5) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xaa29 && cp <= 0xaa2e) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xaa31 && cp <= 0xaa32) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xaa35 && cp <= 0xaa36) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xaa43) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xaa4c) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xaa7c) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xaab0) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xaab2 && cp <= 0xaab4) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xaab7 && cp <= 0xaab8) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xaabe && cp <= 0xaabf) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xaac1) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xaaec && cp <= 0xaaed) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xaaf6) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xabe5) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xabe8) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xabed) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xfb1e) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xfe00 && cp <= 0xfe0f) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xfe20 && cp <= 0xfe2f) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1f3fb && cp <= 0x1f3ff) return GraphemeBreakProperty.Extend; // Emoji modifiers\n\tif (cp >= 0xe0100 && cp <= 0xe01ef) return GraphemeBreakProperty.Extend; // Variation selectors\n\n\treturn GraphemeBreakProperty.Other;\n}\n\n/**\n * Get word break property for codepoint\n */\nexport function getWordBreakProperty(cp: number): WordBreakProperty {\n\t// CR, LF, Newline\n\tif (cp === 0x000d) return WordBreakProperty.CR;\n\tif (cp === 0x000a) return WordBreakProperty.LF;\n\tif (cp === 0x000b || cp === 0x000c || cp === 0x0085 || cp === 0x2028 || cp === 0x2029)\n\t\treturn WordBreakProperty.Newline;\n\n\t// ZWJ\n\tif (cp === 0x200d) return WordBreakProperty.ZWJ;\n\n\t// Format characters\n\tif (cp === 0x00ad) return WordBreakProperty.Format;\n\tif (cp === 0x061c) return WordBreakProperty.Format;\n\tif (cp === 0x200b) return WordBreakProperty.Format;\n\tif (cp >= 0x200e && cp <= 0x200f) return WordBreakProperty.Format;\n\tif (cp >= 0x2060 && cp <= 0x206f) return WordBreakProperty.Format;\n\tif (cp === 0xfeff) return WordBreakProperty.Format;\n\n\t// Regional Indicator\n\tif (cp >= 0x1f1e0 && cp <= 0x1f1ff) return WordBreakProperty.Regional_Indicator;\n\n\t// Extended Pictographic\n\tif (cp >= 0x1f300 && cp <= 0x1f9ff) return WordBreakProperty.Extended_Pictographic;\n\tif (cp >= 0x1fa00 && cp <= 0x1faff) return WordBreakProperty.Extended_Pictographic;\n\tif (cp >= 0x2600 && cp <= 0x26ff) return WordBreakProperty.Extended_Pictographic;\n\tif (cp >= 0x2700 && cp <= 0x27bf) return WordBreakProperty.Extended_Pictographic;\n\n\t// Hebrew Letter\n\tif (cp >= 0x05d0 && cp <= 0x05ea) return WordBreakProperty.Hebrew_Letter;\n\tif (cp >= 0xfb1d && cp <= 0xfb4f) return WordBreakProperty.Hebrew_Letter;\n\n\t// Katakana\n\tif (cp >= 0x30a0 && cp <= 0x30ff) return WordBreakProperty.Katakana;\n\tif (cp === 0x3031 || cp === 0x3032 || cp === 0x3033 || cp === 0x3034 || cp === 0x3035)\n\t\treturn WordBreakProperty.Katakana;\n\tif (cp === 0x309b || cp === 0x309c) return WordBreakProperty.Katakana;\n\tif (cp >= 0x31f0 && cp <= 0x31ff) return WordBreakProperty.Katakana;\n\tif (cp >= 0x32d0 && cp <= 0x32fe) return WordBreakProperty.Katakana;\n\tif (cp >= 0x3300 && cp <= 0x3357) return WordBreakProperty.Katakana;\n\tif (cp >= 0xff66 && cp <= 0xff9d) return WordBreakProperty.Katakana;\n\n\t// Single Quote\n\tif (cp === 0x0027) return WordBreakProperty.Single_Quote;\n\n\t// Double Quote\n\tif (cp === 0x0022) return WordBreakProperty.Double_Quote;\n\n\t// MidNumLet\n\tif (cp === 0x002e) return WordBreakProperty.MidNumLet; // .\n\tif (cp === 0x2018 || cp === 0x2019) return WordBreakProperty.MidNumLet;\n\tif (cp === 0x2024) return WordBreakProperty.MidNumLet;\n\tif (cp === 0xfe52) return WordBreakProperty.MidNumLet;\n\tif (cp === 0xff07) return WordBreakProperty.MidNumLet;\n\tif (cp === 0xff0e) return WordBreakProperty.MidNumLet;\n\n\t// MidLetter\n\tif (cp === 0x003a) return WordBreakProperty.MidLetter; // :\n\tif (cp === 0x00b7) return WordBreakProperty.MidLetter;\n\tif (cp === 0x0387) return WordBreakProperty.MidLetter;\n\tif (cp === 0x05f4) return WordBreakProperty.MidLetter;\n\tif (cp === 0x2027) return WordBreakProperty.MidLetter;\n\tif (cp === 0xfe13) return WordBreakProperty.MidLetter;\n\tif (cp === 0xfe55) return WordBreakProperty.MidLetter;\n\tif (cp === 0xff1a) return WordBreakProperty.MidLetter;\n\n\t// MidNum\n\tif (cp === 0x002c) return WordBreakProperty.MidNum; // ,\n\tif (cp === 0x003b) return WordBreakProperty.MidNum; // ;\n\tif (cp === 0x037e) return WordBreakProperty.MidNum;\n\tif (cp === 0x0589) return WordBreakProperty.MidNum;\n\tif (cp === 0x060c || cp === 0x060d) return WordBreakProperty.MidNum;\n\tif (cp === 0x066c) return WordBreakProperty.MidNum;\n\tif (cp === 0x07f8) return WordBreakProperty.MidNum;\n\tif (cp === 0x2044) return WordBreakProperty.MidNum;\n\tif (cp === 0xfe10) return WordBreakProperty.MidNum;\n\tif (cp === 0xfe14) return WordBreakProperty.MidNum;\n\tif (cp === 0xfe50) return WordBreakProperty.MidNum;\n\tif (cp === 0xfe54) return WordBreakProperty.MidNum;\n\tif (cp === 0xff0c) return WordBreakProperty.MidNum;\n\tif (cp === 0xff1b) return WordBreakProperty.MidNum;\n\n\t// Numeric\n\tif (cp >= 0x0030 && cp <= 0x0039) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0660 && cp <= 0x0669) return WordBreakProperty.Numeric;\n\tif (cp >= 0x06f0 && cp <= 0x06f9) return WordBreakProperty.Numeric;\n\tif (cp >= 0x07c0 && cp <= 0x07c9) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0966 && cp <= 0x096f) return WordBreakProperty.Numeric;\n\tif (cp >= 0x09e6 && cp <= 0x09ef) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0a66 && cp <= 0x0a6f) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0ae6 && cp <= 0x0aef) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0b66 && cp <= 0x0b6f) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0be6 && cp <= 0x0bef) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0c66 && cp <= 0x0c6f) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0ce6 && cp <= 0x0cef) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0d66 && cp <= 0x0d6f) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0de6 && cp <= 0x0def) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0e50 && cp <= 0x0e59) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0ed0 && cp <= 0x0ed9) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0f20 && cp <= 0x0f29) return WordBreakProperty.Numeric;\n\tif (cp >= 0x1040 && cp <= 0x1049) return WordBreakProperty.Numeric;\n\tif (cp >= 0x1090 && cp <= 0x1099) return WordBreakProperty.Numeric;\n\tif (cp >= 0x17e0 && cp <= 0x17e9) return WordBreakProperty.Numeric;\n\tif (cp >= 0x1810 && cp <= 0x1819) return WordBreakProperty.Numeric;\n\tif (cp >= 0x1946 && cp <= 0x194f) return WordBreakProperty.Numeric;\n\tif (cp >= 0x19d0 && cp <= 0x19d9) return WordBreakProperty.Numeric;\n\tif (cp >= 0x1a80 && cp <= 0x1a89) return WordBreakProperty.Numeric;\n\tif (cp >= 0x1a90 && cp <= 0x1a99) return WordBreakProperty.Numeric;\n\tif (cp >= 0x1b50 && cp <= 0x1b59) return WordBreakProperty.Numeric;\n\tif (cp >= 0x1bb0 && cp <= 0x1bb9) return WordBreakProperty.Numeric;\n\tif (cp >= 0x1c40 && cp <= 0x1c49) return WordBreakProperty.Numeric;\n\tif (cp >= 0x1c50 && cp <= 0x1c59) return WordBreakProperty.Numeric;\n\tif (cp >= 0xa620 && cp <= 0xa629) return WordBreakProperty.Numeric;\n\tif (cp >= 0xa8d0 && cp <= 0xa8d9) return WordBreakProperty.Numeric;\n\tif (cp >= 0xa900 && cp <= 0xa909) return WordBreakProperty.Numeric;\n\tif (cp >= 0xa9d0 && cp <= 0xa9d9) return WordBreakProperty.Numeric;\n\tif (cp >= 0xa9f0 && cp <= 0xa9f9) return WordBreakProperty.Numeric;\n\tif (cp >= 0xaa50 && cp <= 0xaa59) return WordBreakProperty.Numeric;\n\tif (cp >= 0xabf0 && cp <= 0xabf9) return WordBreakProperty.Numeric;\n\tif (cp >= 0xff10 && cp <= 0xff19) return WordBreakProperty.Numeric;\n\n\t// ExtendNumLet\n\tif (cp === 0x005f) return WordBreakProperty.ExtendNumLet; // _\n\tif (cp === 0x202f) return WordBreakProperty.ExtendNumLet;\n\tif (cp === 0x2040) return WordBreakProperty.ExtendNumLet;\n\tif (cp === 0x2054) return WordBreakProperty.ExtendNumLet;\n\tif (cp === 0xfe33 || cp === 0xfe34) return WordBreakProperty.ExtendNumLet;\n\tif (cp >= 0xfe4d && cp <= 0xfe4f) return WordBreakProperty.ExtendNumLet;\n\tif (cp === 0xff3f) return WordBreakProperty.ExtendNumLet;\n\n\t// WSegSpace\n\tif (cp === 0x0020) return WordBreakProperty.WSegSpace;\n\tif (cp === 0x1680) return WordBreakProperty.WSegSpace;\n\tif (cp >= 0x2000 && cp <= 0x200a && cp !== 0x2007) return WordBreakProperty.WSegSpace;\n\tif (cp === 0x205f) return WordBreakProperty.WSegSpace;\n\tif (cp === 0x3000) return WordBreakProperty.WSegSpace;\n\n\t// Extend (same as grapheme extend)\n\tconst gbp = getGraphemeBreakProperty(cp);\n\tif (gbp === GraphemeBreakProperty.Extend) return WordBreakProperty.Extend;\n\n\t// ALetter (alphabetic)\n\tif (cp >= 0x0041 && cp <= 0x005a) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0061 && cp <= 0x007a) return WordBreakProperty.ALetter;\n\tif (cp >= 0x00c0 && cp <= 0x00d6) return WordBreakProperty.ALetter;\n\tif (cp >= 0x00d8 && cp <= 0x00f6) return WordBreakProperty.ALetter;\n\tif (cp >= 0x00f8 && cp <= 0x024f) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0250 && cp <= 0x02af) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0370 && cp <= 0x03ff) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0400 && cp <= 0x04ff) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0500 && cp <= 0x052f) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0531 && cp <= 0x0556) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0560 && cp <= 0x0588) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0600 && cp <= 0x06ff) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0900 && cp <= 0x097f) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0980 && cp <= 0x09ff) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0a00 && cp <= 0x0a7f) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0a80 && cp <= 0x0aff) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0b00 && cp <= 0x0b7f) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0b80 && cp <= 0x0bff) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0c00 && cp <= 0x0c7f) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0c80 && cp <= 0x0cff) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0d00 && cp <= 0x0d7f) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0e00 && cp <= 0x0e7f) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0e80 && cp <= 0x0eff) return WordBreakProperty.ALetter;\n\tif (cp >= 0x1000 && cp <= 0x109f) return WordBreakProperty.ALetter;\n\tif (cp >= 0x10a0 && cp <= 0x10ff) return WordBreakProperty.ALetter;\n\tif (cp >= 0x1100 && cp <= 0x11ff) return WordBreakProperty.ALetter;\n\tif (cp >= 0x1780 && cp <= 0x17ff) return WordBreakProperty.ALetter;\n\tif (cp >= 0x3040 && cp <= 0x309f) return WordBreakProperty.ALetter; // Hiragana\n\tif (cp >= 0x1f00 && cp <= 0x1fff) return WordBreakProperty.ALetter;\n\tif (cp >= 0x2c00 && cp <= 0x2c5f) return WordBreakProperty.ALetter;\n\tif (cp >= 0xa000 && cp <= 0xa48f) return WordBreakProperty.ALetter;\n\tif (cp >= 0xa4d0 && cp <= 0xa4ff) return WordBreakProperty.ALetter;\n\tif (cp >= 0xa500 && cp <= 0xa63f) return WordBreakProperty.ALetter;\n\tif (cp >= 0xa640 && cp <= 0xa69f) return WordBreakProperty.ALetter;\n\tif (cp >= 0xa720 && cp <= 0xa7ff) return WordBreakProperty.ALetter;\n\tif (cp >= 0xab00 && cp <= 0xab6f) return WordBreakProperty.ALetter;\n\tif (cp >= 0xac00 && cp <= 0xd7af) return WordBreakProperty.ALetter; // Hangul\n\tif (cp >= 0xfb00 && cp <= 0xfb06) return WordBreakProperty.ALetter;\n\tif (cp >= 0xff21 && cp <= 0xff3a) return WordBreakProperty.ALetter;\n\tif (cp >= 0xff41 && cp <= 0xff5a) return WordBreakProperty.ALetter;\n\n\treturn WordBreakProperty.Other;\n}\n\n/**\n * Grapheme cluster boundary result\n */\nexport interface GraphemeBoundaries {\n\t/** Boundary positions (indices where clusters end) */\n\tboundaries: number[];\n\t/** Grapheme break properties */\n\tproperties: GraphemeBreakProperty[];\n}\n\n/**\n * Find grapheme cluster boundaries in codepoints\n */\nexport function findGraphemeBoundaries(codepoints: number[]): GraphemeBoundaries {\n\tconst len = codepoints.length;\n\tconst properties: GraphemeBreakProperty[] = [];\n\tconst boundaries: number[] = [];\n\n\tfor (const cp of codepoints) {\n\t\tproperties.push(getGraphemeBreakProperty(cp));\n\t}\n\n\tif (len === 0) return { boundaries, properties };\n\n\t// GB1: Break at the start of text\n\t// (implicitly handled)\n\n\t// Track state for RI pairs\n\tlet riCount = 0;\n\tlet inExtendedPictographicSequence = false;\n\n\tfor (let i = 1; i < len; i++) {\n\t\tconst prev = properties[i - 1]!;\n\t\tconst curr = properties[i]!;\n\n\t\tlet shouldBreak = true;\n\n\t\t// GB3: Do not break between a CR and LF\n\t\tif (prev === GraphemeBreakProperty.CR && curr === GraphemeBreakProperty.LF) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// GB4: Break after controls\n\t\telse if (\n\t\t\tprev === GraphemeBreakProperty.Control ||\n\t\t\tprev === GraphemeBreakProperty.CR ||\n\t\t\tprev === GraphemeBreakProperty.LF\n\t\t) {\n\t\t\tshouldBreak = true;\n\t\t}\n\t\t// GB5: Break before controls\n\t\telse if (\n\t\t\tcurr === GraphemeBreakProperty.Control ||\n\t\t\tcurr === GraphemeBreakProperty.CR ||\n\t\t\tcurr === GraphemeBreakProperty.LF\n\t\t) {\n\t\t\tshouldBreak = true;\n\t\t}\n\t\t// GB6: Do not break Hangul syllable sequences\n\t\telse if (\n\t\t\tprev === GraphemeBreakProperty.L &&\n\t\t\t(curr === GraphemeBreakProperty.L ||\n\t\t\t\tcurr === GraphemeBreakProperty.V ||\n\t\t\t\tcurr === GraphemeBreakProperty.LV ||\n\t\t\t\tcurr === GraphemeBreakProperty.LVT)\n\t\t) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// GB7\n\t\telse if (\n\t\t\t(prev === GraphemeBreakProperty.LV || prev === GraphemeBreakProperty.V) &&\n\t\t\t(curr === GraphemeBreakProperty.V || curr === GraphemeBreakProperty.T)\n\t\t) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// GB8\n\t\telse if (\n\t\t\t(prev === GraphemeBreakProperty.LVT || prev === GraphemeBreakProperty.T) &&\n\t\t\tcurr === GraphemeBreakProperty.T\n\t\t) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// GB9: Do not break before extending characters or ZWJ\n\t\telse if (curr === GraphemeBreakProperty.Extend || curr === GraphemeBreakProperty.ZWJ) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// GB9a: Do not break before SpacingMarks\n\t\telse if (curr === GraphemeBreakProperty.SpacingMark) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// GB9b: Do not break after Prepend characters\n\t\telse if (prev === GraphemeBreakProperty.Prepend) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// GB11: Do not break within emoji modifier sequences or emoji ZWJ sequences\n\t\telse if (inExtendedPictographicSequence && prev === GraphemeBreakProperty.ZWJ &&\n\t\t\tcurr === GraphemeBreakProperty.Extended_Pictographic) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// GB12-13: Do not break within emoji flag sequences\n\t\telse if (prev === GraphemeBreakProperty.Regional_Indicator &&\n\t\t\tcurr === GraphemeBreakProperty.Regional_Indicator) {\n\t\t\t// Only break after even number of RIs\n\t\t\tif (riCount % 2 === 1) {\n\t\t\t\tshouldBreak = false;\n\t\t\t}\n\t\t}\n\n\t\t// Track extended pictographic state\n\t\tif (curr === GraphemeBreakProperty.Extended_Pictographic) {\n\t\t\tinExtendedPictographicSequence = true;\n\t\t} else if (curr !== GraphemeBreakProperty.Extend && curr !== GraphemeBreakProperty.ZWJ) {\n\t\t\tinExtendedPictographicSequence = false;\n\t\t}\n\n\t\t// Track RI count\n\t\tif (curr === GraphemeBreakProperty.Regional_Indicator) {\n\t\t\triCount++;\n\t\t} else {\n\t\t\triCount = 0;\n\t\t}\n\n\t\tif (shouldBreak) {\n\t\t\tboundaries.push(i);\n\t\t}\n\t}\n\n\t// GB2: Break at the end of text\n\tboundaries.push(len);\n\n\treturn { boundaries, properties };\n}\n\n/**\n * Word boundary result\n */\nexport interface WordBoundaries {\n\t/** Boundary positions */\n\tboundaries: number[];\n\t/** Word break properties */\n\tproperties: WordBreakProperty[];\n}\n\n/**\n * Find word boundaries in codepoints\n */\nexport function findWordBoundaries(codepoints: number[]): WordBoundaries {\n\tconst len = codepoints.length;\n\tconst properties: WordBreakProperty[] = [];\n\tconst boundaries: number[] = [];\n\n\tfor (const cp of codepoints) {\n\t\tproperties.push(getWordBreakProperty(cp));\n\t}\n\n\tif (len === 0) return { boundaries, properties };\n\n\t// WB1: Break at the start\n\tboundaries.push(0);\n\n\tlet riCount = 0;\n\n\tfor (let i = 1; i < len; i++) {\n\t\tconst prev = properties[i - 1]!;\n\t\tconst curr = properties[i]!;\n\n\t\tlet shouldBreak = true;\n\n\t\t// WB3: Do not break within CRLF\n\t\tif (prev === WordBreakProperty.CR && curr === WordBreakProperty.LF) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// WB3a-b: Break before and after Newlines\n\t\telse if (\n\t\t\tprev === WordBreakProperty.Newline ||\n\t\t\tprev === WordBreakProperty.CR ||\n\t\t\tprev === WordBreakProperty.LF\n\t\t) {\n\t\t\tshouldBreak = true;\n\t\t} else if (\n\t\t\tcurr === WordBreakProperty.Newline ||\n\t\t\tcurr === WordBreakProperty.CR ||\n\t\t\tcurr === WordBreakProperty.LF\n\t\t) {\n\t\t\tshouldBreak = true;\n\t\t}\n\t\t// WB3c: Do not break within emoji ZWJ sequences\n\t\telse if (prev === WordBreakProperty.ZWJ &&\n\t\t\tcurr === WordBreakProperty.Extended_Pictographic) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// WB3d: Keep horizontal whitespace together\n\t\telse if (prev === WordBreakProperty.WSegSpace &&\n\t\t\tcurr === WordBreakProperty.WSegSpace) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// WB4: Ignore Format and Extend characters\n\t\telse if (curr === WordBreakProperty.Format ||\n\t\t\tcurr === WordBreakProperty.Extend ||\n\t\t\tcurr === WordBreakProperty.ZWJ) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// WB5: Do not break between most letters\n\t\telse if (\n\t\t\t(prev === WordBreakProperty.ALetter || prev === WordBreakProperty.Hebrew_Letter) &&\n\t\t\t(curr === WordBreakProperty.ALetter || curr === WordBreakProperty.Hebrew_Letter)\n\t\t) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// WB6-7: Do not break letters across certain punctuation\n\t\telse if (\n\t\t\t(prev === WordBreakProperty.ALetter || prev === WordBreakProperty.Hebrew_Letter) &&\n\t\t\t(curr === WordBreakProperty.MidLetter || curr === WordBreakProperty.MidNumLet || curr === WordBreakProperty.Single_Quote)\n\t\t) {\n\t\t\t// Look ahead\n\t\t\tif (i + 1 < len) {\n\t\t\t\tconst next = properties[i + 1]!;\n\t\t\t\tif (next === WordBreakProperty.ALetter || next === WordBreakProperty.Hebrew_Letter) {\n\t\t\t\t\tshouldBreak = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// WB8-10: Do not break within sequences of digits\n\t\telse if (prev === WordBreakProperty.Numeric && curr === WordBreakProperty.Numeric) {\n\t\t\tshouldBreak = false;\n\t\t} else if (\n\t\t\t(prev === WordBreakProperty.ALetter || prev === WordBreakProperty.Hebrew_Letter) &&\n\t\t\tcurr === WordBreakProperty.Numeric\n\t\t) {\n\t\t\tshouldBreak = false;\n\t\t} else if (\n\t\t\tprev === WordBreakProperty.Numeric &&\n\t\t\t(curr === WordBreakProperty.ALetter || curr === WordBreakProperty.Hebrew_Letter)\n\t\t) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// WB11-12: Do not break within sequences with numeric separators\n\t\telse if (\n\t\t\tprev === WordBreakProperty.Numeric &&\n\t\t\t(curr === WordBreakProperty.MidNum || curr === WordBreakProperty.MidNumLet || curr === WordBreakProperty.Single_Quote)\n\t\t) {\n\t\t\tif (i + 1 < len && properties[i + 1] === WordBreakProperty.Numeric) {\n\t\t\t\tshouldBreak = false;\n\t\t\t}\n\t\t}\n\t\t// WB13: Do not break between Katakana\n\t\telse if (prev === WordBreakProperty.Katakana && curr === WordBreakProperty.Katakana) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// WB13a-b: ExtendNumLet binding\n\t\telse if (\n\t\t\t(prev === WordBreakProperty.ALetter ||\n\t\t\t\tprev === WordBreakProperty.Hebrew_Letter ||\n\t\t\t\tprev === WordBreakProperty.Numeric ||\n\t\t\t\tprev === WordBreakProperty.Katakana ||\n\t\t\t\tprev === WordBreakProperty.ExtendNumLet) &&\n\t\t\tcurr === WordBreakProperty.ExtendNumLet\n\t\t) {\n\t\t\tshouldBreak = false;\n\t\t} else if (\n\t\t\tprev === WordBreakProperty.ExtendNumLet &&\n\t\t\t(curr === WordBreakProperty.ALetter ||\n\t\t\t\tcurr === WordBreakProperty.Hebrew_Letter ||\n\t\t\t\tcurr === WordBreakProperty.Numeric ||\n\t\t\t\tcurr === WordBreakProperty.Katakana)\n\t\t) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// WB15-16: Do not break within emoji flag sequences\n\t\telse if (prev === WordBreakProperty.Regional_Indicator &&\n\t\t\tcurr === WordBreakProperty.Regional_Indicator) {\n\t\t\tif (riCount % 2 === 1) {\n\t\t\t\tshouldBreak = false;\n\t\t\t}\n\t\t}\n\n\t\t// Track RI count\n\t\tif (curr === WordBreakProperty.Regional_Indicator) {\n\t\t\triCount++;\n\t\t} else {\n\t\t\triCount = 0;\n\t\t}\n\n\t\tif (shouldBreak) {\n\t\t\tboundaries.push(i);\n\t\t}\n\t}\n\n\t// WB2: Break at the end\n\tboundaries.push(len);\n\n\treturn { boundaries, properties };\n}\n\n/**\n * Split text into grapheme clusters\n */\nexport function splitGraphemes(text: string): string[] {\n\tconst codepoints: number[] = [];\n\tconst chars: string[] = [];\n\n\tfor (const char of text) {\n\t\tcodepoints.push(char.codePointAt(0) ?? 0);\n\t\tchars.push(char);\n\t}\n\n\tconst { boundaries } = findGraphemeBoundaries(codepoints);\n\tconst graphemes: string[] = [];\n\n\tlet start = 0;\n\tfor (const end of boundaries) {\n\t\tif (end > start) {\n\t\t\tgraphemes.push(chars.slice(start, end).join(\"\"));\n\t\t}\n\t\tstart = end;\n\t}\n\n\treturn graphemes;\n}\n\n/**\n * Split text into words\n */\nexport function splitWords(text: string): string[] {\n\tconst codepoints: number[] = [];\n\tconst chars: string[] = [];\n\n\tfor (const char of text) {\n\t\tcodepoints.push(char.codePointAt(0) ?? 0);\n\t\tchars.push(char);\n\t}\n\n\tconst { boundaries, properties } = findWordBoundaries(codepoints);\n\tconst words: string[] = [];\n\n\tfor (let i = 0; i < boundaries.length - 1; i++) {\n\t\tconst start = boundaries[i]!;\n\t\tconst end = boundaries[i + 1]!;\n\n\t\t// Skip whitespace-only segments\n\t\tlet hasContent = false;\n\t\tfor (let j = start; j < end; j++) {\n\t\t\tconst prop = properties[j]!;\n\t\t\tif (prop !== WordBreakProperty.WSegSpace &&\n\t\t\t\tprop !== WordBreakProperty.CR &&\n\t\t\t\tprop !== WordBreakProperty.LF &&\n\t\t\t\tprop !== WordBreakProperty.Newline) {\n\t\t\t\thasContent = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (hasContent) {\n\t\t\twords.push(chars.slice(start, end).join(\"\"));\n\t\t}\n\t}\n\n\treturn words;\n}\n\n/**\n * Count grapheme clusters in text\n */\nexport function countGraphemes(text: string): number {\n\tconst codepoints: number[] = [];\n\tfor (const char of text) {\n\t\tcodepoints.push(char.codePointAt(0) ?? 0);\n\t}\n\tconst { boundaries } = findGraphemeBoundaries(codepoints);\n\treturn boundaries.length;\n}\n\n/**\n * Analyze grapheme boundaries for glyph infos\n */\nexport function analyzeGraphemesForGlyphs(infos: GlyphInfo[]): GraphemeBoundaries {\n\tconst codepoints = infos.map((info) => info.codepoint);\n\treturn findGraphemeBoundaries(codepoints);\n}\n\n/**\n * Analyze word boundaries for glyph infos\n */\nexport function analyzeWordsForGlyphs(infos: GlyphInfo[]): WordBoundaries {\n\tconst codepoints = infos.map((info) => info.codepoint);\n\treturn findWordBoundaries(codepoints);\n}\n", "/**\n * Unicode Script Detection\n * Detects the script of text based on codepoints\n */\n\n/**\n * Unicode script values (ISO 15924)\n */\nexport enum Script {\n\tCommon = \"Zyyy\",\n\tInherited = \"Zinh\",\n\tUnknown = \"Zzzz\",\n\n\t// Major scripts\n\tLatin = \"Latn\",\n\tGreek = \"Grek\",\n\tCyrillic = \"Cyrl\",\n\tArmenian = \"Armn\",\n\tHebrew = \"Hebr\",\n\tArabic = \"Arab\",\n\tSyriac = \"Syrc\",\n\tThaana = \"Thaa\",\n\tDevanagari = \"Deva\",\n\tBengali = \"Beng\",\n\tGurmukhi = \"Guru\",\n\tGujarati = \"Gujr\",\n\tOriya = \"Orya\",\n\tTamil = \"Taml\",\n\tTelugu = \"Telu\",\n\tKannada = \"Knda\",\n\tMalayalam = \"Mlym\",\n\tSinhala = \"Sinh\",\n\tThai = \"Thai\",\n\tLao = \"Laoo\",\n\tTibetan = \"Tibt\",\n\tMyanmar = \"Mymr\",\n\tGeorgian = \"Geor\",\n\tHangul = \"Hang\",\n\tEthiopic = \"Ethi\",\n\tCherokee = \"Cher\",\n\tCanadianAboriginal = \"Cans\",\n\tOgham = \"Ogam\",\n\tRunic = \"Runr\",\n\tKhmer = \"Khmr\",\n\tMongolian = \"Mong\",\n\tHiragana = \"Hira\",\n\tKatakana = \"Kana\",\n\tBopomofo = \"Bopo\",\n\tHan = \"Hani\",\n\tYi = \"Yiii\",\n\tOldItalic = \"Ital\",\n\tGothic = \"Goth\",\n\tDeseret = \"Dsrt\",\n\tTagalog = \"Tglg\",\n\tHanunoo = \"Hano\",\n\tBuhid = \"Buhd\",\n\tTagbanwa = \"Tagb\",\n\tLimbu = \"Limb\",\n\tTaiLe = \"Tale\",\n\tLinearB = \"Linb\",\n\tUgaritic = \"Ugar\",\n\tShavian = \"Shaw\",\n\tOsmanya = \"Osma\",\n\tCypriot = \"Cprt\",\n\tBraille = \"Brai\",\n\tBuginese = \"Bugi\",\n\tCoptic = \"Copt\",\n\tNewTaiLue = \"Talu\",\n\tGlagolitic = \"Glag\",\n\tTifinagh = \"Tfng\",\n\tSylotiNagri = \"Sylo\",\n\tOldPersian = \"Xpeo\",\n\tKharoshthi = \"Khar\",\n\tBalinese = \"Bali\",\n\tCuneiform = \"Xsux\",\n\tPhoenician = \"Phnx\",\n\tPhagsPa = \"Phag\",\n\tNko = \"Nkoo\",\n\tSundanese = \"Sund\",\n\tLepcha = \"Lepc\",\n\tOlChiki = \"Olck\",\n\tVai = \"Vaii\",\n\tSaurashtra = \"Saur\",\n\tKayahLi = \"Kali\",\n\tRejang = \"Rjng\",\n\tLycian = \"Lyci\",\n\tCarian = \"Cari\",\n\tLydian = \"Lydi\",\n\tCham = \"Cham\",\n\tTaiTham = \"Lana\",\n\tTaiViet = \"Tavt\",\n\tAvestan = \"Avst\",\n\tEgyptianHieroglyphs = \"Egyp\",\n\tSamaritan = \"Samr\",\n\tLisu = \"Lisu\",\n\tBamum = \"Bamu\",\n\tJavanese = \"Java\",\n\tMeeteiMayek = \"Mtei\",\n\tImperialAramaic = \"Armi\",\n\tOldSouthArabian = \"Sarb\",\n\tInscriptionalParthian = \"Prti\",\n\tInscriptionalPahlavi = \"Phli\",\n\tOldTurkic = \"Orkh\",\n\tKaithi = \"Kthi\",\n\tBatak = \"Batk\",\n\tBrahmi = \"Brah\",\n\tMandaic = \"Mand\",\n\tChakma = \"Cakm\",\n\tMeroiticCursive = \"Merc\",\n\tMeroiticHieroglyphs = \"Mero\",\n\tMiao = \"Plrd\",\n\tSharada = \"Shrd\",\n\tSoraSompeng = \"Sora\",\n\tTakri = \"Takr\",\n\tCaucasianAlbanian = \"Aghb\",\n\tBassaVah = \"Bass\",\n\tDuployan = \"Dupl\",\n\tElbasan = \"Elba\",\n\tGrantha = \"Gran\",\n\tPahawhHmong = \"Hmng\",\n\tKhojki = \"Khoj\",\n\tLinearA = \"Lina\",\n\tMahajani = \"Mahj\",\n\tManichaean = \"Mani\",\n\tMendeKikakui = \"Mend\",\n\tModi = \"Modi\",\n\tMro = \"Mroo\",\n\tOldNorthArabian = \"Narb\",\n\tNabataean = \"Nbat\",\n\tPalmyrene = \"Palm\",\n\tPauCinHau = \"Pauc\",\n\tOldPermic = \"Perm\",\n\tPsalterPahlavi = \"Phlp\",\n\tSiddham = \"Sidd\",\n\tKhudawadi = \"Sind\",\n\tTirhuta = \"Tirh\",\n\tWarangCiti = \"Wara\",\n\tAhom = \"Ahom\",\n\tAnatolianHieroglyphs = \"Hluw\",\n\tHatran = \"Hatr\",\n\tMultani = \"Mult\",\n\tOldHungarian = \"Hung\",\n\tSignWriting = \"Sgnw\",\n\tAdlam = \"Adlm\",\n\tBhaiksuki = \"Bhks\",\n\tMarchen = \"Marc\",\n\tNewa = \"Newa\",\n\tOsage = \"Osge\",\n\tTangut = \"Tang\",\n\tMasaramGondi = \"Gonm\",\n\tNushu = \"Nshu\",\n\tSoyombo = \"Soyo\",\n\tZanabazarSquare = \"Zanb\",\n\tDogra = \"Dogr\",\n\tGunjalaGondi = \"Gong\",\n\tMakasar = \"Maka\",\n\tMedefaidrin = \"Medf\",\n\tHanifiRohingya = \"Rohg\",\n\tSogdian = \"Sogd\",\n\tOldSogdian = \"Sogo\",\n\tElymaic = \"Elym\",\n\tNandinagari = \"Nand\",\n\tNyiakengPuachueHmong = \"Hmnp\",\n\tWancho = \"Wcho\",\n\tYezidi = \"Yezi\",\n\tChorasmian = \"Chrs\",\n\tDivesAkuru = \"Diak\",\n\tKhitanSmallScript = \"Kits\",\n\tVithkuqi = \"Vith\",\n\tOldUyghur = \"Ougr\",\n\tCypro_Minoan = \"Cpmn\",\n\tTangsa = \"Tnsa\",\n\tToto = \"Toto\",\n\tKawi = \"Kawi\",\n\tNagMundari = \"Nagm\",\n}\n\n/**\n * Script range entry\n */\ninterface ScriptRange {\n\tstart: number;\n\tend: number;\n\tscript: Script;\n}\n\n/**\n * Script ranges (sorted by start codepoint)\n */\nconst SCRIPT_RANGES: ScriptRange[] = [\n\t// Basic Latin\n\t{ start: 0x0000, end: 0x007f, script: Script.Common },\n\t// Latin-1 Supplement\n\t{ start: 0x0080, end: 0x00ff, script: Script.Latin },\n\t// Latin Extended-A\n\t{ start: 0x0100, end: 0x017f, script: Script.Latin },\n\t// Latin Extended-B\n\t{ start: 0x0180, end: 0x024f, script: Script.Latin },\n\t// IPA Extensions\n\t{ start: 0x0250, end: 0x02af, script: Script.Latin },\n\t// Spacing Modifier Letters\n\t{ start: 0x02b0, end: 0x02ff, script: Script.Common },\n\t// Combining Diacritical Marks\n\t{ start: 0x0300, end: 0x036f, script: Script.Inherited },\n\t// Greek and Coptic\n\t{ start: 0x0370, end: 0x03ff, script: Script.Greek },\n\t// Cyrillic\n\t{ start: 0x0400, end: 0x04ff, script: Script.Cyrillic },\n\t// Cyrillic Supplement\n\t{ start: 0x0500, end: 0x052f, script: Script.Cyrillic },\n\t// Armenian\n\t{ start: 0x0530, end: 0x058f, script: Script.Armenian },\n\t// Hebrew\n\t{ start: 0x0590, end: 0x05ff, script: Script.Hebrew },\n\t// Arabic\n\t{ start: 0x0600, end: 0x06ff, script: Script.Arabic },\n\t// Syriac\n\t{ start: 0x0700, end: 0x074f, script: Script.Syriac },\n\t// Arabic Supplement\n\t{ start: 0x0750, end: 0x077f, script: Script.Arabic },\n\t// Thaana\n\t{ start: 0x0780, end: 0x07bf, script: Script.Thaana },\n\t// NKo\n\t{ start: 0x07c0, end: 0x07ff, script: Script.Nko },\n\t// Samaritan\n\t{ start: 0x0800, end: 0x083f, script: Script.Samaritan },\n\t// Mandaic\n\t{ start: 0x0840, end: 0x085f, script: Script.Mandaic },\n\t// Syriac Supplement\n\t{ start: 0x0860, end: 0x086f, script: Script.Syriac },\n\t// Arabic Extended-B\n\t{ start: 0x0870, end: 0x089f, script: Script.Arabic },\n\t// Arabic Extended-A\n\t{ start: 0x08a0, end: 0x08ff, script: Script.Arabic },\n\t// Devanagari\n\t{ start: 0x0900, end: 0x097f, script: Script.Devanagari },\n\t// Bengali\n\t{ start: 0x0980, end: 0x09ff, script: Script.Bengali },\n\t// Gurmukhi\n\t{ start: 0x0a00, end: 0x0a7f, script: Script.Gurmukhi },\n\t// Gujarati\n\t{ start: 0x0a80, end: 0x0aff, script: Script.Gujarati },\n\t// Oriya\n\t{ start: 0x0b00, end: 0x0b7f, script: Script.Oriya },\n\t// Tamil\n\t{ start: 0x0b80, end: 0x0bff, script: Script.Tamil },\n\t// Telugu\n\t{ start: 0x0c00, end: 0x0c7f, script: Script.Telugu },\n\t// Kannada\n\t{ start: 0x0c80, end: 0x0cff, script: Script.Kannada },\n\t// Malayalam\n\t{ start: 0x0d00, end: 0x0d7f, script: Script.Malayalam },\n\t// Sinhala\n\t{ start: 0x0d80, end: 0x0dff, script: Script.Sinhala },\n\t// Thai\n\t{ start: 0x0e00, end: 0x0e7f, script: Script.Thai },\n\t// Lao\n\t{ start: 0x0e80, end: 0x0eff, script: Script.Lao },\n\t// Tibetan\n\t{ start: 0x0f00, end: 0x0fff, script: Script.Tibetan },\n\t// Myanmar\n\t{ start: 0x1000, end: 0x109f, script: Script.Myanmar },\n\t// Georgian\n\t{ start: 0x10a0, end: 0x10ff, script: Script.Georgian },\n\t// Hangul Jamo\n\t{ start: 0x1100, end: 0x11ff, script: Script.Hangul },\n\t// Ethiopic\n\t{ start: 0x1200, end: 0x137f, script: Script.Ethiopic },\n\t// Ethiopic Supplement\n\t{ start: 0x1380, end: 0x139f, script: Script.Ethiopic },\n\t// Cherokee\n\t{ start: 0x13a0, end: 0x13ff, script: Script.Cherokee },\n\t// Unified Canadian Aboriginal Syllabics\n\t{ start: 0x1400, end: 0x167f, script: Script.CanadianAboriginal },\n\t// Ogham\n\t{ start: 0x1680, end: 0x169f, script: Script.Ogham },\n\t// Runic\n\t{ start: 0x16a0, end: 0x16ff, script: Script.Runic },\n\t// Tagalog\n\t{ start: 0x1700, end: 0x171f, script: Script.Tagalog },\n\t// Hanunoo\n\t{ start: 0x1720, end: 0x173f, script: Script.Hanunoo },\n\t// Buhid\n\t{ start: 0x1740, end: 0x175f, script: Script.Buhid },\n\t// Tagbanwa\n\t{ start: 0x1760, end: 0x177f, script: Script.Tagbanwa },\n\t// Khmer\n\t{ start: 0x1780, end: 0x17ff, script: Script.Khmer },\n\t// Mongolian\n\t{ start: 0x1800, end: 0x18af, script: Script.Mongolian },\n\t// Unified Canadian Aboriginal Syllabics Extended\n\t{ start: 0x18b0, end: 0x18ff, script: Script.CanadianAboriginal },\n\t// Limbu\n\t{ start: 0x1900, end: 0x194f, script: Script.Limbu },\n\t// Tai Le\n\t{ start: 0x1950, end: 0x197f, script: Script.TaiLe },\n\t// New Tai Lue\n\t{ start: 0x1980, end: 0x19df, script: Script.NewTaiLue },\n\t// Khmer Symbols\n\t{ start: 0x19e0, end: 0x19ff, script: Script.Khmer },\n\t// Buginese\n\t{ start: 0x1a00, end: 0x1a1f, script: Script.Buginese },\n\t// Tai Tham\n\t{ start: 0x1a20, end: 0x1aaf, script: Script.TaiTham },\n\t// Combining Diacritical Marks Extended\n\t{ start: 0x1ab0, end: 0x1aff, script: Script.Inherited },\n\t// Balinese\n\t{ start: 0x1b00, end: 0x1b7f, script: Script.Balinese },\n\t// Sundanese\n\t{ start: 0x1b80, end: 0x1bbf, script: Script.Sundanese },\n\t// Batak\n\t{ start: 0x1bc0, end: 0x1bff, script: Script.Batak },\n\t// Lepcha\n\t{ start: 0x1c00, end: 0x1c4f, script: Script.Lepcha },\n\t// Ol Chiki\n\t{ start: 0x1c50, end: 0x1c7f, script: Script.OlChiki },\n\t// Cyrillic Extended-C\n\t{ start: 0x1c80, end: 0x1c8f, script: Script.Cyrillic },\n\t// Georgian Extended\n\t{ start: 0x1c90, end: 0x1cbf, script: Script.Georgian },\n\t// Sundanese Supplement\n\t{ start: 0x1cc0, end: 0x1ccf, script: Script.Sundanese },\n\t// Vedic Extensions\n\t{ start: 0x1cd0, end: 0x1cff, script: Script.Inherited },\n\t// Phonetic Extensions\n\t{ start: 0x1d00, end: 0x1d7f, script: Script.Latin },\n\t// Phonetic Extensions Supplement\n\t{ start: 0x1d80, end: 0x1dbf, script: Script.Latin },\n\t// Combining Diacritical Marks Supplement\n\t{ start: 0x1dc0, end: 0x1dff, script: Script.Inherited },\n\t// Latin Extended Additional\n\t{ start: 0x1e00, end: 0x1eff, script: Script.Latin },\n\t// Greek Extended\n\t{ start: 0x1f00, end: 0x1fff, script: Script.Greek },\n\t// General Punctuation\n\t{ start: 0x2000, end: 0x206f, script: Script.Common },\n\t// Superscripts and Subscripts\n\t{ start: 0x2070, end: 0x209f, script: Script.Common },\n\t// Currency Symbols\n\t{ start: 0x20a0, end: 0x20cf, script: Script.Common },\n\t// Combining Diacritical Marks for Symbols\n\t{ start: 0x20d0, end: 0x20ff, script: Script.Inherited },\n\t// Letterlike Symbols\n\t{ start: 0x2100, end: 0x214f, script: Script.Common },\n\t// Number Forms\n\t{ start: 0x2150, end: 0x218f, script: Script.Common },\n\t// Arrows\n\t{ start: 0x2190, end: 0x21ff, script: Script.Common },\n\t// Mathematical Operators\n\t{ start: 0x2200, end: 0x22ff, script: Script.Common },\n\t// Miscellaneous Technical\n\t{ start: 0x2300, end: 0x23ff, script: Script.Common },\n\t// Control Pictures\n\t{ start: 0x2400, end: 0x243f, script: Script.Common },\n\t// OCR\n\t{ start: 0x2440, end: 0x245f, script: Script.Common },\n\t// Enclosed Alphanumerics\n\t{ start: 0x2460, end: 0x24ff, script: Script.Common },\n\t// Box Drawing\n\t{ start: 0x2500, end: 0x257f, script: Script.Common },\n\t// Block Elements\n\t{ start: 0x2580, end: 0x259f, script: Script.Common },\n\t// Geometric Shapes\n\t{ start: 0x25a0, end: 0x25ff, script: Script.Common },\n\t// Miscellaneous Symbols\n\t{ start: 0x2600, end: 0x26ff, script: Script.Common },\n\t// Dingbats\n\t{ start: 0x2700, end: 0x27bf, script: Script.Common },\n\t// Miscellaneous Mathematical Symbols-A\n\t{ start: 0x27c0, end: 0x27ef, script: Script.Common },\n\t// Supplemental Arrows-A\n\t{ start: 0x27f0, end: 0x27ff, script: Script.Common },\n\t// Braille Patterns\n\t{ start: 0x2800, end: 0x28ff, script: Script.Braille },\n\t// Supplemental Arrows-B\n\t{ start: 0x2900, end: 0x297f, script: Script.Common },\n\t// Miscellaneous Mathematical Symbols-B\n\t{ start: 0x2980, end: 0x29ff, script: Script.Common },\n\t// Supplemental Mathematical Operators\n\t{ start: 0x2a00, end: 0x2aff, script: Script.Common },\n\t// Miscellaneous Symbols and Arrows\n\t{ start: 0x2b00, end: 0x2bff, script: Script.Common },\n\t// Glagolitic\n\t{ start: 0x2c00, end: 0x2c5f, script: Script.Glagolitic },\n\t// Latin Extended-C\n\t{ start: 0x2c60, end: 0x2c7f, script: Script.Latin },\n\t// Coptic\n\t{ start: 0x2c80, end: 0x2cff, script: Script.Coptic },\n\t// Georgian Supplement\n\t{ start: 0x2d00, end: 0x2d2f, script: Script.Georgian },\n\t// Tifinagh\n\t{ start: 0x2d30, end: 0x2d7f, script: Script.Tifinagh },\n\t// Ethiopic Extended\n\t{ start: 0x2d80, end: 0x2ddf, script: Script.Ethiopic },\n\t// Cyrillic Extended-A\n\t{ start: 0x2de0, end: 0x2dff, script: Script.Cyrillic },\n\t// Supplemental Punctuation\n\t{ start: 0x2e00, end: 0x2e7f, script: Script.Common },\n\t// CJK Radicals Supplement\n\t{ start: 0x2e80, end: 0x2eff, script: Script.Han },\n\t// Kangxi Radicals\n\t{ start: 0x2f00, end: 0x2fdf, script: Script.Han },\n\t// Ideographic Description Characters\n\t{ start: 0x2ff0, end: 0x2fff, script: Script.Common },\n\t// CJK Symbols and Punctuation\n\t{ start: 0x3000, end: 0x303f, script: Script.Common },\n\t// Hiragana\n\t{ start: 0x3040, end: 0x309f, script: Script.Hiragana },\n\t// Katakana\n\t{ start: 0x30a0, end: 0x30ff, script: Script.Katakana },\n\t// Bopomofo\n\t{ start: 0x3100, end: 0x312f, script: Script.Bopomofo },\n\t// Hangul Compatibility Jamo\n\t{ start: 0x3130, end: 0x318f, script: Script.Hangul },\n\t// Kanbun\n\t{ start: 0x3190, end: 0x319f, script: Script.Common },\n\t// Bopomofo Extended\n\t{ start: 0x31a0, end: 0x31bf, script: Script.Bopomofo },\n\t// CJK Strokes\n\t{ start: 0x31c0, end: 0x31ef, script: Script.Common },\n\t// Katakana Phonetic Extensions\n\t{ start: 0x31f0, end: 0x31ff, script: Script.Katakana },\n\t// Enclosed CJK Letters and Months\n\t{ start: 0x3200, end: 0x32ff, script: Script.Common },\n\t// CJK Compatibility\n\t{ start: 0x3300, end: 0x33ff, script: Script.Common },\n\t// CJK Unified Ideographs Extension A\n\t{ start: 0x3400, end: 0x4dbf, script: Script.Han },\n\t// Yijing Hexagram Symbols\n\t{ start: 0x4dc0, end: 0x4dff, script: Script.Common },\n\t// CJK Unified Ideographs\n\t{ start: 0x4e00, end: 0x9fff, script: Script.Han },\n\t// Yi Syllables\n\t{ start: 0xa000, end: 0xa48f, script: Script.Yi },\n\t// Yi Radicals\n\t{ start: 0xa490, end: 0xa4cf, script: Script.Yi },\n\t// Lisu\n\t{ start: 0xa4d0, end: 0xa4ff, script: Script.Lisu },\n\t// Vai\n\t{ start: 0xa500, end: 0xa63f, script: Script.Vai },\n\t// Cyrillic Extended-B\n\t{ start: 0xa640, end: 0xa69f, script: Script.Cyrillic },\n\t// Bamum\n\t{ start: 0xa6a0, end: 0xa6ff, script: Script.Bamum },\n\t// Modifier Tone Letters\n\t{ start: 0xa700, end: 0xa71f, script: Script.Common },\n\t// Latin Extended-D\n\t{ start: 0xa720, end: 0xa7ff, script: Script.Latin },\n\t// Syloti Nagri\n\t{ start: 0xa800, end: 0xa82f, script: Script.SylotiNagri },\n\t// Common Indic Number Forms\n\t{ start: 0xa830, end: 0xa83f, script: Script.Common },\n\t// Phags-pa\n\t{ start: 0xa840, end: 0xa87f, script: Script.PhagsPa },\n\t// Saurashtra\n\t{ start: 0xa880, end: 0xa8df, script: Script.Saurashtra },\n\t// Devanagari Extended\n\t{ start: 0xa8e0, end: 0xa8ff, script: Script.Devanagari },\n\t// Kayah Li\n\t{ start: 0xa900, end: 0xa92f, script: Script.KayahLi },\n\t// Rejang\n\t{ start: 0xa930, end: 0xa95f, script: Script.Rejang },\n\t// Hangul Jamo Extended-A\n\t{ start: 0xa960, end: 0xa97f, script: Script.Hangul },\n\t// Javanese\n\t{ start: 0xa980, end: 0xa9df, script: Script.Javanese },\n\t// Myanmar Extended-B\n\t{ start: 0xa9e0, end: 0xa9ff, script: Script.Myanmar },\n\t// Cham\n\t{ start: 0xaa00, end: 0xaa5f, script: Script.Cham },\n\t// Myanmar Extended-A\n\t{ start: 0xaa60, end: 0xaa7f, script: Script.Myanmar },\n\t// Tai Viet\n\t{ start: 0xaa80, end: 0xaadf, script: Script.TaiViet },\n\t// Meetei Mayek Extensions\n\t{ start: 0xaae0, end: 0xaaff, script: Script.MeeteiMayek },\n\t// Ethiopic Extended-A\n\t{ start: 0xab00, end: 0xab2f, script: Script.Ethiopic },\n\t// Latin Extended-E\n\t{ start: 0xab30, end: 0xab6f, script: Script.Latin },\n\t// Cherokee Supplement\n\t{ start: 0xab70, end: 0xabbf, script: Script.Cherokee },\n\t// Meetei Mayek\n\t{ start: 0xabc0, end: 0xabff, script: Script.MeeteiMayek },\n\t// Hangul Syllables\n\t{ start: 0xac00, end: 0xd7af, script: Script.Hangul },\n\t// Hangul Jamo Extended-B\n\t{ start: 0xd7b0, end: 0xd7ff, script: Script.Hangul },\n\t// High Surrogates, Low Surrogates\n\t{ start: 0xd800, end: 0xdfff, script: Script.Unknown },\n\t// Private Use Area\n\t{ start: 0xe000, end: 0xf8ff, script: Script.Unknown },\n\t// CJK Compatibility Ideographs\n\t{ start: 0xf900, end: 0xfaff, script: Script.Han },\n\t// Alphabetic Presentation Forms\n\t{ start: 0xfb00, end: 0xfb4f, script: Script.Latin },\n\t// Arabic Presentation Forms-A\n\t{ start: 0xfb50, end: 0xfdff, script: Script.Arabic },\n\t// Variation Selectors\n\t{ start: 0xfe00, end: 0xfe0f, script: Script.Inherited },\n\t// Vertical Forms\n\t{ start: 0xfe10, end: 0xfe1f, script: Script.Common },\n\t// Combining Half Marks\n\t{ start: 0xfe20, end: 0xfe2f, script: Script.Inherited },\n\t// CJK Compatibility Forms\n\t{ start: 0xfe30, end: 0xfe4f, script: Script.Common },\n\t// Small Form Variants\n\t{ start: 0xfe50, end: 0xfe6f, script: Script.Common },\n\t// Arabic Presentation Forms-B\n\t{ start: 0xfe70, end: 0xfeff, script: Script.Arabic },\n\t// Halfwidth and Fullwidth Forms\n\t{ start: 0xff00, end: 0xffef, script: Script.Common },\n\t// Specials\n\t{ start: 0xfff0, end: 0xffff, script: Script.Common },\n\t// Linear B Syllabary\n\t{ start: 0x10000, end: 0x1007f, script: Script.LinearB },\n\t// Linear B Ideograms\n\t{ start: 0x10080, end: 0x100ff, script: Script.LinearB },\n\t// Aegean Numbers\n\t{ start: 0x10100, end: 0x1013f, script: Script.Common },\n\t// Ancient Greek Numbers\n\t{ start: 0x10140, end: 0x1018f, script: Script.Greek },\n\t// Ancient Symbols\n\t{ start: 0x10190, end: 0x101cf, script: Script.Common },\n\t// Phaistos Disc\n\t{ start: 0x101d0, end: 0x101ff, script: Script.Common },\n\t// Lycian\n\t{ start: 0x10280, end: 0x1029f, script: Script.Lycian },\n\t// Carian\n\t{ start: 0x102a0, end: 0x102df, script: Script.Carian },\n\t// Coptic Epact Numbers\n\t{ start: 0x102e0, end: 0x102ff, script: Script.Inherited },\n\t// Old Italic\n\t{ start: 0x10300, end: 0x1032f, script: Script.OldItalic },\n\t// Gothic\n\t{ start: 0x10330, end: 0x1034f, script: Script.Gothic },\n\t// Old Permic\n\t{ start: 0x10350, end: 0x1037f, script: Script.OldPermic },\n\t// Ugaritic\n\t{ start: 0x10380, end: 0x1039f, script: Script.Ugaritic },\n\t// Old Persian\n\t{ start: 0x103a0, end: 0x103df, script: Script.OldPersian },\n\t// Deseret\n\t{ start: 0x10400, end: 0x1044f, script: Script.Deseret },\n\t// Shavian\n\t{ start: 0x10450, end: 0x1047f, script: Script.Shavian },\n\t// Osmanya\n\t{ start: 0x10480, end: 0x104af, script: Script.Osmanya },\n\t// Osage\n\t{ start: 0x104b0, end: 0x104ff, script: Script.Osage },\n\t// Elbasan\n\t{ start: 0x10500, end: 0x1052f, script: Script.Elbasan },\n\t// Caucasian Albanian\n\t{ start: 0x10530, end: 0x1056f, script: Script.CaucasianAlbanian },\n\t// Vithkuqi\n\t{ start: 0x10570, end: 0x105bf, script: Script.Vithkuqi },\n\t// Linear A\n\t{ start: 0x10600, end: 0x1077f, script: Script.LinearA },\n\t// Latin Extended-F\n\t{ start: 0x10780, end: 0x107bf, script: Script.Latin },\n\t// Cypriot Syllabary\n\t{ start: 0x10800, end: 0x1083f, script: Script.Cypriot },\n\t// Imperial Aramaic\n\t{ start: 0x10840, end: 0x1085f, script: Script.ImperialAramaic },\n\t// Palmyrene\n\t{ start: 0x10860, end: 0x1087f, script: Script.Palmyrene },\n\t// Nabataean\n\t{ start: 0x10880, end: 0x108af, script: Script.Nabataean },\n\t// Hatran\n\t{ start: 0x108e0, end: 0x108ff, script: Script.Hatran },\n\t// Phoenician\n\t{ start: 0x10900, end: 0x1091f, script: Script.Phoenician },\n\t// Lydian\n\t{ start: 0x10920, end: 0x1093f, script: Script.Lydian },\n\t// Meroitic Hieroglyphs\n\t{ start: 0x10980, end: 0x1099f, script: Script.MeroiticHieroglyphs },\n\t// Meroitic Cursive\n\t{ start: 0x109a0, end: 0x109ff, script: Script.MeroiticCursive },\n\t// Kharoshthi\n\t{ start: 0x10a00, end: 0x10a5f, script: Script.Kharoshthi },\n\t// Old South Arabian\n\t{ start: 0x10a60, end: 0x10a7f, script: Script.OldSouthArabian },\n\t// Old North Arabian\n\t{ start: 0x10a80, end: 0x10a9f, script: Script.OldNorthArabian },\n\t// Manichaean\n\t{ start: 0x10ac0, end: 0x10aff, script: Script.Manichaean },\n\t// Avestan\n\t{ start: 0x10b00, end: 0x10b3f, script: Script.Avestan },\n\t// Inscriptional Parthian\n\t{ start: 0x10b40, end: 0x10b5f, script: Script.InscriptionalParthian },\n\t// Inscriptional Pahlavi\n\t{ start: 0x10b60, end: 0x10b7f, script: Script.InscriptionalPahlavi },\n\t// Psalter Pahlavi\n\t{ start: 0x10b80, end: 0x10baf, script: Script.PsalterPahlavi },\n\t// Old Turkic\n\t{ start: 0x10c00, end: 0x10c4f, script: Script.OldTurkic },\n\t// Old Hungarian\n\t{ start: 0x10c80, end: 0x10cff, script: Script.OldHungarian },\n\t// Hanifi Rohingya\n\t{ start: 0x10d00, end: 0x10d3f, script: Script.HanifiRohingya },\n\t// Yezidi\n\t{ start: 0x10e80, end: 0x10ebf, script: Script.Yezidi },\n\t// Old Sogdian\n\t{ start: 0x10f00, end: 0x10f2f, script: Script.OldSogdian },\n\t// Sogdian\n\t{ start: 0x10f30, end: 0x10f6f, script: Script.Sogdian },\n\t// Old Uyghur\n\t{ start: 0x10f70, end: 0x10faf, script: Script.OldUyghur },\n\t// Chorasmian\n\t{ start: 0x10fb0, end: 0x10fdf, script: Script.Chorasmian },\n\t// Elymaic\n\t{ start: 0x10fe0, end: 0x10fff, script: Script.Elymaic },\n\t// Brahmi\n\t{ start: 0x11000, end: 0x1107f, script: Script.Brahmi },\n\t// Kaithi\n\t{ start: 0x11080, end: 0x110cf, script: Script.Kaithi },\n\t// Sora Sompeng\n\t{ start: 0x110d0, end: 0x110ff, script: Script.SoraSompeng },\n\t// Chakma\n\t{ start: 0x11100, end: 0x1114f, script: Script.Chakma },\n\t// Mahajani\n\t{ start: 0x11150, end: 0x1117f, script: Script.Mahajani },\n\t// Sharada\n\t{ start: 0x11180, end: 0x111df, script: Script.Sharada },\n\t// Sinhala Archaic Numbers\n\t{ start: 0x111e0, end: 0x111ff, script: Script.Sinhala },\n\t// Khojki\n\t{ start: 0x11200, end: 0x1124f, script: Script.Khojki },\n\t// Multani\n\t{ start: 0x11280, end: 0x112af, script: Script.Multani },\n\t// Khudawadi\n\t{ start: 0x112b0, end: 0x112ff, script: Script.Khudawadi },\n\t// Grantha\n\t{ start: 0x11300, end: 0x1137f, script: Script.Grantha },\n\t// Newa\n\t{ start: 0x11400, end: 0x1147f, script: Script.Newa },\n\t// Tirhuta\n\t{ start: 0x11480, end: 0x114df, script: Script.Tirhuta },\n\t// Siddham\n\t{ start: 0x11580, end: 0x115ff, script: Script.Siddham },\n\t// Modi\n\t{ start: 0x11600, end: 0x1165f, script: Script.Modi },\n\t// Mongolian Supplement\n\t{ start: 0x11660, end: 0x1167f, script: Script.Mongolian },\n\t// Takri\n\t{ start: 0x11680, end: 0x116cf, script: Script.Takri },\n\t// Ahom\n\t{ start: 0x11700, end: 0x1174f, script: Script.Ahom },\n\t// Dogra\n\t{ start: 0x11800, end: 0x1184f, script: Script.Dogra },\n\t// Warang Citi\n\t{ start: 0x118a0, end: 0x118ff, script: Script.WarangCiti },\n\t// Dives Akuru\n\t{ start: 0x11900, end: 0x1195f, script: Script.DivesAkuru },\n\t// Nandinagari\n\t{ start: 0x119a0, end: 0x119ff, script: Script.Nandinagari },\n\t// Zanabazar Square\n\t{ start: 0x11a00, end: 0x11a4f, script: Script.ZanabazarSquare },\n\t// Soyombo\n\t{ start: 0x11a50, end: 0x11aaf, script: Script.Soyombo },\n\t// UCAS Extended-A\n\t{ start: 0x11ab0, end: 0x11abf, script: Script.CanadianAboriginal },\n\t// Pau Cin Hau\n\t{ start: 0x11ac0, end: 0x11aff, script: Script.PauCinHau },\n\t// Bhaiksuki\n\t{ start: 0x11c00, end: 0x11c6f, script: Script.Bhaiksuki },\n\t// Marchen\n\t{ start: 0x11c70, end: 0x11cbf, script: Script.Marchen },\n\t// Masaram Gondi\n\t{ start: 0x11d00, end: 0x11d5f, script: Script.MasaramGondi },\n\t// Gunjala Gondi\n\t{ start: 0x11d60, end: 0x11daf, script: Script.GunjalaGondi },\n\t// Makasar\n\t{ start: 0x11ee0, end: 0x11eff, script: Script.Makasar },\n\t// Kawi\n\t{ start: 0x11f00, end: 0x11f5f, script: Script.Kawi },\n\t// Cuneiform\n\t{ start: 0x12000, end: 0x123ff, script: Script.Cuneiform },\n\t// Cuneiform Numbers and Punctuation\n\t{ start: 0x12400, end: 0x1247f, script: Script.Cuneiform },\n\t// Early Dynastic Cuneiform\n\t{ start: 0x12480, end: 0x1254f, script: Script.Cuneiform },\n\t// Cypro-Minoan\n\t{ start: 0x12f90, end: 0x12fff, script: Script.Cypro_Minoan },\n\t// Egyptian Hieroglyphs\n\t{ start: 0x13000, end: 0x1342f, script: Script.EgyptianHieroglyphs },\n\t// Egyptian Hieroglyph Format Controls\n\t{ start: 0x13430, end: 0x1345f, script: Script.EgyptianHieroglyphs },\n\t// Anatolian Hieroglyphs\n\t{ start: 0x14400, end: 0x1467f, script: Script.AnatolianHieroglyphs },\n\t// Bamum Supplement\n\t{ start: 0x16800, end: 0x16a3f, script: Script.Bamum },\n\t// Mro\n\t{ start: 0x16a40, end: 0x16a6f, script: Script.Mro },\n\t// Tangsa\n\t{ start: 0x16a70, end: 0x16acf, script: Script.Tangsa },\n\t// Bassa Vah\n\t{ start: 0x16ad0, end: 0x16aff, script: Script.BassaVah },\n\t// Pahawh Hmong\n\t{ start: 0x16b00, end: 0x16b8f, script: Script.PahawhHmong },\n\t// Medefaidrin\n\t{ start: 0x16e40, end: 0x16e9f, script: Script.Medefaidrin },\n\t// Miao\n\t{ start: 0x16f00, end: 0x16f9f, script: Script.Miao },\n\t// Ideographic Symbols and Punctuation\n\t{ start: 0x16fe0, end: 0x16fff, script: Script.Common },\n\t// Tangut\n\t{ start: 0x17000, end: 0x187ff, script: Script.Tangut },\n\t// Tangut Components\n\t{ start: 0x18800, end: 0x18aff, script: Script.Tangut },\n\t// Khitan Small Script\n\t{ start: 0x18b00, end: 0x18cff, script: Script.KhitanSmallScript },\n\t// Tangut Supplement\n\t{ start: 0x18d00, end: 0x18d7f, script: Script.Tangut },\n\t// Kana Extended-B\n\t{ start: 0x1aff0, end: 0x1afff, script: Script.Katakana },\n\t// Kana Supplement\n\t{ start: 0x1b000, end: 0x1b0ff, script: Script.Hiragana },\n\t// Kana Extended-A\n\t{ start: 0x1b100, end: 0x1b12f, script: Script.Hiragana },\n\t// Small Kana Extension\n\t{ start: 0x1b130, end: 0x1b16f, script: Script.Katakana },\n\t// Nushu\n\t{ start: 0x1b170, end: 0x1b2ff, script: Script.Nushu },\n\t// Duployan\n\t{ start: 0x1bc00, end: 0x1bc9f, script: Script.Duployan },\n\t// Shorthand Format Controls\n\t{ start: 0x1bca0, end: 0x1bcaf, script: Script.Common },\n\t// Znamenny Musical Notation\n\t{ start: 0x1cf00, end: 0x1cfcf, script: Script.Common },\n\t// Byzantine Musical Symbols\n\t{ start: 0x1d000, end: 0x1d0ff, script: Script.Common },\n\t// Musical Symbols\n\t{ start: 0x1d100, end: 0x1d1ff, script: Script.Common },\n\t// Ancient Greek Musical Notation\n\t{ start: 0x1d200, end: 0x1d24f, script: Script.Greek },\n\t// Kaktovik Numerals\n\t{ start: 0x1d2c0, end: 0x1d2df, script: Script.Common },\n\t// Mayan Numerals\n\t{ start: 0x1d2e0, end: 0x1d2ff, script: Script.Common },\n\t// Tai Xuan Jing Symbols\n\t{ start: 0x1d300, end: 0x1d35f, script: Script.Common },\n\t// Counting Rod Numerals\n\t{ start: 0x1d360, end: 0x1d37f, script: Script.Common },\n\t// Mathematical Alphanumeric Symbols\n\t{ start: 0x1d400, end: 0x1d7ff, script: Script.Common },\n\t// Sutton SignWriting\n\t{ start: 0x1d800, end: 0x1daaf, script: Script.SignWriting },\n\t// Latin Extended-G\n\t{ start: 0x1df00, end: 0x1dfff, script: Script.Latin },\n\t// Glagolitic Supplement\n\t{ start: 0x1e000, end: 0x1e02f, script: Script.Glagolitic },\n\t// Cyrillic Extended-D\n\t{ start: 0x1e030, end: 0x1e08f, script: Script.Cyrillic },\n\t// Nyiakeng Puachue Hmong\n\t{ start: 0x1e100, end: 0x1e14f, script: Script.NyiakengPuachueHmong },\n\t// Toto\n\t{ start: 0x1e290, end: 0x1e2bf, script: Script.Toto },\n\t// Wancho\n\t{ start: 0x1e2c0, end: 0x1e2ff, script: Script.Wancho },\n\t// Nag Mundari\n\t{ start: 0x1e4d0, end: 0x1e4ff, script: Script.NagMundari },\n\t// Ethiopic Extended-B\n\t{ start: 0x1e7e0, end: 0x1e7ff, script: Script.Ethiopic },\n\t// Mende Kikakui\n\t{ start: 0x1e800, end: 0x1e8df, script: Script.MendeKikakui },\n\t// Adlam\n\t{ start: 0x1e900, end: 0x1e95f, script: Script.Adlam },\n\t// Indic Siyaq Numbers\n\t{ start: 0x1ec70, end: 0x1ecbf, script: Script.Common },\n\t// Ottoman Siyaq Numbers\n\t{ start: 0x1ed00, end: 0x1ed4f, script: Script.Common },\n\t// Arabic Mathematical Alphabetic Symbols\n\t{ start: 0x1ee00, end: 0x1eeff, script: Script.Arabic },\n\t// Mahjong Tiles\n\t{ start: 0x1f000, end: 0x1f02f, script: Script.Common },\n\t// Domino Tiles\n\t{ start: 0x1f030, end: 0x1f09f, script: Script.Common },\n\t// Playing Cards\n\t{ start: 0x1f0a0, end: 0x1f0ff, script: Script.Common },\n\t// Enclosed Alphanumeric Supplement\n\t{ start: 0x1f100, end: 0x1f1ff, script: Script.Common },\n\t// Enclosed Ideographic Supplement\n\t{ start: 0x1f200, end: 0x1f2ff, script: Script.Common },\n\t// Miscellaneous Symbols and Pictographs\n\t{ start: 0x1f300, end: 0x1f5ff, script: Script.Common },\n\t// Emoticons\n\t{ start: 0x1f600, end: 0x1f64f, script: Script.Common },\n\t// Ornamental Dingbats\n\t{ start: 0x1f650, end: 0x1f67f, script: Script.Common },\n\t// Transport and Map Symbols\n\t{ start: 0x1f680, end: 0x1f6ff, script: Script.Common },\n\t// Alchemical Symbols\n\t{ start: 0x1f700, end: 0x1f77f, script: Script.Common },\n\t// Geometric Shapes Extended\n\t{ start: 0x1f780, end: 0x1f7ff, script: Script.Common },\n\t// Supplemental Arrows-C\n\t{ start: 0x1f800, end: 0x1f8ff, script: Script.Common },\n\t// Supplemental Symbols and Pictographs\n\t{ start: 0x1f900, end: 0x1f9ff, script: Script.Common },\n\t// Chess Symbols\n\t{ start: 0x1fa00, end: 0x1fa6f, script: Script.Common },\n\t// Symbols and Pictographs Extended-A\n\t{ start: 0x1fa70, end: 0x1faff, script: Script.Common },\n\t// Symbols for Legacy Computing\n\t{ start: 0x1fb00, end: 0x1fbff, script: Script.Common },\n\t// CJK Unified Ideographs Extension B\n\t{ start: 0x20000, end: 0x2a6df, script: Script.Han },\n\t// CJK Unified Ideographs Extension C\n\t{ start: 0x2a700, end: 0x2b73f, script: Script.Han },\n\t// CJK Unified Ideographs Extension D\n\t{ start: 0x2b740, end: 0x2b81f, script: Script.Han },\n\t// CJK Unified Ideographs Extension E\n\t{ start: 0x2b820, end: 0x2ceaf, script: Script.Han },\n\t// CJK Unified Ideographs Extension F\n\t{ start: 0x2ceb0, end: 0x2ebef, script: Script.Han },\n\t// CJK Compatibility Ideographs Supplement\n\t{ start: 0x2f800, end: 0x2fa1f, script: Script.Han },\n\t// CJK Unified Ideographs Extension G\n\t{ start: 0x30000, end: 0x3134f, script: Script.Han },\n\t// CJK Unified Ideographs Extension H\n\t{ start: 0x31350, end: 0x323af, script: Script.Han },\n\t// Tags\n\t{ start: 0xe0000, end: 0xe007f, script: Script.Common },\n\t// Variation Selectors Supplement\n\t{ start: 0xe0100, end: 0xe01ef, script: Script.Inherited },\n\t// Supplementary Private Use Area-A\n\t{ start: 0xf0000, end: 0xfffff, script: Script.Unknown },\n\t// Supplementary Private Use Area-B\n\t{ start: 0x100000, end: 0x10ffff, script: Script.Unknown },\n];\n\n/**\n * Get script for a codepoint using binary search\n */\nexport function getScript(cp: number): Script {\n\tlet left = 0;\n\tlet right = SCRIPT_RANGES.length - 1;\n\n\twhile (left <= right) {\n\t\tconst mid = (left + right) >>> 1;\n\t\tconst range = SCRIPT_RANGES[mid]!;\n\n\t\tif (cp < range.start) {\n\t\t\tright = mid - 1;\n\t\t} else if (cp > range.end) {\n\t\t\tleft = mid + 1;\n\t\t} else {\n\t\t\treturn range.script;\n\t\t}\n\t}\n\n\treturn Script.Unknown;\n}\n\n/**\n * Get script for a string (returns the dominant non-Common/Inherited script)\n */\nexport function detectScript(text: string): Script {\n\tconst counts = new Map<Script, number>();\n\n\tfor (const char of text) {\n\t\tconst cp = char.codePointAt(0) ?? 0;\n\t\tconst script = getScript(cp);\n\n\t\t// Skip Common and Inherited scripts\n\t\tif (script === Script.Common || script === Script.Inherited) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tcounts.set(script, (counts.get(script) ?? 0) + 1);\n\t}\n\n\tif (counts.size === 0) {\n\t\treturn Script.Common;\n\t}\n\n\t// Return the most frequent script\n\tlet maxScript = Script.Common;\n\tlet maxCount = 0;\n\n\tfor (const [script, count] of counts) {\n\t\tif (count > maxCount) {\n\t\t\tmaxCount = count;\n\t\t\tmaxScript = script;\n\t\t}\n\t}\n\n\treturn maxScript;\n}\n\n/**\n * Get all scripts present in text\n */\nexport function getScripts(text: string): Script[] {\n\tconst scripts = new Set<Script>();\n\n\tfor (const char of text) {\n\t\tconst cp = char.codePointAt(0) ?? 0;\n\t\tconst script = getScript(cp);\n\t\tscripts.add(script);\n\t}\n\n\treturn Array.from(scripts);\n}\n\n/**\n * Check if text contains only characters from a specific script\n * (Common and Inherited are allowed)\n */\nexport function isScript(text: string, script: Script): boolean {\n\tfor (const char of text) {\n\t\tconst cp = char.codePointAt(0) ?? 0;\n\t\tconst charScript = getScript(cp);\n\n\t\tif (\n\t\t\tcharScript !== script &&\n\t\t\tcharScript !== Script.Common &&\n\t\t\tcharScript !== Script.Inherited\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Script run - a contiguous sequence of characters with the same script\n */\nexport interface ScriptRun {\n\tscript: Script;\n\tstart: number;\n\tend: number;\n\ttext: string;\n}\n\n/**\n * Split text into script runs\n */\nexport function getScriptRuns(text: string): ScriptRun[] {\n\tconst runs: ScriptRun[] = [];\n\tif (text.length === 0) return runs;\n\n\tlet currentScript: Script | null = null;\n\tlet runStart = 0;\n\tlet charIndex = 0;\n\n\tconst chars: string[] = [];\n\tfor (const char of text) {\n\t\tchars.push(char);\n\t}\n\n\tfor (let i = 0; i < chars.length; i++) {\n\t\tconst char = chars[i]!;\n\t\tconst cp = char.codePointAt(0) ?? 0;\n\t\tlet script = getScript(cp);\n\n\t\t// Treat Common and Inherited as part of the current run\n\t\tif (script === Script.Common || script === Script.Inherited) {\n\t\t\tif (currentScript !== null) {\n\t\t\t\tscript = currentScript;\n\t\t\t}\n\t\t}\n\n\t\tif (currentScript === null) {\n\t\t\tcurrentScript = script;\n\t\t\trunStart = i;\n\t\t} else if (script !== currentScript && script !== Script.Common && script !== Script.Inherited) {\n\t\t\t// End current run\n\t\t\truns.push({\n\t\t\t\tscript: currentScript,\n\t\t\t\tstart: runStart,\n\t\t\t\tend: i,\n\t\t\t\ttext: chars.slice(runStart, i).join(\"\"),\n\t\t\t});\n\t\t\tcurrentScript = script;\n\t\t\trunStart = i;\n\t\t}\n\t}\n\n\t// Add final run\n\tif (currentScript !== null) {\n\t\truns.push({\n\t\t\tscript: currentScript,\n\t\t\tstart: runStart,\n\t\t\tend: chars.length,\n\t\t\ttext: chars.slice(runStart).join(\"\"),\n\t\t});\n\t}\n\n\treturn runs;\n}\n\n/**\n * Get OpenType script tag for a Unicode script\n */\nexport function getScriptTag(script: Script): string {\n\t// Map Script enum to OpenType script tags\n\tconst tagMap: Record<Script, string> = {\n\t\t[Script.Common]: \"DFLT\",\n\t\t[Script.Inherited]: \"DFLT\",\n\t\t[Script.Unknown]: \"DFLT\",\n\t\t[Script.Latin]: \"latn\",\n\t\t[Script.Greek]: \"grek\",\n\t\t[Script.Cyrillic]: \"cyrl\",\n\t\t[Script.Armenian]: \"armn\",\n\t\t[Script.Hebrew]: \"hebr\",\n\t\t[Script.Arabic]: \"arab\",\n\t\t[Script.Syriac]: \"syrc\",\n\t\t[Script.Thaana]: \"thaa\",\n\t\t[Script.Devanagari]: \"deva\",\n\t\t[Script.Bengali]: \"beng\",\n\t\t[Script.Gurmukhi]: \"guru\",\n\t\t[Script.Gujarati]: \"gujr\",\n\t\t[Script.Oriya]: \"orya\",\n\t\t[Script.Tamil]: \"taml\",\n\t\t[Script.Telugu]: \"telu\",\n\t\t[Script.Kannada]: \"knda\",\n\t\t[Script.Malayalam]: \"mlym\",\n\t\t[Script.Sinhala]: \"sinh\",\n\t\t[Script.Thai]: \"thai\",\n\t\t[Script.Lao]: \"lao \",\n\t\t[Script.Tibetan]: \"tibt\",\n\t\t[Script.Myanmar]: \"mymr\",\n\t\t[Script.Georgian]: \"geor\",\n\t\t[Script.Hangul]: \"hang\",\n\t\t[Script.Ethiopic]: \"ethi\",\n\t\t[Script.Cherokee]: \"cher\",\n\t\t[Script.CanadianAboriginal]: \"cans\",\n\t\t[Script.Ogham]: \"ogam\",\n\t\t[Script.Runic]: \"runr\",\n\t\t[Script.Khmer]: \"khmr\",\n\t\t[Script.Mongolian]: \"mong\",\n\t\t[Script.Hiragana]: \"kana\",\n\t\t[Script.Katakana]: \"kana\",\n\t\t[Script.Bopomofo]: \"bopo\",\n\t\t[Script.Han]: \"hani\",\n\t\t[Script.Yi]: \"yi  \",\n\t\t[Script.OldItalic]: \"ital\",\n\t\t[Script.Gothic]: \"goth\",\n\t\t[Script.Deseret]: \"dsrt\",\n\t\t[Script.Tagalog]: \"tglg\",\n\t\t[Script.Hanunoo]: \"hano\",\n\t\t[Script.Buhid]: \"buhd\",\n\t\t[Script.Tagbanwa]: \"tagb\",\n\t\t[Script.Limbu]: \"limb\",\n\t\t[Script.TaiLe]: \"tale\",\n\t\t[Script.LinearB]: \"linb\",\n\t\t[Script.Ugaritic]: \"ugar\",\n\t\t[Script.Shavian]: \"shaw\",\n\t\t[Script.Osmanya]: \"osma\",\n\t\t[Script.Cypriot]: \"cprt\",\n\t\t[Script.Braille]: \"brai\",\n\t\t[Script.Buginese]: \"bugi\",\n\t\t[Script.Coptic]: \"copt\",\n\t\t[Script.NewTaiLue]: \"talu\",\n\t\t[Script.Glagolitic]: \"glag\",\n\t\t[Script.Tifinagh]: \"tfng\",\n\t\t[Script.SylotiNagri]: \"sylo\",\n\t\t[Script.OldPersian]: \"xpeo\",\n\t\t[Script.Kharoshthi]: \"khar\",\n\t\t[Script.Balinese]: \"bali\",\n\t\t[Script.Cuneiform]: \"xsux\",\n\t\t[Script.Phoenician]: \"phnx\",\n\t\t[Script.PhagsPa]: \"phag\",\n\t\t[Script.Nko]: \"nko \",\n\t\t[Script.Sundanese]: \"sund\",\n\t\t[Script.Lepcha]: \"lepc\",\n\t\t[Script.OlChiki]: \"olck\",\n\t\t[Script.Vai]: \"vai \",\n\t\t[Script.Saurashtra]: \"saur\",\n\t\t[Script.KayahLi]: \"kali\",\n\t\t[Script.Rejang]: \"rjng\",\n\t\t[Script.Lycian]: \"lyci\",\n\t\t[Script.Carian]: \"cari\",\n\t\t[Script.Lydian]: \"lydi\",\n\t\t[Script.Cham]: \"cham\",\n\t\t[Script.TaiTham]: \"lana\",\n\t\t[Script.TaiViet]: \"tavt\",\n\t\t[Script.Avestan]: \"avst\",\n\t\t[Script.EgyptianHieroglyphs]: \"egyp\",\n\t\t[Script.Samaritan]: \"samr\",\n\t\t[Script.Lisu]: \"lisu\",\n\t\t[Script.Bamum]: \"bamu\",\n\t\t[Script.Javanese]: \"java\",\n\t\t[Script.MeeteiMayek]: \"mtei\",\n\t\t[Script.ImperialAramaic]: \"armi\",\n\t\t[Script.OldSouthArabian]: \"sarb\",\n\t\t[Script.InscriptionalParthian]: \"prti\",\n\t\t[Script.InscriptionalPahlavi]: \"phli\",\n\t\t[Script.OldTurkic]: \"orkh\",\n\t\t[Script.Kaithi]: \"kthi\",\n\t\t[Script.Batak]: \"batk\",\n\t\t[Script.Brahmi]: \"brah\",\n\t\t[Script.Mandaic]: \"mand\",\n\t\t[Script.Chakma]: \"cakm\",\n\t\t[Script.MeroiticCursive]: \"merc\",\n\t\t[Script.MeroiticHieroglyphs]: \"mero\",\n\t\t[Script.Miao]: \"plrd\",\n\t\t[Script.Sharada]: \"shrd\",\n\t\t[Script.SoraSompeng]: \"sora\",\n\t\t[Script.Takri]: \"takr\",\n\t\t[Script.CaucasianAlbanian]: \"aghb\",\n\t\t[Script.BassaVah]: \"bass\",\n\t\t[Script.Duployan]: \"dupl\",\n\t\t[Script.Elbasan]: \"elba\",\n\t\t[Script.Grantha]: \"gran\",\n\t\t[Script.PahawhHmong]: \"hmng\",\n\t\t[Script.Khojki]: \"khoj\",\n\t\t[Script.LinearA]: \"lina\",\n\t\t[Script.Mahajani]: \"mahj\",\n\t\t[Script.Manichaean]: \"mani\",\n\t\t[Script.MendeKikakui]: \"mend\",\n\t\t[Script.Modi]: \"modi\",\n\t\t[Script.Mro]: \"mroo\",\n\t\t[Script.OldNorthArabian]: \"narb\",\n\t\t[Script.Nabataean]: \"nbat\",\n\t\t[Script.Palmyrene]: \"palm\",\n\t\t[Script.PauCinHau]: \"pauc\",\n\t\t[Script.OldPermic]: \"perm\",\n\t\t[Script.PsalterPahlavi]: \"phlp\",\n\t\t[Script.Siddham]: \"sidd\",\n\t\t[Script.Khudawadi]: \"sind\",\n\t\t[Script.Tirhuta]: \"tirh\",\n\t\t[Script.WarangCiti]: \"wara\",\n\t\t[Script.Ahom]: \"ahom\",\n\t\t[Script.AnatolianHieroglyphs]: \"hluw\",\n\t\t[Script.Hatran]: \"hatr\",\n\t\t[Script.Multani]: \"mult\",\n\t\t[Script.OldHungarian]: \"hung\",\n\t\t[Script.SignWriting]: \"sgnw\",\n\t\t[Script.Adlam]: \"adlm\",\n\t\t[Script.Bhaiksuki]: \"bhks\",\n\t\t[Script.Marchen]: \"marc\",\n\t\t[Script.Newa]: \"newa\",\n\t\t[Script.Osage]: \"osge\",\n\t\t[Script.Tangut]: \"tang\",\n\t\t[Script.MasaramGondi]: \"gonm\",\n\t\t[Script.Nushu]: \"nshu\",\n\t\t[Script.Soyombo]: \"soyo\",\n\t\t[Script.ZanabazarSquare]: \"zanb\",\n\t\t[Script.Dogra]: \"dogr\",\n\t\t[Script.GunjalaGondi]: \"gong\",\n\t\t[Script.Makasar]: \"maka\",\n\t\t[Script.Medefaidrin]: \"medf\",\n\t\t[Script.HanifiRohingya]: \"rohg\",\n\t\t[Script.Sogdian]: \"sogd\",\n\t\t[Script.OldSogdian]: \"sogo\",\n\t\t[Script.Elymaic]: \"elym\",\n\t\t[Script.Nandinagari]: \"nand\",\n\t\t[Script.NyiakengPuachueHmong]: \"hmnp\",\n\t\t[Script.Wancho]: \"wcho\",\n\t\t[Script.Yezidi]: \"yezi\",\n\t\t[Script.Chorasmian]: \"chrs\",\n\t\t[Script.DivesAkuru]: \"diak\",\n\t\t[Script.KhitanSmallScript]: \"kits\",\n\t\t[Script.Vithkuqi]: \"vith\",\n\t\t[Script.OldUyghur]: \"ougr\",\n\t\t[Script.Cypro_Minoan]: \"cpmn\",\n\t\t[Script.Tangsa]: \"tnsa\",\n\t\t[Script.Toto]: \"toto\",\n\t\t[Script.Kawi]: \"kawi\",\n\t\t[Script.NagMundari]: \"nagm\",\n\t};\n\n\treturn tagMap[script] ?? \"DFLT\";\n}\n\n/**\n * Check if a script requires complex shaping\n */\nexport function isComplexScript(script: Script): boolean {\n\tconst complexScripts = new Set([\n\t\tScript.Arabic,\n\t\tScript.Syriac,\n\t\tScript.Hebrew,\n\t\tScript.Thaana,\n\t\tScript.Nko,\n\t\tScript.Devanagari,\n\t\tScript.Bengali,\n\t\tScript.Gurmukhi,\n\t\tScript.Gujarati,\n\t\tScript.Oriya,\n\t\tScript.Tamil,\n\t\tScript.Telugu,\n\t\tScript.Kannada,\n\t\tScript.Malayalam,\n\t\tScript.Sinhala,\n\t\tScript.Thai,\n\t\tScript.Lao,\n\t\tScript.Tibetan,\n\t\tScript.Myanmar,\n\t\tScript.Khmer,\n\t\tScript.Mongolian,\n\t\tScript.Hangul,\n\t]);\n\n\treturn complexScripts.has(script);\n}\n\n/**\n * Get script direction (LTR or RTL)\n */\nexport function getScriptDirection(script: Script): \"ltr\" | \"rtl\" {\n\tconst rtlScripts = new Set([\n\t\tScript.Arabic,\n\t\tScript.Hebrew,\n\t\tScript.Syriac,\n\t\tScript.Thaana,\n\t\tScript.Nko,\n\t\tScript.Samaritan,\n\t\tScript.Mandaic,\n\t\tScript.ImperialAramaic,\n\t\tScript.Phoenician,\n\t\tScript.OldSouthArabian,\n\t\tScript.OldNorthArabian,\n\t\tScript.Avestan,\n\t\tScript.InscriptionalParthian,\n\t\tScript.InscriptionalPahlavi,\n\t\tScript.PsalterPahlavi,\n\t\tScript.Hatran,\n\t\tScript.Lydian,\n\t\tScript.Nabataean,\n\t\tScript.Palmyrene,\n\t\tScript.Manichaean,\n\t\tScript.MendeKikakui,\n\t\tScript.HanifiRohingya,\n\t\tScript.Yezidi,\n\t\tScript.OldSogdian,\n\t\tScript.Sogdian,\n\t\tScript.Elymaic,\n\t\tScript.Chorasmian,\n\t\tScript.OldUyghur,\n\t\tScript.Adlam,\n\t]);\n\n\treturn rtlScripts.has(script) ? \"rtl\" : \"ltr\";\n}\n", "/**\n * Rasterizer types - FreeType-style bitmap rendering\n */\n\nimport type { PathCommand, GlyphPath } from \"../render/path.ts\";\n\n/**\n * Pixel modes for bitmap output\n */\nexport enum PixelMode {\n\t/** 1-bit per pixel, 8 pixels per byte */\n\tMono = 0,\n\t/** 8-bit grayscale, 1 byte per pixel */\n\tGray = 1,\n\t/** 24-bit LCD subpixel RGB, 3 bytes per pixel */\n\tLCD = 2,\n\t/** 24-bit LCD subpixel vertical RGB */\n\tLCD_V = 3,\n}\n\n/**\n * Fill rule for outline rendering\n */\nexport enum FillRule {\n\t/** Non-zero winding rule (default) */\n\tNonZero = 0,\n\t/** Even-odd (alternating) fill rule */\n\tEvenOdd = 1,\n}\n\n/**\n * Bitmap buffer for rasterized glyphs\n */\nexport interface Bitmap {\n\t/** Pixel buffer */\n\tbuffer: Uint8Array;\n\t/** Width in pixels */\n\twidth: number;\n\t/** Height in pixels */\n\trows: number;\n\t/** Bytes per row (may include padding) */\n\tpitch: number;\n\t/** Pixel format */\n\tpixelMode: PixelMode;\n\t/** Number of gray levels (256 for 8-bit) */\n\tnumGrays: number;\n}\n\n/**\n * A single horizontal span of pixels (for direct rendering)\n */\nexport interface Span {\n\t/** X position of span start */\n\tx: number;\n\t/** Length in pixels */\n\tlen: number;\n\t/** Coverage value 0-255 */\n\tcoverage: number;\n}\n\n/**\n * Callback for span-based rendering\n * @template T User data type passed through from render call\n */\nexport type SpanFunc<T = void> = (y: number, spans: Span[], userData: T) => void;\n\n/**\n * Rasterization parameters\n */\nexport interface RasterParams {\n\t/** Target bitmap (null for span callback mode) */\n\ttarget?: Bitmap;\n\t/** Source outline path */\n\tsource: GlyphPath;\n\t/** Fill rule */\n\tfillRule?: FillRule;\n\t/** Span callback for direct rendering */\n\tspanFunc?: SpanFunc;\n\t/** Clip box (in pixels) */\n\tclipBox?: {\n\t\txMin: number;\n\t\tyMin: number;\n\t\txMax: number;\n\t\tyMax: number;\n\t};\n}\n\n/**\n * Options for rasterizing a glyph\n */\nexport interface RasterizeOptions {\n\t/** Width in pixels */\n\twidth: number;\n\t/** Height in pixels */\n\theight: number;\n\t/** Scale factor (font units to pixels) */\n\tscale: number;\n\t/** X offset in pixels */\n\toffsetX?: number;\n\t/** Y offset in pixels */\n\toffsetY?: number;\n\t/** Pixel mode */\n\tpixelMode?: PixelMode;\n\t/** Fill rule */\n\tfillRule?: FillRule;\n\t/** Flip Y axis (font coords are Y-up, bitmap is Y-down) */\n\tflipY?: boolean;\n}\n\n/**\n * Result of glyph rasterization\n */\nexport interface RasterizedGlyph {\n\t/** Pixel data */\n\tbitmap: Bitmap;\n\t/** Bearing X (offset from origin to left edge) */\n\tbearingX: number;\n\t/** Bearing Y (offset from origin to top edge) */\n\tbearingY: number;\n}\n\n/**\n * Glyph metrics for atlas building\n */\nexport interface GlyphMetrics {\n\t/** Glyph ID */\n\tglyphId: number;\n\t/** X position in atlas */\n\tatlasX: number;\n\t/** Y position in atlas */\n\tatlasY: number;\n\t/** Width in atlas */\n\twidth: number;\n\t/** Height in atlas */\n\theight: number;\n\t/** Bearing X */\n\tbearingX: number;\n\t/** Bearing Y */\n\tbearingY: number;\n\t/** Horizontal advance */\n\tadvance: number;\n}\n\n/**\n * Texture atlas containing multiple glyphs\n */\nexport interface GlyphAtlas {\n\t/** Atlas bitmap */\n\tbitmap: Bitmap;\n\t/** Glyph metrics indexed by glyph ID */\n\tglyphs: Map<number, GlyphMetrics>;\n\t/** Font size used for rendering */\n\tfontSize: number;\n}\n\n/**\n * Options for building a glyph atlas\n */\nexport interface AtlasOptions {\n\t/** Font size in pixels */\n\tfontSize: number;\n\t/** Padding between glyphs */\n\tpadding?: number;\n\t/** Maximum atlas width */\n\tmaxWidth?: number;\n\t/** Maximum atlas height */\n\tmaxHeight?: number;\n\t/** Pixel mode */\n\tpixelMode?: PixelMode;\n\t/** Enable hinting */\n\thinting?: boolean;\n}\n\n/**\n * Create an empty bitmap\n */\nexport function createBitmap(\n\twidth: number,\n\theight: number,\n\tpixelMode: PixelMode = PixelMode.Gray,\n): Bitmap {\n\tlet bytesPerPixel: number;\n\tswitch (pixelMode) {\n\t\tcase PixelMode.Mono:\n\t\t\tbytesPerPixel = 1 / 8; // 8 pixels per byte\n\t\t\tbreak;\n\t\tcase PixelMode.Gray:\n\t\t\tbytesPerPixel = 1;\n\t\t\tbreak;\n\t\tcase PixelMode.LCD:\n\t\tcase PixelMode.LCD_V:\n\t\t\tbytesPerPixel = 3;\n\t\t\tbreak;\n\t}\n\n\tconst pitch =\n\t\tpixelMode === PixelMode.Mono\n\t\t\t? Math.ceil(width / 8)\n\t\t\t: width * bytesPerPixel;\n\n\treturn {\n\t\tbuffer: new Uint8Array(pitch * height),\n\t\twidth,\n\t\trows: height,\n\t\tpitch,\n\t\tpixelMode,\n\t\tnumGrays: pixelMode === PixelMode.Mono ? 2 : 256,\n\t};\n}\n\n/**\n * Clear a bitmap to zero\n */\nexport function clearBitmap(bitmap: Bitmap): void {\n\tbitmap.buffer.fill(0);\n}\n\n/**\n * Create a bottom-up bitmap (negative pitch)\n * Bottom-up bitmaps have row 0 at the bottom of the image,\n * which matches some graphics APIs (e.g., Windows DIB, OpenGL textures)\n */\nexport function createBottomUpBitmap(\n\twidth: number,\n\theight: number,\n\tpixelMode: PixelMode = PixelMode.Gray,\n): Bitmap {\n\tconst bitmap = createBitmap(width, height, pixelMode);\n\t// Negative pitch indicates bottom-up storage\n\tbitmap.pitch = -bitmap.pitch;\n\treturn bitmap;\n}\n", "/**\n * Fixed-point arithmetic utilities for rasterization\n *\n * FreeType uses several fixed-point formats:\n * - F26Dot6: 26.6 format (64 units per pixel) for coordinates\n * - F16Dot16: 16.16 format for high-precision calculations\n * - F2Dot14: 2.14 format for normalized vectors\n */\n\n// Bit shifts for fixed-point formats\nexport const PIXEL_BITS = 8; // Subpixel precision (256 levels per pixel)\nexport const ONE_PIXEL = 1 << PIXEL_BITS; // 256\nexport const PIXEL_MASK = ONE_PIXEL - 1; // 0xFF\n\n// 26.6 fixed-point (FreeType's standard format)\nexport const F26DOT6_SHIFT = 6;\nexport const F26DOT6_ONE = 1 << F26DOT6_SHIFT; // 64\n\n// 16.16 fixed-point\nexport const F16DOT16_SHIFT = 16;\nexport const F16DOT16_ONE = 1 << F16DOT16_SHIFT; // 65536\n\n/**\n * Convert float to 26.6 fixed-point\n */\nexport function floatToF26Dot6(x: number): number {\n\treturn Math.round(x * F26DOT6_ONE);\n}\n\n/**\n * Convert 26.6 fixed-point to float\n */\nexport function f26Dot6ToFloat(x: number): number {\n\treturn x / F26DOT6_ONE;\n}\n\n/**\n * Convert float to internal raster coordinates (PIXEL_BITS precision)\n * Input is in font units, output has 256 subpixel levels per pixel\n */\nexport function floatToPixel(x: number, scale: number): number {\n\treturn Math.round(x * scale * ONE_PIXEL);\n}\n\n/**\n * Truncate to pixel (floor for positive, ceil for negative)\n */\nexport function truncPixel(x: number): number {\n\treturn x >> PIXEL_BITS;\n}\n\n/**\n * Get fractional part (0 to ONE_PIXEL-1)\n */\nexport function fracPixel(x: number): number {\n\treturn x & PIXEL_MASK;\n}\n\n/**\n * Round to nearest pixel\n */\nexport function roundPixel(x: number): number {\n\treturn (x + (ONE_PIXEL >> 1)) >> PIXEL_BITS;\n}\n\n/**\n * Floor to pixel boundary\n */\nexport function floorPixel(x: number): number {\n\treturn x & ~PIXEL_MASK;\n}\n\n/**\n * Ceiling to pixel boundary\n */\nexport function ceilPixel(x: number): number {\n\treturn (x + PIXEL_MASK) & ~PIXEL_MASK;\n}\n\n/**\n * Upscale from 26.6 to internal PIXEL_BITS format\n * PIXEL_BITS=8 means 2 extra bits of precision vs 26.6\n */\nexport function upscale(x: number): number {\n\treturn x << (PIXEL_BITS - F26DOT6_SHIFT);\n}\n\n/**\n * Downscale from internal format to 26.6\n */\nexport function downscale(x: number): number {\n\treturn x >> (PIXEL_BITS - F26DOT6_SHIFT);\n}\n\n/**\n * Multiply two fixed-point numbers and divide, avoiding overflow\n * Computes (a * b) / c with 64-bit intermediate precision\n */\nexport function mulDiv(a: number, b: number, c: number): number {\n\tif (c === 0) return 0;\n\t// Use BigInt for 64-bit precision\n\tconst result = (BigInt(a) * BigInt(b)) / BigInt(c);\n\treturn Number(result);\n}\n\n/**\n * Multiply two 16.16 fixed-point numbers\n */\nexport function mulFix(a: number, b: number): number {\n\treturn mulDiv(a, b, F16DOT16_ONE);\n}\n\n/**\n * Divide two numbers and return 16.16 fixed-point result\n */\nexport function divFix(a: number, b: number): number {\n\tif (b === 0) return 0;\n\treturn mulDiv(a, F16DOT16_ONE, b);\n}\n\n/**\n * Fast approximation of sqrt(x*x + y*y) using \"alpha max plus beta min\" algorithm.\n * Uses alpha = 1, beta = 3/8 for max error < 7% vs exact value.\n * From FreeType's FT_HYPOT macro.\n */\nexport function hypot(x: number, y: number): number {\n\tx = abs(x);\n\ty = abs(y);\n\treturn x > y ? x + ((3 * y) >> 3) : y + ((3 * x) >> 3);\n}\n\n/**\n * Calculate the length of a 2D vector (integer math)\n * Uses FreeType's \"alpha max plus beta min\" approximation\n */\nexport function vectorLength(dx: number, dy: number): number {\n\treturn hypot(dx, dy);\n}\n\n/**\n * Normalize a 2D vector to unit length (16.16 fixed-point output)\n */\nexport function normalizeVector(\n\tdx: number,\n\tdy: number,\n): { x: number; y: number } {\n\tconst len = Math.sqrt(dx * dx + dy * dy);\n\tif (len === 0) return { x: F16DOT16_ONE, y: 0 };\n\treturn {\n\t\tx: Math.round((dx / len) * F16DOT16_ONE),\n\t\ty: Math.round((dy / len) * F16DOT16_ONE),\n\t};\n}\n\n/**\n * Clamp value to range\n */\nexport function clamp(x: number, min: number, max: number): number {\n\treturn x < min ? min : x > max ? max : x;\n}\n\n/**\n * Absolute value\n */\nexport function abs(x: number): number {\n\treturn x < 0 ? -x : x;\n}\n\n/**\n * Sign of value (-1, 0, or 1)\n */\nexport function sign(x: number): number {\n\treturn x < 0 ? -1 : x > 0 ? 1 : 0;\n}\n", "/**\n * Cell management for scanline rasterization\n *\n * Based on FreeType's ftgrays.c cell accumulation approach.\n * Each cell tracks coverage and area for anti-aliased rendering.\n *\n * Uses pool-based allocation with overflow detection for bounded memory.\n */\n\nimport { truncPixel } from \"./fixed-point.ts\";\n\n/** Default pool size (matches FreeType's FT_MAX_GRAY_POOL) */\nconst DEFAULT_POOL_SIZE = 2048;\n\n/** Sentinel X value for null cell */\nconst CELL_MAX_X = 0x7fffffff;\n\n/**\n * Pool overflow error - thrown when cell pool is exhausted\n */\nexport class PoolOverflowError extends Error {\n\tconstructor() {\n\t\tsuper(\"Cell pool overflow\");\n\t\tthis.name = \"PoolOverflowError\";\n\t}\n}\n\n/**\n * A cell accumulates coverage information for one pixel\n */\nexport interface Cell {\n\t/** X coordinate in pixels */\n\tx: number;\n\t/** Accumulated signed area */\n\tarea: number;\n\t/** Accumulated coverage (winding number contribution) */\n\tcover: number;\n\t/** Next cell in linked list (index into pool, -1 for end) */\n\tnext: number;\n}\n\n/**\n * Cell storage with pool-based allocation and linked lists per scanline.\n * Matches FreeType's approach for bounded memory usage.\n */\nexport class CellBuffer {\n\t/** Fixed-size cell pool */\n\tprivate pool: Cell[];\n\t/** Pool size */\n\tprivate poolSize: number;\n\t/** Next free cell index */\n\tprivate freeIndex: number;\n\t/** Per-scanline linked list heads (index into pool, -1 for empty) */\n\tprivate ycells: number[];\n\n\t/** Band bounds (Y range for current render pass) */\n\tprivate bandMinY: number = 0;\n\tprivate bandMaxY: number = 0;\n\n\t/** Bounding box of active cells */\n\tminY: number = Infinity;\n\tmaxY: number = -Infinity;\n\tminX: number = Infinity;\n\tmaxX: number = -Infinity;\n\n\t/** Current position for incremental cell updates */\n\tprivate currentX: number = 0;\n\tprivate currentY: number = 0;\n\tprivate currentCellIndex: number = -1;\n\n\t/** Clip bounds in pixels */\n\tprivate clipMinX: number = -Infinity;\n\tprivate clipMinY: number = -Infinity;\n\tprivate clipMaxX: number = Infinity;\n\tprivate clipMaxY: number = Infinity;\n\n\t/** Null cell index (sentinel at end of pool) */\n\tprivate nullCellIndex: number;\n\n\t/** Whether band bounds have been set */\n\tprivate bandSet: boolean = false;\n\n\tconstructor(poolSize: number = DEFAULT_POOL_SIZE) {\n\t\tthis.poolSize = poolSize;\n\t\tthis.nullCellIndex = poolSize - 1;\n\n\t\t// Pre-allocate pool\n\t\tthis.pool = new Array(poolSize);\n\t\tfor (let i = 0; i < poolSize; i++) {\n\t\t\tthis.pool[i] = { x: 0, area: 0, cover: 0, next: -1 };\n\t\t}\n\n\t\t// Initialize null cell (sentinel)\n\t\tthis.pool[this.nullCellIndex]!.x = CELL_MAX_X;\n\t\tthis.pool[this.nullCellIndex]!.next = -1;\n\n\t\tthis.ycells = [];\n\t\tthis.freeIndex = 0;\n\n\t\t// Default band bounds (large range for backward compatibility)\n\t\tthis.bandMinY = -10000;\n\t\tthis.bandMaxY = 10000;\n\t}\n\n\t/**\n\t * Set clipping bounds\n\t */\n\tsetClip(minX: number, minY: number, maxX: number, maxY: number): void {\n\t\tthis.clipMinX = minX;\n\t\tthis.clipMinY = minY;\n\t\tthis.clipMaxX = maxX;\n\t\tthis.clipMaxY = maxY;\n\t}\n\n\t/**\n\t * Set band bounds for current render pass\n\t */\n\tsetBandBounds(minY: number, maxY: number): void {\n\t\tthis.bandMinY = minY;\n\t\tthis.bandMaxY = maxY;\n\t\tthis.bandSet = true;\n\n\t\t// Resize ycells array for band height\n\t\tconst height = maxY - minY;\n\t\tif (this.ycells.length < height) {\n\t\t\tthis.ycells = new Array(height);\n\t\t}\n\n\t\t// Initialize all rows to null cell\n\t\tfor (let i = 0; i < height; i++) {\n\t\t\tthis.ycells[i] = this.nullCellIndex;\n\t\t}\n\n\t\t// Calculate how many cells we need for ycells pointers\n\t\t// Reserve space at start of pool for ycells (like FreeType)\n\t\tthis.freeIndex = 0;\n\t}\n\n\t/**\n\t * Clear all cells for new band\n\t */\n\treset(): void {\n\t\t// Reset pool\n\t\tthis.freeIndex = 0;\n\n\t\t// Reset null cell\n\t\tthis.pool[this.nullCellIndex]!.x = CELL_MAX_X;\n\t\tthis.pool[this.nullCellIndex]!.area = 0;\n\t\tthis.pool[this.nullCellIndex]!.cover = 0;\n\t\tthis.pool[this.nullCellIndex]!.next = -1;\n\n\t\t// Reset ycells to null (only if band was set; otherwise leave for dynamic expansion)\n\t\tif (this.bandSet) {\n\t\t\tfor (let i = 0; i < this.ycells.length; i++) {\n\t\t\t\tthis.ycells[i] = this.nullCellIndex;\n\t\t\t}\n\t\t} else {\n\t\t\t// Clear ycells for dynamic mode - will be initialized on first use\n\t\t\tthis.ycells = [];\n\t\t\t// Use very large bounds to avoid clipping before ensureYCellsCapacity is called\n\t\t\tthis.bandMinY = -100000;\n\t\t\tthis.bandMaxY = 100000;\n\t\t}\n\n\t\tthis.minY = Infinity;\n\t\tthis.maxY = -Infinity;\n\t\tthis.minX = Infinity;\n\t\tthis.maxX = -Infinity;\n\t\tthis.currentCellIndex = -1;\n\t}\n\n\t/**\n\t * Set current position (in subpixel coordinates)\n\t * @throws PoolOverflowError if pool is exhausted\n\t */\n\tsetCurrentCell(x: number, y: number): void {\n\t\tconst px = truncPixel(x);\n\t\tconst py = truncPixel(y);\n\n\t\t// Check if we're already at this cell\n\t\tif (this.currentCellIndex >= 0 && this.currentX === px && this.currentY === py) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check clipping (use band bounds for Y)\n\t\tif (\n\t\t\tpy < this.bandMinY ||\n\t\t\tpy >= this.bandMaxY ||\n\t\t\tpx < this.clipMinX ||\n\t\t\tpx >= this.clipMaxX\n\t\t) {\n\t\t\tthis.currentCellIndex = this.nullCellIndex;\n\t\t\tthis.currentX = px;\n\t\t\tthis.currentY = py;\n\t\t\treturn;\n\t\t}\n\n\t\t// Get or create cell for this position\n\t\tthis.currentX = px;\n\t\tthis.currentY = py;\n\t\tthis.currentCellIndex = this.findOrCreateCell(px, py);\n\n\t\t// Update bounds\n\t\tthis.minY = Math.min(this.minY, py);\n\t\tthis.maxY = Math.max(this.maxY, py);\n\t\tthis.minX = Math.min(this.minX, px);\n\t\tthis.maxX = Math.max(this.maxX, px);\n\t}\n\n\t/**\n\t * Find or create a cell at the given pixel position\n\t * @throws PoolOverflowError if pool is exhausted\n\t */\n\tprivate findOrCreateCell(x: number, y: number): number {\n\t\t// Auto-expand band if needed (for backward compatibility when setBandBounds not called)\n\t\tif (!this.bandSet) {\n\t\t\tthis.ensureYCellsCapacity(y);\n\t\t}\n\n\t\tconst rowIndex = y - this.bandMinY;\n\t\tif (rowIndex < 0 || rowIndex >= this.ycells.length) {\n\t\t\treturn this.nullCellIndex;\n\t\t}\n\n\t\t// Walk linked list for this row\n\t\tlet prevIndex = -1;\n\t\tlet cellIndex = this.ycells[rowIndex]!;\n\n\t\twhile (cellIndex !== this.nullCellIndex) {\n\t\t\tconst cell = this.pool[cellIndex]!;\n\t\t\tif (cell.x === x) {\n\t\t\t\treturn cellIndex; // Found existing cell\n\t\t\t}\n\t\t\tif (cell.x > x) {\n\t\t\t\tbreak; // Insert before this cell\n\t\t\t}\n\t\t\tprevIndex = cellIndex;\n\t\t\tcellIndex = cell.next;\n\t\t}\n\n\t\t// Need to allocate new cell\n\t\tif (this.freeIndex >= this.nullCellIndex) {\n\t\t\tthrow new PoolOverflowError();\n\t\t}\n\n\t\tconst newIndex = this.freeIndex++;\n\t\tconst newCell = this.pool[newIndex]!;\n\t\tnewCell.x = x;\n\t\tnewCell.area = 0;\n\t\tnewCell.cover = 0;\n\t\tnewCell.next = cellIndex;\n\n\t\t// Link into list\n\t\tif (prevIndex === -1) {\n\t\t\tthis.ycells[rowIndex] = newIndex;\n\t\t} else {\n\t\t\tthis.pool[prevIndex]!.next = newIndex;\n\t\t}\n\n\t\treturn newIndex;\n\t}\n\n\t/**\n\t * Ensure ycells array can accommodate the given Y coordinate\n\t * Used for backward compatibility when setBandBounds is not called\n\t */\n\tprivate ensureYCellsCapacity(y: number): void {\n\t\t// Initialize band if first access\n\t\tif (this.ycells.length === 0) {\n\t\t\t// Start with a reasonable range centered around y\n\t\t\tthis.bandMinY = Math.min(y, 0);\n\t\t\tthis.bandMaxY = Math.max(y + 1, 256);\n\t\t\tconst height = this.bandMaxY - this.bandMinY;\n\t\t\tthis.ycells = new Array(height);\n\t\t\tfor (let i = 0; i < height; i++) {\n\t\t\t\tthis.ycells[i] = this.nullCellIndex;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// Expand if needed\n\t\tif (y < this.bandMinY) {\n\t\t\tconst expand = this.bandMinY - y;\n\t\t\tconst newYcells = new Array(this.ycells.length + expand);\n\t\t\tfor (let i = 0; i < expand; i++) {\n\t\t\t\tnewYcells[i] = this.nullCellIndex;\n\t\t\t}\n\t\t\tfor (let i = 0; i < this.ycells.length; i++) {\n\t\t\t\tnewYcells[expand + i] = this.ycells[i];\n\t\t\t}\n\t\t\tthis.ycells = newYcells;\n\t\t\tthis.bandMinY = y;\n\t\t} else if (y >= this.bandMaxY) {\n\t\t\tconst newMaxY = y + 1;\n\t\t\tconst oldLen = this.ycells.length;\n\t\t\tconst newLen = newMaxY - this.bandMinY;\n\t\t\tif (newLen > oldLen) {\n\t\t\t\tconst newYcells = new Array(newLen);\n\t\t\t\tfor (let i = 0; i < oldLen; i++) {\n\t\t\t\t\tnewYcells[i] = this.ycells[i];\n\t\t\t\t}\n\t\t\t\tfor (let i = oldLen; i < newLen; i++) {\n\t\t\t\t\tnewYcells[i] = this.nullCellIndex;\n\t\t\t\t}\n\t\t\t\tthis.ycells = newYcells;\n\t\t\t}\n\t\t\tthis.bandMaxY = newMaxY;\n\t\t}\n\t}\n\n\t/**\n\t * Add area and cover to current cell\n\t */\n\taddArea(area: number, cover: number): void {\n\t\tif (this.currentCellIndex >= 0) {\n\t\t\tconst cell = this.pool[this.currentCellIndex]!;\n\t\t\tcell.area += area;\n\t\t\tcell.cover += cover;\n\t\t}\n\t}\n\n\t/**\n\t * Get current cell area (for accumulation)\n\t */\n\tgetArea(): number {\n\t\tif (this.currentCellIndex >= 0) {\n\t\t\treturn this.pool[this.currentCellIndex]!.area;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Get current cell cover\n\t */\n\tgetCover(): number {\n\t\tif (this.currentCellIndex >= 0) {\n\t\t\treturn this.pool[this.currentCellIndex]!.cover;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Get all cells for a given Y coordinate, sorted by X\n\t */\n\tgetCellsForRow(y: number): Cell[] {\n\t\tconst rowIndex = y - this.bandMinY;\n\t\tif (rowIndex < 0 || rowIndex >= this.ycells.length) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst cells: Cell[] = [];\n\t\tlet cellIndex = this.ycells[rowIndex]!;\n\t\twhile (cellIndex !== this.nullCellIndex) {\n\t\t\tcells.push(this.pool[cellIndex]!);\n\t\t\tcellIndex = this.pool[cellIndex]!.next;\n\t\t}\n\t\treturn cells;\n\t}\n\n\t/**\n\t * Iterate over all cells in scanline order within band\n\t */\n\t*iterateCells(): Generator<{ y: number; cells: Cell[] }> {\n\t\tfor (let i = 0; i < this.ycells.length; i++) {\n\t\t\tconst y = this.bandMinY + i;\n\t\t\tlet cellIndex = this.ycells[i]!;\n\t\t\tif (cellIndex === this.nullCellIndex) continue;\n\n\t\t\tconst cells: Cell[] = [];\n\t\t\twhile (cellIndex !== this.nullCellIndex) {\n\t\t\t\tcells.push(this.pool[cellIndex]!);\n\t\t\t\tcellIndex = this.pool[cellIndex]!.next;\n\t\t\t}\n\t\t\tif (cells.length > 0) {\n\t\t\t\tyield { y, cells };\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Iterate cells for a single row (for band sweep)\n\t */\n\t*iterateRowCells(y: number): Generator<Cell> {\n\t\tconst rowIndex = y - this.bandMinY;\n\t\tif (rowIndex < 0 || rowIndex >= this.ycells.length) return;\n\n\t\tlet cellIndex = this.ycells[rowIndex]!;\n\t\twhile (cellIndex !== this.nullCellIndex) {\n\t\t\tyield this.pool[cellIndex]!;\n\t\t\tcellIndex = this.pool[cellIndex]!.next;\n\t\t}\n\t}\n\n\t/**\n\t * Get number of cells currently allocated\n\t */\n\tgetCellCount(): number {\n\t\treturn this.freeIndex;\n\t}\n\n\t/**\n\t * Check if pool is near capacity\n\t */\n\tisNearCapacity(): boolean {\n\t\treturn this.freeIndex > this.poolSize * 0.9;\n\t}\n}\n\n/**\n * Convert cell coverage to 8-bit grayscale value\n *\n * The area is accumulated in 2*PIXEL_BITS precision.\n * We need to shift down to get 0-255 coverage.\n */\nexport function coverageToGray(area: number): number {\n\t// Area is in ONE_PIXEL * ONE_PIXEL precision\n\t// Shift down to 0-255 range\n\tlet coverage = area >> (PIXEL_BITS * 2 - 8);\n\n\t// Clamp to 0-255\n\tif (coverage < 0) coverage = -coverage;\n\tif (coverage > 255) coverage = 255;\n\n\treturn coverage;\n}\n\n/**\n * Apply non-zero winding fill rule\n */\nexport function applyNonZeroRule(cover: number): number {\n\tlet c = cover;\n\tif (c < 0) c = -c;\n\tif (c > 255) c = 255;\n\treturn c;\n}\n\n/**\n * Apply even-odd fill rule\n */\nexport function applyEvenOddRule(cover: number): number {\n\tlet c = cover;\n\tif (c < 0) c = -c;\n\tc &= 511; // Mod 512\n\tif (c > 256) c = 512 - c;\n\tif (c > 255) c = 255;\n\treturn c;\n}\n", "/**\n * Gray-scale anti-aliased rasterizer\n *\n * Based on FreeType's ftgrays.c - a coverage-based scanline rasterizer\n * that produces high-quality anti-aliased output.\n *\n * Algorithm overview:\n * 1. Convert outline to line segments (flatten curves)\n * 2. For each line segment, compute coverage contribution to cells\n * 3. Sweep scanlines, accumulating coverage\n * 4. Convert coverage to grayscale pixels\n *\n * Key concepts:\n * - cover: accumulated vertical change (winding contribution)\n * - area: accumulated (y-delta * x-position) for edge anti-aliasing\n *\n * Band processing:\n * - Large glyphs are divided into vertical bands\n * - Each band is rendered with bounded memory pool\n * - On overflow, band is bisected and retried\n */\n\nimport {\n\tPIXEL_BITS,\n\tONE_PIXEL,\n\ttruncPixel,\n\tfracPixel,\n\tabs,\n} from \"./fixed-point.ts\";\nimport { CellBuffer, PoolOverflowError } from \"./cell.ts\";\nimport type { Bitmap, Span, FillRule } from \"./types.ts\";\nimport { FillRule as FillRuleEnum, PixelMode } from \"./types.ts\";\n\n/** Maximum band bisection depth (like FreeType's 32 bands stack) */\nconst MAX_BAND_DEPTH = 32;\n\n/** Span buffer size for direct rendering */\nconst MAX_GRAY_SPANS = 16;\n\n/**\n * Rasterizer state\n */\nexport class GrayRaster {\n\tprivate cells: CellBuffer;\n\n\t// Current position in subpixel coordinates\n\tprivate x: number = 0;\n\tprivate y: number = 0;\n\n\t// Clip bounds in pixels\n\tprivate minX: number = 0;\n\tprivate minY: number = 0;\n\tprivate maxX: number = 0;\n\tprivate maxY: number = 0;\n\n\tconstructor() {\n\t\tthis.cells = new CellBuffer();\n\t}\n\n\t/**\n\t * Set clip rectangle (in pixels)\n\t */\n\tsetClip(minX: number, minY: number, maxX: number, maxY: number): void {\n\t\tthis.minX = minX;\n\t\tthis.minY = minY;\n\t\tthis.maxX = maxX;\n\t\tthis.maxY = maxY;\n\t\tthis.cells.setClip(minX, minY, maxX, maxY);\n\t}\n\n\t/**\n\t * Set band bounds for current render pass\n\t */\n\tsetBandBounds(minY: number, maxY: number): void {\n\t\tthis.cells.setBandBounds(minY, maxY);\n\t}\n\n\t/**\n\t * Reset rasterizer state\n\t */\n\treset(): void {\n\t\tthis.cells.reset();\n\t\tthis.x = 0;\n\t\tthis.y = 0;\n\t}\n\n\t/**\n\t * Move to a new position (start new contour)\n\t * Coordinates are in subpixel units (ONE_PIXEL per pixel)\n\t */\n\tmoveTo(x: number, y: number): void {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.cells.setCurrentCell(x, y);\n\t}\n\n\t/**\n\t * Draw line to position\n\t */\n\tlineTo(toX: number, toY: number): void {\n\t\tthis.renderLine(toX, toY);\n\t\tthis.x = toX;\n\t\tthis.y = toY;\n\t}\n\n\t/**\n\t * Render a line from current position to (toX, toY)\n\t * This is the core rasterization algorithm.\n\t */\n\tprivate renderLine(toX: number, toY: number): void {\n\t\tlet ey1 = truncPixel(this.y);\n\t\tlet ey2 = truncPixel(toY);\n\n\t\t// Vertical clipping\n\t\tif ((ey1 >= this.maxY && ey2 >= this.maxY) ||\n\t\t\t(ey1 < this.minY && ey2 < this.minY)) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet fy1 = fracPixel(this.y);\n\t\tlet fy2 = fracPixel(toY);\n\n\t\t// Single scanline case\n\t\tif (ey1 === ey2) {\n\t\t\tthis.renderScanline(ey1, this.x, fy1, toX, fy2);\n\t\t\treturn;\n\t\t}\n\n\t\tconst dx = toX - this.x;\n\t\tconst dy = toY - this.y;\n\n\t\t// Vertical line - optimized path\n\t\tif (dx === 0) {\n\t\t\tconst ex = truncPixel(this.x);\n\t\t\tconst twoFx = fracPixel(this.x) * 2;\n\n\t\t\tlet first: number;\n\t\t\tlet incr: number;\n\n\t\t\tif (dy > 0) {\n\t\t\t\tfirst = ONE_PIXEL;\n\t\t\t\tincr = 1;\n\t\t\t} else {\n\t\t\t\tfirst = 0;\n\t\t\t\tincr = -1;\n\t\t\t}\n\n\t\t\t// First partial scanline\n\t\t\tlet delta = first - fy1;\n\t\t\tthis.cells.setCurrentCell(this.x, ey1 << PIXEL_BITS);\n\t\t\tthis.cells.addArea(delta * twoFx, delta);\n\t\t\tey1 += incr;\n\n\t\t\t// Full scanlines\n\t\t\tthis.cells.setCurrentCell(this.x, ey1 << PIXEL_BITS);\n\t\t\tdelta = first + first - ONE_PIXEL;\n\t\t\twhile (ey1 !== ey2) {\n\t\t\t\tthis.cells.addArea(delta * twoFx, delta);\n\t\t\t\tey1 += incr;\n\t\t\t\tthis.cells.setCurrentCell(this.x, ey1 << PIXEL_BITS);\n\t\t\t}\n\n\t\t\t// Last partial scanline\n\t\t\tdelta = fy2 - ONE_PIXEL + first;\n\t\t\tthis.cells.addArea(delta * twoFx, delta);\n\t\t\treturn;\n\t\t}\n\n\t\t// General case: line crosses multiple scanlines\n\t\tlet x = this.x;\n\t\tlet incr: number;\n\t\tlet first: number;\n\n\t\tif (dy > 0) {\n\t\t\tfirst = ONE_PIXEL;\n\t\t\tincr = 1;\n\t\t} else {\n\t\t\tfirst = 0;\n\t\t\tincr = -1;\n\t\t}\n\n\t\t// First partial scanline\n\t\tlet delta = first - fy1;\n\t\tconst xDelta = this.mulDiv(dx, delta, abs(dy));\n\t\tlet x2 = x + xDelta;\n\n\t\tthis.renderScanline(ey1, x, fy1, x2, first);\n\t\tx = x2;\n\t\tey1 += incr;\n\n\t\tthis.cells.setCurrentCell(x, ey1 << PIXEL_BITS);\n\n\t\t// Full scanlines\n\t\tif (ey1 !== ey2) {\n\t\t\tconst xLift = this.mulDiv(dx, ONE_PIXEL, abs(dy));\n\t\t\tdelta = first + first - ONE_PIXEL;\n\n\t\t\twhile (ey1 !== ey2) {\n\t\t\t\tx2 = x + xLift;\n\t\t\t\tthis.renderScanline(ey1, x, ONE_PIXEL - first, x2, first);\n\t\t\t\tx = x2;\n\t\t\t\tey1 += incr;\n\t\t\t\tthis.cells.setCurrentCell(x, ey1 << PIXEL_BITS);\n\t\t\t}\n\t\t}\n\n\t\t// Last partial scanline\n\t\tdelta = fy2 - ONE_PIXEL + first;\n\t\tthis.renderScanline(ey1, x, ONE_PIXEL - first, toX, fy2);\n\t}\n\n\t/**\n\t * Render a line segment within a single scanline\n\t */\n\tprivate renderScanline(\n\t\tey: number,\n\t\tx1: number,\n\t\ty1: number,\n\t\tx2: number,\n\t\ty2: number,\n\t): void {\n\t\tconst ex1 = truncPixel(x1);\n\t\tconst ex2 = truncPixel(x2);\n\n\t\t// Trivial case: horizontal line\n\t\tif (y1 === y2) {\n\t\t\tthis.cells.setCurrentCell(x2, ey << PIXEL_BITS);\n\t\t\treturn;\n\t\t}\n\n\t\tconst fx1 = fracPixel(x1);\n\t\tconst fx2 = fracPixel(x2);\n\n\t\t// Single cell case\n\t\tif (ex1 === ex2) {\n\t\t\tconst delta = y2 - y1;\n\t\t\tthis.cells.setCurrentCell(x1, ey << PIXEL_BITS);\n\t\t\tthis.cells.addArea(delta * (fx1 + fx2), delta);\n\t\t\treturn;\n\t\t}\n\n\t\t// Multiple cells\n\t\tconst dx = x2 - x1;\n\t\tconst dy = y2 - y1;\n\n\t\tlet first: number;\n\t\tlet incr: number;\n\n\t\tif (dx > 0) {\n\t\t\tfirst = ONE_PIXEL;\n\t\t\tincr = 1;\n\t\t} else {\n\t\t\tfirst = 0;\n\t\t\tincr = -1;\n\t\t}\n\n\t\t// First cell\n\t\tlet delta = this.mulDiv(dy, (first - fx1), abs(dx));\n\t\tthis.cells.setCurrentCell(x1, ey << PIXEL_BITS);\n\t\tthis.cells.addArea(delta * (fx1 + first), delta);\n\n\t\tlet y = y1 + delta;\n\t\tlet ex = ex1 + incr;\n\t\tthis.cells.setCurrentCell(ex << PIXEL_BITS, ey << PIXEL_BITS);\n\n\t\t// Middle cells (full width)\n\t\tif (ex !== ex2) {\n\t\t\tconst yLift = this.mulDiv(dy, ONE_PIXEL, abs(dx));\n\n\t\t\twhile (ex !== ex2) {\n\t\t\t\tdelta = yLift;\n\t\t\t\tthis.cells.addArea(delta * ONE_PIXEL, delta);\n\t\t\t\ty += delta;\n\t\t\t\tex += incr;\n\t\t\t\tthis.cells.setCurrentCell(ex << PIXEL_BITS, ey << PIXEL_BITS);\n\t\t\t}\n\t\t}\n\n\t\t// Last cell\n\t\tdelta = y2 - y;\n\t\tthis.cells.addArea(delta * (fx2 + ONE_PIXEL - first), delta);\n\t}\n\n\t/**\n\t * Multiply and divide with 64-bit precision\n\t */\n\tprivate mulDiv(a: number, b: number, c: number): number {\n\t\tif (c === 0) return 0;\n\t\treturn Math.trunc((a * b) / c);\n\t}\n\n\t/**\n\t * Draw a quadratic Bezier curve using simple parametric sampling\n\t */\n\tconicTo(cx: number, cy: number, toX: number, toY: number): void {\n\t\tconst p0x = this.x;\n\t\tconst p0y = this.y;\n\n\t\t// Estimate number of segments based on curve length\n\t\tconst dx1 = cx - p0x;\n\t\tconst dy1 = cy - p0y;\n\t\tconst dx2 = toX - cx;\n\t\tconst dy2 = toY - cy;\n\t\tconst len = Math.sqrt(dx1 * dx1 + dy1 * dy1) + Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n\t\t// At least 4 segments, more for longer curves\n\t\tconst numSegments = Math.max(4, Math.ceil(len / (ONE_PIXEL * 4)));\n\n\t\tfor (let i = 1; i <= numSegments; i++) {\n\t\t\tconst t = i / numSegments;\n\t\t\tconst ti = 1 - t;\n\t\t\t// Quadratic bezier: B(t) = (1-t)P0 + 2(1-t)tP1 + tP2\n\t\t\tconst x = Math.round(ti * ti * p0x + 2 * ti * t * cx + t * t * toX);\n\t\t\tconst y = Math.round(ti * ti * p0y + 2 * ti * t * cy + t * t * toY);\n\t\t\tthis.renderLine(x, y);\n\t\t\t// Update current position for next segment\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tthis.x = toX;\n\t\tthis.y = toY;\n\t}\n\n\t/**\n\t * Draw a cubic Bezier curve\n\t */\n\tcubicTo(\n\t\tcx1: number,\n\t\tcy1: number,\n\t\tcx2: number,\n\t\tcy2: number,\n\t\tx: number,\n\t\ty: number,\n\t): void {\n\t\tthis.subdivCubic(this.x, this.y, cx1, cy1, cx2, cy2, x, y, 0);\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tprivate subdivCubic(\n\t\tx1: number,\n\t\ty1: number,\n\t\tcx1: number,\n\t\tcy1: number,\n\t\tcx2: number,\n\t\tcy2: number,\n\t\tx4: number,\n\t\ty4: number,\n\t\tlevel: number,\n\t): void {\n\t\tif (level > 16) {\n\t\t\tthis.renderLine(x4, y4);\n\t\t\tthis.x = x4;\n\t\t\tthis.y = y4;\n\t\t\treturn;\n\t\t}\n\n\t\t// De Casteljau midpoints\n\t\tconst x12 = (x1 + cx1) >> 1;\n\t\tconst y12 = (y1 + cy1) >> 1;\n\t\tconst x23 = (cx1 + cx2) >> 1;\n\t\tconst y23 = (cy1 + cy2) >> 1;\n\t\tconst x34 = (cx2 + x4) >> 1;\n\t\tconst y34 = (cy2 + y4) >> 1;\n\t\tconst x123 = (x12 + x23) >> 1;\n\t\tconst y123 = (y12 + y23) >> 1;\n\t\tconst x234 = (x23 + x34) >> 1;\n\t\tconst y234 = (y23 + y34) >> 1;\n\t\tconst x1234 = (x123 + x234) >> 1;\n\t\tconst y1234 = (y123 + y234) >> 1;\n\n\t\t// Flatness test\n\t\tconst dx = x4 - x1;\n\t\tconst dy = y4 - y1;\n\t\tconst d1 = abs((cx1 - x4) * dy - (cy1 - y4) * dx);\n\t\tconst d2 = abs((cx2 - x4) * dy - (cy2 - y4) * dx);\n\n\t\tif (d1 + d2 <= (ONE_PIXEL >> 1) * (abs(dx) + abs(dy))) {\n\t\t\tthis.renderLine(x4, y4);\n\t\t\tthis.x = x4;\n\t\t\tthis.y = y4;\n\t\t\treturn;\n\t\t}\n\n\t\tthis.subdivCubic(x1, y1, x12, y12, x123, y123, x1234, y1234, level + 1);\n\t\tthis.subdivCubic(x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1);\n\t}\n\n\t/**\n\t * Sweep all cells and render to bitmap\n\t *\n\t * Supports both top-down (positive pitch) and bottom-up (negative pitch) bitmaps.\n\t * For positive pitch: y=0 is at top of image (first row in buffer)\n\t * For negative pitch: y=0 is at bottom of image (last row in buffer)\n\t */\n\tsweep(bitmap: Bitmap, fillRule: FillRule = FillRuleEnum.NonZero): void {\n\t\t// Calculate origin offset for pitch direction\n\t\t// Positive pitch (top-down): origin at start of buffer\n\t\t// Negative pitch (bottom-up): origin at (rows-1)*|pitch| for y=0 to be at bottom\n\t\tconst pitch = bitmap.pitch;\n\t\tconst origin = pitch < 0 ? (bitmap.rows - 1) * -pitch : 0;\n\n\t\tfor (const { y, cells } of this.cells.iterateCells()) {\n\t\t\tif (y < 0 || y >= bitmap.rows) continue;\n\n\t\t\tlet cover = 0;\n\t\t\tlet x = 0;\n\t\t\t// For positive pitch: row = y * pitch (y=0 at top)\n\t\t\t// For negative pitch: row = origin - y * |pitch| (y=0 at bottom)\n\t\t\tconst row = pitch < 0 ? origin - y * -pitch : y * pitch;\n\n\t\t\tfor (const cell of cells) {\n\t\t\t\t// Fill span from previous x to current cell\n\t\t\t\tif (cell.x > x && cover !== 0) {\n\t\t\t\t\tconst gray = this.applyFillRule(cover, fillRule);\n\t\t\t\t\tif (gray > 0) {\n\t\t\t\t\t\tconst start = Math.max(0, x);\n\t\t\t\t\t\tconst end = Math.min(bitmap.width, cell.x);\n\t\t\t\t\t\tthis.fillSpan(bitmap, row, start, end, gray);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Compute anti-aliased coverage for this edge cell\n\t\t\t\t// FreeType: cover += cell->cover * (ONE_PIXEL * 2)\n\t\t\t\t//           area = cover - cell->area\n\t\t\t\t// The area is SUBTRACTED from scaled cover, not added\n\t\t\t\tconst scaledCover = cover * (ONE_PIXEL * 2);\n\t\t\t\tconst area = scaledCover - cell.area;\n\t\t\t\tconst gray = this.applyFillRule(area >> (PIXEL_BITS + 1), fillRule);\n\n\t\t\t\tif (gray > 0 && cell.x >= 0 && cell.x < bitmap.width) {\n\t\t\t\t\tthis.setPixel(bitmap, row, cell.x, gray);\n\t\t\t\t}\n\n\t\t\t\tcover += cell.cover;\n\t\t\t\tx = cell.x + 1;\n\t\t\t}\n\n\t\t\t// Fill remaining span\n\t\t\tif (x < bitmap.width && cover !== 0) {\n\t\t\t\tconst gray = this.applyFillRule(cover, fillRule);\n\t\t\t\tif (gray > 0) {\n\t\t\t\t\tthis.fillSpan(bitmap, row, x, bitmap.width, gray);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate applyFillRule(value: number, fillRule: FillRule): number {\n\t\tlet v = value;\n\t\tif (v < 0) v = -v;\n\n\t\tif (fillRule === FillRuleEnum.EvenOdd) {\n\t\t\tv &= 511;\n\t\t\tif (v > 256) v = 512 - v;\n\t\t}\n\n\t\treturn v > 255 ? 255 : v;\n\t}\n\n\tprivate fillSpan(\n\t\tbitmap: Bitmap,\n\t\trow: number,\n\t\tstart: number,\n\t\tend: number,\n\t\tgray: number,\n\t): void {\n\t\tif (bitmap.pixelMode === PixelMode.Gray) {\n\t\t\tfor (let x = start; x < end; x++) {\n\t\t\t\tbitmap.buffer[row + x] = gray;\n\t\t\t}\n\t\t} else if (bitmap.pixelMode === PixelMode.Mono) {\n\t\t\tif (gray >= 128) {\n\t\t\t\tfor (let x = start; x < end; x++) {\n\t\t\t\t\tconst byteIdx = row + (x >> 3);\n\t\t\t\t\tconst bitIdx = 7 - (x & 7);\n\t\t\t\t\tbitmap.buffer[byteIdx] |= 1 << bitIdx;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (bitmap.pixelMode === PixelMode.LCD) {\n\t\t\t// LCD mode: 3 bytes per pixel (RGB subpixels)\n\t\t\t// For now, write same coverage to all 3 subpixels\n\t\t\t// A proper implementation would use subpixel positioning\n\t\t\tfor (let x = start; x < end; x++) {\n\t\t\t\tconst idx = row + x * 3;\n\t\t\t\tbitmap.buffer[idx] = gray;\n\t\t\t\tbitmap.buffer[idx + 1] = gray;\n\t\t\t\tbitmap.buffer[idx + 2] = gray;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate setPixel(\n\t\tbitmap: Bitmap,\n\t\trow: number,\n\t\tx: number,\n\t\tgray: number,\n\t): void {\n\t\tif (bitmap.pixelMode === PixelMode.Gray) {\n\t\t\tbitmap.buffer[row + x] = gray;\n\t\t} else if (bitmap.pixelMode === PixelMode.Mono) {\n\t\t\tif (gray >= 128) {\n\t\t\t\tconst byteIdx = row + (x >> 3);\n\t\t\t\tconst bitIdx = 7 - (x & 7);\n\t\t\t\tbitmap.buffer[byteIdx] |= 1 << bitIdx;\n\t\t\t}\n\t\t} else if (bitmap.pixelMode === PixelMode.LCD) {\n\t\t\t// LCD mode: 3 bytes per pixel (RGB subpixels)\n\t\t\tconst idx = row + x * 3;\n\t\t\tbitmap.buffer[idx] = gray;\n\t\t\tbitmap.buffer[idx + 1] = gray;\n\t\t\tbitmap.buffer[idx + 2] = gray;\n\t\t}\n\t}\n\n\t/**\n\t * Sweep and call span callback (unbuffered)\n\t * @param callback Span callback function\n\t * @param fillRule Fill rule to apply\n\t * @param userData User data passed to callback (like FreeType's render_span_data)\n\t */\n\tsweepSpans<T = void>(\n\t\tcallback: (y: number, spans: Span[], userData: T) => void,\n\t\tfillRule: FillRule = FillRuleEnum.NonZero,\n\t\tuserData?: T,\n\t): void {\n\t\tfor (const { y, cells } of this.cells.iterateCells()) {\n\t\t\tconst spans: Span[] = [];\n\t\t\tlet cover = 0;\n\t\t\tlet spanStart = -1;\n\n\t\t\tfor (const cell of cells) {\n\t\t\t\t// If we have cover, emit span\n\t\t\t\tif (cover !== 0 && cell.x > spanStart + 1) {\n\t\t\t\t\tconst gray = this.applyFillRule(cover, fillRule);\n\t\t\t\t\tif (gray > 0) {\n\t\t\t\t\t\tspans.push({\n\t\t\t\t\t\t\tx: spanStart + 1,\n\t\t\t\t\t\t\tlen: cell.x - spanStart - 1,\n\t\t\t\t\t\t\tcoverage: gray,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Edge cell - area is SUBTRACTED from scaled cover\n\t\t\t\tconst scaledCover = cover * (ONE_PIXEL * 2);\n\t\t\t\tconst area = scaledCover - cell.area;\n\t\t\t\tconst gray = this.applyFillRule(area >> (PIXEL_BITS + 1), fillRule);\n\t\t\t\tif (gray > 0) {\n\t\t\t\t\tspans.push({ x: cell.x, len: 1, coverage: gray });\n\t\t\t\t}\n\n\t\t\t\tcover += cell.cover;\n\t\t\t\tspanStart = cell.x;\n\t\t\t}\n\n\t\t\tif (spans.length > 0) {\n\t\t\t\tcallback(y, spans, userData as T);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Sweep with span buffering (like FreeType's gray_sweep_direct)\n\t * Buffers up to 16 spans before flushing for better performance\n\t * @param callback Span callback function\n\t * @param fillRule Fill rule to apply\n\t * @param minX Minimum X clip bound\n\t * @param maxX Maximum X clip bound\n\t * @param userData User data passed to callback (like FreeType's render_span_data)\n\t */\n\tsweepDirect<T = void>(\n\t\tcallback: (y: number, spans: Span[], userData: T) => void,\n\t\tfillRule: FillRule = FillRuleEnum.NonZero,\n\t\tminX: number = 0,\n\t\tmaxX: number = Infinity,\n\t\tuserData?: T,\n\t): void {\n\t\tconst spanBuffer: Span[] = [];\n\n\t\tfor (const { y, cells } of this.cells.iterateCells()) {\n\t\t\tlet cover = 0;\n\t\t\tlet x = minX;\n\n\t\t\tfor (const cell of cells) {\n\t\t\t\t// Fill span from previous x to current cell\n\t\t\t\tif (cover !== 0 && cell.x > x) {\n\t\t\t\t\tconst gray = this.applyFillRule(cover, fillRule);\n\t\t\t\t\tif (gray > 0) {\n\t\t\t\t\t\tspanBuffer.push({ x, len: cell.x - x, coverage: gray });\n\t\t\t\t\t\tif (spanBuffer.length >= MAX_GRAY_SPANS) {\n\t\t\t\t\t\t\tcallback(y, spanBuffer.splice(0, spanBuffer.length), userData as T);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Edge cell - area is SUBTRACTED from scaled cover\n\t\t\t\tconst scaledCover = cover * (ONE_PIXEL * 2);\n\t\t\t\tconst area = scaledCover - cell.area;\n\t\t\t\tconst gray = this.applyFillRule(area >> (PIXEL_BITS + 1), fillRule);\n\t\t\t\tif (gray > 0 && cell.x >= minX && cell.x < maxX) {\n\t\t\t\t\tspanBuffer.push({ x: cell.x, len: 1, coverage: gray });\n\t\t\t\t\tif (spanBuffer.length >= MAX_GRAY_SPANS) {\n\t\t\t\t\t\tcallback(y, spanBuffer.splice(0, spanBuffer.length), userData as T);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcover += cell.cover;\n\t\t\t\tx = cell.x + 1;\n\t\t\t}\n\n\t\t\t// Fill remaining span\n\t\t\tif (cover !== 0 && x < maxX) {\n\t\t\t\tconst gray = this.applyFillRule(cover, fillRule);\n\t\t\t\tif (gray > 0) {\n\t\t\t\t\tspanBuffer.push({ x, len: Math.min(maxX, this.maxX + 1) - x, coverage: gray });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Flush remaining spans for this row\n\t\t\tif (spanBuffer.length > 0) {\n\t\t\t\tcallback(y, spanBuffer.splice(0, spanBuffer.length), userData as T);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Render with band processing for bounded memory.\n\t * Divides large glyphs into bands, retries with bisection on overflow.\n\t * Supports both Y-dimension (vertical) and X-dimension (horizontal) bisection\n\t * like FreeType's ftgrays.c gray_convert_glyph.\n\t *\n\t * @param bitmap Target bitmap\n\t * @param decomposeFn Function that decomposes outline to rasterizer commands\n\t * @param bounds Glyph bounds (minY, maxY, optionally minX, maxX)\n\t * @param fillRule Fill rule to apply\n\t */\n\trenderWithBands(\n\t\tbitmap: Bitmap,\n\t\tdecomposeFn: () => void,\n\t\tbounds: { minY: number; maxY: number; minX?: number; maxX?: number },\n\t\tfillRule: FillRule = FillRuleEnum.NonZero,\n\t): void {\n\t\t// Calculate initial band height based on pool size\n\t\t// Aim for bands that use ~1/8 of pool to leave room for overflow\n\t\tconst poolSize = 2048;\n\t\tconst height = bounds.maxY - bounds.minY;\n\t\tlet bandHeight = Math.max(1, Math.floor(poolSize / 8));\n\n\t\t// Adjust if glyph is small enough for single band\n\t\tif (height <= bandHeight) {\n\t\t\tbandHeight = height;\n\t\t}\n\n\t\t// X bounds default to bitmap width\n\t\tconst xMin = bounds.minX ?? 0;\n\t\tconst xMax = bounds.maxX ?? bitmap.width;\n\n\t\t// Stack for band bisection (like FreeType's bands[32])\n\t\t// Each band has Y bounds and X bounds for 2D bisection\n\t\tconst bandStack: Array<{\n\t\t\tminY: number;\n\t\t\tmaxY: number;\n\t\t\tminX: number;\n\t\t\tmaxX: number;\n\t\t}> = [];\n\n\t\t// Initial bands (full X range for each Y band)\n\t\tfor (let y = bounds.minY; y < bounds.maxY; y += bandHeight) {\n\t\t\tbandStack.push({\n\t\t\t\tminY: y,\n\t\t\t\tmaxY: Math.min(y + bandHeight, bounds.maxY),\n\t\t\t\tminX: xMin,\n\t\t\t\tmaxX: xMax,\n\t\t\t});\n\t\t}\n\n\t\t// Process bands with 2D bisection on overflow\n\t\tlet depth = 0;\n\t\twhile (bandStack.length > 0 && depth < MAX_BAND_DEPTH) {\n\t\t\tconst band = bandStack.pop()!;\n\n\t\t\tif (this.renderBandWithXClip(bitmap, decomposeFn, band.minY, band.maxY, band.minX, band.maxX, fillRule)) {\n\t\t\t\tcontinue; // Success\n\t\t\t}\n\n\t\t\t// Overflow - try X bisection first (like FreeType), then Y\n\t\t\tconst midX = (band.minX + band.maxX) >> 1;\n\t\t\tif (midX > band.minX) {\n\t\t\t\t// Bisect in X dimension\n\t\t\t\tbandStack.push({ minY: band.minY, maxY: band.maxY, minX: midX, maxX: band.maxX });\n\t\t\t\tbandStack.push({ minY: band.minY, maxY: band.maxY, minX: band.minX, maxX: midX });\n\t\t\t\tdepth++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// X can't be bisected, try Y\n\t\t\tconst midY = (band.minY + band.maxY) >> 1;\n\t\t\tif (midY > band.minY) {\n\t\t\t\t// Bisect in Y dimension\n\t\t\t\tbandStack.push({ minY: midY, maxY: band.maxY, minX: band.minX, maxX: band.maxX });\n\t\t\t\tbandStack.push({ minY: band.minY, maxY: midY, minX: band.minX, maxX: band.maxX });\n\t\t\t\tdepth++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Can't bisect in either dimension - rotten glyph\n\t\t\tconsole.warn(`Rasterizer: band overflow at (${band.minX},${band.minY}), cannot bisect further`);\n\t\t}\n\t}\n\n\t/**\n\t * Render a single band with X clipping\n\t * @returns true on success, false on pool overflow\n\t */\n\tprivate renderBandWithXClip(\n\t\tbitmap: Bitmap,\n\t\tdecomposeFn: () => void,\n\t\tminY: number,\n\t\tmaxY: number,\n\t\tminX: number,\n\t\tmaxX: number,\n\t\tfillRule: FillRule,\n\t): boolean {\n\t\t// Set up band bounds\n\t\tthis.cells.setBandBounds(minY, maxY);\n\t\tthis.cells.reset();\n\t\tthis.minY = minY;\n\t\tthis.maxY = maxY;\n\n\t\ttry {\n\t\t\t// Decompose outline (may throw PoolOverflowError)\n\t\t\tdecomposeFn();\n\n\t\t\t// Sweep and render to bitmap with X clipping\n\t\t\tthis.sweepBandWithXClip(bitmap, minY, maxY, minX, maxX, fillRule);\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\tif (e instanceof PoolOverflowError) {\n\t\t\t\treturn false; // Need to bisect\n\t\t\t}\n\t\t\tthrow e; // Re-throw other errors\n\t\t}\n\t}\n\n\t/**\n\t * Sweep a band with X clipping and render to bitmap\n\t */\n\tprivate sweepBandWithXClip(\n\t\tbitmap: Bitmap,\n\t\tminY: number,\n\t\tmaxY: number,\n\t\tminX: number,\n\t\tmaxX: number,\n\t\tfillRule: FillRule,\n\t): void {\n\t\tconst pitch = bitmap.pitch;\n\t\tconst origin = pitch < 0 ? (bitmap.rows - 1) * -pitch : 0;\n\n\t\tfor (let y = minY; y < maxY; y++) {\n\t\t\tif (y < 0 || y >= bitmap.rows) continue;\n\n\t\t\tlet cover = 0;\n\t\t\tlet x = minX;\n\t\t\tconst row = pitch < 0 ? origin - y * -pitch : y * pitch;\n\n\t\t\tfor (const cell of this.cells.iterateRowCells(y)) {\n\t\t\t\t// Skip cells outside X clip\n\t\t\t\tif (cell.x < minX) {\n\t\t\t\t\tcover += cell.cover;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cell.x >= maxX) {\n\t\t\t\t\t// Fill remaining clipped span\n\t\t\t\t\tif (cover !== 0 && x < maxX) {\n\t\t\t\t\t\tconst gray = this.applyFillRule(cover, fillRule);\n\t\t\t\t\t\tif (gray > 0) {\n\t\t\t\t\t\t\tthis.fillSpan(bitmap, row, Math.max(0, x), Math.min(bitmap.width, maxX), gray);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Fill span from previous x to current cell\n\t\t\t\tif (cell.x > x && cover !== 0) {\n\t\t\t\t\tconst gray = this.applyFillRule(cover, fillRule);\n\t\t\t\t\tif (gray > 0) {\n\t\t\t\t\t\tconst start = Math.max(0, x);\n\t\t\t\t\t\tconst end = Math.min(bitmap.width, cell.x);\n\t\t\t\t\t\tthis.fillSpan(bitmap, row, start, end, gray);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Edge cell anti-aliasing - area is SUBTRACTED from scaled cover\n\t\t\t\tconst scaledCover = cover * (ONE_PIXEL * 2);\n\t\t\t\tconst area = scaledCover - cell.area;\n\t\t\t\tconst gray = this.applyFillRule(area >> (PIXEL_BITS + 1), fillRule);\n\n\t\t\t\tif (gray > 0 && cell.x >= 0 && cell.x < bitmap.width) {\n\t\t\t\t\tthis.setPixel(bitmap, row, cell.x, gray);\n\t\t\t\t}\n\n\t\t\t\tcover += cell.cover;\n\t\t\t\tx = cell.x + 1;\n\t\t\t}\n\n\t\t\t// Fill remaining span within X clip\n\t\t\tif (x < maxX && x < bitmap.width && cover !== 0) {\n\t\t\t\tconst gray = this.applyFillRule(cover, fillRule);\n\t\t\t\tif (gray > 0) {\n\t\t\t\t\tthis.fillSpan(bitmap, row, x, Math.min(bitmap.width, maxX), gray);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n", "/**\n * Decompose path commands into rasterizer calls\n */\n\nimport { type PathCommand, type GlyphPath, OutlineFlags } from \"../render/path.ts\";\nimport type { GrayRaster } from \"./gray-raster.ts\";\nimport { ONE_PIXEL } from \"./fixed-point.ts\";\nimport { FillRule } from \"./types.ts\";\n\n/**\n * Outline validation error types (like FreeType's error codes)\n */\nexport enum OutlineError {\n\tOk = 0,\n\tInvalidOutline = 1,\n\tInvalidArgument = 2,\n\tEmptyOutline = 3,\n}\n\n/**\n * Validation result with error code and message\n */\nexport interface ValidationResult {\n\terror: OutlineError;\n\tmessage?: string;\n}\n\n/**\n * Validate a GlyphPath before rasterization (like FreeType's outline validation)\n *\n * Checks:\n * - Path is not null/undefined\n * - Commands array exists\n * - Path is not empty (unless allowEmpty is true)\n * - Command structure is valid\n * - Contours are properly closed (start with M, end with Z)\n */\nexport function validateOutline(\n\tpath: GlyphPath | null | undefined,\n\tallowEmpty: boolean = true,\n): ValidationResult {\n\t// Check for null/undefined path\n\tif (!path) {\n\t\treturn { error: OutlineError.InvalidOutline, message: \"Path is null or undefined\" };\n\t}\n\n\t// Check commands array exists\n\tif (!path.commands) {\n\t\treturn { error: OutlineError.InvalidOutline, message: \"Path commands array is missing\" };\n\t}\n\n\t// Check for empty path\n\tif (path.commands.length === 0) {\n\t\tif (allowEmpty) {\n\t\t\treturn { error: OutlineError.EmptyOutline };\n\t\t}\n\t\treturn { error: OutlineError.InvalidOutline, message: \"Path is empty\" };\n\t}\n\n\t// Validate command structure\n\tlet hasMove = false;\n\tlet inContour = false;\n\tlet contourCount = 0;\n\n\tfor (let i = 0; i < path.commands.length; i++) {\n\t\tconst cmd = path.commands[i]!;\n\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\":\n\t\t\t\tif (inContour) {\n\t\t\t\t\t// Implicit close - allowed but noted\n\t\t\t\t}\n\t\t\t\thasMove = true;\n\t\t\t\tinContour = true;\n\t\t\t\tcontourCount++;\n\t\t\t\t// Validate coordinates are finite numbers\n\t\t\t\tif (!isFinite(cmd.x) || !isFinite(cmd.y)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\terror: OutlineError.InvalidOutline,\n\t\t\t\t\t\tmessage: `Invalid coordinates at command ${i}: (${cmd.x}, ${cmd.y})`,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"L\":\n\t\t\t\tif (!hasMove) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\terror: OutlineError.InvalidOutline,\n\t\t\t\t\t\tmessage: `Line command at ${i} without preceding moveTo`,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (!isFinite(cmd.x) || !isFinite(cmd.y)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\terror: OutlineError.InvalidOutline,\n\t\t\t\t\t\tmessage: `Invalid coordinates at command ${i}`,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"Q\":\n\t\t\t\tif (!hasMove) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\terror: OutlineError.InvalidOutline,\n\t\t\t\t\t\tmessage: `Quadratic curve at ${i} without preceding moveTo`,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\t!isFinite(cmd.x1) ||\n\t\t\t\t\t!isFinite(cmd.y1) ||\n\t\t\t\t\t!isFinite(cmd.x) ||\n\t\t\t\t\t!isFinite(cmd.y)\n\t\t\t\t) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\terror: OutlineError.InvalidOutline,\n\t\t\t\t\t\tmessage: `Invalid coordinates at command ${i}`,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"C\":\n\t\t\t\tif (!hasMove) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\terror: OutlineError.InvalidOutline,\n\t\t\t\t\t\tmessage: `Cubic curve at ${i} without preceding moveTo`,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\t!isFinite(cmd.x1) ||\n\t\t\t\t\t!isFinite(cmd.y1) ||\n\t\t\t\t\t!isFinite(cmd.x2) ||\n\t\t\t\t\t!isFinite(cmd.y2) ||\n\t\t\t\t\t!isFinite(cmd.x) ||\n\t\t\t\t\t!isFinite(cmd.y)\n\t\t\t\t) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\terror: OutlineError.InvalidOutline,\n\t\t\t\t\t\tmessage: `Invalid coordinates at command ${i}`,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"Z\":\n\t\t\t\tinContour = false;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn {\n\t\t\t\t\terror: OutlineError.InvalidOutline,\n\t\t\t\t\tmessage: `Unknown command type at ${i}: ${(cmd as PathCommand).type}`,\n\t\t\t\t};\n\t\t}\n\t}\n\n\t// Warn if no contours found (valid but useless)\n\tif (contourCount === 0 && !allowEmpty) {\n\t\treturn { error: OutlineError.EmptyOutline, message: \"No contours in path\" };\n\t}\n\n\treturn { error: OutlineError.Ok };\n}\n\n/**\n * Convert a GlyphPath to rasterizer commands\n *\n * @param raster - The rasterizer instance\n * @param path - Path commands to decompose\n * @param scale - Scale factor (font units to pixels)\n * @param offsetX - X offset in pixels\n * @param offsetY - Y offset in pixels\n * @param flipY - Flip Y axis (font coords are Y-up)\n */\nexport function decomposePath(\n\traster: GrayRaster,\n\tpath: GlyphPath,\n\tscale: number,\n\toffsetX: number = 0,\n\toffsetY: number = 0,\n\tflipY: boolean = true,\n): void {\n\tlet startX = 0;\n\tlet startY = 0;\n\tlet inContour = false;\n\n\tfor (const cmd of path.commands) {\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\": {\n\t\t\t\t// Close previous contour if open\n\t\t\t\tif (inContour) {\n\t\t\t\t\traster.lineTo(startX, startY);\n\t\t\t\t}\n\n\t\t\t\t// Convert to subpixel coordinates\n\t\t\t\tconst x = toSubpixel(cmd.x, scale, offsetX);\n\t\t\t\tconst y = flipY\n\t\t\t\t\t? toSubpixelFlipY(cmd.y, scale, offsetY)\n\t\t\t\t\t: toSubpixel(cmd.y, scale, offsetY);\n\n\t\t\t\traster.moveTo(x, y);\n\t\t\t\tstartX = x;\n\t\t\t\tstartY = y;\n\t\t\t\tinContour = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"L\": {\n\t\t\t\tconst x = toSubpixel(cmd.x, scale, offsetX);\n\t\t\t\tconst y = flipY\n\t\t\t\t\t? toSubpixelFlipY(cmd.y, scale, offsetY)\n\t\t\t\t\t: toSubpixel(cmd.y, scale, offsetY);\n\n\t\t\t\traster.lineTo(x, y);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"Q\": {\n\t\t\t\tconst cx = toSubpixel(cmd.x1, scale, offsetX);\n\t\t\t\tconst cy = flipY\n\t\t\t\t\t? toSubpixelFlipY(cmd.y1, scale, offsetY)\n\t\t\t\t\t: toSubpixel(cmd.y1, scale, offsetY);\n\t\t\t\tconst x = toSubpixel(cmd.x, scale, offsetX);\n\t\t\t\tconst y = flipY\n\t\t\t\t\t? toSubpixelFlipY(cmd.y, scale, offsetY)\n\t\t\t\t\t: toSubpixel(cmd.y, scale, offsetY);\n\n\t\t\t\traster.conicTo(cx, cy, x, y);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"C\": {\n\t\t\t\tconst cx1 = toSubpixel(cmd.x1, scale, offsetX);\n\t\t\t\tconst cy1 = flipY\n\t\t\t\t\t? toSubpixelFlipY(cmd.y1, scale, offsetY)\n\t\t\t\t\t: toSubpixel(cmd.y1, scale, offsetY);\n\t\t\t\tconst cx2 = toSubpixel(cmd.x2, scale, offsetX);\n\t\t\t\tconst cy2 = flipY\n\t\t\t\t\t? toSubpixelFlipY(cmd.y2, scale, offsetY)\n\t\t\t\t\t: toSubpixel(cmd.y2, scale, offsetY);\n\t\t\t\tconst x = toSubpixel(cmd.x, scale, offsetX);\n\t\t\t\tconst y = flipY\n\t\t\t\t\t? toSubpixelFlipY(cmd.y, scale, offsetY)\n\t\t\t\t\t: toSubpixel(cmd.y, scale, offsetY);\n\n\t\t\t\traster.cubicTo(cx1, cy1, cx2, cy2, x, y);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"Z\": {\n\t\t\t\t// Close contour\n\t\t\t\tif (inContour) {\n\t\t\t\t\traster.lineTo(startX, startY);\n\t\t\t\t\tinContour = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Close final contour if still open\n\tif (inContour) {\n\t\traster.lineTo(startX, startY);\n\t}\n}\n\n/**\n * Convert font units to subpixel coordinates\n */\nfunction toSubpixel(value: number, scale: number, offset: number): number {\n\treturn Math.round((value * scale + offset) * ONE_PIXEL);\n}\n\n/**\n * Convert font units to subpixel coordinates with Y flip\n * Font coordinates are Y-up, bitmap is Y-down\n */\nfunction toSubpixelFlipY(value: number, scale: number, offset: number): number {\n\treturn Math.round((-value * scale + offset) * ONE_PIXEL);\n}\n\n/**\n * Calculate bounding box of path in pixel coordinates\n */\nexport function getPathBounds(\n\tpath: GlyphPath,\n\tscale: number,\n\tflipY: boolean = true,\n): { minX: number; minY: number; maxX: number; maxY: number } | null {\n\tif (!path.bounds) return null;\n\n\tconst b = path.bounds;\n\n\tif (flipY) {\n\t\treturn {\n\t\t\tminX: Math.floor(b.xMin * scale),\n\t\t\tminY: Math.floor(-b.yMax * scale),\n\t\t\tmaxX: Math.ceil(b.xMax * scale),\n\t\t\tmaxY: Math.ceil(-b.yMin * scale),\n\t\t};\n\t} else {\n\t\treturn {\n\t\t\tminX: Math.floor(b.xMin * scale),\n\t\t\tminY: Math.floor(b.yMin * scale),\n\t\t\tmaxX: Math.ceil(b.xMax * scale),\n\t\t\tmaxY: Math.ceil(b.yMax * scale),\n\t\t};\n\t}\n}\n\n/**\n * Get fill rule from outline flags (like FreeType's FT_OUTLINE_EVEN_ODD_FILL check)\n *\n * @param path Path with optional flags\n * @param defaultRule Default fill rule if flags not set\n * @returns Fill rule to use\n */\nexport function getFillRuleFromFlags(\n\tpath: GlyphPath | null | undefined,\n\tdefaultRule: FillRule = FillRule.NonZero,\n): FillRule {\n\tif (!path?.flags) return defaultRule;\n\treturn (path.flags & OutlineFlags.EvenOddFill) !== 0\n\t\t? FillRule.EvenOdd\n\t\t: FillRule.NonZero;\n}\n", "/**\n * TrueType Hinting Types\n *\n * Based on FreeType's ttinterp.h and ttobjs.h\n */\n\n/**\n * 26.6 fixed-point number (used for coordinates)\n */\nexport type F26Dot6 = number;\n\n/**\n * 2.14 fixed-point number (used for unit vectors)\n */\nexport type F2Dot14 = number;\n\n/**\n * Unit vector in 2.14 format\n */\nexport interface UnitVector {\n\tx: F2Dot14;\n\ty: F2Dot14;\n}\n\n/**\n * Point coordinate\n */\nexport interface Point {\n\tx: F26Dot6;\n\ty: F26Dot6;\n}\n\n/**\n * Rounding mode for ROUND instruction\n */\nexport enum RoundMode {\n\tToHalfGrid = 0,\n\tToGrid = 1,\n\tToDoubleGrid = 2,\n\tDownToGrid = 3,\n\tUpToGrid = 4,\n\tOff = 5,\n\tSuper = 6,\n\tSuper45 = 7,\n}\n\n/**\n * Touch flags for points\n */\nexport const enum TouchFlag {\n\tX = 0x01,\n\tY = 0x02,\n\tBoth = 0x03,\n}\n\n/**\n * Glyph zone - holds glyph points\n */\nexport interface GlyphZone {\n\t/** Number of points */\n\tnPoints: number;\n\t/** Number of contours */\n\tnContours: number;\n\t/** Original point positions (before hinting) */\n\torg: Point[];\n\t/** Current point positions (after hinting) */\n\tcur: Point[];\n\t/** Original unscaled positions */\n\torus: Point[];\n\t/** Touch flags per point */\n\ttags: Uint8Array;\n\t/** Contour end indices */\n\tcontours: Uint16Array;\n}\n\n/**\n * TrueType Graphics State\n *\n * Contains all state variables that control how instructions operate\n */\nexport interface GraphicsState {\n\t// Reference points\n\trp0: number;\n\trp1: number;\n\trp2: number;\n\n\t// Dual projection vector (for getting distances)\n\tdualVector: UnitVector;\n\t// Projection vector (direction along which we measure)\n\tprojVector: UnitVector;\n\t// Freedom vector (direction in which points can move)\n\tfreeVector: UnitVector;\n\n\t// Loop counter for repeated operations\n\tloop: number;\n\n\t// Minimum distance\n\tminimumDistance: F26Dot6;\n\n\t// Round state\n\troundState: RoundMode;\n\n\t// Auto flip for MIRP/MDRP\n\tautoFlip: boolean;\n\n\t// Control value cut-in\n\tcontrolValueCutIn: F26Dot6;\n\n\t// Single width cut-in\n\tsingleWidthCutIn: F26Dot6;\n\t// Single width value\n\tsingleWidthValue: F26Dot6;\n\n\t// Delta base (for DELTA instructions)\n\tdeltaBase: number;\n\t// Delta shift (for DELTA instructions)\n\tdeltaShift: number;\n\n\t// Instruction control flags\n\tinstructControl: number;\n\n\t// Scan control flags\n\tscanControl: number;\n\tscanType: number;\n\n\t// Zone pointers (0 = twilight, 1 = glyph)\n\tgep0: number;\n\tgep1: number;\n\tgep2: number;\n\n\t// Super rounding parameters\n\tperiod: F26Dot6;\n\tphase: F26Dot6;\n\tthreshold: F26Dot6;\n}\n\n/**\n * Create default graphics state\n */\nexport function createDefaultGraphicsState(): GraphicsState {\n\treturn {\n\t\trp0: 0,\n\t\trp1: 0,\n\t\trp2: 0,\n\t\tdualVector: { x: 0x4000, y: 0 }, // 1.0, 0.0 in 2.14\n\t\tprojVector: { x: 0x4000, y: 0 },\n\t\tfreeVector: { x: 0x4000, y: 0 },\n\t\tloop: 1,\n\t\tminimumDistance: 64, // 1 pixel in 26.6\n\t\troundState: RoundMode.ToGrid,\n\t\tautoFlip: true,\n\t\tcontrolValueCutIn: 68, // 17/16 pixel in 26.6\n\t\tsingleWidthCutIn: 0,\n\t\tsingleWidthValue: 0,\n\t\tdeltaBase: 9,\n\t\tdeltaShift: 3,\n\t\tinstructControl: 0,\n\t\tscanControl: 0,\n\t\tscanType: 0,\n\t\tgep0: 1,\n\t\tgep1: 1,\n\t\tgep2: 1,\n\t\tperiod: 64,\n\t\tphase: 0,\n\t\tthreshold: 32,\n\t};\n}\n\n/**\n * Function definition (from FDEF instruction)\n */\nexport interface FunctionDef {\n\t/** Function number */\n\tid: number;\n\t/** Start offset in bytecode */\n\tstart: number;\n\t/** End offset (just after ENDF) */\n\tend: number;\n\t/** Active (has been defined) */\n\tactive: boolean;\n\t/** Which code range */\n\trange: CodeRange;\n}\n\n/**\n * Instruction definition (from IDEF instruction)\n */\nexport interface InstructionDef {\n\t/** Opcode being redefined */\n\topcode: number;\n\t/** Start offset */\n\tstart: number;\n\t/** End offset */\n\tend: number;\n\t/** Active */\n\tactive: boolean;\n\t/** Code range */\n\trange: CodeRange;\n}\n\n/**\n * Code range type\n */\nexport enum CodeRange {\n\tNone = 0,\n\tFont = 1,  // fpgm table\n\tCVT = 2,   // prep table\n\tGlyph = 3, // glyph instructions\n}\n\n/**\n * Call stack record\n */\nexport interface CallRecord {\n\t/** Caller's instruction pointer */\n\tcallerIP: number;\n\t/** Caller's code range */\n\tcallerRange: CodeRange;\n\t/** Function definition */\n\tdef: FunctionDef;\n\t/** Loop count (for LOOPCALL) */\n\tcount: number;\n}\n\n/**\n * Execution context for the TrueType interpreter\n */\nexport interface ExecContext {\n\t// Graphics state\n\tGS: GraphicsState;\n\t// Default graphics state (reset after each glyph)\n\tdefaultGS: GraphicsState;\n\n\t// Zone pointers\n\tzp0: GlyphZone;\n\tzp1: GlyphZone;\n\tzp2: GlyphZone;\n\n\t// Twilight zone (synthetic points)\n\ttwilight: GlyphZone;\n\t// Glyph zone (actual glyph points)\n\tpts: GlyphZone;\n\n\t// Stack\n\tstack: Int32Array;\n\tstackTop: number;\n\n\t// Instruction pointer and code\n\tIP: number;\n\tcode: Uint8Array;\n\tcodeSize: number;\n\tcurrentRange: CodeRange;\n\n\t// Current opcode\n\topcode: number;\n\t// Number of arguments for current opcode\n\tnumArgs: number;\n\n\t// Control Value Table (scaled)\n\tcvt: Int32Array;\n\tcvtSize: number;\n\n\t// Storage area\n\tstorage: Int32Array;\n\tstorageSize: number;\n\n\t// Function definitions\n\tFDefs: FunctionDef[];\n\tmaxFDefs: number;\n\n\t// Instruction definitions\n\tIDefs: InstructionDef[];\n\tmaxIDefs: number;\n\n\t// Call stack\n\tcallStack: CallRecord[];\n\tcallStackTop: number;\n\tmaxCallStack: number;\n\n\t// Code ranges\n\tcodeRanges: Map<CodeRange, { code: Uint8Array; size: number }>;\n\n\t// Pixels per EM\n\tppem: number;\n\t// Point size\n\tpointSize: number;\n\n\t// Scale factor from font units to 26.6 pixels\n\tscale: number;\n\n\t// Error state\n\terror: string | null;\n\n\t// Instruction execution count (for infinite loop protection)\n\tinstructionCount: number;\n\tmaxInstructions: number;\n}\n\n/**\n * Create an empty glyph zone\n */\nexport function createGlyphZone(maxPoints: number, maxContours: number): GlyphZone {\n\treturn {\n\t\tnPoints: 0,\n\t\tnContours: 0,\n\t\torg: new Array(maxPoints).fill(null).map(() => ({ x: 0, y: 0 })),\n\t\tcur: new Array(maxPoints).fill(null).map(() => ({ x: 0, y: 0 })),\n\t\torus: new Array(maxPoints).fill(null).map(() => ({ x: 0, y: 0 })),\n\t\ttags: new Uint8Array(maxPoints),\n\t\tcontours: new Uint16Array(maxContours),\n\t};\n}\n\n/**\n * Create execution context\n */\nexport function createExecContext(\n\tmaxStack: number = 256,\n\tmaxStorage: number = 64,\n\tmaxFDefs: number = 64,\n\tmaxIDefs: number = 64,\n\tmaxCallStack: number = 32,\n\tmaxTwilightPoints: number = 16,\n): ExecContext {\n\tconst defaultGS = createDefaultGraphicsState();\n\n\treturn {\n\t\tGS: { ...defaultGS },\n\t\tdefaultGS,\n\n\t\tzp0: createGlyphZone(0, 0),\n\t\tzp1: createGlyphZone(0, 0),\n\t\tzp2: createGlyphZone(0, 0),\n\n\t\ttwilight: createGlyphZone(maxTwilightPoints, 1),\n\t\tpts: createGlyphZone(0, 0),\n\n\t\tstack: new Int32Array(maxStack),\n\t\tstackTop: 0,\n\n\t\tIP: 0,\n\t\tcode: new Uint8Array(0),\n\t\tcodeSize: 0,\n\t\tcurrentRange: CodeRange.None,\n\n\t\topcode: 0,\n\t\tnumArgs: 0,\n\n\t\tcvt: new Int32Array(0),\n\t\tcvtSize: 0,\n\n\t\tstorage: new Int32Array(maxStorage),\n\t\tstorageSize: maxStorage,\n\n\t\tFDefs: new Array(maxFDefs).fill(null).map((_, i) => ({\n\t\t\tid: i,\n\t\t\tstart: 0,\n\t\t\tend: 0,\n\t\t\tactive: false,\n\t\t\trange: CodeRange.None,\n\t\t})),\n\t\tmaxFDefs,\n\n\t\tIDefs: new Array(maxIDefs).fill(null).map((_, i) => ({\n\t\t\topcode: i,\n\t\t\tstart: 0,\n\t\t\tend: 0,\n\t\t\tactive: false,\n\t\t\trange: CodeRange.None,\n\t\t})),\n\t\tmaxIDefs,\n\n\t\tcallStack: new Array(maxCallStack).fill(null).map(() => ({\n\t\t\tcallerIP: 0,\n\t\t\tcallerRange: CodeRange.None,\n\t\t\tdef: { id: 0, start: 0, end: 0, active: false, range: CodeRange.None },\n\t\t\tcount: 0,\n\t\t})),\n\t\tcallStackTop: 0,\n\t\tmaxCallStack,\n\n\t\tcodeRanges: new Map(),\n\n\t\tppem: 12,\n\t\tpointSize: 12,\n\t\tscale: 1,\n\n\t\terror: null,\n\n\t\tinstructionCount: 0,\n\t\tmaxInstructions: 1000000,\n\t};\n}\n\n/**\n * TrueType Opcodes\n */\nexport const Opcode = {\n\t// Push instructions\n\tNPUSHB: 0x40,\n\tNPUSHW: 0x41,\n\tPUSHB_0: 0xb0,\n\tPUSHB_1: 0xb1,\n\tPUSHB_2: 0xb2,\n\tPUSHB_3: 0xb3,\n\tPUSHB_4: 0xb4,\n\tPUSHB_5: 0xb5,\n\tPUSHB_6: 0xb6,\n\tPUSHB_7: 0xb7,\n\tPUSHW_0: 0xb8,\n\tPUSHW_1: 0xb9,\n\tPUSHW_2: 0xba,\n\tPUSHW_3: 0xbb,\n\tPUSHW_4: 0xbc,\n\tPUSHW_5: 0xbd,\n\tPUSHW_6: 0xbe,\n\tPUSHW_7: 0xbf,\n\n\t// Storage instructions\n\tRS: 0x43,\n\tWS: 0x42,\n\n\t// CVT instructions\n\tRCVT: 0x45,\n\tWCVTP: 0x44,\n\tWCVTF: 0x70,\n\n\t// Stack operations\n\tDUP: 0x20,\n\tPOP: 0x21,\n\tCLEAR: 0x22,\n\tSWAP: 0x23,\n\tDEPTH: 0x24,\n\tCINDEX: 0x25,\n\tMINDEX: 0x26,\n\tROLL: 0x8a,\n\n\t// Arithmetic\n\tADD: 0x60,\n\tSUB: 0x61,\n\tDIV: 0x62,\n\tMUL: 0x63,\n\tABS: 0x64,\n\tNEG: 0x65,\n\tFLOOR: 0x66,\n\tCEILING: 0x67,\n\tMAX: 0x8b,\n\tMIN: 0x8c,\n\n\t// Comparison\n\tLT: 0x50,\n\tLTEQ: 0x51,\n\tGT: 0x52,\n\tGTEQ: 0x53,\n\tEQ: 0x54,\n\tNEQ: 0x55,\n\tODD: 0x56,\n\tEVEN: 0x57,\n\n\t// Logic\n\tAND: 0x5a,\n\tOR: 0x5b,\n\tNOT: 0x5c,\n\n\t// Control flow\n\tIF: 0x58,\n\tELSE: 0x1b,\n\tEIF: 0x59,\n\tJMPR: 0x1c,\n\tJROT: 0x78,\n\tJROF: 0x79,\n\n\t// Functions\n\tFDEF: 0x2c,\n\tENDF: 0x2d,\n\tCALL: 0x2b,\n\tLOOPCALL: 0x2a,\n\tIDEF: 0x89,\n\n\t// Graphics state - vectors\n\tSVTCA_Y: 0x00,\n\tSVTCA_X: 0x01,\n\tSPVTCA_Y: 0x02,\n\tSPVTCA_X: 0x03,\n\tSFVTCA_Y: 0x04,\n\tSFVTCA_X: 0x05,\n\tSPVTL_0: 0x06,\n\tSPVTL_1: 0x07,\n\tSFVTL_0: 0x08,\n\tSFVTL_1: 0x09,\n\tSDPVTL_0: 0x86,\n\tSDPVTL_1: 0x87,\n\tSPVFS: 0x0a,\n\tSFVFS: 0x0b,\n\tGPV: 0x0c,\n\tGFV: 0x0d,\n\tSFVTPV: 0x0e,\n\tISECT: 0x0f,\n\n\t// Graphics state - reference points\n\tSRP0: 0x10,\n\tSRP1: 0x11,\n\tSRP2: 0x12,\n\n\t// Graphics state - zone pointers\n\tSZP0: 0x13,\n\tSZP1: 0x14,\n\tSZP2: 0x15,\n\tSZPS: 0x16,\n\n\t// Graphics state - other\n\tSLOOP: 0x17,\n\tRTG: 0x18,\n\tRTHG: 0x19,\n\tSMD: 0x1a,\n\tRDTG: 0x7d,\n\tRUTG: 0x7c,\n\tROFF: 0x7a,\n\tSROUND: 0x76,\n\tS45ROUND: 0x77,\n\tSCVTCI: 0x1d,\n\tSSWCI: 0x1e,\n\tSSW: 0x1f,\n\tFLIPON: 0x4d,\n\tFLIPOFF: 0x4e,\n\tSANGW: 0x7e,\n\tSDB: 0x5e,\n\tSDS: 0x5f,\n\n\t// Point operations\n\tGC_0: 0x46,\n\tGC_1: 0x47,\n\tSCFS: 0x48,\n\tMD_0: 0x49,\n\tMD_1: 0x4a,\n\tMPPEM: 0x4b,\n\tMPS: 0x4c,\n\tFLIPPT: 0x80,\n\tFLIPRGON: 0x81,\n\tFLIPRGOFF: 0x82,\n\n\t// Point movement\n\tSHP_0: 0x32,\n\tSHP_1: 0x33,\n\tSHC_0: 0x34,\n\tSHC_1: 0x35,\n\tSHZ_0: 0x36,\n\tSHZ_1: 0x37,\n\tSHPIX: 0x38,\n\tIP: 0x39,\n\tMSIRP_0: 0x3a,\n\tMSIRP_1: 0x3b,\n\tALIGNRP: 0x3c,\n\tRTDG: 0x3d,\n\tMIAP_0: 0x3e,\n\tMIAP_1: 0x3f,\n\n\t// ALIGNPTS - Align Points\n\tALIGNPTS: 0x27,\n\n\t// UTP - UnTouch Point\n\tUTP: 0x29,\n\n\t// MDAP - Move Direct Absolute Point\n\tMDAP_0: 0x2e,\n\tMDAP_1: 0x2f,\n\n\t// IUP - Interpolate Untouched Points\n\tIUP_Y: 0x30,\n\tIUP_X: 0x31,\n\n\t// Delta instructions\n\tDELTAP1: 0x5d,\n\tDELTAP2: 0x71,\n\tDELTAP3: 0x72,\n\tDELTAC1: 0x73,\n\tDELTAC2: 0x74,\n\tDELTAC3: 0x75,\n\n\t// Rounding\n\tROUND_0: 0x68,\n\tROUND_1: 0x69,\n\tROUND_2: 0x6a,\n\tROUND_3: 0x6b,\n\tNROUND_0: 0x6c,\n\tNROUND_1: 0x6d,\n\tNROUND_2: 0x6e,\n\tNROUND_3: 0x6f,\n\n\t// Other\n\tGETINFO: 0x88,\n\tINSTCTRL: 0x8e,\n\tSCANCTRL: 0x85,\n\tSCANTYPE: 0x8d,\n\tAA: 0x7f,\n\tDEBUG: 0x4f,\n\n\t// MDRP - Move Direct Relative Point (32 variants: 0xc0-0xdf)\n\tMDRP_BASE: 0xc0,\n\n\t// MIRP - Move Indirect Relative Point (32 variants: 0xe0-0xff)\n\tMIRP_BASE: 0xe0,\n} as const;\n\n/**\n * Number of values popped from stack for each opcode\n */\nexport const OpcodePops: Record<number, number> = {\n\t[Opcode.RS]: 1,\n\t[Opcode.WS]: 2,\n\t[Opcode.RCVT]: 1,\n\t[Opcode.WCVTP]: 2,\n\t[Opcode.WCVTF]: 2,\n\t[Opcode.DUP]: 1,\n\t[Opcode.POP]: 1,\n\t[Opcode.CLEAR]: 0,\n\t[Opcode.SWAP]: 2,\n\t[Opcode.DEPTH]: 0,\n\t[Opcode.CINDEX]: 1,\n\t[Opcode.MINDEX]: 1,\n\t[Opcode.ROLL]: 3,\n\t[Opcode.ADD]: 2,\n\t[Opcode.SUB]: 2,\n\t[Opcode.DIV]: 2,\n\t[Opcode.MUL]: 2,\n\t[Opcode.ABS]: 1,\n\t[Opcode.NEG]: 1,\n\t[Opcode.FLOOR]: 1,\n\t[Opcode.CEILING]: 1,\n\t[Opcode.MAX]: 2,\n\t[Opcode.MIN]: 2,\n\t[Opcode.LT]: 2,\n\t[Opcode.LTEQ]: 2,\n\t[Opcode.GT]: 2,\n\t[Opcode.GTEQ]: 2,\n\t[Opcode.EQ]: 2,\n\t[Opcode.NEQ]: 2,\n\t[Opcode.ODD]: 1,\n\t[Opcode.EVEN]: 1,\n\t[Opcode.AND]: 2,\n\t[Opcode.OR]: 2,\n\t[Opcode.NOT]: 1,\n\t[Opcode.IF]: 1,\n\t[Opcode.JMPR]: 1,\n\t[Opcode.JROT]: 2,\n\t[Opcode.JROF]: 2,\n\t[Opcode.CALL]: 1,\n\t[Opcode.LOOPCALL]: 2,\n\t[Opcode.SRP0]: 1,\n\t[Opcode.SRP1]: 1,\n\t[Opcode.SRP2]: 1,\n\t[Opcode.SZP0]: 1,\n\t[Opcode.SZP1]: 1,\n\t[Opcode.SZP2]: 1,\n\t[Opcode.SZPS]: 1,\n\t[Opcode.SLOOP]: 1,\n\t[Opcode.SMD]: 1,\n\t[Opcode.SCVTCI]: 1,\n\t[Opcode.SSWCI]: 1,\n\t[Opcode.SSW]: 1,\n\t[Opcode.SDB]: 1,\n\t[Opcode.SDS]: 1,\n\t[Opcode.SPVFS]: 2,\n\t[Opcode.SFVFS]: 2,\n\t[Opcode.SPVTL_0]: 2,\n\t[Opcode.SPVTL_1]: 2,\n\t[Opcode.SFVTL_0]: 2,\n\t[Opcode.SFVTL_1]: 2,\n\t[Opcode.SCFS]: 2,\n\t[Opcode.GC_0]: 1,\n\t[Opcode.GC_1]: 1,\n\t[Opcode.MD_0]: 2,\n\t[Opcode.MD_1]: 2,\n\t[Opcode.ISECT]: 5,\n\t[Opcode.ALIGNRP]: 0, // Uses loop\n\t[Opcode.IP]: 0, // Uses loop\n\t[Opcode.SHPIX]: 1, // Plus loop points\n\t[Opcode.MSIRP_0]: 2,\n\t[Opcode.MSIRP_1]: 2,\n\t[Opcode.MIAP_0]: 2,\n\t[Opcode.MIAP_1]: 2,\n\t[Opcode.MDAP_0]: 1,\n\t[Opcode.MDAP_1]: 1,\n\t[Opcode.DELTAP1]: 1,\n\t[Opcode.DELTAP2]: 1,\n\t[Opcode.DELTAP3]: 1,\n\t[Opcode.DELTAC1]: 1,\n\t[Opcode.DELTAC2]: 1,\n\t[Opcode.DELTAC3]: 1,\n\t[Opcode.SROUND]: 1,\n\t[Opcode.S45ROUND]: 1,\n\t[Opcode.ROUND_0]: 1,\n\t[Opcode.ROUND_1]: 1,\n\t[Opcode.ROUND_2]: 1,\n\t[Opcode.ROUND_3]: 1,\n\t[Opcode.NROUND_0]: 1,\n\t[Opcode.NROUND_1]: 1,\n\t[Opcode.NROUND_2]: 1,\n\t[Opcode.NROUND_3]: 1,\n\t[Opcode.INSTCTRL]: 2,\n\t[Opcode.SCANCTRL]: 1,\n\t[Opcode.SCANTYPE]: 1,\n\t[Opcode.GETINFO]: 1,\n\t[Opcode.FLIPPT]: 0, // Uses loop\n\t[Opcode.FLIPRGON]: 2,\n\t[Opcode.FLIPRGOFF]: 2,\n};\n", "/**\n * Stack manipulation instructions\n */\n\nimport type { ExecContext } from \"../types.ts\";\n\n/** DUP - Duplicate top of stack */\nexport function DUP(ctx: ExecContext): void {\n\tconst val = ctx.stack[ctx.stackTop - 1]!;\n\tctx.stack[ctx.stackTop++] = val;\n}\n\n/** POP - Pop top of stack */\nexport function POP(ctx: ExecContext): void {\n\tctx.stackTop--;\n}\n\n/** CLEAR - Clear the entire stack */\nexport function CLEAR(ctx: ExecContext): void {\n\tctx.stackTop = 0;\n}\n\n/** SWAP - Swap top two elements */\nexport function SWAP(ctx: ExecContext): void {\n\tconst a = ctx.stack[ctx.stackTop - 1]!;\n\tconst b = ctx.stack[ctx.stackTop - 2]!;\n\tctx.stack[ctx.stackTop - 1] = b;\n\tctx.stack[ctx.stackTop - 2] = a;\n}\n\n/** DEPTH - Push stack depth */\nexport function DEPTH(ctx: ExecContext): void {\n\tconst depth = ctx.stackTop;\n\tctx.stack[ctx.stackTop++] = depth;\n}\n\n/** CINDEX - Copy indexed element to top */\nexport function CINDEX(ctx: ExecContext): void {\n\tconst index = ctx.stack[--ctx.stackTop]!;\n\tif (index <= 0 || index > ctx.stackTop) {\n\t\tctx.error = `CINDEX: invalid index ${index}`;\n\t\treturn;\n\t}\n\tctx.stack[ctx.stackTop++] = ctx.stack[ctx.stackTop - index]!;\n}\n\n/** MINDEX - Move indexed element to top */\nexport function MINDEX(ctx: ExecContext): void {\n\tconst index = ctx.stack[--ctx.stackTop]!;\n\tif (index <= 0 || index > ctx.stackTop) {\n\t\tctx.error = `MINDEX: invalid index ${index}`;\n\t\treturn;\n\t}\n\n\tconst val = ctx.stack[ctx.stackTop - index]!;\n\n\t// Shift elements down\n\tfor (let i = ctx.stackTop - index; i < ctx.stackTop - 1; i++) {\n\t\tctx.stack[i] = ctx.stack[i + 1]!;\n\t}\n\n\tctx.stack[ctx.stackTop - 1] = val;\n}\n\n/** ROLL - Roll top three elements */\nexport function ROLL(ctx: ExecContext): void {\n\tconst a = ctx.stack[ctx.stackTop - 1]!;\n\tconst b = ctx.stack[ctx.stackTop - 2]!;\n\tconst c = ctx.stack[ctx.stackTop - 3]!;\n\n\tctx.stack[ctx.stackTop - 1] = c;\n\tctx.stack[ctx.stackTop - 2] = a;\n\tctx.stack[ctx.stackTop - 3] = b;\n}\n\n/** Push byte(s) from instruction stream */\nexport function PUSHB(ctx: ExecContext, count: number): void {\n\tfor (let i = 0; i < count; i++) {\n\t\tctx.stack[ctx.stackTop++] = ctx.code[ctx.IP++]!;\n\t}\n}\n\n/** Push word(s) from instruction stream */\nexport function PUSHW(ctx: ExecContext, count: number): void {\n\tfor (let i = 0; i < count; i++) {\n\t\tconst hi = ctx.code[ctx.IP++]!;\n\t\tconst lo = ctx.code[ctx.IP++]!;\n\t\t// Sign extend\n\t\tlet val = (hi << 8) | lo;\n\t\tif (val >= 0x8000) val -= 0x10000;\n\t\tctx.stack[ctx.stackTop++] = val;\n\t}\n}\n\n/** NPUSHB - Push N bytes */\nexport function NPUSHB(ctx: ExecContext): void {\n\tconst n = ctx.code[ctx.IP++]!;\n\tPUSHB(ctx, n);\n}\n\n/** NPUSHW - Push N words */\nexport function NPUSHW(ctx: ExecContext): void {\n\tconst n = ctx.code[ctx.IP++]!;\n\tPUSHW(ctx, n);\n}\n", "/**\n * Arithmetic and logic instructions\n */\n\nimport type { ExecContext } from \"../types.ts\";\n\n/** ADD - Add top two values */\nexport function ADD(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop]!;\n\tconst a = ctx.stack[--ctx.stackTop]!;\n\tctx.stack[ctx.stackTop++] = a + b;\n}\n\n/** SUB - Subtract top two values */\nexport function SUB(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop]!;\n\tconst a = ctx.stack[--ctx.stackTop]!;\n\tctx.stack[ctx.stackTop++] = a - b;\n}\n\n/** DIV - Divide (26.6 fixed-point) */\nexport function DIV(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop]!;\n\tconst a = ctx.stack[--ctx.stackTop]!;\n\n\tif (b === 0) {\n\t\tctx.error = \"DIV: division by zero\";\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\n\t// Result is (a * 64) / b for 26.6 precision\n\tctx.stack[ctx.stackTop++] = Math.trunc((a * 64) / b);\n}\n\n/** MUL - Multiply (26.6 fixed-point) */\nexport function MUL(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop]!;\n\tconst a = ctx.stack[--ctx.stackTop]!;\n\n\t// Result is (a * b) / 64 for 26.6 precision\n\tctx.stack[ctx.stackTop++] = Math.trunc((a * b) / 64);\n}\n\n/** ABS - Absolute value */\nexport function ABS(ctx: ExecContext): void {\n\tconst val = ctx.stack[ctx.stackTop - 1]!;\n\tctx.stack[ctx.stackTop - 1] = val < 0 ? -val : val;\n}\n\n/** NEG - Negate */\nexport function NEG(ctx: ExecContext): void {\n\tctx.stack[ctx.stackTop - 1] = -ctx.stack[ctx.stackTop - 1]!;\n}\n\n/** FLOOR - Floor to 26.6 integer (multiple of 64) */\nexport function FLOOR(ctx: ExecContext): void {\n\tconst val = ctx.stack[ctx.stackTop - 1]!;\n\tctx.stack[ctx.stackTop - 1] = val & ~63;\n}\n\n/** CEILING - Ceiling to 26.6 integer (multiple of 64) */\nexport function CEILING(ctx: ExecContext): void {\n\tconst val = ctx.stack[ctx.stackTop - 1]!;\n\tctx.stack[ctx.stackTop - 1] = (val + 63) & ~63;\n}\n\n/** MAX - Maximum of top two */\nexport function MAX(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop]!;\n\tconst a = ctx.stack[--ctx.stackTop]!;\n\tctx.stack[ctx.stackTop++] = a > b ? a : b;\n}\n\n/** MIN - Minimum of top two */\nexport function MIN(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop]!;\n\tconst a = ctx.stack[--ctx.stackTop]!;\n\tctx.stack[ctx.stackTop++] = a < b ? a : b;\n}\n\n// Comparison instructions\n\n/** LT - Less than */\nexport function LT(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop]!;\n\tconst a = ctx.stack[--ctx.stackTop]!;\n\tctx.stack[ctx.stackTop++] = a < b ? 1 : 0;\n}\n\n/** LTEQ - Less than or equal */\nexport function LTEQ(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop]!;\n\tconst a = ctx.stack[--ctx.stackTop]!;\n\tctx.stack[ctx.stackTop++] = a <= b ? 1 : 0;\n}\n\n/** GT - Greater than */\nexport function GT(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop]!;\n\tconst a = ctx.stack[--ctx.stackTop]!;\n\tctx.stack[ctx.stackTop++] = a > b ? 1 : 0;\n}\n\n/** GTEQ - Greater than or equal */\nexport function GTEQ(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop]!;\n\tconst a = ctx.stack[--ctx.stackTop]!;\n\tctx.stack[ctx.stackTop++] = a >= b ? 1 : 0;\n}\n\n/** EQ - Equal */\nexport function EQ(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop]!;\n\tconst a = ctx.stack[--ctx.stackTop]!;\n\tctx.stack[ctx.stackTop++] = a === b ? 1 : 0;\n}\n\n/** NEQ - Not equal */\nexport function NEQ(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop]!;\n\tconst a = ctx.stack[--ctx.stackTop]!;\n\tctx.stack[ctx.stackTop++] = a !== b ? 1 : 0;\n}\n\n/** ODD - Test if odd (after rounding to pixels) */\nexport function ODD(ctx: ExecContext): void {\n\tconst val = ctx.stack[ctx.stackTop - 1]!;\n\t// Round to nearest pixel and test bit 6\n\tconst rounded = (val + 32) & ~63;\n\tctx.stack[ctx.stackTop - 1] = (rounded & 64) ? 1 : 0;\n}\n\n/** EVEN - Test if even (after rounding to pixels) */\nexport function EVEN(ctx: ExecContext): void {\n\tconst val = ctx.stack[ctx.stackTop - 1]!;\n\t// Round to nearest pixel and test bit 6\n\tconst rounded = (val + 32) & ~63;\n\tctx.stack[ctx.stackTop - 1] = (rounded & 64) ? 0 : 1;\n}\n\n// Logic instructions\n\n/** AND - Logical AND */\nexport function AND(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop]!;\n\tconst a = ctx.stack[--ctx.stackTop]!;\n\tctx.stack[ctx.stackTop++] = a && b ? 1 : 0;\n}\n\n/** OR - Logical OR */\nexport function OR(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop]!;\n\tconst a = ctx.stack[--ctx.stackTop]!;\n\tctx.stack[ctx.stackTop++] = a || b ? 1 : 0;\n}\n\n/** NOT - Logical NOT */\nexport function NOT(ctx: ExecContext): void {\n\tconst val = ctx.stack[ctx.stackTop - 1]!;\n\tctx.stack[ctx.stackTop - 1] = val ? 0 : 1;\n}\n", "/**\n * Control flow instructions\n */\n\nimport { type ExecContext, type FunctionDef, CodeRange } from \"../types.ts\";\n\n/** IF - Conditional branch */\nexport function IF(ctx: ExecContext): void {\n\tconst condition = ctx.stack[--ctx.stackTop]!;\n\n\tif (condition) {\n\t\t// Continue execution (true branch)\n\t\treturn;\n\t}\n\n\t// Skip to ELSE or EIF\n\tlet depth = 1;\n\n\twhile (ctx.IP < ctx.codeSize) {\n\t\tconst opcode = ctx.code[ctx.IP++]!;\n\n\t\tswitch (opcode) {\n\t\t\tcase 0x58: // IF\n\t\t\t\tdepth++;\n\t\t\t\tbreak;\n\t\t\tcase 0x1b: // ELSE\n\t\t\t\tif (depth === 1) {\n\t\t\t\t\t// Found matching ELSE, continue from here\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0x59: // EIF\n\t\t\t\tdepth--;\n\t\t\t\tif (depth === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// Skip push instructions\n\t\t\tcase 0x40: // NPUSHB\n\t\t\t\tctx.IP += 1 + ctx.code[ctx.IP]!;\n\t\t\t\tbreak;\n\t\t\tcase 0x41: // NPUSHW\n\t\t\t\tctx.IP += 1 + ctx.code[ctx.IP]! * 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (opcode >= 0xb0 && opcode <= 0xb7) {\n\t\t\t\t\t// PUSHB[n]\n\t\t\t\t\tctx.IP += (opcode - 0xb0) + 1;\n\t\t\t\t} else if (opcode >= 0xb8 && opcode <= 0xbf) {\n\t\t\t\t\t// PUSHW[n]\n\t\t\t\t\tctx.IP += ((opcode - 0xb8) + 1) * 2;\n\t\t\t\t}\n\t\t}\n\t}\n\n\tctx.error = \"IF: missing EIF\";\n}\n\n/** ELSE - Alternative branch */\nexport function ELSE(ctx: ExecContext): void {\n\t// We're in the true branch and hit ELSE, skip to EIF\n\tlet depth = 1;\n\n\twhile (ctx.IP < ctx.codeSize) {\n\t\tconst opcode = ctx.code[ctx.IP++]!;\n\n\t\tswitch (opcode) {\n\t\t\tcase 0x58: // IF\n\t\t\t\tdepth++;\n\t\t\t\tbreak;\n\t\t\tcase 0x59: // EIF\n\t\t\t\tdepth--;\n\t\t\t\tif (depth === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0x40: // NPUSHB\n\t\t\t\tctx.IP += 1 + ctx.code[ctx.IP]!;\n\t\t\t\tbreak;\n\t\t\tcase 0x41: // NPUSHW\n\t\t\t\tctx.IP += 1 + ctx.code[ctx.IP]! * 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (opcode >= 0xb0 && opcode <= 0xb7) {\n\t\t\t\t\tctx.IP += (opcode - 0xb0) + 1;\n\t\t\t\t} else if (opcode >= 0xb8 && opcode <= 0xbf) {\n\t\t\t\t\tctx.IP += ((opcode - 0xb8) + 1) * 2;\n\t\t\t\t}\n\t\t}\n\t}\n\n\tctx.error = \"ELSE: missing EIF\";\n}\n\n/** EIF - End IF */\nexport function EIF(_ctx: ExecContext): void {\n\t// Nothing to do - just a marker\n}\n\n/** JMPR - Jump relative */\nexport function JMPR(ctx: ExecContext): void {\n\tconst offset = ctx.stack[--ctx.stackTop]!;\n\tctx.IP += offset - 1; // -1 because IP was already incremented\n}\n\n/** JROT - Jump relative on true */\nexport function JROT(ctx: ExecContext): void {\n\tconst condition = ctx.stack[--ctx.stackTop]!;\n\tconst offset = ctx.stack[--ctx.stackTop]!;\n\n\tif (condition) {\n\t\tctx.IP += offset - 1;\n\t}\n}\n\n/** JROF - Jump relative on false */\nexport function JROF(ctx: ExecContext): void {\n\tconst condition = ctx.stack[--ctx.stackTop]!;\n\tconst offset = ctx.stack[--ctx.stackTop]!;\n\n\tif (!condition) {\n\t\tctx.IP += offset - 1;\n\t}\n}\n\n/** FDEF - Define function */\nexport function FDEF(ctx: ExecContext): void {\n\tconst funcNum = ctx.stack[--ctx.stackTop]!;\n\n\tif (funcNum < 0 || funcNum >= ctx.maxFDefs) {\n\t\tctx.error = `FDEF: invalid function number ${funcNum}`;\n\t\treturn;\n\t}\n\n\tconst def = ctx.FDefs[funcNum]!;\n\tdef.id = funcNum;\n\tdef.start = ctx.IP;\n\tdef.active = true;\n\tdef.range = ctx.currentRange;\n\n\t// Skip to ENDF\n\twhile (ctx.IP < ctx.codeSize) {\n\t\tconst opcode = ctx.code[ctx.IP++]!;\n\n\t\tif (opcode === 0x2d) {\n\t\t\t// ENDF\n\t\t\tdef.end = ctx.IP;\n\t\t\treturn;\n\t\t}\n\n\t\t// Skip push instructions\n\t\tif (opcode === 0x40) {\n\t\t\tctx.IP += 1 + ctx.code[ctx.IP]!;\n\t\t} else if (opcode === 0x41) {\n\t\t\tctx.IP += 1 + ctx.code[ctx.IP]! * 2;\n\t\t} else if (opcode >= 0xb0 && opcode <= 0xb7) {\n\t\t\tctx.IP += (opcode - 0xb0) + 1;\n\t\t} else if (opcode >= 0xb8 && opcode <= 0xbf) {\n\t\t\tctx.IP += ((opcode - 0xb8) + 1) * 2;\n\t\t}\n\t}\n\n\tctx.error = \"FDEF: missing ENDF\";\n}\n\n/** ENDF - End function definition */\nexport function ENDF(ctx: ExecContext): void {\n\t// Called when returning from function call\n\tif (ctx.callStackTop <= 0) {\n\t\tctx.error = \"ENDF: not in function call\";\n\t\treturn;\n\t}\n\n\tconst call = ctx.callStack[ctx.callStackTop - 1]!;\n\n\t// Decrement loop count for LOOPCALL\n\tcall.count--;\n\n\tif (call.count > 0) {\n\t\t// Loop again\n\t\tctx.IP = call.def.start;\n\t} else {\n\t\t// Return to caller\n\t\tctx.callStackTop--;\n\t\tctx.IP = call.callerIP;\n\t\tctx.currentRange = call.callerRange;\n\n\t\t// Restore code pointer\n\t\tconst range = ctx.codeRanges.get(ctx.currentRange);\n\t\tif (range) {\n\t\t\tctx.code = range.code;\n\t\t\tctx.codeSize = range.size;\n\t\t}\n\t}\n}\n\n/** CALL - Call function */\nexport function CALL(ctx: ExecContext): void {\n\tconst funcNum = ctx.stack[--ctx.stackTop]!;\n\n\tif (funcNum < 0 || funcNum >= ctx.maxFDefs) {\n\t\tctx.error = `CALL: invalid function number ${funcNum}`;\n\t\treturn;\n\t}\n\n\tconst def = ctx.FDefs[funcNum]!;\n\tif (!def.active) {\n\t\tctx.error = `CALL: function ${funcNum} not defined`;\n\t\treturn;\n\t}\n\n\tif (ctx.callStackTop >= ctx.maxCallStack) {\n\t\tctx.error = \"CALL: call stack overflow\";\n\t\treturn;\n\t}\n\n\t// Push call record\n\tconst call = ctx.callStack[ctx.callStackTop++]!;\n\tcall.callerIP = ctx.IP;\n\tcall.callerRange = ctx.currentRange;\n\tcall.def = def;\n\tcall.count = 1;\n\n\t// Switch to function's code range\n\tctx.currentRange = def.range;\n\tconst range = ctx.codeRanges.get(ctx.currentRange);\n\tif (range) {\n\t\tctx.code = range.code;\n\t\tctx.codeSize = range.size;\n\t}\n\tctx.IP = def.start;\n}\n\n/** LOOPCALL - Call function with loop count */\nexport function LOOPCALL(ctx: ExecContext): void {\n\tconst funcNum = ctx.stack[--ctx.stackTop]!;\n\tconst count = ctx.stack[--ctx.stackTop]!;\n\n\tif (funcNum < 0 || funcNum >= ctx.maxFDefs) {\n\t\tctx.error = `LOOPCALL: invalid function number ${funcNum}`;\n\t\treturn;\n\t}\n\n\tconst def = ctx.FDefs[funcNum]!;\n\tif (!def.active) {\n\t\tctx.error = `LOOPCALL: function ${funcNum} not defined`;\n\t\treturn;\n\t}\n\n\tif (count <= 0) {\n\t\treturn; // Nothing to do\n\t}\n\n\tif (ctx.callStackTop >= ctx.maxCallStack) {\n\t\tctx.error = \"LOOPCALL: call stack overflow\";\n\t\treturn;\n\t}\n\n\t// Push call record\n\tconst call = ctx.callStack[ctx.callStackTop++]!;\n\tcall.callerIP = ctx.IP;\n\tcall.callerRange = ctx.currentRange;\n\tcall.def = def;\n\tcall.count = count;\n\n\t// Switch to function's code range\n\tctx.currentRange = def.range;\n\tconst range = ctx.codeRanges.get(ctx.currentRange);\n\tif (range) {\n\t\tctx.code = range.code;\n\t\tctx.codeSize = range.size;\n\t}\n\tctx.IP = def.start;\n}\n\n/** IDEF - Define instruction */\nexport function IDEF(ctx: ExecContext): void {\n\tconst opcode = ctx.stack[--ctx.stackTop]!;\n\n\tif (opcode < 0 || opcode >= ctx.maxIDefs) {\n\t\tctx.error = `IDEF: invalid opcode ${opcode}`;\n\t\treturn;\n\t}\n\n\tconst def = ctx.IDefs[opcode]!;\n\tdef.opcode = opcode;\n\tdef.start = ctx.IP;\n\tdef.active = true;\n\tdef.range = ctx.currentRange;\n\n\t// Skip to ENDF\n\twhile (ctx.IP < ctx.codeSize) {\n\t\tconst op = ctx.code[ctx.IP++]!;\n\n\t\tif (op === 0x2d) {\n\t\t\t// ENDF\n\t\t\tdef.end = ctx.IP;\n\t\t\treturn;\n\t\t}\n\n\t\t// Skip push instructions\n\t\tif (op === 0x40) {\n\t\t\tctx.IP += 1 + ctx.code[ctx.IP]!;\n\t\t} else if (op === 0x41) {\n\t\t\tctx.IP += 1 + ctx.code[ctx.IP]! * 2;\n\t\t} else if (op >= 0xb0 && op <= 0xb7) {\n\t\t\tctx.IP += (op - 0xb0) + 1;\n\t\t} else if (op >= 0xb8 && op <= 0xbf) {\n\t\t\tctx.IP += ((op - 0xb8) + 1) * 2;\n\t\t}\n\t}\n\n\tctx.error = \"IDEF: missing ENDF\";\n}\n", "/**\n * TrueType rounding functions\n *\n * These implement the various rounding modes used by the interpreter.\n */\n\nimport { type F26Dot6, RoundMode, type GraphicsState } from \"./types.ts\";\n\n/**\n * Round to grid (nearest integer pixel)\n */\nexport function roundToGrid(distance: F26Dot6, compensation: F26Dot6): F26Dot6 {\n\tif (distance >= 0) {\n\t\treturn ((distance + 32 + compensation) & -64);\n\t} else {\n\t\treturn -(((-distance + 32 + compensation) & -64));\n\t}\n}\n\n/**\n * Round to half grid (nearest half pixel)\n */\nexport function roundToHalfGrid(distance: F26Dot6, compensation: F26Dot6): F26Dot6 {\n\tif (distance >= 0) {\n\t\treturn ((distance + 32 + compensation) & -64) + 32;\n\t} else {\n\t\treturn -((((-distance + 32 + compensation) & -64) + 32));\n\t}\n}\n\n/**\n * Round to double grid (nearest half pixel boundary)\n */\nexport function roundToDoubleGrid(distance: F26Dot6, compensation: F26Dot6): F26Dot6 {\n\tif (distance >= 0) {\n\t\treturn ((distance + 16 + compensation) & -32);\n\t} else {\n\t\treturn -(((-distance + 16 + compensation) & -32));\n\t}\n}\n\n/**\n * Round down to grid (floor to pixel)\n */\nexport function roundDownToGrid(distance: F26Dot6, compensation: F26Dot6): F26Dot6 {\n\tif (distance >= 0) {\n\t\treturn ((distance + compensation) & -64);\n\t} else {\n\t\treturn -(((compensation - distance) & -64));\n\t}\n}\n\n/**\n * Round up to grid (ceiling to pixel)\n */\nexport function roundUpToGrid(distance: F26Dot6, compensation: F26Dot6): F26Dot6 {\n\tif (distance >= 0) {\n\t\treturn ((distance + 63 + compensation) & -64);\n\t} else {\n\t\treturn -(((63 + compensation - distance) & -64));\n\t}\n}\n\n/**\n * No rounding\n */\nexport function roundOff(distance: F26Dot6, _compensation: F26Dot6): F26Dot6 {\n\treturn distance;\n}\n\n/**\n * Super rounding (parametric rounding)\n */\nexport function roundSuper(\n\tdistance: F26Dot6,\n\tcompensation: F26Dot6,\n\tGS: GraphicsState,\n): F26Dot6 {\n\tconst { period, phase, threshold } = GS;\n\n\tif (distance >= 0) {\n\t\tconst val = (distance + threshold - phase + compensation) & -period;\n\t\treturn val + phase;\n\t} else {\n\t\tconst val = ((-distance + threshold - phase + compensation) & -period);\n\t\treturn -(val + phase);\n\t}\n}\n\n/**\n * Super rounding 45 degrees (for diagonal lines)\n */\nexport function roundSuper45(\n\tdistance: F26Dot6,\n\tcompensation: F26Dot6,\n\tGS: GraphicsState,\n): F26Dot6 {\n\t// Same as super rounding but with 45-degree adjusted period\n\t// Period is multiplied by sqrt(2)/2  0.707\n\tconst { period, phase, threshold } = GS;\n\tconst period45 = Math.round(period * 46 / 64); // sqrt(2)/2  46/64\n\n\tif (distance >= 0) {\n\t\tconst val = (distance + threshold - phase + compensation) & -period45;\n\t\treturn val + phase;\n\t} else {\n\t\tconst val = ((-distance + threshold - phase + compensation) & -period45);\n\t\treturn -(val + phase);\n\t}\n}\n\n/**\n * Apply current rounding mode\n */\nexport function round(\n\tdistance: F26Dot6,\n\tcompensation: F26Dot6,\n\tGS: GraphicsState,\n): F26Dot6 {\n\tswitch (GS.roundState) {\n\t\tcase RoundMode.ToGrid:\n\t\t\treturn roundToGrid(distance, compensation);\n\t\tcase RoundMode.ToHalfGrid:\n\t\t\treturn roundToHalfGrid(distance, compensation);\n\t\tcase RoundMode.ToDoubleGrid:\n\t\t\treturn roundToDoubleGrid(distance, compensation);\n\t\tcase RoundMode.DownToGrid:\n\t\t\treturn roundDownToGrid(distance, compensation);\n\t\tcase RoundMode.UpToGrid:\n\t\t\treturn roundUpToGrid(distance, compensation);\n\t\tcase RoundMode.Off:\n\t\t\treturn roundOff(distance, compensation);\n\t\tcase RoundMode.Super:\n\t\t\treturn roundSuper(distance, compensation, GS);\n\t\tcase RoundMode.Super45:\n\t\t\treturn roundSuper45(distance, compensation, GS);\n\t\tdefault:\n\t\t\treturn roundToGrid(distance, compensation);\n\t}\n}\n\n/**\n * Parse SROUND/S45ROUND selector byte\n */\nexport function parseSuperRound(selector: number, GS: GraphicsState): void {\n\t// Period selection (bits 6-7)\n\tswitch ((selector >> 6) & 0x03) {\n\t\tcase 0:\n\t\t\tGS.period = 32; // 1/2 pixel\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tGS.period = 64; // 1 pixel\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tGS.period = 128; // 2 pixels\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Reserved\n\t\t\tGS.period = 64;\n\t}\n\n\t// Phase selection (bits 4-5)\n\tswitch ((selector >> 4) & 0x03) {\n\t\tcase 0:\n\t\t\tGS.phase = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tGS.phase = GS.period >> 2; // period/4\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tGS.phase = GS.period >> 1; // period/2\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tGS.phase = (GS.period * 3) >> 2; // 3*period/4\n\t\t\tbreak;\n\t}\n\n\t// Threshold selection (bits 0-3)\n\tconst thresholdBits = selector & 0x0f;\n\tif (thresholdBits === 0) {\n\t\tGS.threshold = GS.period - 1;\n\t} else {\n\t\tGS.threshold = ((thresholdBits - 4) * GS.period) >> 3;\n\t}\n}\n\n/**\n * Compensate distance for engine characteristics\n * Used with ROUND and movement instructions\n */\nexport function compensate(distance: F26Dot6, GS: GraphicsState): F26Dot6 {\n\t// Engine compensation is typically 0 for modern displays\n\t// But some fonts depend on it for grid-fitting\n\treturn 0;\n}\n", "/**\n * Graphics state manipulation instructions\n */\n\nimport { type ExecContext, RoundMode, type UnitVector, TouchFlag } from \"../types.ts\";\nimport { parseSuperRound } from \"../rounding.ts\";\n\n// Vector instructions\n\n/** SVTCA - Set vectors to coordinate axis (both projection and freedom) */\nexport function SVTCA(ctx: ExecContext, axis: 0 | 1): void {\n\tif (axis === 0) {\n\t\t// Y axis\n\t\tctx.GS.projVector = { x: 0, y: 0x4000 };\n\t\tctx.GS.freeVector = { x: 0, y: 0x4000 };\n\t\tctx.GS.dualVector = { x: 0, y: 0x4000 };\n\t} else {\n\t\t// X axis\n\t\tctx.GS.projVector = { x: 0x4000, y: 0 };\n\t\tctx.GS.freeVector = { x: 0x4000, y: 0 };\n\t\tctx.GS.dualVector = { x: 0x4000, y: 0 };\n\t}\n}\n\n/** SPVTCA - Set projection vector to coordinate axis */\nexport function SPVTCA(ctx: ExecContext, axis: 0 | 1): void {\n\tif (axis === 0) {\n\t\tctx.GS.projVector = { x: 0, y: 0x4000 };\n\t\tctx.GS.dualVector = { x: 0, y: 0x4000 };\n\t} else {\n\t\tctx.GS.projVector = { x: 0x4000, y: 0 };\n\t\tctx.GS.dualVector = { x: 0x4000, y: 0 };\n\t}\n}\n\n/** SFVTCA - Set freedom vector to coordinate axis */\nexport function SFVTCA(ctx: ExecContext, axis: 0 | 1): void {\n\tif (axis === 0) {\n\t\tctx.GS.freeVector = { x: 0, y: 0x4000 };\n\t} else {\n\t\tctx.GS.freeVector = { x: 0x4000, y: 0 };\n\t}\n}\n\n/** Calculate unit vector from two points */\nfunction vectorFromPoints(ctx: ExecContext, p1: number, p2: number, zone1: number, zone2: number): UnitVector {\n\tconst z1 = zone1 === 0 ? ctx.twilight : ctx.pts;\n\tconst z2 = zone2 === 0 ? ctx.twilight : ctx.pts;\n\n\tconst pt1 = z1.cur[p1];\n\tconst pt2 = z2.cur[p2];\n\n\tif (!pt1 || !pt2) {\n\t\treturn { x: 0x4000, y: 0 };\n\t}\n\n\tconst dx = pt2.x - pt1.x;\n\tconst dy = pt2.y - pt1.y;\n\n\tconst len = Math.sqrt(dx * dx + dy * dy);\n\tif (len === 0) {\n\t\treturn { x: 0x4000, y: 0 };\n\t}\n\n\treturn {\n\t\tx: Math.round((dx / len) * 0x4000),\n\t\ty: Math.round((dy / len) * 0x4000),\n\t};\n}\n\n/** SPVTL - Set projection vector to line */\nexport function SPVTL(ctx: ExecContext, perpendicular: boolean): void {\n\tconst p2 = ctx.stack[--ctx.stackTop]!;\n\tconst p1 = ctx.stack[--ctx.stackTop]!;\n\n\tlet vec = vectorFromPoints(ctx, p1, p2, ctx.GS.gep1, ctx.GS.gep2);\n\n\tif (perpendicular) {\n\t\t// Rotate 90 degrees\n\t\tconst temp = vec.x;\n\t\tvec.x = vec.y;\n\t\tvec.y = -temp;\n\t}\n\n\tctx.GS.projVector = vec;\n\tctx.GS.dualVector = vec;\n}\n\n/** SFVTL - Set freedom vector to line */\nexport function SFVTL(ctx: ExecContext, perpendicular: boolean): void {\n\tconst p2 = ctx.stack[--ctx.stackTop]!;\n\tconst p1 = ctx.stack[--ctx.stackTop]!;\n\n\tlet vec = vectorFromPoints(ctx, p1, p2, ctx.GS.gep1, ctx.GS.gep2);\n\n\tif (perpendicular) {\n\t\tconst temp = vec.x;\n\t\tvec.x = vec.y;\n\t\tvec.y = -temp;\n\t}\n\n\tctx.GS.freeVector = vec;\n}\n\n/** SDPVTL - Set dual projection vector to line (only sets dualVector, not projVector) */\nexport function SDPVTL(ctx: ExecContext, perpendicular: boolean): void {\n\tconst p2 = ctx.stack[--ctx.stackTop]!;\n\tconst p1 = ctx.stack[--ctx.stackTop]!;\n\n\tlet vec = vectorFromPoints(ctx, p1, p2, ctx.GS.gep1, ctx.GS.gep2);\n\n\tif (perpendicular) {\n\t\tconst temp = vec.x;\n\t\tvec.x = vec.y;\n\t\tvec.y = -temp;\n\t}\n\n\t// SDPVTL only sets dualVector (used for measuring original distances)\n\t// Unlike SPVTL which sets both projVector and dualVector\n\tctx.GS.dualVector = vec;\n}\n\n/** SPVFS - Set projection vector from stack */\nexport function SPVFS(ctx: ExecContext): void {\n\tconst y = ctx.stack[--ctx.stackTop]!;\n\tconst x = ctx.stack[--ctx.stackTop]!;\n\n\t// Normalize\n\tconst len = Math.sqrt(x * x + y * y);\n\tif (len === 0) {\n\t\tctx.GS.projVector = { x: 0x4000, y: 0 };\n\t} else {\n\t\tctx.GS.projVector = {\n\t\t\tx: Math.round((x / len) * 0x4000),\n\t\t\ty: Math.round((y / len) * 0x4000),\n\t\t};\n\t}\n\tctx.GS.dualVector = { ...ctx.GS.projVector };\n}\n\n/** SFVFS - Set freedom vector from stack */\nexport function SFVFS(ctx: ExecContext): void {\n\tconst y = ctx.stack[--ctx.stackTop]!;\n\tconst x = ctx.stack[--ctx.stackTop]!;\n\n\tconst len = Math.sqrt(x * x + y * y);\n\tif (len === 0) {\n\t\tctx.GS.freeVector = { x: 0x4000, y: 0 };\n\t} else {\n\t\tctx.GS.freeVector = {\n\t\t\tx: Math.round((x / len) * 0x4000),\n\t\t\ty: Math.round((y / len) * 0x4000),\n\t\t};\n\t}\n}\n\n/** GPV - Get projection vector */\nexport function GPV(ctx: ExecContext): void {\n\tctx.stack[ctx.stackTop++] = ctx.GS.projVector.x;\n\tctx.stack[ctx.stackTop++] = ctx.GS.projVector.y;\n}\n\n/** GFV - Get freedom vector */\nexport function GFV(ctx: ExecContext): void {\n\tctx.stack[ctx.stackTop++] = ctx.GS.freeVector.x;\n\tctx.stack[ctx.stackTop++] = ctx.GS.freeVector.y;\n}\n\n/** SFVTPV - Set freedom vector to projection vector */\nexport function SFVTPV(ctx: ExecContext): void {\n\tctx.GS.freeVector = { ...ctx.GS.projVector };\n}\n\n// Reference point instructions\n\n/** SRP0 - Set reference point 0 */\nexport function SRP0(ctx: ExecContext): void {\n\tctx.GS.rp0 = ctx.stack[--ctx.stackTop]!;\n}\n\n/** SRP1 - Set reference point 1 */\nexport function SRP1(ctx: ExecContext): void {\n\tctx.GS.rp1 = ctx.stack[--ctx.stackTop]!;\n}\n\n/** SRP2 - Set reference point 2 */\nexport function SRP2(ctx: ExecContext): void {\n\tctx.GS.rp2 = ctx.stack[--ctx.stackTop]!;\n}\n\n// Zone pointer instructions\n\n/** SZP0 - Set zone pointer 0 */\nexport function SZP0(ctx: ExecContext): void {\n\tconst zone = ctx.stack[--ctx.stackTop]!;\n\tif (zone !== 0 && zone !== 1) {\n\t\tctx.error = `SZP0: invalid zone ${zone}`;\n\t\treturn;\n\t}\n\tctx.GS.gep0 = zone;\n\tctx.zp0 = zone === 0 ? ctx.twilight : ctx.pts;\n}\n\n/** SZP1 - Set zone pointer 1 */\nexport function SZP1(ctx: ExecContext): void {\n\tconst zone = ctx.stack[--ctx.stackTop]!;\n\tif (zone !== 0 && zone !== 1) {\n\t\tctx.error = `SZP1: invalid zone ${zone}`;\n\t\treturn;\n\t}\n\tctx.GS.gep1 = zone;\n\tctx.zp1 = zone === 0 ? ctx.twilight : ctx.pts;\n}\n\n/** SZP2 - Set zone pointer 2 */\nexport function SZP2(ctx: ExecContext): void {\n\tconst zone = ctx.stack[--ctx.stackTop]!;\n\tif (zone !== 0 && zone !== 1) {\n\t\tctx.error = `SZP2: invalid zone ${zone}`;\n\t\treturn;\n\t}\n\tctx.GS.gep2 = zone;\n\tctx.zp2 = zone === 0 ? ctx.twilight : ctx.pts;\n}\n\n/** SZPS - Set all zone pointers */\nexport function SZPS(ctx: ExecContext): void {\n\tconst zone = ctx.stack[--ctx.stackTop]!;\n\tif (zone !== 0 && zone !== 1) {\n\t\tctx.error = `SZPS: invalid zone ${zone}`;\n\t\treturn;\n\t}\n\tctx.GS.gep0 = zone;\n\tctx.GS.gep1 = zone;\n\tctx.GS.gep2 = zone;\n\tconst z = zone === 0 ? ctx.twilight : ctx.pts;\n\tctx.zp0 = z;\n\tctx.zp1 = z;\n\tctx.zp2 = z;\n}\n\n// Other graphics state\n\n/** SLOOP - Set loop counter */\nexport function SLOOP(ctx: ExecContext): void {\n\tconst count = ctx.stack[--ctx.stackTop]!;\n\tif (count <= 0) {\n\t\tctx.error = `SLOOP: invalid count ${count}`;\n\t\treturn;\n\t}\n\tctx.GS.loop = count;\n}\n\n/** SMD - Set minimum distance */\nexport function SMD(ctx: ExecContext): void {\n\tctx.GS.minimumDistance = ctx.stack[--ctx.stackTop]!;\n}\n\n/** SCVTCI - Set control value table cut-in */\nexport function SCVTCI(ctx: ExecContext): void {\n\tctx.GS.controlValueCutIn = ctx.stack[--ctx.stackTop]!;\n}\n\n/** SSWCI - Set single width cut-in */\nexport function SSWCI(ctx: ExecContext): void {\n\tctx.GS.singleWidthCutIn = ctx.stack[--ctx.stackTop]!;\n}\n\n/** SSW - Set single width value */\nexport function SSW(ctx: ExecContext): void {\n\tctx.GS.singleWidthValue = ctx.stack[--ctx.stackTop]!;\n}\n\n/** SDB - Set delta base */\nexport function SDB(ctx: ExecContext): void {\n\tctx.GS.deltaBase = ctx.stack[--ctx.stackTop]!;\n}\n\n/** SDS - Set delta shift */\nexport function SDS(ctx: ExecContext): void {\n\tctx.GS.deltaShift = ctx.stack[--ctx.stackTop]!;\n}\n\n// Rounding state\n\n/** RTG - Round to grid */\nexport function RTG(ctx: ExecContext): void {\n\tctx.GS.roundState = RoundMode.ToGrid;\n}\n\n/** RTHG - Round to half grid */\nexport function RTHG(ctx: ExecContext): void {\n\tctx.GS.roundState = RoundMode.ToHalfGrid;\n}\n\n/** RTDG - Round to double grid */\nexport function RTDG(ctx: ExecContext): void {\n\tctx.GS.roundState = RoundMode.ToDoubleGrid;\n}\n\n/** RDTG - Round down to grid */\nexport function RDTG(ctx: ExecContext): void {\n\tctx.GS.roundState = RoundMode.DownToGrid;\n}\n\n/** RUTG - Round up to grid */\nexport function RUTG(ctx: ExecContext): void {\n\tctx.GS.roundState = RoundMode.UpToGrid;\n}\n\n/** ROFF - Rounding off */\nexport function ROFF(ctx: ExecContext): void {\n\tctx.GS.roundState = RoundMode.Off;\n}\n\n/** SROUND - Super round */\nexport function SROUND(ctx: ExecContext): void {\n\tconst selector = ctx.stack[--ctx.stackTop]!;\n\tparseSuperRound(selector, ctx.GS);\n\tctx.GS.roundState = RoundMode.Super;\n}\n\n/** S45ROUND - Super round 45 degrees */\nexport function S45ROUND(ctx: ExecContext): void {\n\tconst selector = ctx.stack[--ctx.stackTop]!;\n\tparseSuperRound(selector, ctx.GS);\n\tctx.GS.roundState = RoundMode.Super45;\n}\n\n// Flip auto-flip\n\n/** FLIPON - Turn auto-flip on */\nexport function FLIPON(ctx: ExecContext): void {\n\tctx.GS.autoFlip = true;\n}\n\n/** FLIPOFF - Turn auto-flip off */\nexport function FLIPOFF(ctx: ExecContext): void {\n\tctx.GS.autoFlip = false;\n}\n\n// Scan and instruction control\n\n/** SCANCTRL - Set scan conversion control */\nexport function SCANCTRL(ctx: ExecContext): void {\n\tctx.GS.scanControl = ctx.stack[--ctx.stackTop]!;\n}\n\n/** SCANTYPE - Set scan type */\nexport function SCANTYPE(ctx: ExecContext): void {\n\tctx.GS.scanType = ctx.stack[--ctx.stackTop]!;\n}\n\n/** INSTCTRL - Set instruction control */\nexport function INSTCTRL(ctx: ExecContext): void {\n\tconst selector = ctx.stack[--ctx.stackTop]!;\n\tconst value = ctx.stack[--ctx.stackTop]!;\n\n\t// Bit 0: inhibit grid-fitting\n\t// Bit 1: ignore CVT values\n\tif (selector === 1 || selector === 2) {\n\t\tif (value) {\n\t\t\tctx.GS.instructControl |= selector;\n\t\t} else {\n\t\t\tctx.GS.instructControl &= ~selector;\n\t\t}\n\t}\n}\n\n/** GETINFO - Get font engine info */\nexport function GETINFO(ctx: ExecContext): void {\n\tconst selector = ctx.stack[--ctx.stackTop]!;\n\tlet result = 0;\n\n\t// Bit 0: version (we claim version 35 = Windows 95)\n\tif (selector & 1) {\n\t\tresult |= 35;\n\t}\n\n\t// Bit 1: glyph rotated\n\t// Bit 2: glyph stretched\n\n\t// Bit 5: grayscale rendering\n\tif (selector & 32) {\n\t\tresult |= 1 << 12;\n\t}\n\n\t// Bit 6: ClearType enabled\n\t// Bit 7: backwards compatible mode\n\n\tctx.stack[ctx.stackTop++] = result;\n}\n\n// Storage and CVT\n\n/** RS - Read storage */\nexport function RS(ctx: ExecContext): void {\n\tconst index = ctx.stack[--ctx.stackTop]!;\n\tif (index < 0 || index >= ctx.storageSize) {\n\t\tctx.error = `RS: invalid index ${index}`;\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\tctx.stack[ctx.stackTop++] = ctx.storage[index]!;\n}\n\n/** WS - Write storage */\nexport function WS(ctx: ExecContext): void {\n\tconst value = ctx.stack[--ctx.stackTop]!;\n\tconst index = ctx.stack[--ctx.stackTop]!;\n\tif (index < 0 || index >= ctx.storageSize) {\n\t\tctx.error = `WS: invalid index ${index}`;\n\t\treturn;\n\t}\n\tctx.storage[index] = value;\n}\n\n/** RCVT - Read CVT value */\nexport function RCVT(ctx: ExecContext): void {\n\tconst index = ctx.stack[--ctx.stackTop]!;\n\tif (index < 0 || index >= ctx.cvtSize) {\n\t\tctx.error = `RCVT: invalid index ${index}`;\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\tctx.stack[ctx.stackTop++] = ctx.cvt[index]!;\n}\n\n/** WCVTP - Write CVT value in pixels */\nexport function WCVTP(ctx: ExecContext): void {\n\tconst value = ctx.stack[--ctx.stackTop]!;\n\tconst index = ctx.stack[--ctx.stackTop]!;\n\tif (index < 0 || index >= ctx.cvtSize) {\n\t\tctx.error = `WCVTP: invalid index ${index}`;\n\t\treturn;\n\t}\n\tctx.cvt[index] = value;\n}\n\n/** WCVTF - Write CVT value in font units */\nexport function WCVTF(ctx: ExecContext): void {\n\tconst value = ctx.stack[--ctx.stackTop]!;\n\tconst index = ctx.stack[--ctx.stackTop]!;\n\tif (index < 0 || index >= ctx.cvtSize) {\n\t\tctx.error = `WCVTF: invalid index ${index}`;\n\t\treturn;\n\t}\n\t// Convert from font units to pixels (26.6)\n\tctx.cvt[index] = Math.round(value * ctx.scale);\n}\n\n/** UTP - UnTouch Point */\nexport function UTP(ctx: ExecContext): void {\n\tconst pointIndex = ctx.stack[--ctx.stackTop]!;\n\tconst zone = ctx.zp0;\n\n\tif (pointIndex < 0 || pointIndex >= zone.nPoints) {\n\t\tctx.error = `UTP: invalid point ${pointIndex}`;\n\t\treturn;\n\t}\n\n\t// Clear touch flags based on freedom vector direction\n\tconst fv = ctx.GS.freeVector;\n\tif (fv.y !== 0) {\n\t\tzone.tags[pointIndex] &= ~TouchFlag.Y;\n\t}\n\tif (fv.x !== 0) {\n\t\tzone.tags[pointIndex] &= ~TouchFlag.X;\n\t}\n}\n", "/**\n * Point movement instructions\n *\n * These are the core hinting operations that actually move glyph points.\n */\n\nimport {\n\ttype ExecContext,\n\ttype GlyphZone,\n\ttype F26Dot6,\n\ttype Point,\n\tTouchFlag,\n} from \"../types.ts\";\nimport { round, compensate } from \"../rounding.ts\";\n\n/**\n * Project a point onto the projection vector\n */\nexport function project(ctx: ExecContext, p: Point): F26Dot6 {\n\treturn (\n\t\t(p.x * ctx.GS.projVector.x + p.y * ctx.GS.projVector.y + 0x2000) >> 14\n\t);\n}\n\n/**\n * Project using dual vector (for original positions)\n */\nexport function dualProject(ctx: ExecContext, p: Point): F26Dot6 {\n\treturn (\n\t\t(p.x * ctx.GS.dualVector.x + p.y * ctx.GS.dualVector.y + 0x2000) >> 14\n\t);\n}\n\n/**\n * Move a point along the freedom vector\n */\nexport function movePoint(\n\tctx: ExecContext,\n\tzone: GlyphZone,\n\tpointIndex: number,\n\tdistance: F26Dot6,\n): void {\n\tconst pt = zone.cur[pointIndex]!;\n\n\t// Calculate movement along freedom vector\n\t// freedom vector is in 2.14 format, so divide by 0x4000\n\tconst fv = ctx.GS.freeVector;\n\tconst pv = ctx.GS.projVector;\n\n\t// Calculate dot product of freedom and projection vectors\n\tconst dot = ((fv.x * pv.x + fv.y * pv.y + 0x2000) >> 14);\n\n\tif (dot === 0) {\n\t\t// Vectors are perpendicular, can't move\n\t\treturn;\n\t}\n\n\t// Scale distance by freedom/projection relationship\n\tconst dx = Math.round((distance * fv.x) / dot);\n\tconst dy = Math.round((distance * fv.y) / dot);\n\n\tpt.x += dx;\n\tpt.y += dy;\n}\n\n/**\n * Get current position of a point projected onto projection vector\n */\nexport function getCurrent(\n\tctx: ExecContext,\n\tzone: GlyphZone,\n\tpointIndex: number,\n): F26Dot6 {\n\tconst pt = zone.cur[pointIndex];\n\tif (!pt) return 0;\n\treturn project(ctx, pt);\n}\n\n/**\n * Get original position of a point projected onto dual vector\n */\nexport function getOriginal(\n\tctx: ExecContext,\n\tzone: GlyphZone,\n\tpointIndex: number,\n): F26Dot6 {\n\tconst pt = zone.org[pointIndex];\n\tif (!pt) return 0;\n\treturn dualProject(ctx, pt);\n}\n\n/**\n * Mark point as touched in the current direction\n */\nexport function touchPoint(ctx: ExecContext, zone: GlyphZone, pointIndex: number): void {\n\t// Set touch flag based on freedom vector direction\n\tconst fv = ctx.GS.freeVector;\n\tif (fv.y !== 0) {\n\t\tzone.tags[pointIndex] |= TouchFlag.Y;\n\t}\n\tif (fv.x !== 0) {\n\t\tzone.tags[pointIndex] |= TouchFlag.X;\n\t}\n}\n\n// =============================================================================\n// MDAP - Move Direct Absolute Point\n// =============================================================================\n\n/** MDAP - Move Direct Absolute Point */\nexport function MDAP(ctx: ExecContext, doRound: boolean): void {\n\tconst pointIndex = ctx.stack[--ctx.stackTop]!;\n\n\tconst zone = ctx.zp0;\n\tif (pointIndex < 0 || pointIndex >= zone.nPoints) {\n\t\tctx.error = `MDAP: invalid point ${pointIndex}`;\n\t\treturn;\n\t}\n\n\tlet distance = getCurrent(ctx, zone, pointIndex);\n\n\tif (doRound) {\n\t\tconst comp = compensate(distance, ctx.GS);\n\t\tdistance = round(distance, comp, ctx.GS) - distance;\n\t} else {\n\t\tdistance = 0;\n\t}\n\n\tmovePoint(ctx, zone, pointIndex, distance);\n\ttouchPoint(ctx, zone, pointIndex);\n\n\tctx.GS.rp0 = pointIndex;\n\tctx.GS.rp1 = pointIndex;\n}\n\n// =============================================================================\n// MIAP - Move Indirect Absolute Point\n// =============================================================================\n\n/** MIAP - Move Indirect Absolute Point (uses CVT) */\nexport function MIAP(ctx: ExecContext, doRound: boolean): void {\n\tconst cvtIndex = ctx.stack[--ctx.stackTop]!;\n\tconst pointIndex = ctx.stack[--ctx.stackTop]!;\n\n\tconst zone = ctx.zp0;\n\tif (pointIndex < 0 || pointIndex >= zone.nPoints) {\n\t\tctx.error = `MIAP: invalid point ${pointIndex}`;\n\t\treturn;\n\t}\n\n\tif (cvtIndex < 0 || cvtIndex >= ctx.cvtSize) {\n\t\tctx.error = `MIAP: invalid CVT index ${cvtIndex}`;\n\t\treturn;\n\t}\n\n\tlet cvtDistance = ctx.cvt[cvtIndex]!;\n\tlet currentPos = getCurrent(ctx, zone, pointIndex);\n\n\tif (doRound) {\n\t\t// Check if we should use CVT value or current position\n\t\tconst diff = Math.abs(cvtDistance - currentPos);\n\n\t\tif (diff > ctx.GS.controlValueCutIn) {\n\t\t\t// Difference too large, use current position\n\t\t\tcvtDistance = currentPos;\n\t\t}\n\n\t\tconst comp = compensate(cvtDistance, ctx.GS);\n\t\tcvtDistance = round(cvtDistance, comp, ctx.GS);\n\t}\n\n\tconst distance = cvtDistance - currentPos;\n\tmovePoint(ctx, zone, pointIndex, distance);\n\ttouchPoint(ctx, zone, pointIndex);\n\n\tctx.GS.rp0 = pointIndex;\n\tctx.GS.rp1 = pointIndex;\n}\n\n// =============================================================================\n// MDRP - Move Direct Relative Point\n// =============================================================================\n\n/** MDRP - Move Direct Relative Point */\nexport function MDRP(ctx: ExecContext, flags: number): void {\n\tconst pointIndex = ctx.stack[--ctx.stackTop]!;\n\n\tconst setRp0 = (flags & 0x10) !== 0;\n\tconst keepMinDist = (flags & 0x08) !== 0;\n\tconst doRound = (flags & 0x04) !== 0;\n\t// bits 0-1 are distance type (ignored for now)\n\n\tconst zp0 = ctx.zp0;\n\tconst zp1 = ctx.zp1;\n\n\tif (pointIndex < 0 || pointIndex >= zp1.nPoints) {\n\t\tctx.error = `MDRP: invalid point ${pointIndex}`;\n\t\treturn;\n\t}\n\n\tconst rp0 = ctx.GS.rp0;\n\tif (rp0 < 0 || rp0 >= zp0.nPoints) {\n\t\tctx.error = `MDRP: invalid rp0 ${rp0}`;\n\t\treturn;\n\t}\n\n\t// Get original distance (using dual projection vector)\n\tlet distance = getOriginal(ctx, zp1, pointIndex) - getOriginal(ctx, zp0, rp0);\n\n\t// Auto-flip if enabled and distance is negative\n\tif (ctx.GS.autoFlip && distance < 0) {\n\t\tdistance = -distance;\n\t}\n\n\tif (doRound) {\n\t\tconst comp = compensate(distance, ctx.GS);\n\t\tdistance = round(distance, comp, ctx.GS);\n\t}\n\n\t// Apply minimum distance\n\tif (keepMinDist) {\n\t\tif (distance >= 0) {\n\t\t\tif (distance < ctx.GS.minimumDistance) {\n\t\t\t\tdistance = ctx.GS.minimumDistance;\n\t\t\t}\n\t\t} else {\n\t\t\tif (distance > -ctx.GS.minimumDistance) {\n\t\t\t\tdistance = -ctx.GS.minimumDistance;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate actual movement needed\n\tconst currentDist =\n\t\tgetCurrent(ctx, zp1, pointIndex) - getCurrent(ctx, zp0, rp0);\n\tconst move = distance - currentDist;\n\n\tmovePoint(ctx, zp1, pointIndex, move);\n\ttouchPoint(ctx, zp1, pointIndex);\n\n\tctx.GS.rp1 = ctx.GS.rp0;\n\tctx.GS.rp2 = pointIndex;\n\tif (setRp0) {\n\t\tctx.GS.rp0 = pointIndex;\n\t}\n}\n\n// =============================================================================\n// MIRP - Move Indirect Relative Point\n// =============================================================================\n\n/** MIRP - Move Indirect Relative Point (uses CVT) */\nexport function MIRP(ctx: ExecContext, flags: number): void {\n\tconst cvtIndex = ctx.stack[--ctx.stackTop]!;\n\tconst pointIndex = ctx.stack[--ctx.stackTop]!;\n\n\tconst setRp0 = (flags & 0x10) !== 0;\n\tconst keepMinDist = (flags & 0x08) !== 0;\n\tconst doRound = (flags & 0x04) !== 0;\n\t// bits 0-1 are distance type (ignored for now)\n\n\tconst zp0 = ctx.zp0;\n\tconst zp1 = ctx.zp1;\n\n\tif (pointIndex < 0 || pointIndex >= zp1.nPoints) {\n\t\tctx.error = `MIRP: invalid point ${pointIndex}`;\n\t\treturn;\n\t}\n\n\tif (cvtIndex < 0 || cvtIndex >= ctx.cvtSize) {\n\t\tctx.error = `MIRP: invalid CVT index ${cvtIndex}`;\n\t\treturn;\n\t}\n\n\tconst rp0 = ctx.GS.rp0;\n\tif (rp0 < 0 || rp0 >= zp0.nPoints) {\n\t\tctx.error = `MIRP: invalid rp0 ${rp0}`;\n\t\treturn;\n\t}\n\n\t// Get original distance for comparison\n\tlet orgDist = getOriginal(ctx, zp1, pointIndex) - getOriginal(ctx, zp0, rp0);\n\n\t// Get CVT distance\n\tlet cvtDist = ctx.cvt[cvtIndex]!;\n\n\t// Auto-flip\n\tif (ctx.GS.autoFlip) {\n\t\tif ((orgDist < 0 && cvtDist > 0) || (orgDist > 0 && cvtDist < 0)) {\n\t\t\tcvtDist = -cvtDist;\n\t\t}\n\t}\n\n\t// Check control value cut-in\n\tconst diff = Math.abs(orgDist - cvtDist);\n\tlet distance: F26Dot6;\n\n\tif (diff > ctx.GS.controlValueCutIn) {\n\t\t// Use original distance\n\t\tdistance = orgDist;\n\t} else {\n\t\t// Use CVT distance\n\t\tdistance = cvtDist;\n\t}\n\n\tif (doRound) {\n\t\tconst comp = compensate(distance, ctx.GS);\n\t\tdistance = round(distance, comp, ctx.GS);\n\t}\n\n\t// Apply minimum distance\n\tif (keepMinDist) {\n\t\tif (orgDist >= 0) {\n\t\t\tif (distance < ctx.GS.minimumDistance) {\n\t\t\t\tdistance = ctx.GS.minimumDistance;\n\t\t\t}\n\t\t} else {\n\t\t\tif (distance > -ctx.GS.minimumDistance) {\n\t\t\t\tdistance = -ctx.GS.minimumDistance;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate actual movement needed\n\tconst currentDist =\n\t\tgetCurrent(ctx, zp1, pointIndex) - getCurrent(ctx, zp0, rp0);\n\tconst move = distance - currentDist;\n\n\tmovePoint(ctx, zp1, pointIndex, move);\n\ttouchPoint(ctx, zp1, pointIndex);\n\n\tctx.GS.rp1 = ctx.GS.rp0;\n\tctx.GS.rp2 = pointIndex;\n\tif (setRp0) {\n\t\tctx.GS.rp0 = pointIndex;\n\t}\n}\n\n// =============================================================================\n// SHP - Shift Point\n// =============================================================================\n\n/** SHP - Shift Point using reference point */\nexport function SHP(ctx: ExecContext, useRp1: boolean): void {\n\tconst refZone = useRp1 ? ctx.zp0 : ctx.zp1;\n\tconst refPoint = useRp1 ? ctx.GS.rp1 : ctx.GS.rp2;\n\n\tif (refPoint < 0 || refPoint >= refZone.nPoints) {\n\t\tctx.error = `SHP: invalid reference point ${refPoint}`;\n\t\treturn;\n\t}\n\n\t// Calculate shift amount from reference point movement\n\tconst orgRef = getOriginal(ctx, refZone, refPoint);\n\tconst curRef = getCurrent(ctx, refZone, refPoint);\n\tconst shift = curRef - orgRef;\n\n\t// Apply to loop count points\n\tconst zone = ctx.zp2;\n\tconst count = ctx.GS.loop;\n\tctx.GS.loop = 1;\n\n\tfor (let i = 0; i < count; i++) {\n\t\tconst pointIndex = ctx.stack[--ctx.stackTop]!;\n\n\t\tif (pointIndex < 0 || pointIndex >= zone.nPoints) {\n\t\t\tctx.error = `SHP: invalid point ${pointIndex}`;\n\t\t\treturn;\n\t\t}\n\n\t\tmovePoint(ctx, zone, pointIndex, shift);\n\t\ttouchPoint(ctx, zone, pointIndex);\n\t}\n}\n\n// =============================================================================\n// SHC - Shift Contour\n// =============================================================================\n\n/** SHC - Shift Contour using reference point */\nexport function SHC(ctx: ExecContext, useRp1: boolean): void {\n\tconst contourIndex = ctx.stack[--ctx.stackTop]!;\n\n\tconst refZone = useRp1 ? ctx.zp0 : ctx.zp1;\n\tconst refPoint = useRp1 ? ctx.GS.rp1 : ctx.GS.rp2;\n\n\tif (refPoint < 0 || refPoint >= refZone.nPoints) {\n\t\tctx.error = `SHC: invalid reference point ${refPoint}`;\n\t\treturn;\n\t}\n\n\tconst zone = ctx.zp2;\n\tif (contourIndex < 0 || contourIndex >= zone.nContours) {\n\t\tctx.error = `SHC: invalid contour ${contourIndex}`;\n\t\treturn;\n\t}\n\n\t// Calculate shift amount\n\tconst orgRef = getOriginal(ctx, refZone, refPoint);\n\tconst curRef = getCurrent(ctx, refZone, refPoint);\n\tconst shift = curRef - orgRef;\n\n\t// Get contour bounds\n\tconst start = contourIndex === 0 ? 0 : zone.contours[contourIndex - 1]! + 1;\n\tconst end = zone.contours[contourIndex]!;\n\n\t// Shift all points in contour (except reference point if in same zone)\n\tfor (let i = start; i <= end; i++) {\n\t\tif (zone === refZone && i === refPoint) continue;\n\t\tmovePoint(ctx, zone, i, shift);\n\t\ttouchPoint(ctx, zone, i);\n\t}\n}\n\n// =============================================================================\n// SHZ - Shift Zone\n// =============================================================================\n\n/** SHZ - Shift Zone using reference point */\nexport function SHZ(ctx: ExecContext, useRp1: boolean): void {\n\tconst zoneIndex = ctx.stack[--ctx.stackTop]!;\n\n\tconst refZone = useRp1 ? ctx.zp0 : ctx.zp1;\n\tconst refPoint = useRp1 ? ctx.GS.rp1 : ctx.GS.rp2;\n\n\tif (refPoint < 0 || refPoint >= refZone.nPoints) {\n\t\tctx.error = `SHZ: invalid reference point ${refPoint}`;\n\t\treturn;\n\t}\n\n\tconst zone = zoneIndex === 0 ? ctx.twilight : ctx.pts;\n\n\t// Calculate shift amount\n\tconst orgRef = getOriginal(ctx, refZone, refPoint);\n\tconst curRef = getCurrent(ctx, refZone, refPoint);\n\tconst shift = curRef - orgRef;\n\n\t// Shift all points in zone (except reference point if in same zone)\n\tfor (let i = 0; i < zone.nPoints; i++) {\n\t\tif (zone === refZone && i === refPoint) continue;\n\t\tmovePoint(ctx, zone, i, shift);\n\t\t// Note: SHZ doesn't set touch flags\n\t}\n}\n\n// =============================================================================\n// SHPIX - Shift Point by Pixel Amount\n// =============================================================================\n\n/** SHPIX - Shift Point by Pixel Amount */\nexport function SHPIX(ctx: ExecContext): void {\n\tconst distance = ctx.stack[--ctx.stackTop]!;\n\n\tconst zone = ctx.zp2;\n\tconst count = ctx.GS.loop;\n\tctx.GS.loop = 1;\n\n\tfor (let i = 0; i < count; i++) {\n\t\tconst pointIndex = ctx.stack[--ctx.stackTop]!;\n\n\t\tif (pointIndex < 0 || pointIndex >= zone.nPoints) {\n\t\t\tctx.error = `SHPIX: invalid point ${pointIndex}`;\n\t\t\treturn;\n\t\t}\n\n\t\tmovePoint(ctx, zone, pointIndex, distance);\n\t\ttouchPoint(ctx, zone, pointIndex);\n\t}\n}\n\n// =============================================================================\n// IP - Interpolate Point\n// =============================================================================\n\n/** IP - Interpolate Point */\nexport function IP(ctx: ExecContext): void {\n\tconst rp1 = ctx.GS.rp1;\n\tconst rp2 = ctx.GS.rp2;\n\n\tif (rp1 < 0 || rp1 >= ctx.zp0.nPoints) {\n\t\tctx.error = `IP: invalid rp1 ${rp1}`;\n\t\treturn;\n\t}\n\tif (rp2 < 0 || rp2 >= ctx.zp1.nPoints) {\n\t\tctx.error = `IP: invalid rp2 ${rp2}`;\n\t\treturn;\n\t}\n\n\t// Get original and current positions of reference points\n\tconst org1 = getOriginal(ctx, ctx.zp0, rp1);\n\tconst org2 = getOriginal(ctx, ctx.zp1, rp2);\n\tconst cur1 = getCurrent(ctx, ctx.zp0, rp1);\n\tconst cur2 = getCurrent(ctx, ctx.zp1, rp2);\n\n\tconst orgRange = org2 - org1;\n\tconst curRange = cur2 - cur1;\n\n\tconst zone = ctx.zp2;\n\tconst count = ctx.GS.loop;\n\tctx.GS.loop = 1;\n\n\tfor (let i = 0; i < count; i++) {\n\t\tconst pointIndex = ctx.stack[--ctx.stackTop]!;\n\n\t\tif (pointIndex < 0 || pointIndex >= zone.nPoints) {\n\t\t\tctx.error = `IP: invalid point ${pointIndex}`;\n\t\t\treturn;\n\t\t}\n\n\t\tconst orgPt = getOriginal(ctx, zone, pointIndex);\n\t\tconst curPt = getCurrent(ctx, zone, pointIndex);\n\n\t\tlet newPos: F26Dot6;\n\n\t\tif (orgRange !== 0) {\n\t\t\t// Interpolate based on relative position\n\t\t\tconst t = orgPt - org1;\n\t\t\tnewPos = cur1 + Math.round((t * curRange) / orgRange);\n\t\t} else {\n\t\t\t// Reference points coincide, just shift\n\t\t\tnewPos = curPt + (cur1 - org1);\n\t\t}\n\n\t\tmovePoint(ctx, zone, pointIndex, newPos - curPt);\n\t\ttouchPoint(ctx, zone, pointIndex);\n\t}\n}\n\n// =============================================================================\n// ALIGNRP - Align Reference Point\n// =============================================================================\n\n/** ALIGNRP - Align to Reference Point */\nexport function ALIGNRP(ctx: ExecContext): void {\n\tconst rp0 = ctx.GS.rp0;\n\n\tif (rp0 < 0 || rp0 >= ctx.zp0.nPoints) {\n\t\tctx.error = `ALIGNRP: invalid rp0 ${rp0}`;\n\t\treturn;\n\t}\n\n\tconst refPos = getCurrent(ctx, ctx.zp0, rp0);\n\n\tconst zone = ctx.zp1;\n\tconst count = ctx.GS.loop;\n\tctx.GS.loop = 1;\n\n\tfor (let i = 0; i < count; i++) {\n\t\tconst pointIndex = ctx.stack[--ctx.stackTop]!;\n\n\t\tif (pointIndex < 0 || pointIndex >= zone.nPoints) {\n\t\t\tctx.error = `ALIGNRP: invalid point ${pointIndex}`;\n\t\t\treturn;\n\t\t}\n\n\t\tconst curPos = getCurrent(ctx, zone, pointIndex);\n\t\tconst distance = refPos - curPos;\n\n\t\tmovePoint(ctx, zone, pointIndex, distance);\n\t\ttouchPoint(ctx, zone, pointIndex);\n\t}\n}\n\n// =============================================================================\n// MSIRP - Move Stack Indirect Relative Point\n// =============================================================================\n\n/** MSIRP - Move Stack Indirect Relative Point */\nexport function MSIRP(ctx: ExecContext, setRp0: boolean): void {\n\tconst distance = ctx.stack[--ctx.stackTop]!;\n\tconst pointIndex = ctx.stack[--ctx.stackTop]!;\n\n\tconst zp0 = ctx.zp0;\n\tconst zp1 = ctx.zp1;\n\n\tif (pointIndex < 0 || pointIndex >= zp1.nPoints) {\n\t\tctx.error = `MSIRP: invalid point ${pointIndex}`;\n\t\treturn;\n\t}\n\n\tconst rp0 = ctx.GS.rp0;\n\tif (rp0 < 0 || rp0 >= zp0.nPoints) {\n\t\tctx.error = `MSIRP: invalid rp0 ${rp0}`;\n\t\treturn;\n\t}\n\n\t// Calculate current distance and move to achieve desired distance\n\tconst currentDist =\n\t\tgetCurrent(ctx, zp1, pointIndex) - getCurrent(ctx, zp0, rp0);\n\tconst move = distance - currentDist;\n\n\tmovePoint(ctx, zp1, pointIndex, move);\n\ttouchPoint(ctx, zp1, pointIndex);\n\n\tctx.GS.rp1 = ctx.GS.rp0;\n\tctx.GS.rp2 = pointIndex;\n\tif (setRp0) {\n\t\tctx.GS.rp0 = pointIndex;\n\t}\n}\n\n// =============================================================================\n// ISECT - Move Point to Intersection\n// =============================================================================\n\n/** ISECT - Move Point to Intersection of two lines */\nexport function ISECT(ctx: ExecContext): void {\n\tconst b1 = ctx.stack[--ctx.stackTop]!;\n\tconst b0 = ctx.stack[--ctx.stackTop]!;\n\tconst a1 = ctx.stack[--ctx.stackTop]!;\n\tconst a0 = ctx.stack[--ctx.stackTop]!;\n\tconst point = ctx.stack[--ctx.stackTop]!;\n\n\t// Line A: points a0 to a1 in zp0\n\t// Line B: points b0 to b1 in zp1\n\t// Move point in zp2 to intersection\n\n\tconst zone0 = ctx.zp0;\n\tconst zone1 = ctx.zp1;\n\tconst zone2 = ctx.zp2;\n\n\tif (\n\t\ta0 < 0 ||\n\t\ta0 >= zone0.nPoints ||\n\t\ta1 < 0 ||\n\t\ta1 >= zone0.nPoints\n\t) {\n\t\tctx.error = `ISECT: invalid line A points`;\n\t\treturn;\n\t}\n\tif (\n\t\tb0 < 0 ||\n\t\tb0 >= zone1.nPoints ||\n\t\tb1 < 0 ||\n\t\tb1 >= zone1.nPoints\n\t) {\n\t\tctx.error = `ISECT: invalid line B points`;\n\t\treturn;\n\t}\n\tif (point < 0 || point >= zone2.nPoints) {\n\t\tctx.error = `ISECT: invalid point ${point}`;\n\t\treturn;\n\t}\n\n\t// Get line endpoints\n\tconst pa0 = zone0.cur[a0]!;\n\tconst pa1 = zone0.cur[a1]!;\n\tconst pb0 = zone1.cur[b0]!;\n\tconst pb1 = zone1.cur[b1]!;\n\n\t// Calculate direction vectors\n\tconst dax = pa1.x - pa0.x;\n\tconst day = pa1.y - pa0.y;\n\tconst dbx = pb1.x - pb0.x;\n\tconst dby = pb1.y - pb0.y;\n\n\t// Cross product for denominator\n\tconst denom = dax * dby - day * dbx;\n\n\tconst pt = zone2.cur[point]!;\n\n\tif (denom === 0) {\n\t\t// Lines are parallel, move point to midpoint\n\t\tpt.x = (pa0.x + pa1.x + pb0.x + pb1.x) >> 2;\n\t\tpt.y = (pa0.y + pa1.y + pb0.y + pb1.y) >> 2;\n\t} else {\n\t\t// Calculate intersection\n\t\tconst dx = pb0.x - pa0.x;\n\t\tconst dy = pb0.y - pa0.y;\n\t\tconst t = (dx * dby - dy * dbx) / denom;\n\n\t\tpt.x = Math.round(pa0.x + t * dax);\n\t\tpt.y = Math.round(pa0.y + t * day);\n\t}\n\n\tzone2.tags[point] |= TouchFlag.Both;\n}\n\n// =============================================================================\n// ALIGNPTS - Align Points\n// =============================================================================\n\n/** ALIGNPTS - Align two points */\nexport function ALIGNPTS(ctx: ExecContext): void {\n\tconst p2 = ctx.stack[--ctx.stackTop]!;\n\tconst p1 = ctx.stack[--ctx.stackTop]!;\n\n\tconst zone1 = ctx.zp0;\n\tconst zone2 = ctx.zp1;\n\n\tif (p1 < 0 || p1 >= zone1.nPoints) {\n\t\tctx.error = `ALIGNPTS: invalid point ${p1}`;\n\t\treturn;\n\t}\n\tif (p2 < 0 || p2 >= zone2.nPoints) {\n\t\tctx.error = `ALIGNPTS: invalid point ${p2}`;\n\t\treturn;\n\t}\n\n\t// Get current positions projected\n\tconst pos1 = getCurrent(ctx, zone1, p1);\n\tconst pos2 = getCurrent(ctx, zone2, p2);\n\n\t// Move both to midpoint\n\tconst mid = (pos1 + pos2) >> 1;\n\n\tmovePoint(ctx, zone1, p1, mid - pos1);\n\tmovePoint(ctx, zone2, p2, mid - pos2);\n\n\ttouchPoint(ctx, zone1, p1);\n\ttouchPoint(ctx, zone2, p2);\n}\n\n// =============================================================================\n// GC - Get Coordinate\n// =============================================================================\n\n/** GC - Get Coordinate projected onto projection vector */\nexport function GC(ctx: ExecContext, useOriginal: boolean): void {\n\tconst pointIndex = ctx.stack[--ctx.stackTop]!;\n\tconst zone = ctx.zp2;\n\n\tif (pointIndex < 0 || pointIndex >= zone.nPoints) {\n\t\tctx.error = `GC: invalid point ${pointIndex}`;\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\n\tconst coord = useOriginal\n\t\t? getOriginal(ctx, zone, pointIndex)\n\t\t: getCurrent(ctx, zone, pointIndex);\n\n\tctx.stack[ctx.stackTop++] = coord;\n}\n\n// =============================================================================\n// SCFS - Set Coordinate From Stack\n// =============================================================================\n\n/** SCFS - Set Coordinate From Stack */\nexport function SCFS(ctx: ExecContext): void {\n\tconst coord = ctx.stack[--ctx.stackTop]!;\n\tconst pointIndex = ctx.stack[--ctx.stackTop]!;\n\n\tconst zone = ctx.zp2;\n\n\tif (pointIndex < 0 || pointIndex >= zone.nPoints) {\n\t\tctx.error = `SCFS: invalid point ${pointIndex}`;\n\t\treturn;\n\t}\n\n\tconst current = getCurrent(ctx, zone, pointIndex);\n\tmovePoint(ctx, zone, pointIndex, coord - current);\n\ttouchPoint(ctx, zone, pointIndex);\n}\n\n// =============================================================================\n// MD - Measure Distance\n// =============================================================================\n\n/** MD - Measure Distance between two points */\nexport function MD(ctx: ExecContext, useOriginal: boolean): void {\n\tconst p2 = ctx.stack[--ctx.stackTop]!;\n\tconst p1 = ctx.stack[--ctx.stackTop]!;\n\n\tconst zone0 = ctx.zp0;\n\tconst zone1 = ctx.zp1;\n\n\tif (p1 < 0 || p1 >= zone0.nPoints) {\n\t\tctx.error = `MD: invalid point ${p1}`;\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\tif (p2 < 0 || p2 >= zone1.nPoints) {\n\t\tctx.error = `MD: invalid point ${p2}`;\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\n\tlet distance: F26Dot6;\n\n\tif (useOriginal) {\n\t\tdistance = getOriginal(ctx, zone1, p2) - getOriginal(ctx, zone0, p1);\n\t} else {\n\t\tdistance = getCurrent(ctx, zone1, p2) - getCurrent(ctx, zone0, p1);\n\t}\n\n\tctx.stack[ctx.stackTop++] = distance;\n}\n\n// =============================================================================\n// MPPEM / MPS - Get Pixels Per EM / Point Size\n// =============================================================================\n\n/** MPPEM - Measure Pixels Per EM */\nexport function MPPEM(ctx: ExecContext): void {\n\tctx.stack[ctx.stackTop++] = ctx.ppem;\n}\n\n/** MPS - Measure Point Size */\nexport function MPS(ctx: ExecContext): void {\n\tctx.stack[ctx.stackTop++] = ctx.pointSize;\n}\n\n// =============================================================================\n// FLIPPT - Flip Point\n// =============================================================================\n\n/** FLIPPT - Flip on-curve/off-curve flag */\nexport function FLIPPT(ctx: ExecContext): void {\n\tconst zone = ctx.pts;\n\tconst count = ctx.GS.loop;\n\tctx.GS.loop = 1;\n\n\tfor (let i = 0; i < count; i++) {\n\t\tconst pointIndex = ctx.stack[--ctx.stackTop]!;\n\n\t\tif (pointIndex < 0 || pointIndex >= zone.nPoints) {\n\t\t\tctx.error = `FLIPPT: invalid point ${pointIndex}`;\n\t\t\treturn;\n\t\t}\n\n\t\t// Toggle bit 0 (on-curve flag)\n\t\tzone.tags[pointIndex] ^= 0x01;\n\t}\n}\n\n// =============================================================================\n// FLIPRGON / FLIPRGOFF - Flip Range On/Off\n// =============================================================================\n\n/** FLIPRGON - Set on-curve flag for range */\nexport function FLIPRGON(ctx: ExecContext): void {\n\tconst endPoint = ctx.stack[--ctx.stackTop]!;\n\tconst startPoint = ctx.stack[--ctx.stackTop]!;\n\n\tconst zone = ctx.pts;\n\n\tif (startPoint < 0 || endPoint >= zone.nPoints || startPoint > endPoint) {\n\t\tctx.error = `FLIPRGON: invalid range ${startPoint}-${endPoint}`;\n\t\treturn;\n\t}\n\n\tfor (let i = startPoint; i <= endPoint; i++) {\n\t\tzone.tags[i] |= 0x01; // Set on-curve\n\t}\n}\n\n/** FLIPRGOFF - Clear on-curve flag for range */\nexport function FLIPRGOFF(ctx: ExecContext): void {\n\tconst endPoint = ctx.stack[--ctx.stackTop]!;\n\tconst startPoint = ctx.stack[--ctx.stackTop]!;\n\n\tconst zone = ctx.pts;\n\n\tif (startPoint < 0 || endPoint >= zone.nPoints || startPoint > endPoint) {\n\t\tctx.error = `FLIPRGOFF: invalid range ${startPoint}-${endPoint}`;\n\t\treturn;\n\t}\n\n\tfor (let i = startPoint; i <= endPoint; i++) {\n\t\tzone.tags[i] &= ~0x01; // Clear on-curve\n\t}\n}\n\n// =============================================================================\n// ROUND / NROUND - Round Value\n// =============================================================================\n\n/** ROUND - Round value */\nexport function ROUND(ctx: ExecContext, _colorIndex: number): void {\n\tconst value = ctx.stack[--ctx.stackTop]!;\n\tconst comp = compensate(value, ctx.GS);\n\tctx.stack[ctx.stackTop++] = round(value, comp, ctx.GS);\n}\n\n/** NROUND - No-round (just applies engine compensation) */\nexport function NROUND(ctx: ExecContext, _colorIndex: number): void {\n\tconst value = ctx.stack[--ctx.stackTop]!;\n\tconst comp = compensate(value, ctx.GS);\n\tctx.stack[ctx.stackTop++] = value + comp;\n}\n", "/**\n * IUP - Interpolate Untouched Points\n *\n * This instruction interpolates all points that haven't been touched\n * by previous hinting instructions. It's typically called near the end\n * of glyph hinting to smooth out the positions of all remaining points.\n */\n\nimport { type ExecContext, type GlyphZone, TouchFlag } from \"../types.ts\";\n\n/**\n * Interpolate untouched points in X direction\n */\nexport function IUP_X(ctx: ExecContext): void {\n\tinterpolateUntouched(ctx, TouchFlag.X, true);\n}\n\n/**\n * Interpolate untouched points in Y direction\n */\nexport function IUP_Y(ctx: ExecContext): void {\n\tinterpolateUntouched(ctx, TouchFlag.Y, false);\n}\n\n/**\n * Core interpolation logic\n */\nfunction interpolateUntouched(\n\tctx: ExecContext,\n\ttouchFlag: TouchFlag,\n\tisX: boolean,\n): void {\n\tconst zone = ctx.pts;\n\tconst nPoints = zone.nPoints;\n\tconst nContours = zone.nContours;\n\n\tif (nPoints === 0 || nContours === 0) return;\n\n\t// Process each contour separately\n\tlet contourStart = 0;\n\n\tfor (let c = 0; c < nContours; c++) {\n\t\tconst contourEnd = zone.contours[c]!;\n\n\t\t// Find first touched point in this contour\n\t\tlet firstTouched = -1;\n\t\tfor (let i = contourStart; i <= contourEnd; i++) {\n\t\t\tif (zone.tags[i]! & touchFlag) {\n\t\t\t\tfirstTouched = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (firstTouched < 0) {\n\t\t\t// No touched points in contour, skip\n\t\t\tcontourStart = contourEnd + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Walk through contour interpolating untouched points between touched ones\n\t\tlet prevTouched = firstTouched;\n\t\tlet i = firstTouched + 1;\n\t\tlet wrapped = false;\n\n\t\twhile (true) {\n\t\t\t// Find next touched point\n\t\t\tif (i > contourEnd) {\n\t\t\t\tif (wrapped) break;\n\t\t\t\ti = contourStart;\n\t\t\t\twrapped = true;\n\t\t\t}\n\n\t\t\tif (i === firstTouched && wrapped) {\n\t\t\t\t// Back to start, interpolate remaining points\n\t\t\t\tif (prevTouched !== firstTouched) {\n\t\t\t\t\tinterpolateRange(\n\t\t\t\t\t\tzone,\n\t\t\t\t\t\tprevTouched,\n\t\t\t\t\t\tfirstTouched,\n\t\t\t\t\t\tcontourStart,\n\t\t\t\t\t\tcontourEnd,\n\t\t\t\t\t\tisX,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (zone.tags[i]! & touchFlag) {\n\t\t\t\t// Found touched point - interpolate between prevTouched and i\n\t\t\t\tif (prevTouched !== i) {\n\t\t\t\t\tinterpolateRange(\n\t\t\t\t\t\tzone,\n\t\t\t\t\t\tprevTouched,\n\t\t\t\t\t\ti,\n\t\t\t\t\t\tcontourStart,\n\t\t\t\t\t\tcontourEnd,\n\t\t\t\t\t\tisX,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tprevTouched = i;\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\n\t\tcontourStart = contourEnd + 1;\n\t}\n}\n\n/**\n * Interpolate points between two touched reference points\n */\nfunction interpolateRange(\n\tzone: GlyphZone,\n\tp1: number,\n\tp2: number,\n\tcontourStart: number,\n\tcontourEnd: number,\n\tisX: boolean,\n): void {\n\t// Get original and current positions of reference points\n\tconst org1 = isX ? zone.org[p1]!.x : zone.org[p1]!.y;\n\tconst org2 = isX ? zone.org[p2]!.x : zone.org[p2]!.y;\n\tconst cur1 = isX ? zone.cur[p1]!.x : zone.cur[p1]!.y;\n\tconst cur2 = isX ? zone.cur[p2]!.x : zone.cur[p2]!.y;\n\n\t// Ensure org1 <= org2 for interpolation\n\tlet lo_org: number, hi_org: number;\n\tlet lo_cur: number, hi_cur: number;\n\n\tif (org1 <= org2) {\n\t\tlo_org = org1;\n\t\thi_org = org2;\n\t\tlo_cur = cur1;\n\t\thi_cur = cur2;\n\t} else {\n\t\tlo_org = org2;\n\t\thi_org = org1;\n\t\tlo_cur = cur2;\n\t\thi_cur = cur1;\n\t}\n\n\tconst orgRange = hi_org - lo_org;\n\tconst curRange = hi_cur - lo_cur;\n\n\t// Walk through points between p1 and p2 (wrapping around contour)\n\tlet i = p1 + 1;\n\tif (i > contourEnd) i = contourStart;\n\n\twhile (i !== p2) {\n\t\tconst org = isX ? zone.org[i]!.x : zone.org[i]!.y;\n\t\tlet newPos: number;\n\n\t\tif (org <= lo_org) {\n\t\t\t// Point is below/left of both references - shift by lo movement\n\t\t\tnewPos = (isX ? zone.cur[i]!.x : zone.cur[i]!.y) + (lo_cur - lo_org);\n\t\t} else if (org >= hi_org) {\n\t\t\t// Point is above/right of both references - shift by hi movement\n\t\t\tnewPos = (isX ? zone.cur[i]!.x : zone.cur[i]!.y) + (hi_cur - hi_org);\n\t\t} else {\n\t\t\t// Point is between references - interpolate\n\t\t\tif (orgRange !== 0) {\n\t\t\t\tconst t = org - lo_org;\n\t\t\t\tnewPos = lo_cur + Math.round((t * curRange) / orgRange);\n\t\t\t} else {\n\t\t\t\tnewPos = lo_cur;\n\t\t\t}\n\t\t}\n\n\t\tif (isX) {\n\t\t\tzone.cur[i]!.x = newPos;\n\t\t} else {\n\t\t\tzone.cur[i]!.y = newPos;\n\t\t}\n\n\t\ti++;\n\t\tif (i > contourEnd) i = contourStart;\n\t}\n}\n", "/**\n * Delta instructions\n *\n * These instructions allow fine-tuning of point positions and CVT values\n * at specific pixel-per-em (ppem) sizes. This is useful for fixing\n * rendering issues that only appear at certain sizes.\n */\n\nimport { type ExecContext, type GlyphZone } from \"../types.ts\";\nimport { movePoint, touchPoint } from \"./points.ts\";\n\n/**\n * DELTAP1 - Delta exception point (ppem 0-15 + deltaBase)\n */\nexport function DELTAP1(ctx: ExecContext): void {\n\tdeltaPoint(ctx, 0);\n}\n\n/**\n * DELTAP2 - Delta exception point (ppem 16-31 + deltaBase)\n */\nexport function DELTAP2(ctx: ExecContext): void {\n\tdeltaPoint(ctx, 16);\n}\n\n/**\n * DELTAP3 - Delta exception point (ppem 32-47 + deltaBase)\n */\nexport function DELTAP3(ctx: ExecContext): void {\n\tdeltaPoint(ctx, 32);\n}\n\n/**\n * Common logic for DELTAP1/2/3\n */\nfunction deltaPoint(ctx: ExecContext, rangeOffset: number): void {\n\tconst count = ctx.stack[--ctx.stackTop]!;\n\n\tif (count < 0) {\n\t\tctx.error = `DELTAP: invalid count ${count}`;\n\t\treturn;\n\t}\n\n\tconst zone = ctx.zp0;\n\n\tfor (let i = 0; i < count; i++) {\n\t\tconst argByte = ctx.stack[--ctx.stackTop]!;\n\t\tconst pointIndex = ctx.stack[--ctx.stackTop]!;\n\n\t\tif (pointIndex < 0 || pointIndex >= zone.nPoints) {\n\t\t\tctx.error = `DELTAP: invalid point ${pointIndex}`;\n\t\t\treturn;\n\t\t}\n\n\t\t// Extract ppem delta and magnitude from argByte\n\t\t// High nibble: ppem - deltaBase - rangeOffset\n\t\t// Low nibble: magnitude (0-15, where 8-15 are negative)\n\t\tconst ppemDelta = ((argByte >> 4) & 0x0f) + ctx.GS.deltaBase + rangeOffset;\n\t\tconst magnitude = argByte & 0x0f;\n\n\t\t// Check if we're at the target ppem\n\t\tif (ppemDelta !== ctx.ppem) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Convert magnitude to actual delta value\n\t\t// 0-7: positive 1-8 (shifted by deltaShift)\n\t\t// 8-15: negative 1-8 (shifted by deltaShift)\n\t\tlet delta: number;\n\t\tif (magnitude < 8) {\n\t\t\tdelta = (magnitude + 1) << (6 - ctx.GS.deltaShift);\n\t\t} else {\n\t\t\tdelta = -((magnitude - 7) << (6 - ctx.GS.deltaShift));\n\t\t}\n\n\t\tmovePoint(ctx, zone, pointIndex, delta);\n\t\ttouchPoint(ctx, zone, pointIndex);\n\t}\n}\n\n/**\n * DELTAC1 - Delta exception CVT (ppem 0-15 + deltaBase)\n */\nexport function DELTAC1(ctx: ExecContext): void {\n\tdeltaCVT(ctx, 0);\n}\n\n/**\n * DELTAC2 - Delta exception CVT (ppem 16-31 + deltaBase)\n */\nexport function DELTAC2(ctx: ExecContext): void {\n\tdeltaCVT(ctx, 16);\n}\n\n/**\n * DELTAC3 - Delta exception CVT (ppem 32-47 + deltaBase)\n */\nexport function DELTAC3(ctx: ExecContext): void {\n\tdeltaCVT(ctx, 32);\n}\n\n/**\n * Common logic for DELTAC1/2/3\n */\nfunction deltaCVT(ctx: ExecContext, rangeOffset: number): void {\n\tconst count = ctx.stack[--ctx.stackTop]!;\n\n\tif (count < 0) {\n\t\tctx.error = `DELTAC: invalid count ${count}`;\n\t\treturn;\n\t}\n\n\tfor (let i = 0; i < count; i++) {\n\t\tconst argByte = ctx.stack[--ctx.stackTop]!;\n\t\tconst cvtIndex = ctx.stack[--ctx.stackTop]!;\n\n\t\tif (cvtIndex < 0 || cvtIndex >= ctx.cvtSize) {\n\t\t\tctx.error = `DELTAC: invalid CVT index ${cvtIndex}`;\n\t\t\treturn;\n\t\t}\n\n\t\t// Extract ppem delta and magnitude\n\t\tconst ppemDelta = ((argByte >> 4) & 0x0f) + ctx.GS.deltaBase + rangeOffset;\n\t\tconst magnitude = argByte & 0x0f;\n\n\t\t// Check if we're at the target ppem\n\t\tif (ppemDelta !== ctx.ppem) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Convert magnitude to actual delta value\n\t\tlet delta: number;\n\t\tif (magnitude < 8) {\n\t\t\tdelta = (magnitude + 1) << (6 - ctx.GS.deltaShift);\n\t\t} else {\n\t\t\tdelta = -((magnitude - 7) << (6 - ctx.GS.deltaShift));\n\t\t}\n\n\t\tctx.cvt[cvtIndex]! += delta;\n\t}\n}\n", "/**\n * TrueType Bytecode Interpreter\n *\n * Main dispatch loop for executing TrueType hinting instructions.\n */\n\nimport {\n\ttype ExecContext,\n\tOpcode,\n\tCodeRange,\n} from \"./types.ts\";\n\n// Import instruction implementations\nimport {\n\tDUP,\n\tPOP,\n\tCLEAR,\n\tSWAP,\n\tDEPTH,\n\tCINDEX,\n\tMINDEX,\n\tROLL,\n\tPUSHB,\n\tPUSHW,\n\tNPUSHB,\n\tNPUSHW,\n} from \"./instructions/stack.ts\";\n\nimport {\n\tADD,\n\tSUB,\n\tDIV,\n\tMUL,\n\tABS,\n\tNEG,\n\tFLOOR,\n\tCEILING,\n\tMAX,\n\tMIN,\n\tLT,\n\tLTEQ,\n\tGT,\n\tGTEQ,\n\tEQ,\n\tNEQ,\n\tODD,\n\tEVEN,\n\tAND,\n\tOR,\n\tNOT,\n} from \"./instructions/arithmetic.ts\";\n\nimport {\n\tIF,\n\tELSE,\n\tEIF,\n\tJMPR,\n\tJROT,\n\tJROF,\n\tFDEF,\n\tENDF,\n\tCALL,\n\tLOOPCALL,\n\tIDEF,\n} from \"./instructions/control-flow.ts\";\n\nimport {\n\tSVTCA,\n\tSPVTCA,\n\tSFVTCA,\n\tSPVTL,\n\tSFVTL,\n\tSDPVTL,\n\tSPVFS,\n\tSFVFS,\n\tGPV,\n\tGFV,\n\tSFVTPV,\n\tSRP0,\n\tSRP1,\n\tSRP2,\n\tSZP0,\n\tSZP1,\n\tSZP2,\n\tSZPS,\n\tSLOOP,\n\tSMD,\n\tSCVTCI,\n\tSSWCI,\n\tSSW,\n\tSDB,\n\tSDS,\n\tRTG,\n\tRTHG,\n\tRTDG,\n\tRDTG,\n\tRUTG,\n\tROFF,\n\tSROUND,\n\tS45ROUND,\n\tFLIPON,\n\tFLIPOFF,\n\tSCANCTRL,\n\tSCANTYPE,\n\tINSTCTRL,\n\tGETINFO,\n\tRS,\n\tWS,\n\tRCVT,\n\tWCVTP,\n\tWCVTF,\n\tUTP,\n} from \"./instructions/graphics-state.ts\";\n\nimport {\n\tMDAP,\n\tMIAP,\n\tMDRP,\n\tMIRP,\n\tSHP,\n\tSHC,\n\tSHZ,\n\tSHPIX,\n\tIP,\n\tALIGNRP,\n\tMSIRP,\n\tISECT,\n\tALIGNPTS,\n\tGC,\n\tSCFS,\n\tMD,\n\tMPPEM,\n\tMPS,\n\tFLIPPT,\n\tFLIPRGON,\n\tFLIPRGOFF,\n\tROUND,\n\tNROUND,\n} from \"./instructions/points.ts\";\n\nimport { IUP_X, IUP_Y } from \"./instructions/interpolate.ts\";\n\nimport {\n\tDELTAP1,\n\tDELTAP2,\n\tDELTAP3,\n\tDELTAC1,\n\tDELTAC2,\n\tDELTAC3,\n} from \"./instructions/delta.ts\";\n\n/**\n * Execute bytecode from the current instruction pointer\n */\nexport function execute(ctx: ExecContext): void {\n\twhile (ctx.IP < ctx.codeSize && ctx.error === null) {\n\t\t// Check instruction limit\n\t\tif (++ctx.instructionCount > ctx.maxInstructions) {\n\t\t\tctx.error = \"Instruction limit exceeded (possible infinite loop)\";\n\t\t\treturn;\n\t\t}\n\n\t\tconst opcode = ctx.code[ctx.IP++]!;\n\t\tctx.opcode = opcode;\n\n\t\texecuteOpcode(ctx, opcode);\n\t}\n}\n\n/**\n * Execute a single opcode\n */\nfunction executeOpcode(ctx: ExecContext, opcode: number): void {\n\t// Handle PUSHB[n] (0xB0-0xB7)\n\tif (opcode >= 0xb0 && opcode <= 0xb7) {\n\t\tPUSHB(ctx, (opcode - 0xb0) + 1);\n\t\treturn;\n\t}\n\n\t// Handle PUSHW[n] (0xB8-0xBF)\n\tif (opcode >= 0xb8 && opcode <= 0xbf) {\n\t\tPUSHW(ctx, (opcode - 0xb8) + 1);\n\t\treturn;\n\t}\n\n\t// Handle MDRP[flags] (0xC0-0xDF)\n\tif (opcode >= 0xc0 && opcode <= 0xdf) {\n\t\tMDRP(ctx, opcode & 0x1f);\n\t\treturn;\n\t}\n\n\t// Handle MIRP[flags] (0xE0-0xFF)\n\tif (opcode >= 0xe0 && opcode <= 0xff) {\n\t\tMIRP(ctx, opcode & 0x1f);\n\t\treturn;\n\t}\n\n\tswitch (opcode) {\n\t\t// Vector setting\n\t\tcase Opcode.SVTCA_Y:\n\t\t\tSVTCA(ctx, 0);\n\t\t\tbreak;\n\t\tcase Opcode.SVTCA_X:\n\t\t\tSVTCA(ctx, 1);\n\t\t\tbreak;\n\t\tcase Opcode.SPVTCA_Y:\n\t\t\tSPVTCA(ctx, 0);\n\t\t\tbreak;\n\t\tcase Opcode.SPVTCA_X:\n\t\t\tSPVTCA(ctx, 1);\n\t\t\tbreak;\n\t\tcase Opcode.SFVTCA_Y:\n\t\t\tSFVTCA(ctx, 0);\n\t\t\tbreak;\n\t\tcase Opcode.SFVTCA_X:\n\t\t\tSFVTCA(ctx, 1);\n\t\t\tbreak;\n\t\tcase Opcode.SPVTL_0:\n\t\t\tSPVTL(ctx, false);\n\t\t\tbreak;\n\t\tcase Opcode.SPVTL_1:\n\t\t\tSPVTL(ctx, true);\n\t\t\tbreak;\n\t\tcase Opcode.SFVTL_0:\n\t\t\tSFVTL(ctx, false);\n\t\t\tbreak;\n\t\tcase Opcode.SFVTL_1:\n\t\t\tSFVTL(ctx, true);\n\t\t\tbreak;\n\t\tcase Opcode.SDPVTL_0:\n\t\t\tSDPVTL(ctx, false);\n\t\t\tbreak;\n\t\tcase Opcode.SDPVTL_1:\n\t\t\tSDPVTL(ctx, true);\n\t\t\tbreak;\n\t\tcase Opcode.SPVFS:\n\t\t\tSPVFS(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SFVFS:\n\t\t\tSFVFS(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.GPV:\n\t\t\tGPV(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.GFV:\n\t\t\tGFV(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SFVTPV:\n\t\t\tSFVTPV(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.ISECT:\n\t\t\tISECT(ctx);\n\t\t\tbreak;\n\n\t\t// Reference points\n\t\tcase Opcode.SRP0:\n\t\t\tSRP0(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SRP1:\n\t\t\tSRP1(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SRP2:\n\t\t\tSRP2(ctx);\n\t\t\tbreak;\n\n\t\t// Zone pointers\n\t\tcase Opcode.SZP0:\n\t\t\tSZP0(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SZP1:\n\t\t\tSZP1(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SZP2:\n\t\t\tSZP2(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SZPS:\n\t\t\tSZPS(ctx);\n\t\t\tbreak;\n\n\t\t// Loop and other GS\n\t\tcase Opcode.SLOOP:\n\t\t\tSLOOP(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.RTG:\n\t\t\tRTG(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.RTHG:\n\t\t\tRTHG(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SMD:\n\t\t\tSMD(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.ELSE:\n\t\t\tELSE(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.JMPR:\n\t\t\tJMPR(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SCVTCI:\n\t\t\tSCVTCI(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SSWCI:\n\t\t\tSSWCI(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SSW:\n\t\t\tSSW(ctx);\n\t\t\tbreak;\n\n\t\t// Stack operations\n\t\tcase Opcode.DUP:\n\t\t\tDUP(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.POP:\n\t\t\tPOP(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.CLEAR:\n\t\t\tCLEAR(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SWAP:\n\t\t\tSWAP(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.DEPTH:\n\t\t\tDEPTH(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.CINDEX:\n\t\t\tCINDEX(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.MINDEX:\n\t\t\tMINDEX(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.ROLL:\n\t\t\tROLL(ctx);\n\t\t\tbreak;\n\n\t\t// Functions\n\t\tcase Opcode.FDEF:\n\t\t\tFDEF(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.ENDF:\n\t\t\tENDF(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.CALL:\n\t\t\tCALL(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.LOOPCALL:\n\t\t\tLOOPCALL(ctx);\n\t\t\tbreak;\n\n\t\t// Point movement\n\t\tcase Opcode.MDAP_0:\n\t\t\tMDAP(ctx, false);\n\t\t\tbreak;\n\t\tcase Opcode.MDAP_1:\n\t\t\tMDAP(ctx, true);\n\t\t\tbreak;\n\t\tcase Opcode.IUP_Y:\n\t\t\tIUP_Y(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.IUP_X:\n\t\t\tIUP_X(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SHP_0:\n\t\t\tSHP(ctx, false);\n\t\t\tbreak;\n\t\tcase Opcode.SHP_1:\n\t\t\tSHP(ctx, true);\n\t\t\tbreak;\n\t\tcase Opcode.SHC_0:\n\t\t\tSHC(ctx, false);\n\t\t\tbreak;\n\t\tcase Opcode.SHC_1:\n\t\t\tSHC(ctx, true);\n\t\t\tbreak;\n\t\tcase Opcode.SHZ_0:\n\t\t\tSHZ(ctx, false);\n\t\t\tbreak;\n\t\tcase Opcode.SHZ_1:\n\t\t\tSHZ(ctx, true);\n\t\t\tbreak;\n\t\tcase Opcode.SHPIX:\n\t\t\tSHPIX(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.IP:\n\t\t\tIP(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.MSIRP_0:\n\t\t\tMSIRP(ctx, false);\n\t\t\tbreak;\n\t\tcase Opcode.MSIRP_1:\n\t\t\tMSIRP(ctx, true);\n\t\t\tbreak;\n\t\tcase Opcode.ALIGNRP:\n\t\t\tALIGNRP(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.ALIGNPTS:\n\t\t\tALIGNPTS(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.UTP:\n\t\t\tUTP(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.RTDG:\n\t\t\tRTDG(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.MIAP_0:\n\t\t\tMIAP(ctx, false);\n\t\t\tbreak;\n\t\tcase Opcode.MIAP_1:\n\t\t\tMIAP(ctx, true);\n\t\t\tbreak;\n\n\t\t// Push instructions\n\t\tcase Opcode.NPUSHB:\n\t\t\tNPUSHB(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.NPUSHW:\n\t\t\tNPUSHW(ctx);\n\t\t\tbreak;\n\n\t\t// Storage\n\t\tcase Opcode.WS:\n\t\t\tWS(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.RS:\n\t\t\tRS(ctx);\n\t\t\tbreak;\n\n\t\t// CVT\n\t\tcase Opcode.WCVTP:\n\t\t\tWCVTP(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.RCVT:\n\t\t\tRCVT(ctx);\n\t\t\tbreak;\n\n\t\t// Point operations\n\t\tcase Opcode.GC_0:\n\t\t\tGC(ctx, false);\n\t\t\tbreak;\n\t\tcase Opcode.GC_1:\n\t\t\tGC(ctx, true);\n\t\t\tbreak;\n\t\tcase Opcode.SCFS:\n\t\t\tSCFS(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.MD_0:\n\t\t\tMD(ctx, false);\n\t\t\tbreak;\n\t\tcase Opcode.MD_1:\n\t\t\tMD(ctx, true);\n\t\t\tbreak;\n\t\tcase Opcode.MPPEM:\n\t\t\tMPPEM(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.MPS:\n\t\t\tMPS(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.FLIPON:\n\t\t\tFLIPON(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.FLIPOFF:\n\t\t\tFLIPOFF(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.DEBUG:\n\t\t\t// DEBUG is a no-op\n\t\t\tbreak;\n\n\t\t// Comparison\n\t\tcase Opcode.LT:\n\t\t\tLT(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.LTEQ:\n\t\t\tLTEQ(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.GT:\n\t\t\tGT(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.GTEQ:\n\t\t\tGTEQ(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.EQ:\n\t\t\tEQ(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.NEQ:\n\t\t\tNEQ(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.ODD:\n\t\t\tODD(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.EVEN:\n\t\t\tEVEN(ctx);\n\t\t\tbreak;\n\n\t\t// Control flow\n\t\tcase Opcode.IF:\n\t\t\tIF(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.EIF:\n\t\t\tEIF(ctx);\n\t\t\tbreak;\n\n\t\t// Logic\n\t\tcase Opcode.AND:\n\t\t\tAND(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.OR:\n\t\t\tOR(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.NOT:\n\t\t\tNOT(ctx);\n\t\t\tbreak;\n\n\t\t// Delta instructions\n\t\tcase Opcode.DELTAP1:\n\t\t\tDELTAP1(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SDB:\n\t\t\tSDB(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SDS:\n\t\t\tSDS(ctx);\n\t\t\tbreak;\n\n\t\t// Arithmetic\n\t\tcase Opcode.ADD:\n\t\t\tADD(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SUB:\n\t\t\tSUB(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.DIV:\n\t\t\tDIV(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.MUL:\n\t\t\tMUL(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.ABS:\n\t\t\tABS(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.NEG:\n\t\t\tNEG(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.FLOOR:\n\t\t\tFLOOR(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.CEILING:\n\t\t\tCEILING(ctx);\n\t\t\tbreak;\n\n\t\t// Rounding\n\t\tcase Opcode.ROUND_0:\n\t\t\tROUND(ctx, 0);\n\t\t\tbreak;\n\t\tcase Opcode.ROUND_1:\n\t\t\tROUND(ctx, 1);\n\t\t\tbreak;\n\t\tcase Opcode.ROUND_2:\n\t\t\tROUND(ctx, 2);\n\t\t\tbreak;\n\t\tcase Opcode.ROUND_3:\n\t\t\tROUND(ctx, 3);\n\t\t\tbreak;\n\t\tcase Opcode.NROUND_0:\n\t\t\tNROUND(ctx, 0);\n\t\t\tbreak;\n\t\tcase Opcode.NROUND_1:\n\t\t\tNROUND(ctx, 1);\n\t\t\tbreak;\n\t\tcase Opcode.NROUND_2:\n\t\t\tNROUND(ctx, 2);\n\t\t\tbreak;\n\t\tcase Opcode.NROUND_3:\n\t\t\tNROUND(ctx, 3);\n\t\t\tbreak;\n\n\t\t// CVT font units\n\t\tcase Opcode.WCVTF:\n\t\t\tWCVTF(ctx);\n\t\t\tbreak;\n\n\t\t// Delta\n\t\tcase Opcode.DELTAP2:\n\t\t\tDELTAP2(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.DELTAP3:\n\t\t\tDELTAP3(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.DELTAC1:\n\t\t\tDELTAC1(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.DELTAC2:\n\t\t\tDELTAC2(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.DELTAC3:\n\t\t\tDELTAC3(ctx);\n\t\t\tbreak;\n\n\t\t// Super rounding\n\t\tcase Opcode.SROUND:\n\t\t\tSROUND(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.S45ROUND:\n\t\t\tS45ROUND(ctx);\n\t\t\tbreak;\n\n\t\t// Jump\n\t\tcase Opcode.JROT:\n\t\t\tJROT(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.JROF:\n\t\t\tJROF(ctx);\n\t\t\tbreak;\n\n\t\t// Rounding modes\n\t\tcase Opcode.ROFF:\n\t\t\tROFF(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.RUTG:\n\t\t\tRUTG(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.RDTG:\n\t\t\tRDTG(ctx);\n\t\t\tbreak;\n\n\t\t// Other\n\t\tcase Opcode.SANGW:\n\t\t\t// SANGW is deprecated (set angle weight), ignore\n\t\t\tctx.stackTop--;\n\t\t\tbreak;\n\t\tcase Opcode.AA:\n\t\t\t// AA (adjust angle) is deprecated, ignore\n\t\t\tctx.stackTop--;\n\t\t\tbreak;\n\n\t\t// Flip\n\t\tcase Opcode.FLIPPT:\n\t\t\tFLIPPT(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.FLIPRGON:\n\t\t\tFLIPRGON(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.FLIPRGOFF:\n\t\t\tFLIPRGOFF(ctx);\n\t\t\tbreak;\n\n\t\t// Scan\n\t\tcase Opcode.SCANCTRL:\n\t\t\tSCANCTRL(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SCANTYPE:\n\t\t\tSCANTYPE(ctx);\n\t\t\tbreak;\n\n\t\t// Min/Max\n\t\tcase Opcode.MAX:\n\t\t\tMAX(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.MIN:\n\t\t\tMIN(ctx);\n\t\t\tbreak;\n\n\t\t// Getinfo and instctrl\n\t\tcase Opcode.GETINFO:\n\t\t\tGETINFO(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.IDEF:\n\t\t\tIDEF(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.INSTCTRL:\n\t\t\tINSTCTRL(ctx);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t// Check for user-defined instruction\n\t\t\tif (opcode < ctx.maxIDefs && ctx.IDefs[opcode]?.active) {\n\t\t\t\tconst def = ctx.IDefs[opcode]!;\n\n\t\t\t\tif (ctx.callStackTop >= ctx.maxCallStack) {\n\t\t\t\t\tctx.error = \"IDEF call: call stack overflow\";\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Push call record\n\t\t\t\tconst call = ctx.callStack[ctx.callStackTop++]!;\n\t\t\t\tcall.callerIP = ctx.IP;\n\t\t\t\tcall.callerRange = ctx.currentRange;\n\t\t\t\tcall.def = {\n\t\t\t\t\tid: opcode,\n\t\t\t\t\tstart: def.start,\n\t\t\t\t\tend: def.end,\n\t\t\t\t\tactive: true,\n\t\t\t\t\trange: def.range,\n\t\t\t\t};\n\t\t\t\tcall.count = 1;\n\n\t\t\t\t// Switch to IDEF's code range\n\t\t\t\tctx.currentRange = def.range;\n\t\t\t\tconst range = ctx.codeRanges.get(ctx.currentRange);\n\t\t\t\tif (range) {\n\t\t\t\t\tctx.code = range.code;\n\t\t\t\t\tctx.codeSize = range.size;\n\t\t\t\t}\n\t\t\t\tctx.IP = def.start;\n\t\t\t} else {\n\t\t\t\tctx.error = `Unknown opcode 0x${opcode.toString(16)}`;\n\t\t\t}\n\t}\n}\n\n/**\n * Set up execution context with code range\n */\nexport function setCodeRange(\n\tctx: ExecContext,\n\trange: CodeRange,\n\tcode: Uint8Array,\n): void {\n\tctx.codeRanges.set(range, { code, size: code.length });\n}\n\n/**\n * Run code in a specific range\n */\nexport function runProgram(\n\tctx: ExecContext,\n\trange: CodeRange,\n): void {\n\tconst codeRange = ctx.codeRanges.get(range);\n\tif (!codeRange) {\n\t\treturn;\n\t}\n\n\tctx.currentRange = range;\n\tctx.code = codeRange.code;\n\tctx.codeSize = codeRange.size;\n\tctx.IP = 0;\n\tctx.instructionCount = 0;\n\n\texecute(ctx);\n}\n\n/**\n * Run the font program (fpgm table)\n */\nexport function runFontProgram(ctx: ExecContext): void {\n\trunProgram(ctx, CodeRange.Font);\n}\n\n/**\n * Run the CVT program (prep table)\n */\nexport function runCVTProgram(ctx: ExecContext): void {\n\t// Reset graphics state to default before prep\n\tctx.GS = { ...ctx.defaultGS };\n\trunProgram(ctx, CodeRange.CVT);\n\t// Save modified GS as new default for glyphs\n\tctx.defaultGS = { ...ctx.GS };\n}\n\n/**\n * Run glyph instructions\n */\nexport function runGlyphProgram(ctx: ExecContext, instructions: Uint8Array): void {\n\t// Reset graphics state to default\n\tctx.GS = { ...ctx.defaultGS };\n\n\t// Set up glyph zone pointers\n\tctx.zp0 = ctx.pts;\n\tctx.zp1 = ctx.pts;\n\tctx.zp2 = ctx.pts;\n\n\t// Set up glyph code range\n\tsetCodeRange(ctx, CodeRange.Glyph, instructions);\n\trunProgram(ctx, CodeRange.Glyph);\n}\n", "/**\n * TrueType Hinting Program Execution\n *\n * This module handles the setup and execution of TrueType hinting programs:\n * - fpgm: Font program (executed once when font is loaded)\n * - prep: CVT program (executed when size changes)\n * - glyph: Per-glyph instructions\n */\n\nimport {\n\ttype ExecContext,\n\ttype GlyphZone,\n\ttype Point,\n\tcreateExecContext,\n\tcreateGlyphZone,\n\tCodeRange,\n} from \"./types.ts\";\nimport {\n\tsetCodeRange,\n\trunFontProgram,\n\trunCVTProgram,\n\trunGlyphProgram,\n} from \"./interpreter.ts\";\n\n/**\n * Hinting engine for a font\n */\nexport interface HintingEngine {\n\t/** Execution context */\n\tctx: ExecContext;\n\t/** Units per EM from font */\n\tunitsPerEM: number;\n\t/** Has fpgm been executed */\n\tfpgmExecuted: boolean;\n\t/** Current ppem (prep needs re-run if this changes) */\n\tcurrentPpem: number;\n}\n\n/**\n * Create a hinting engine for a font\n */\nexport function createHintingEngine(\n\tunitsPerEM: number,\n\tmaxStack: number = 256,\n\tmaxStorage: number = 64,\n\tmaxFDefs: number = 64,\n\tmaxTwilightPoints: number = 16,\n\tcvtValues?: Int32Array,\n): HintingEngine {\n\tconst ctx = createExecContext(\n\t\tmaxStack,\n\t\tmaxStorage,\n\t\tmaxFDefs,\n\t\tmaxFDefs, // maxIDefs\n\t\t32, // maxCallStack\n\t\tmaxTwilightPoints,\n\t);\n\n\t// Initialize CVT if provided\n\tif (cvtValues) {\n\t\tctx.cvt = new Int32Array(cvtValues);\n\t\tctx.cvtSize = cvtValues.length;\n\t}\n\n\treturn {\n\t\tctx,\n\t\tunitsPerEM,\n\t\tfpgmExecuted: false,\n\t\tcurrentPpem: 0,\n\t};\n}\n\n/**\n * Load font program (fpgm table)\n */\nexport function loadFontProgram(engine: HintingEngine, fpgm: Uint8Array): void {\n\tsetCodeRange(engine.ctx, CodeRange.Font, fpgm);\n}\n\n/**\n * Load CVT program (prep table)\n */\nexport function loadCVTProgram(engine: HintingEngine, prep: Uint8Array): void {\n\tsetCodeRange(engine.ctx, CodeRange.CVT, prep);\n}\n\n/**\n * Execute fpgm (should be called once after font load)\n */\nexport function executeFontProgram(engine: HintingEngine): string | null {\n\tif (engine.fpgmExecuted) return null;\n\n\tengine.ctx.error = null;\n\trunFontProgram(engine.ctx);\n\tengine.fpgmExecuted = true;\n\n\treturn engine.ctx.error;\n}\n\n/**\n * Set up for a specific size and execute prep if needed\n */\nexport function setSize(\n\tengine: HintingEngine,\n\tppem: number,\n\tpointSize: number,\n): string | null {\n\t// Always run fpgm first if not done\n\tif (!engine.fpgmExecuted) {\n\t\tconst fpgmError = executeFontProgram(engine);\n\t\tif (fpgmError) return fpgmError;\n\t}\n\n\t// Skip prep if size hasn't changed\n\tif (engine.currentPpem === ppem) return null;\n\n\t// Calculate scale factor: font units to 26.6 pixels\n\t// scale = ppem / unitsPerEM * 64 (for 26.6 format)\n\tengine.ctx.scale = (ppem * 64) / engine.unitsPerEM;\n\tengine.ctx.ppem = ppem;\n\tengine.ctx.pointSize = pointSize;\n\n\t// Scale CVT values from font units to pixels\n\tscaleCVT(engine.ctx);\n\n\t// Run prep program\n\tengine.ctx.error = null;\n\trunCVTProgram(engine.ctx);\n\tengine.currentPpem = ppem;\n\n\treturn engine.ctx.error;\n}\n\n/**\n * Scale CVT values from font units to 26.6 pixels\n */\nfunction scaleCVT(ctx: ExecContext): void {\n\tfor (let i = 0; i < ctx.cvtSize; i++) {\n\t\tctx.cvt[i] = Math.round(ctx.cvt[i]! * ctx.scale);\n\t}\n}\n\n/**\n * Glyph outline for hinting\n */\nexport interface GlyphOutline {\n\t/** X coordinates in font units */\n\txCoords: number[];\n\t/** Y coordinates in font units */\n\tyCoords: number[];\n\t/** Point flags (bit 0 = on-curve) */\n\tflags: Uint8Array;\n\t/** End point indices for each contour */\n\tcontourEnds: number[];\n\t/** Glyph instructions */\n\tinstructions: Uint8Array;\n\t/** Left side bearing in font units (for phantom point) */\n\tlsb?: number;\n\t/** Advance width in font units (for phantom point) */\n\tadvanceWidth?: number;\n\t/** Top side bearing in font units (for vertical phantom point) */\n\ttsb?: number;\n\t/** Advance height in font units (for vertical phantom point) */\n\tadvanceHeight?: number;\n}\n\n/**\n * Hinted glyph result\n */\nexport interface HintedGlyph {\n\t/** Hinted X coordinates in 26.6 pixels */\n\txCoords: number[];\n\t/** Hinted Y coordinates in 26.6 pixels */\n\tyCoords: number[];\n\t/** Point flags */\n\tflags: Uint8Array;\n\t/** Contour end indices */\n\tcontourEnds: number[];\n\t/** Error message if hinting failed */\n\terror: string | null;\n}\n\n/**\n * Hint a glyph\n */\nexport function hintGlyph(\n\tengine: HintingEngine,\n\toutline: GlyphOutline,\n): HintedGlyph {\n\tconst ctx = engine.ctx;\n\tconst nPoints = outline.xCoords.length;\n\tconst nContours = outline.contourEnds.length;\n\n\t// Add phantom points (4 points after glyph points)\n\tconst totalPoints = nPoints + 4;\n\n\t// Set up glyph zone\n\tconst zone = createGlyphZone(totalPoints, nContours);\n\tzone.nPoints = totalPoints;\n\tzone.nContours = nContours;\n\n\t// Scale and copy point coordinates\n\tfor (let i = 0; i < nPoints; i++) {\n\t\tconst x = Math.round(outline.xCoords[i]! * ctx.scale);\n\t\tconst y = Math.round(outline.yCoords[i]! * ctx.scale);\n\n\t\tzone.org[i]!.x = x;\n\t\tzone.org[i]!.y = y;\n\t\tzone.cur[i]!.x = x;\n\t\tzone.cur[i]!.y = y;\n\t\tzone.orus[i]!.x = outline.xCoords[i]!;\n\t\tzone.orus[i]!.y = outline.yCoords[i]!;\n\t\tzone.tags[i] = outline.flags[i]!;\n\t}\n\n\t// Set up phantom points (for horizontal/vertical metrics)\n\t// Point n: origin (xMin - lsb, 0)\n\t// Point n+1: advance width point (origin.x + advanceWidth, 0)\n\t// Point n+2: top origin (0, yMax + tsb) - for vertical\n\t// Point n+3: bottom point (0, top - advanceHeight) - for vertical\n\n\t// Calculate xMin from outline for phantom point positioning\n\tlet xMin = Infinity;\n\tfor (let i = 0; i < nPoints; i++) {\n\t\tif (outline.xCoords[i]! < xMin) xMin = outline.xCoords[i]!;\n\t}\n\tif (!isFinite(xMin)) xMin = 0;\n\n\tconst lsb = outline.lsb ?? 0;\n\tconst advW = outline.advanceWidth ?? 0;\n\n\t// Phantom point 0: horizontal origin\n\tconst pp0x = Math.round((xMin - lsb) * ctx.scale);\n\tzone.org[nPoints]!.x = pp0x;\n\tzone.org[nPoints]!.y = 0;\n\tzone.cur[nPoints]!.x = pp0x;\n\tzone.cur[nPoints]!.y = 0;\n\tzone.orus[nPoints]!.x = xMin - lsb;\n\tzone.orus[nPoints]!.y = 0;\n\tzone.tags[nPoints] = 0;\n\n\t// Phantom point 1: advance width\n\tconst pp1x = Math.round((xMin - lsb + advW) * ctx.scale);\n\tzone.org[nPoints + 1]!.x = pp1x;\n\tzone.org[nPoints + 1]!.y = 0;\n\tzone.cur[nPoints + 1]!.x = pp1x;\n\tzone.cur[nPoints + 1]!.y = 0;\n\tzone.orus[nPoints + 1]!.x = xMin - lsb + advW;\n\tzone.orus[nPoints + 1]!.y = 0;\n\tzone.tags[nPoints + 1] = 0;\n\n\t// Phantom points 2 & 3: vertical metrics (simplified - set to 0)\n\tfor (let i = nPoints + 2; i < totalPoints; i++) {\n\t\tzone.org[i]!.x = 0;\n\t\tzone.org[i]!.y = 0;\n\t\tzone.cur[i]!.x = 0;\n\t\tzone.cur[i]!.y = 0;\n\t\tzone.orus[i]!.x = 0;\n\t\tzone.orus[i]!.y = 0;\n\t\tzone.tags[i] = 0;\n\t}\n\n\t// Copy contour ends\n\tfor (let i = 0; i < nContours; i++) {\n\t\tzone.contours[i] = outline.contourEnds[i]!;\n\t}\n\n\t// Set up context\n\tctx.pts = zone;\n\tctx.zp0 = zone;\n\tctx.zp1 = zone;\n\tctx.zp2 = zone;\n\n\t// Reset twilight zone\n\tctx.twilight.nPoints = ctx.twilight.org.length;\n\tfor (let i = 0; i < ctx.twilight.nPoints; i++) {\n\t\tctx.twilight.org[i]!.x = 0;\n\t\tctx.twilight.org[i]!.y = 0;\n\t\tctx.twilight.cur[i]!.x = 0;\n\t\tctx.twilight.cur[i]!.y = 0;\n\t\tctx.twilight.tags[i] = 0;\n\t}\n\n\t// Run glyph instructions\n\tctx.error = null;\n\tif (outline.instructions.length > 0) {\n\t\trunGlyphProgram(ctx, outline.instructions);\n\t}\n\n\t// Extract results\n\tconst xCoords = new Array<number>(nPoints);\n\tconst yCoords = new Array<number>(nPoints);\n\n\tfor (let i = 0; i < nPoints; i++) {\n\t\txCoords[i] = zone.cur[i]!.x;\n\t\tyCoords[i] = zone.cur[i]!.y;\n\t}\n\n\treturn {\n\t\txCoords,\n\t\tyCoords,\n\t\tflags: outline.flags,\n\t\tcontourEnds: outline.contourEnds,\n\t\terror: ctx.error,\n\t};\n}\n\n/**\n * Convert hinted coordinates from 26.6 to floating point pixels\n */\nexport function hintedToPixels(coords: number[]): number[] {\n\treturn coords.map((c) => c / 64);\n}\n", "/**\n * High-level rasterization API\n */\n\nimport type { Font } from \"../font/font.ts\";\nimport type { GlyphId } from \"../types.ts\";\nimport type { SimpleGlyph, CompositeGlyph } from \"../font/tables/glyf.ts\";\nimport { getGlyphPath, type GlyphPath } from \"../render/path.ts\";\nimport { GrayRaster } from \"./gray-raster.ts\";\nimport { decomposePath, getPathBounds } from \"./outline-decompose.ts\";\nimport {\n\ttype Bitmap,\n\ttype RasterizedGlyph,\n\ttype RasterizeOptions,\n\tPixelMode,\n\tFillRule,\n\tcreateBitmap,\n\tclearBitmap,\n} from \"./types.ts\";\nimport {\n\ttype HintingEngine,\n\ttype GlyphOutline,\n\ttype HintedGlyph,\n\tcreateHintingEngine,\n\tloadFontProgram,\n\tloadCVTProgram,\n\tsetSize,\n\thintGlyph,\n} from \"../hinting/programs.ts\";\n\n/** Cached hinting engines per font */\nconst hintingEngineCache = new WeakMap<Font, HintingEngine>();\n\n/** Get or create hinting engine for a font */\nfunction getHintingEngine(font: Font): HintingEngine | null {\n\tif (!font.isTrueType || !font.hasHinting) return null;\n\n\tlet engine = hintingEngineCache.get(font);\n\tif (engine) return engine;\n\n\tconst cvt = font.cvtTable;\n\tconst cvtValues = cvt ? new Int32Array(cvt.values) : undefined;\n\n\tengine = createHintingEngine(\n\t\tfont.unitsPerEm,\n\t\tfont.maxp.maxStackElements || 256,\n\t\tfont.maxp.maxStorage || 64,\n\t\tfont.maxp.maxFunctionDefs || 64,\n\t\tfont.maxp.maxTwilightPoints || 16,\n\t\tcvtValues,\n\t);\n\n\tconst fpgm = font.fpgm;\n\tif (fpgm) loadFontProgram(engine, fpgm.instructions);\n\n\tconst prep = font.prep;\n\tif (prep) loadCVTProgram(engine, prep.instructions);\n\n\thintingEngineCache.set(font, engine);\n\treturn engine;\n}\n\n/** Convert TrueType glyph to outline for hinting */\nfunction glyphToOutline(font: Font, glyphId: GlyphId): GlyphOutline | null {\n\tconst glyph = font.getGlyph(glyphId);\n\tif (!glyph || glyph.type === \"empty\") return null;\n\n\tconst xCoords: number[] = [];\n\tconst yCoords: number[] = [];\n\tconst flags: number[] = [];\n\tconst contourEnds: number[] = [];\n\n\t// Get metrics for phantom points\n\tconst advanceWidth = font.advanceWidth(glyphId);\n\tconst lsb = font.leftSideBearing(glyphId);\n\n\tif (glyph.type === \"simple\") {\n\t\tlet pointIndex = 0;\n\t\tfor (const contour of glyph.contours) {\n\t\t\tfor (const point of contour) {\n\t\t\t\txCoords.push(point.x);\n\t\t\t\tyCoords.push(point.y);\n\t\t\t\tflags.push(point.onCurve ? 1 : 0);\n\t\t\t\tpointIndex++;\n\t\t\t}\n\t\t\tcontourEnds.push(pointIndex - 1);\n\t\t}\n\t\treturn {\n\t\t\txCoords,\n\t\t\tyCoords,\n\t\t\tflags: new Uint8Array(flags),\n\t\t\tcontourEnds,\n\t\t\tinstructions: glyph.instructions,\n\t\t\tlsb,\n\t\t\tadvanceWidth,\n\t\t};\n\t} else {\n\t\t// Composite - flatten components\n\t\tfor (const component of glyph.components) {\n\t\t\tconst compGlyph = font.getGlyph(component.glyphId);\n\t\t\tif (!compGlyph || compGlyph.type !== \"simple\") continue;\n\n\t\t\tconst [a, b, c, d] = component.transform;\n\t\t\tconst ox = component.arg1, oy = component.arg2;\n\t\t\tlet pointOffset = xCoords.length;\n\n\t\t\tfor (const contour of compGlyph.contours) {\n\t\t\t\tfor (const point of contour) {\n\t\t\t\t\txCoords.push(point.x * a + point.y * c + ox);\n\t\t\t\t\tyCoords.push(point.x * b + point.y * d + oy);\n\t\t\t\t\tflags.push(point.onCurve ? 1 : 0);\n\t\t\t\t\tpointOffset++;\n\t\t\t\t}\n\t\t\t\tcontourEnds.push(pointOffset - 1);\n\t\t\t}\n\t\t}\n\t\tif (xCoords.length === 0) return null;\n\t\treturn {\n\t\t\txCoords,\n\t\t\tyCoords,\n\t\t\tflags: new Uint8Array(flags),\n\t\t\tcontourEnds,\n\t\t\tinstructions: glyph.instructions,\n\t\t\tlsb,\n\t\t\tadvanceWidth,\n\t\t};\n\t}\n}\n\n/** Decompose hinted glyph to rasterizer */\nfunction decomposeHintedGlyph(\n\traster: GrayRaster,\n\thinted: HintedGlyph,\n\toffsetX: number,\n\toffsetY: number,\n): void {\n\tconst { xCoords, yCoords, flags, contourEnds } = hinted;\n\tlet contourIdx = 0, contourStart = 0;\n\n\tfor (let i = 0; i < xCoords.length; i++) {\n\t\tconst isEnd = i === contourEnds[contourIdx];\n\t\t// Convert 26.6 to rasterizer format (shift left 2 for 26.8)\n\t\tconst x = ((xCoords[i]! << 2) | 0) + (offsetX << 8);\n\t\tconst y = ((-yCoords[i]! << 2) | 0) + (offsetY << 8); // Flip Y\n\t\tconst onCurve = (flags[i]! & 1) !== 0;\n\n\t\tif (i === contourStart) {\n\t\t\traster.moveTo(x, y);\n\t\t} else if (onCurve) {\n\t\t\traster.lineTo(x, y);\n\t\t} else {\n\t\t\tconst nextIdx = isEnd ? contourStart : i + 1;\n\t\t\tconst nx = ((xCoords[nextIdx]! << 2) | 0) + (offsetX << 8);\n\t\t\tconst ny = ((-yCoords[nextIdx]! << 2) | 0) + (offsetY << 8);\n\t\t\tconst nextOn = (flags[nextIdx]! & 1) !== 0;\n\n\t\t\tif (nextOn) {\n\t\t\t\traster.conicTo(x, y, nx, ny);\n\t\t\t\tif (!isEnd) i++;\n\t\t\t} else {\n\t\t\t\traster.conicTo(x, y, (x + nx) >> 1, (y + ny) >> 1);\n\t\t\t}\n\t\t}\n\n\t\tif (isEnd) {\n\t\t\tconst sx = ((xCoords[contourStart]! << 2) | 0) + (offsetX << 8);\n\t\t\tconst sy = ((-yCoords[contourStart]! << 2) | 0) + (offsetY << 8);\n\t\t\tif (onCurve && i !== contourStart) raster.lineTo(sx, sy);\n\t\t\tcontourIdx++;\n\t\t\tcontourStart = i + 1;\n\t\t}\n\t}\n}\n\n/** Threshold for using band processing (height in pixels) */\nconst BAND_PROCESSING_THRESHOLD = 256;\n\n/**\n * Rasterize a glyph path to a bitmap\n */\nexport function rasterizePath(\n\tpath: GlyphPath,\n\toptions: RasterizeOptions,\n): Bitmap {\n\tconst {\n\t\twidth,\n\t\theight,\n\t\tscale,\n\t\toffsetX = 0,\n\t\toffsetY = 0,\n\t\tpixelMode = PixelMode.Gray,\n\t\tfillRule = FillRule.NonZero,\n\t\tflipY = true,\n\t} = options;\n\n\t// Create bitmap\n\tconst bitmap = createBitmap(width, height, pixelMode);\n\n\t// Create rasterizer\n\tconst raster = new GrayRaster();\n\traster.setClip(0, 0, width, height);\n\n\t// Use band processing for large glyphs to ensure bounded memory\n\tif (height > BAND_PROCESSING_THRESHOLD) {\n\t\tconst decomposeFn = () => decomposePath(raster, path, scale, offsetX, offsetY, flipY);\n\t\traster.renderWithBands(bitmap, decomposeFn, { minY: 0, maxY: height }, fillRule);\n\t} else {\n\t\t// Small glyph - render in single pass with full height band\n\t\traster.setBandBounds(0, height);\n\t\traster.reset();\n\t\tdecomposePath(raster, path, scale, offsetX, offsetY, flipY);\n\t\traster.sweep(bitmap, fillRule);\n\t}\n\n\treturn bitmap;\n}\n\n/**\n * Rasterize a glyph from a font\n */\nexport function rasterizeGlyph(\n\tfont: Font,\n\tglyphId: GlyphId,\n\tfontSize: number,\n\toptions?: {\n\t\tpixelMode?: PixelMode;\n\t\tpadding?: number;\n\t\t/** Use TrueType hinting if available */\n\t\thinting?: boolean;\n\t},\n): RasterizedGlyph | null {\n\tconst padding = options?.padding ?? 1;\n\tconst pixelMode = options?.pixelMode ?? PixelMode.Gray;\n\tconst useHinting = options?.hinting ?? false;\n\n\t// Try hinted rendering if requested\n\tif (useHinting && font.hasHinting) {\n\t\tconst result = rasterizeHintedGlyph(font, glyphId, fontSize, padding, pixelMode);\n\t\tif (result) return result;\n\t}\n\n\t// Fall back to unhinted rendering\n\tconst path = getGlyphPath(font, glyphId);\n\tif (!path) return null;\n\n\tconst scale = fontSize / font.unitsPerEm;\n\n\t// Get bounds\n\tconst bounds = getPathBounds(path, scale, true);\n\tif (!bounds) {\n\t\treturn {\n\t\t\tbitmap: createBitmap(1, 1, pixelMode),\n\t\t\tbearingX: 0,\n\t\t\tbearingY: 0,\n\t\t};\n\t}\n\n\tconst width = bounds.maxX - bounds.minX + padding * 2;\n\tconst height = bounds.maxY - bounds.minY + padding * 2;\n\n\tif (width <= 0 || height <= 0) {\n\t\treturn {\n\t\t\tbitmap: createBitmap(1, 1, pixelMode),\n\t\t\tbearingX: 0,\n\t\t\tbearingY: 0,\n\t\t};\n\t}\n\n\tconst offsetX = -bounds.minX + padding;\n\tconst offsetY = -bounds.minY + padding;\n\n\tconst bitmap = rasterizePath(path, {\n\t\twidth,\n\t\theight,\n\t\tscale,\n\t\toffsetX,\n\t\toffsetY,\n\t\tpixelMode,\n\t\tflipY: true,\n\t});\n\n\treturn {\n\t\tbitmap,\n\t\tbearingX: bounds.minX - padding,\n\t\tbearingY: -(bounds.minY - padding),\n\t};\n}\n\n/** Rasterize a glyph with TrueType hinting */\nfunction rasterizeHintedGlyph(\n\tfont: Font,\n\tglyphId: GlyphId,\n\tfontSize: number,\n\tpadding: number,\n\tpixelMode: PixelMode,\n): RasterizedGlyph | null {\n\tconst engine = getHintingEngine(font);\n\tif (!engine) return null;\n\n\tconst outline = glyphToOutline(font, glyphId);\n\tif (!outline) return null;\n\n\tconst ppem = Math.round(fontSize);\n\tconst error = setSize(engine, ppem, ppem);\n\tif (error) return null;\n\n\tconst hinted = hintGlyph(engine, outline);\n\tif (hinted.error || hinted.xCoords.length === 0) return null;\n\n\t// Calculate bounds from hinted coordinates (26.6 fixed point)\n\tlet minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n\tfor (let i = 0; i < hinted.xCoords.length; i++) {\n\t\tconst x = hinted.xCoords[i]! / 64;\n\t\tconst y = hinted.yCoords[i]! / 64;\n\t\tminX = Math.min(minX, x);\n\t\tminY = Math.min(minY, y);\n\t\tmaxX = Math.max(maxX, x);\n\t\tmaxY = Math.max(maxY, y);\n\t}\n\n\tif (!isFinite(minX)) {\n\t\treturn { bitmap: createBitmap(1, 1, pixelMode), bearingX: 0, bearingY: 0 };\n\t}\n\n\tconst bMinX = Math.floor(minX), bMinY = Math.floor(minY);\n\tconst bMaxX = Math.ceil(maxX), bMaxY = Math.ceil(maxY);\n\tconst width = bMaxX - bMinX + padding * 2;\n\tconst height = bMaxY - bMinY + padding * 2;\n\n\tif (width <= 0 || height <= 0) {\n\t\treturn { bitmap: createBitmap(1, 1, pixelMode), bearingX: 0, bearingY: 0 };\n\t}\n\n\tconst bitmap = createBitmap(width, height, pixelMode);\n\tconst raster = new GrayRaster();\n\traster.setClip(0, 0, width, height);\n\traster.reset();\n\n\tconst offsetX = -bMinX + padding;\n\tconst offsetY = height - 1 + bMinY - padding;\n\n\tdecomposeHintedGlyph(raster, hinted, offsetX, offsetY);\n\traster.sweep(bitmap, FillRule.NonZero);\n\n\treturn {\n\t\tbitmap,\n\t\tbearingX: bMinX - padding,\n\t\tbearingY: bMaxY + padding,\n\t};\n}\n\n/**\n * Rasterize text string using shaped glyphs\n */\nexport function rasterizeText(\n\tfont: Font,\n\ttext: string,\n\tfontSize: number,\n\toptions?: {\n\t\tpixelMode?: PixelMode;\n\t\tpadding?: number;\n\t},\n): Bitmap | null {\n\t// This would integrate with the shaper\n\t// For now, simple glyph-by-glyph rendering\n\n\tconst scale = fontSize / font.unitsPerEm;\n\tconst padding = options?.padding ?? 2;\n\tconst pixelMode = options?.pixelMode ?? PixelMode.Gray;\n\n\t// Get glyphs for text\n\tconst glyphs: { glyphId: GlyphId; advance: number }[] = [];\n\tlet totalAdvance = 0;\n\tlet maxAscent = 0;\n\tlet maxDescent = 0;\n\n\tfor (const char of text) {\n\t\tconst codepoint = char.codePointAt(0);\n\t\tif (codepoint === undefined) continue;\n\n\t\tconst glyphId = font.glyphId(codepoint);\n\t\tif (glyphId === undefined) continue;\n\n\t\tconst advance = font.advanceWidth(glyphId) * scale;\n\t\tconst path = getGlyphPath(font, glyphId);\n\n\t\tif (path?.bounds) {\n\t\t\tmaxAscent = Math.max(maxAscent, -path.bounds.yMin * scale);\n\t\t\tmaxDescent = Math.max(maxDescent, path.bounds.yMax * scale);\n\t\t}\n\n\t\tglyphs.push({ glyphId, advance });\n\t\ttotalAdvance += advance;\n\t}\n\n\tif (glyphs.length === 0) return null;\n\n\t// Create bitmap\n\tconst width = Math.ceil(totalAdvance) + padding * 2;\n\tconst height = Math.ceil(maxAscent + maxDescent) + padding * 2;\n\n\tconst bitmap = createBitmap(width, height, pixelMode);\n\tconst raster = new GrayRaster();\n\traster.setClip(0, 0, width, height);\n\n\t// Render each glyph\n\tlet x = padding;\n\tconst baseline = maxDescent + padding;\n\n\tfor (const { glyphId, advance } of glyphs) {\n\t\tconst path = getGlyphPath(font, glyphId);\n\t\tif (path) {\n\t\t\traster.reset();\n\t\t\tdecomposePath(raster, path, scale, x, baseline, true);\n\t\t\traster.sweep(bitmap);\n\t\t}\n\t\tx += advance;\n\t}\n\n\treturn bitmap;\n}\n\n/**\n * Export bitmap to raw RGBA pixels (for WebGL textures, etc.)\n */\nexport function bitmapToRGBA(bitmap: Bitmap): Uint8Array {\n\t// bitmap.width is always the pixel width\n\t// For LCD mode, pitch = width * 3 (3 bytes per pixel for R, G, B subpixels)\n\tconst isLCD = bitmap.pixelMode === PixelMode.LCD;\n\tconst rgba = new Uint8Array(bitmap.width * bitmap.rows * 4);\n\n\tfor (let y = 0; y < bitmap.rows; y++) {\n\t\tfor (let x = 0; x < bitmap.width; x++) {\n\t\t\tconst dstIdx = (y * bitmap.width + x) * 4;\n\n\t\t\tif (bitmap.pixelMode === PixelMode.Gray) {\n\t\t\t\tconst srcIdx = y * bitmap.pitch + x;\n\t\t\t\tconst alpha = bitmap.buffer[srcIdx] ?? 0;\n\t\t\t\t// Black text on white background\n\t\t\t\trgba[dstIdx] = 255 - alpha;\n\t\t\t\trgba[dstIdx + 1] = 255 - alpha;\n\t\t\t\trgba[dstIdx + 2] = 255 - alpha;\n\t\t\t\trgba[dstIdx + 3] = 255;\n\t\t\t} else if (bitmap.pixelMode === PixelMode.Mono) {\n\t\t\t\tconst byteIdx = y * bitmap.pitch + (x >> 3);\n\t\t\t\tconst bitIdx = 7 - (x & 7);\n\t\t\t\tconst alpha = ((bitmap.buffer[byteIdx] ?? 0) >> bitIdx) & 1 ? 255 : 0;\n\t\t\t\trgba[dstIdx] = 255 - alpha;\n\t\t\t\trgba[dstIdx + 1] = 255 - alpha;\n\t\t\t\trgba[dstIdx + 2] = 255 - alpha;\n\t\t\t\trgba[dstIdx + 3] = 255;\n\t\t\t} else if (isLCD) {\n\t\t\t\t// LCD: 3 bytes per pixel (R, G, B subpixel coverage)\n\t\t\t\tconst srcIdx = y * bitmap.pitch + x * 3;\n\t\t\t\tconst r = bitmap.buffer[srcIdx] ?? 0;\n\t\t\t\tconst g = bitmap.buffer[srcIdx + 1] ?? 0;\n\t\t\t\tconst b = bitmap.buffer[srcIdx + 2] ?? 0;\n\t\t\t\t// Black text on white background with subpixel colors\n\t\t\t\trgba[dstIdx] = 255 - r;\n\t\t\t\trgba[dstIdx + 1] = 255 - g;\n\t\t\t\trgba[dstIdx + 2] = 255 - b;\n\t\t\t\trgba[dstIdx + 3] = 255;\n\t\t\t} else {\n\t\t\t\t// Fallback for other modes\n\t\t\t\tconst srcIdx = y * bitmap.pitch + x;\n\t\t\t\tconst alpha = bitmap.buffer[srcIdx] ?? 0;\n\t\t\t\trgba[dstIdx] = 255 - alpha;\n\t\t\t\trgba[dstIdx + 1] = 255 - alpha;\n\t\t\t\trgba[dstIdx + 2] = 255 - alpha;\n\t\t\t\trgba[dstIdx + 3] = 255;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn rgba;\n}\n\n/**\n * Export bitmap to grayscale array\n */\nexport function bitmapToGray(bitmap: Bitmap): Uint8Array {\n\tif (bitmap.pixelMode === PixelMode.Gray && bitmap.pitch === bitmap.width) {\n\t\treturn bitmap.buffer;\n\t}\n\n\tconst gray = new Uint8Array(bitmap.width * bitmap.rows);\n\n\tfor (let y = 0; y < bitmap.rows; y++) {\n\t\tfor (let x = 0; x < bitmap.width; x++) {\n\t\t\tconst dstIdx = y * bitmap.width + x;\n\n\t\t\tif (bitmap.pixelMode === PixelMode.Gray) {\n\t\t\t\tgray[dstIdx] = bitmap.buffer[y * bitmap.pitch + x] ?? 0;\n\t\t\t} else if (bitmap.pixelMode === PixelMode.Mono) {\n\t\t\t\tconst byteIdx = y * bitmap.pitch + (x >> 3);\n\t\t\t\tconst bitIdx = 7 - (x & 7);\n\t\t\t\tgray[dstIdx] = ((bitmap.buffer[byteIdx] ?? 0) >> bitIdx) & 1 ? 255 : 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn gray;\n}\n\n// Re-export types\nexport {\n\ttype Bitmap,\n\ttype RasterizedGlyph,\n\ttype RasterizeOptions,\n\ttype Span,\n\tPixelMode,\n\tFillRule,\n\tcreateBitmap,\n\tclearBitmap,\n} from \"./types.ts\";\n"],
  "mappings": "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;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA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,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA;AAAA,EAEzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA;AAAA,EAEzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA;AAAA,EAEzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA;AAAA,EAEzB,CAAC,MAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA;AAAA,EACzB,CAAC,MAAQ,CAAC,KA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Q,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAI1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;A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AAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC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,MAAS,QAAO;AAC3C,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,OAAO,MAAS,QAAO;AAC3B,MAAI,OAAO,MAAS,QAAO;AAC3B,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,OAAO,MAAS,QAAO;AAC3B,MAAI,OAAO,MAAS,QAAO;AAC3B,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,OAAO,MAAS,QAAO;AAC3B,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,OAAO,MAAS,QAAO;AAC3B,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO;AAC3C,MAAI,OAAO,KAAS,QAAO;AAC3B,MAAI,MAAM,SAAW,MAAM,MAAS,QAAO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CzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,QAAU,OAAO,KAAQ,QAAO;AAC3C,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AAGzC,MAAI,MAAM,OAAU,MAAM,IAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,OAAO,KAAQ,QAAO;AAC1B,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,QAAU,MAAM,KAAQ,QAAO;AACzC,MAAI,MAAM,SAAU,MAAM,MAAQ,QAAO;AACzC,MAAI,OAAO,MAAQ,QAAO;AAC1B,MAAI,MAAM,SAAU,MAAM,MAAQ,QAAO;AACzC,MAAI,MAAM,SAAU,MAAM,MAAQ,QAAO;AACzC,MAAI,MAAM,SAAU,MAAM,MAAQ,QAAO;AACzC,MAAI,MAAM,SAAU,MAAM,MAAQ,QAAO;AACzC,MAAI,MAAM,SAAU,MAAM,MAAQ,QAAO;AACzC,MAAI,MAAM,SAAU,MAAM,MAAQ,QAAO;AACzC,MAAI,MAAM,SAAU,MAAM,MAAQ,QAAO;AACzC,MAAI,OAAO,MAAQ,QAAO;AAC1B,MAAI,OAAO,MAAQ,QAAO;AAC1B,MAAI,OAAO,MAAQ,QAAO;AAC1B,MAAI,MAAM,SAAU,MAAM,MAAQ,QAAO;AACzC,MAAI,OAAO,MAAQ,QAAO;AAC1B,MAAI,MAAM,SAAU,MAAM,MAAQ,QAAO;AACzC,MAAI,MAAM,SAAU,MAAM,MAAQ,QAAO;AACzC,MAAI,OAAO,MAAQ,QAAO;AAC1B,MAAI,MAAM,SAAU,MAAM,MAAQ,QAAO;AACzC,MAAI,MAAM,SAAU,MAAM,MAAQ,QAAO;AACzC,MAAI,MAAM,SAAU,MAAM,MAAQ,QAAO;AACzC,MAAI,OAAO,MAAQ,QAAO;AAC1B,MAAI,MAAM,SAAU,MAAM,MAAQ,QAAO;AACzC,MAAI,MAAM,SAAU,MAAM,MAAQ,QAAO;AACzC,MAAI,OAAO,MAAQ,QAAO;AAC1B,MAAI,MAAM,SAAU,MAAM,MAAQ,QAAO;AACzC,MAAI,MAAM,SAAU,MAAM,MAAQ,QAAO;AACzC,MAAI,MAAM,SAAU,MAAM,MAAQ,QAAO;AACzC,MAAI,OAAO,MAAQ,QAAO;AAC1B,MAAI,OAAO,MAAQ,QAAO;AAC1B,MAAI,OAAO,MAAQ,QAAO;AAC1B,MAAI,OAAO,MAAQ,QAAO;AAC1B,MAAI,MAAM,SAAU,MAAM,MAAQ,QAAO;AACzC,MAAI,MAAM,SAAU,MAAM,MAAQ,QAAO;AACzC,MAAI,MAAM,SAAU,MAAM,MAAQ,QAAO;AACzC,MAAI,OAAO,MAAQ,QAAO;AAC1B,MAAI,MAAM,SAAU,MAAM,MAAQ,QAAO;AACzC,MAAI,OAAO,MAAQ,QAAO;AAC1B,MAAI,OAAO,MAAQ,QAAO;AAC1B,MAAI,OAAO,MAAQ,QAAO;AAC1B,MAAI,OAAO,MAAQ,QAAO;AAC1B,MAAI,OAAO,MAAQ,QAAO;AAC1B,MAAI,MAAM,SAAU,MAAM,MAAQ,QAAO;AACzC,MAAI,MAAM,SAAU,MAAM,MAAQ,QAAO;AACzC,MAAI,MAAM,UAAW,MAA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",
  "names": ["Direction", "ClusterLevel", "BufferFlags", "GlyphClass", "tag", "tag", "tag", "parseIndex", "parseFDSelect", "parseItemVariationStore", "readOffset", "parseDict", "parseReal", "deltaToAbsolute", "subtable", "PaintFormat", "Extend", "CompositeMode", "parseDeltaSetIndexMap", "parseItemVariationStore", "PaletteType", "getGlyphClass", "parseGlyphData", "c", "features", "feature", "parseExtensionLookup", "tag", "MorxSubtableType", "features", "parseItemVariationStore", "tag", "FeatureType", "LigatureSetting", "VerticalPositionSetting", "NumberCaseSetting", "NumberSpacingSetting", "FractionsSetting", "CaseSensitiveLayoutSetting", "StylisticAlternativesSetting", "ContextualAlternativesSetting", "LowerCaseSetting", "UpperCaseSetting", "SmartSwashSetting", "DiacriticsSetting", "CharacterShapeSetting", "FeatureFlags", "features", "getFeature", "feature", "tag", "parseItemVariationStore", "parseDeltaSetIndexMap", "tag", "JustifyMode", "tag", "i", "NormalizationMode", "getGlyphClass", "feature", "features", "getGlyphClass", "map", "map", "top", "parse", "map", "getCharType", "LineBreakClass", "BreakAction", "BreakOpportunity", "GraphemeBreakProperty", "WordBreakProperty", "Script", "PixelMode", "FillRule", "PIXEL_BITS", "PIXEL_BITS", "first", "incr", "delta", "PIXEL_BITS", "gray", "i"]
}
